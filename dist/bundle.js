/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 176);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.createTypeAnnotationBasedOnTypeof = exports.removeTypeDuplicates = exports.createUnionTypeAnnotation = exports.valueToNode = exports.toBlock = exports.toExpression = exports.toStatement = exports.toBindingIdentifierName = exports.toIdentifier = exports.toKeyAlias = exports.toSequenceExpression = exports.toComputedKey = exports.isNodesEquivalent = exports.isImmutable = exports.isScope = exports.isSpecifierDefault = exports.isVar = exports.isBlockScoped = exports.isLet = exports.isValidIdentifier = exports.isReferenced = exports.isBinding = exports.getOuterBindingIdentifiers = exports.getBindingIdentifiers = exports.TYPES = exports.react = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;

var _getOwnPropertySymbols = __webpack_require__(208);

var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = __webpack_require__(29);

var _keys2 = _interopRequireDefault(_keys);

var _stringify = __webpack_require__(35);

var _stringify2 = _interopRequireDefault(_stringify);

var _constants = __webpack_require__(89);

Object.defineProperty(exports, "STATEMENT_OR_BLOCK_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.STATEMENT_OR_BLOCK_KEYS;
  }
});
Object.defineProperty(exports, "FLATTENABLE_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.FLATTENABLE_KEYS;
  }
});
Object.defineProperty(exports, "FOR_INIT_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.FOR_INIT_KEYS;
  }
});
Object.defineProperty(exports, "COMMENT_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.COMMENT_KEYS;
  }
});
Object.defineProperty(exports, "LOGICAL_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.LOGICAL_OPERATORS;
  }
});
Object.defineProperty(exports, "UPDATE_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.UPDATE_OPERATORS;
  }
});
Object.defineProperty(exports, "BOOLEAN_NUMBER_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.BOOLEAN_NUMBER_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "EQUALITY_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.EQUALITY_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "COMPARISON_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.COMPARISON_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "BOOLEAN_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.BOOLEAN_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "NUMBER_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.NUMBER_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "BOOLEAN_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.BOOLEAN_UNARY_OPERATORS;
  }
});
Object.defineProperty(exports, "NUMBER_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.NUMBER_UNARY_OPERATORS;
  }
});
Object.defineProperty(exports, "STRING_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.STRING_UNARY_OPERATORS;
  }
});
Object.defineProperty(exports, "UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.UNARY_OPERATORS;
  }
});
Object.defineProperty(exports, "INHERIT_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.INHERIT_KEYS;
  }
});
Object.defineProperty(exports, "BLOCK_SCOPED_SYMBOL", {
  enumerable: true,
  get: function get() {
    return _constants.BLOCK_SCOPED_SYMBOL;
  }
});
Object.defineProperty(exports, "NOT_LOCAL_BINDING", {
  enumerable: true,
  get: function get() {
    return _constants.NOT_LOCAL_BINDING;
  }
});
exports.is = is;
exports.isType = isType;
exports.validate = validate;
exports.shallowEqual = shallowEqual;
exports.appendToMemberExpression = appendToMemberExpression;
exports.prependToMemberExpression = prependToMemberExpression;
exports.ensureBlock = ensureBlock;
exports.clone = clone;
exports.cloneWithoutLoc = cloneWithoutLoc;
exports.cloneDeep = cloneDeep;
exports.buildMatchMemberExpression = buildMatchMemberExpression;
exports.removeComments = removeComments;
exports.inheritsComments = inheritsComments;
exports.inheritTrailingComments = inheritTrailingComments;
exports.inheritLeadingComments = inheritLeadingComments;
exports.inheritInnerComments = inheritInnerComments;
exports.inherits = inherits;
exports.assertNode = assertNode;
exports.isNode = isNode;
exports.traverseFast = traverseFast;
exports.removeProperties = removeProperties;
exports.removePropertiesDeep = removePropertiesDeep;

var _retrievers = __webpack_require__(132);

Object.defineProperty(exports, "getBindingIdentifiers", {
  enumerable: true,
  get: function get() {
    return _retrievers.getBindingIdentifiers;
  }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
  enumerable: true,
  get: function get() {
    return _retrievers.getOuterBindingIdentifiers;
  }
});

var _validators = __webpack_require__(220);

Object.defineProperty(exports, "isBinding", {
  enumerable: true,
  get: function get() {
    return _validators.isBinding;
  }
});
Object.defineProperty(exports, "isReferenced", {
  enumerable: true,
  get: function get() {
    return _validators.isReferenced;
  }
});
Object.defineProperty(exports, "isValidIdentifier", {
  enumerable: true,
  get: function get() {
    return _validators.isValidIdentifier;
  }
});
Object.defineProperty(exports, "isLet", {
  enumerable: true,
  get: function get() {
    return _validators.isLet;
  }
});
Object.defineProperty(exports, "isBlockScoped", {
  enumerable: true,
  get: function get() {
    return _validators.isBlockScoped;
  }
});
Object.defineProperty(exports, "isVar", {
  enumerable: true,
  get: function get() {
    return _validators.isVar;
  }
});
Object.defineProperty(exports, "isSpecifierDefault", {
  enumerable: true,
  get: function get() {
    return _validators.isSpecifierDefault;
  }
});
Object.defineProperty(exports, "isScope", {
  enumerable: true,
  get: function get() {
    return _validators.isScope;
  }
});
Object.defineProperty(exports, "isImmutable", {
  enumerable: true,
  get: function get() {
    return _validators.isImmutable;
  }
});
Object.defineProperty(exports, "isNodesEquivalent", {
  enumerable: true,
  get: function get() {
    return _validators.isNodesEquivalent;
  }
});

var _converters = __webpack_require__(229);

Object.defineProperty(exports, "toComputedKey", {
  enumerable: true,
  get: function get() {
    return _converters.toComputedKey;
  }
});
Object.defineProperty(exports, "toSequenceExpression", {
  enumerable: true,
  get: function get() {
    return _converters.toSequenceExpression;
  }
});
Object.defineProperty(exports, "toKeyAlias", {
  enumerable: true,
  get: function get() {
    return _converters.toKeyAlias;
  }
});
Object.defineProperty(exports, "toIdentifier", {
  enumerable: true,
  get: function get() {
    return _converters.toIdentifier;
  }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
  enumerable: true,
  get: function get() {
    return _converters.toBindingIdentifierName;
  }
});
Object.defineProperty(exports, "toStatement", {
  enumerable: true,
  get: function get() {
    return _converters.toStatement;
  }
});
Object.defineProperty(exports, "toExpression", {
  enumerable: true,
  get: function get() {
    return _converters.toExpression;
  }
});
Object.defineProperty(exports, "toBlock", {
  enumerable: true,
  get: function get() {
    return _converters.toBlock;
  }
});
Object.defineProperty(exports, "valueToNode", {
  enumerable: true,
  get: function get() {
    return _converters.valueToNode;
  }
});

var _flow = __webpack_require__(238);

Object.defineProperty(exports, "createUnionTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _flow.createUnionTypeAnnotation;
  }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
  enumerable: true,
  get: function get() {
    return _flow.removeTypeDuplicates;
  }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
  enumerable: true,
  get: function get() {
    return _flow.createTypeAnnotationBasedOnTypeof;
  }
});

var _toFastProperties = __webpack_require__(239);

var _toFastProperties2 = _interopRequireDefault(_toFastProperties);

var _clone = __webpack_require__(137);

var _clone2 = _interopRequireDefault(_clone);

var _uniq = __webpack_require__(299);

var _uniq2 = _interopRequireDefault(_uniq);

__webpack_require__(309);

var _definitions = __webpack_require__(22);

var _react2 = __webpack_require__(316);

var _react = _interopRequireWildcard(_react2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var t = exports;

function registerType(type) {
  var is = t["is" + type];
  if (!is) {
    is = t["is" + type] = function (node, opts) {
      return t.is(type, node, opts);
    };
  }

  t["assert" + type] = function (node, opts) {
    opts = opts || {};
    if (!is(node, opts)) {
      throw new Error("Expected type " + (0, _stringify2.default)(type) + " with option " + (0, _stringify2.default)(opts));
    }
  };
}

exports.VISITOR_KEYS = _definitions.VISITOR_KEYS;
exports.ALIAS_KEYS = _definitions.ALIAS_KEYS;
exports.NODE_FIELDS = _definitions.NODE_FIELDS;
exports.BUILDER_KEYS = _definitions.BUILDER_KEYS;
exports.DEPRECATED_KEYS = _definitions.DEPRECATED_KEYS;
exports.react = _react;


for (var type in t.VISITOR_KEYS) {
  registerType(type);
}

t.FLIPPED_ALIAS_KEYS = {};

(0, _keys2.default)(t.ALIAS_KEYS).forEach(function (type) {
  t.ALIAS_KEYS[type].forEach(function (alias) {
    var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];
    types.push(type);
  });
});

(0, _keys2.default)(t.FLIPPED_ALIAS_KEYS).forEach(function (type) {
  t[type.toUpperCase() + "_TYPES"] = t.FLIPPED_ALIAS_KEYS[type];
  registerType(type);
});

var TYPES = exports.TYPES = (0, _keys2.default)(t.VISITOR_KEYS).concat((0, _keys2.default)(t.FLIPPED_ALIAS_KEYS)).concat((0, _keys2.default)(t.DEPRECATED_KEYS));

function is(type, node, opts) {
  if (!node) return false;

  var matches = isType(node.type, type);
  if (!matches) return false;

  if (typeof opts === "undefined") {
    return true;
  } else {
    return t.shallowEqual(node, opts);
  }
}

function isType(nodeType, targetType) {
  if (nodeType === targetType) return true;

  if (t.ALIAS_KEYS[targetType]) return false;

  var aliases = t.FLIPPED_ALIAS_KEYS[targetType];
  if (aliases) {
    if (aliases[0] === nodeType) return true;

    for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var alias = _ref;

      if (nodeType === alias) return true;
    }
  }

  return false;
}

(0, _keys2.default)(t.BUILDER_KEYS).forEach(function (type) {
  var keys = t.BUILDER_KEYS[type];

  function builder() {
    if (arguments.length > keys.length) {
      throw new Error("t." + type + ": Too many arguments passed. Received " + arguments.length + " but can receive " + ("no more than " + keys.length));
    }

    var node = {};
    node.type = type;

    var i = 0;

    for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _key = _ref2;

      var field = t.NODE_FIELDS[type][_key];

      var arg = arguments[i++];
      if (arg === undefined) arg = (0, _clone2.default)(field.default);

      node[_key] = arg;
    }

    for (var key in node) {
      validate(node, key, node[key]);
    }

    return node;
  }

  t[type] = builder;
  t[type[0].toLowerCase() + type.slice(1)] = builder;
});

var _loop = function _loop(_type) {
  var newType = t.DEPRECATED_KEYS[_type];

  function proxy(fn) {
    return function () {
      console.trace("The node type " + _type + " has been renamed to " + newType);
      return fn.apply(this, arguments);
    };
  }

  t[_type] = t[_type[0].toLowerCase() + _type.slice(1)] = proxy(t[newType]);
  t["is" + _type] = proxy(t["is" + newType]);
  t["assert" + _type] = proxy(t["assert" + newType]);
};

for (var _type in t.DEPRECATED_KEYS) {
  _loop(_type);
}

function validate(node, key, val) {
  if (!node) return;

  var fields = t.NODE_FIELDS[node.type];
  if (!fields) return;

  var field = fields[key];
  if (!field || !field.validate) return;
  if (field.optional && val == null) return;

  field.validate(node, key, val);
}

function shallowEqual(actual, expected) {
  var keys = (0, _keys2.default)(expected);

  for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
    var _ref3;

    if (_isArray3) {
      if (_i3 >= _iterator3.length) break;
      _ref3 = _iterator3[_i3++];
    } else {
      _i3 = _iterator3.next();
      if (_i3.done) break;
      _ref3 = _i3.value;
    }

    var key = _ref3;

    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}

function appendToMemberExpression(member, append, computed) {
  member.object = t.memberExpression(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
}

function prependToMemberExpression(member, prepend) {
  member.object = t.memberExpression(prepend, member.object);
  return member;
}

function ensureBlock(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "body";

  return node[key] = t.toBlock(node[key], node);
}

function clone(node) {
  if (!node) return node;
  var newNode = {};
  for (var key in node) {
    if (key[0] === "_") continue;
    newNode[key] = node[key];
  }
  return newNode;
}

function cloneWithoutLoc(node) {
  var newNode = clone(node);
  delete newNode.loc;
  return newNode;
}

function cloneDeep(node) {
  if (!node) return node;
  var newNode = {};

  for (var key in node) {
    if (key[0] === "_") continue;

    var val = node[key];

    if (val) {
      if (val.type) {
        val = t.cloneDeep(val);
      } else if (Array.isArray(val)) {
        val = val.map(t.cloneDeep);
      }
    }

    newNode[key] = val;
  }

  return newNode;
}

function buildMatchMemberExpression(match, allowPartial) {
  var parts = match.split(".");

  return function (member) {
    if (!t.isMemberExpression(member)) return false;

    var search = [member];
    var i = 0;

    while (search.length) {
      var node = search.shift();

      if (allowPartial && i === parts.length) {
        return true;
      }

      if (t.isIdentifier(node)) {
        if (parts[i] !== node.name) return false;
      } else if (t.isStringLiteral(node)) {
        if (parts[i] !== node.value) return false;
      } else if (t.isMemberExpression(node)) {
        if (node.computed && !t.isStringLiteral(node.property)) {
          return false;
        } else {
          search.push(node.object);
          search.push(node.property);
          continue;
        }
      } else {
        return false;
      }

      if (++i > parts.length) {
        return false;
      }
    }

    return true;
  };
}

function removeComments(node) {
  for (var _iterator4 = t.COMMENT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
    var _ref4;

    if (_isArray4) {
      if (_i4 >= _iterator4.length) break;
      _ref4 = _iterator4[_i4++];
    } else {
      _i4 = _iterator4.next();
      if (_i4.done) break;
      _ref4 = _i4.value;
    }

    var key = _ref4;

    delete node[key];
  }
  return node;
}

function inheritsComments(child, parent) {
  inheritTrailingComments(child, parent);
  inheritLeadingComments(child, parent);
  inheritInnerComments(child, parent);
  return child;
}

function inheritTrailingComments(child, parent) {
  _inheritComments("trailingComments", child, parent);
}

function inheritLeadingComments(child, parent) {
  _inheritComments("leadingComments", child, parent);
}

function inheritInnerComments(child, parent) {
  _inheritComments("innerComments", child, parent);
}

function _inheritComments(key, child, parent) {
  if (child && parent) {
    child[key] = (0, _uniq2.default)([].concat(child[key], parent[key]).filter(Boolean));
  }
}

function inherits(child, parent) {
  if (!child || !parent) return child;

  for (var _iterator5 = t.INHERIT_KEYS.optional, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
    var _ref5;

    if (_isArray5) {
      if (_i5 >= _iterator5.length) break;
      _ref5 = _iterator5[_i5++];
    } else {
      _i5 = _iterator5.next();
      if (_i5.done) break;
      _ref5 = _i5.value;
    }

    var _key2 = _ref5;

    if (child[_key2] == null) {
      child[_key2] = parent[_key2];
    }
  }

  for (var key in parent) {
    if (key[0] === "_") child[key] = parent[key];
  }

  for (var _iterator6 = t.INHERIT_KEYS.force, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
    var _ref6;

    if (_isArray6) {
      if (_i6 >= _iterator6.length) break;
      _ref6 = _iterator6[_i6++];
    } else {
      _i6 = _iterator6.next();
      if (_i6.done) break;
      _ref6 = _i6.value;
    }

    var _key3 = _ref6;

    child[_key3] = parent[_key3];
  }

  t.inheritsComments(child, parent);

  return child;
}

function assertNode(node) {
  if (!isNode(node)) {
    throw new TypeError("Not a valid node " + (node && node.type));
  }
}

function isNode(node) {
  return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

(0, _toFastProperties2.default)(t);
(0, _toFastProperties2.default)(t.VISITOR_KEYS);

function traverseFast(node, enter, opts) {
  if (!node) return;

  var keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;

  opts = opts || {};
  enter(node, opts);

  for (var _iterator7 = keys, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
    var _ref7;

    if (_isArray7) {
      if (_i7 >= _iterator7.length) break;
      _ref7 = _iterator7[_i7++];
    } else {
      _i7 = _iterator7.next();
      if (_i7.done) break;
      _ref7 = _i7.value;
    }

    var key = _ref7;

    var subNode = node[key];

    if (Array.isArray(subNode)) {
      for (var _iterator8 = subNode, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {
        var _ref8;

        if (_isArray8) {
          if (_i8 >= _iterator8.length) break;
          _ref8 = _iterator8[_i8++];
        } else {
          _i8 = _iterator8.next();
          if (_i8.done) break;
          _ref8 = _i8.value;
        }

        var _node = _ref8;

        traverseFast(_node, enter, opts);
      }
    } else {
      traverseFast(subNode, enter, opts);
    }
  }
}

var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

var CLEAR_KEYS_PLUS_COMMENTS = t.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

function removeProperties(node, opts) {
  opts = opts || {};
  var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
  for (var _iterator9 = map, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {
    var _ref9;

    if (_isArray9) {
      if (_i9 >= _iterator9.length) break;
      _ref9 = _iterator9[_i9++];
    } else {
      _i9 = _iterator9.next();
      if (_i9.done) break;
      _ref9 = _i9.value;
    }

    var _key4 = _ref9;

    if (node[_key4] != null) node[_key4] = undefined;
  }

  for (var key in node) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }

  var syms = (0, _getOwnPropertySymbols2.default)(node);
  for (var _iterator10 = syms, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {
    var _ref10;

    if (_isArray10) {
      if (_i10 >= _iterator10.length) break;
      _ref10 = _iterator10[_i10++];
    } else {
      _i10 = _iterator10.next();
      if (_i10.done) break;
      _ref10 = _i10.value;
    }

    var sym = _ref10;

    node[sym] = null;
  }
}

function removePropertiesDeep(tree, opts) {
  traverseFast(tree, removeProperties, opts);
  return tree;
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(197), __esModule: true };

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(8);
var core = __webpack_require__(2);
var ctx = __webpack_require__(28);
var hide = __webpack_require__(14);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(82)('wks');
var uid = __webpack_require__(49);
var Symbol = __webpack_require__(8).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(135);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(12);
var IE8_DOM_DEFINE = __webpack_require__(123);
var toPrimitive = __webpack_require__(77);
var dP = Object.defineProperty;

exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(15)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(11);
var createDesc = __webpack_require__(47);
module.exports = __webpack_require__(13) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 16 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(221);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(223);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36),
    getRawTag = __webpack_require__(234),
    objectToString = __webpack_require__(235);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 19 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(142),
    baseKeys = __webpack_require__(273),
    isArrayLike = __webpack_require__(21);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(138),
    isLength = __webpack_require__(97);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = undefined;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = __webpack_require__(35);

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __webpack_require__(17);

var _typeof3 = _interopRequireDefault(_typeof2);

exports.assertEach = assertEach;
exports.assertOneOf = assertOneOf;
exports.assertNodeType = assertNodeType;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;

var _index = __webpack_require__(0);

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VISITOR_KEYS = exports.VISITOR_KEYS = {};
var ALIAS_KEYS = exports.ALIAS_KEYS = {};
var NODE_FIELDS = exports.NODE_FIELDS = {};
var BUILDER_KEYS = exports.BUILDER_KEYS = {};
var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};

function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else if (val === undefined) {
    return "undefined";
  } else {
    return typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val);
  }
}

function assertEach(callback) {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;

    for (var i = 0; i < val.length; i++) {
      callback(node, key + "[" + i + "]", val[i]);
    }
  }
  validator.each = callback;
  return validator;
}

function assertOneOf() {
  for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {
    vals[_key] = arguments[_key];
  }

  function validate(node, key, val) {
    if (vals.indexOf(val) < 0) {
      throw new TypeError("Property " + key + " expected value to be one of " + (0, _stringify2.default)(vals) + " but got " + (0, _stringify2.default)(val));
    }
  }

  validate.oneOf = vals;

  return validate;
}

function assertNodeType() {
  for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    types[_key2] = arguments[_key2];
  }

  function validate(node, key, val) {
    var valid = false;

    for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var type = _ref;

      if (t.is(type, val)) {
        valid = true;
        break;
      }
    }

    if (!valid) {
      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type)));
    }
  }

  validate.oneOfNodeTypes = types;

  return validate;
}

function assertNodeOrValueType() {
  for (var _len3 = arguments.length, types = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    types[_key3] = arguments[_key3];
  }

  function validate(node, key, val) {
    var valid = false;

    for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var type = _ref2;

      if (getType(val) === type || t.is(type, val)) {
        valid = true;
        break;
      }
    }

    if (!valid) {
      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type)));
    }
  }

  validate.oneOfNodeOrValueTypes = types;

  return validate;
}

function assertValueType(type) {
  function validate(node, key, val) {
    var valid = getType(val) === type;

    if (!valid) {
      throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
    }
  }

  validate.type = type;

  return validate;
}

function chain() {
  for (var _len4 = arguments.length, fns = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    fns[_key4] = arguments[_key4];
  }

  function validate() {
    for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var fn = _ref3;

      fn.apply(undefined, arguments);
    }
  }
  validate.chainOf = fns;
  return validate;
}

function defineType(type) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var inherits = opts.inherits && store[opts.inherits] || {};

  opts.fields = opts.fields || inherits.fields || {};
  opts.visitor = opts.visitor || inherits.visitor || [];
  opts.aliases = opts.aliases || inherits.aliases || [];
  opts.builder = opts.builder || inherits.builder || opts.visitor || [];

  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }

  for (var _iterator4 = opts.visitor.concat(opts.builder), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
    var _ref4;

    if (_isArray4) {
      if (_i4 >= _iterator4.length) break;
      _ref4 = _iterator4[_i4++];
    } else {
      _i4 = _iterator4.next();
      if (_i4.done) break;
      _ref4 = _i4.value;
    }

    var _key5 = _ref4;

    opts.fields[_key5] = opts.fields[_key5] || {};
  }

  for (var key in opts.fields) {
    var field = opts.fields[key];

    if (opts.builder.indexOf(key) === -1) {
      field.optional = true;
    }
    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate) {
      field.validate = assertValueType(getType(field.default));
    }
  }

  VISITOR_KEYS[type] = opts.visitor;
  BUILDER_KEYS[type] = opts.builder;
  NODE_FIELDS[type] = opts.fields;
  ALIAS_KEYS[type] = opts.aliases;

  store[type] = opts;
}

var store = {};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * # API
 *
 * @author Ivan Voischev (@voischev),
 *         Anton Winogradov (@awinogradov),
 *         Alexej Yaroshevich (@zxqfox),
 *         Vasiliy (@Yeti-or)
 *
 * @namespace tree
 */
var api = {
  /**
   * Walks the tree and passes all nodes via a callback
   *
   * @memberof tree
   *
   * @param  {Function} cb  Callback
   * @return {Function}     Callback(node)
   *
   *@example
   * ```js
   * export const walk = (tree) => {
   *   tree.walk((node) => {
   *     let classes = node.attrs && node.attrs.class.split(' ') || []
   *
   *     if (classes.includes(className)) return cb(node)
   *       return node
   *   })
   * }
   * ```
   */
  walk: function (cb) {
    return traverse(this, cb)
  },
  /**
   * Matches an expression to search for nodes in the tree
   *
   * @memberof tree
   *
   * @param  {String|RegExp|Object|Array} expression - Matcher(s) to search
   * @param  {Function} cb Callback
   *
   * @return {Function} Callback(node)
   *
   * @example
   * ```js
   * export const match = (tree) => {
   *   // Single matcher
   *   tree.match({ tag: 'custom-tag' }, (node) => {
   *     let tag = node.tag
   *
   *     Object.assign(node, { tag: 'div', attrs: {class: tag} })
   *
   *     return node
   *   })
   *   // Multiple matchers
   *   tree.match([{ tag: 'b' }, { tag: 'strong' }], (node) => {
   *     let style = 'font-weight: bold;'
   *
   *     node.tag = 'span'
   *
   *     node.attrs
   *       ? ( node.attrs.style
   *         ? ( node.attrs.style += style )
   *         : node.attrs.style = style
   *       )
   *       : node.attrs = { style: style }
   *
   *     return node
   *   })
   * }
   * ```
   */
  match: function (expression, cb) {
    return Array.isArray(expression)
      ? traverse(this, function (node) {
        for (var i = 0; i < expression.length; i++) {
          if (compare(expression[i], node)) return cb(node)
        }

        return node
      })
      : traverse(this, function (node) {
        if (compare(expression, node)) return cb(node)

        return node
      })
  },
  /**
   * Tree messages to store and pass metadata between plugins
   *
   * @memberof tree
   * @type {Array} messages
   *
   * @example
   * ```js
   * export default function plugin (options = {}) {
   *   return function (tree) {
   *      tree.messages.push({
   *        type: 'dependency',
   *        file: 'path/to/dependency.html',
   *        from: tree.options.from
   *      })
   *
   *      return tree
   *   }
   * }
   * ```
   */
  messages: []
}

/**
 * Extends the tree with the it's API
 *
 * @module API
 *
 * @param   {Array} tree - PostHTML Tree
 *
 * @returns {Array} tree - PostHTML Tree (extended)
 */
module.exports = function (tree) {
  tree.walk = api.walk
  tree.match = api.match
  tree.messages = api.messages
}

module.exports.walk = api.walk
module.exports.match = api.match

/** @private */
function traverse (tree, cb) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      tree[i] = traverse(cb(tree[i]), cb)
    }
  } else if (
      tree &&
      typeof tree === 'object' &&
      tree.hasOwnProperty('content')
  ) traverse(tree.content, cb)

  return tree
}

/** @private */
function compare (expected, actual) {
  if (expected instanceof RegExp) {
    if (typeof actual === 'object') return false
    if (typeof actual === 'string') return expected.test(actual)
  }

  if (typeof expected !== typeof actual) return false
  if (typeof expected !== 'object' || expected === null) {
    return expected === actual
  }

  if (Array.isArray(expected)) {
    return expected.every(function (exp) {
      return [].some.call(actual, function (act) {
        return compare(exp, act)
      })
    })
  }

  return Object.keys(expected).every(function (key) {
    var ao = actual[key]
    var eo = expected[key]

    if (typeof eo === 'object' && eo !== null && ao !== null) {
      return compare(eo, ao)
    }
    if (typeof eo === 'boolean') {
      return eo !== (ao == null)
    }

    return ao === eo
  })
}


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _virtualTypes = __webpack_require__(128);

var virtualTypes = _interopRequireWildcard(_virtualTypes);

var _debug2 = __webpack_require__(317);

var _debug3 = _interopRequireDefault(_debug2);

var _invariant = __webpack_require__(323);

var _invariant2 = _interopRequireDefault(_invariant);

var _index = __webpack_require__(30);

var _index2 = _interopRequireDefault(_index);

var _assign = __webpack_require__(324);

var _assign2 = _interopRequireDefault(_assign);

var _scope = __webpack_require__(105);

var _scope2 = _interopRequireDefault(_scope);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

var _cache = __webpack_require__(65);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _debug = (0, _debug3.default)("babel");

var NodePath = function () {
  function NodePath(hub, parent) {
    (0, _classCallCheck3.default)(this, NodePath);

    this.parent = parent;
    this.hub = hub;
    this.contexts = [];
    this.data = {};
    this.shouldSkip = false;
    this.shouldStop = false;
    this.removed = false;
    this.state = null;
    this.opts = null;
    this.skipKeys = null;
    this.parentPath = null;
    this.context = null;
    this.container = null;
    this.listKey = null;
    this.inList = false;
    this.parentKey = null;
    this.key = null;
    this.node = null;
    this.scope = null;
    this.type = null;
    this.typeAnnotation = null;
  }

  NodePath.get = function get(_ref) {
    var hub = _ref.hub,
        parentPath = _ref.parentPath,
        parent = _ref.parent,
        container = _ref.container,
        listKey = _ref.listKey,
        key = _ref.key;

    if (!hub && parentPath) {
      hub = parentPath.hub;
    }

    (0, _invariant2.default)(parent, "To get a node path the parent needs to exist");

    var targetNode = container[key];

    var paths = _cache.path.get(parent) || [];
    if (!_cache.path.has(parent)) {
      _cache.path.set(parent, paths);
    }

    var path = void 0;

    for (var i = 0; i < paths.length; i++) {
      var pathCheck = paths[i];
      if (pathCheck.node === targetNode) {
        path = pathCheck;
        break;
      }
    }

    if (!path) {
      path = new NodePath(hub, parent);
      paths.push(path);
    }

    path.setup(parentPath, container, listKey, key);

    return path;
  };

  NodePath.prototype.getScope = function getScope(scope) {
    var ourScope = scope;

    if (this.isScope()) {
      ourScope = new _scope2.default(this, scope);
    }

    return ourScope;
  };

  NodePath.prototype.setData = function setData(key, val) {
    return this.data[key] = val;
  };

  NodePath.prototype.getData = function getData(key, def) {
    var val = this.data[key];
    if (!val && def) val = this.data[key] = def;
    return val;
  };

  NodePath.prototype.buildCodeFrameError = function buildCodeFrameError(msg) {
    var Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;

    return this.hub.file.buildCodeFrameError(this.node, msg, Error);
  };

  NodePath.prototype.traverse = function traverse(visitor, state) {
    (0, _index2.default)(this.node, visitor, this.scope, state, this);
  };

  NodePath.prototype.mark = function mark(type, message) {
    this.hub.file.metadata.marked.push({
      type: type,
      message: message,
      loc: this.node.loc
    });
  };

  NodePath.prototype.set = function set(key, node) {
    t.validate(this.node, key, node);
    this.node[key] = node;
  };

  NodePath.prototype.getPathLocation = function getPathLocation() {
    var parts = [];
    var path = this;
    do {
      var key = path.key;
      if (path.inList) key = path.listKey + "[" + key + "]";
      parts.unshift(key);
    } while (path = path.parentPath);
    return parts.join(".");
  };

  NodePath.prototype.debug = function debug(buildMessage) {
    if (!_debug.enabled) return;
    _debug(this.getPathLocation() + " " + this.type + ": " + buildMessage());
  };

  return NodePath;
}();

exports.default = NodePath;


(0, _assign2.default)(NodePath.prototype, __webpack_require__(361));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(362));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(365));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(374));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(375));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(376));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(377));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(378));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(380));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(382));
(0, _assign2.default)(NodePath.prototype, __webpack_require__(383));

var _loop2 = function _loop2() {
  if (_isArray) {
    if (_i >= _iterator.length) return "break";
    _ref2 = _iterator[_i++];
  } else {
    _i = _iterator.next();
    if (_i.done) return "break";
    _ref2 = _i.value;
  }

  var type = _ref2;

  var typeKey = "is" + type;
  NodePath.prototype[typeKey] = function (opts) {
    return t[typeKey](this.node, opts);
  };

  NodePath.prototype["assert" + type] = function (opts) {
    if (!this[typeKey](opts)) {
      throw new TypeError("Expected node path of type " + type);
    }
  };
};

for (var _iterator = t.TYPES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
  var _ref2;

  var _ret2 = _loop2();

  if (_ret2 === "break") break;
}

var _loop = function _loop(type) {
  if (type[0] === "_") return "continue";
  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);

  var virtualType = virtualTypes[type];

  NodePath.prototype["is" + type] = function (opts) {
    return virtualType.checkPath(this, opts);
  };
};

for (var type in virtualTypes) {
  var _ret = _loop(type);

  if (_ret === "continue") continue;
}
module.exports = exports["default"];

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(251),
    getValue = __webpack_require__(254);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(72);
var defined = __webpack_require__(74);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(122);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(212), __esModule: true };

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.visitors = exports.Hub = exports.Scope = exports.NodePath = undefined;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _path = __webpack_require__(24);

Object.defineProperty(exports, "NodePath", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_path).default;
  }
});

var _scope = __webpack_require__(105);

Object.defineProperty(exports, "Scope", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scope).default;
  }
});

var _hub = __webpack_require__(164);

Object.defineProperty(exports, "Hub", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_hub).default;
  }
});
exports.default = traverse;

var _context = __webpack_require__(384);

var _context2 = _interopRequireDefault(_context);

var _visitors = __webpack_require__(385);

var visitors = _interopRequireWildcard(_visitors);

var _babelMessages = __webpack_require__(64);

var messages = _interopRequireWildcard(_babelMessages);

var _includes = __webpack_require__(112);

var _includes2 = _interopRequireDefault(_includes);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

var _cache = __webpack_require__(65);

var cache = _interopRequireWildcard(_cache);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.visitors = visitors;
function traverse(parent, opts, scope, state, parentPath) {
  if (!parent) return;
  if (!opts) opts = {};

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error(messages.get("traverseNeedsParent", parent.type));
    }
  }

  visitors.explode(opts);

  traverse.node(parent, opts, scope, state, parentPath);
}

traverse.visitors = visitors;
traverse.verify = visitors.verify;
traverse.explode = visitors.explode;

traverse.NodePath = __webpack_require__(24);
traverse.Scope = __webpack_require__(105);
traverse.Hub = __webpack_require__(164);

traverse.cheap = function (node, enter) {
  return t.traverseFast(node, enter);
};

traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
  var keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;

  var context = new _context2.default(scope, opts, state, parentPath);
  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var key = _ref;

    if (skipKeys && skipKeys[key]) continue;
    if (context.visit(node, key)) return;
  }
};

traverse.clearNode = function (node, opts) {
  t.removeProperties(node, opts);

  cache.path.delete(node);
};

traverse.removeProperties = function (tree, opts) {
  t.traverseFast(tree, traverse.clearNode, opts);
  return tree;
};

function hasBlacklistedType(path, state) {
  if (path.node.type === state.type) {
    state.has = true;
    path.stop();
  }
}

traverse.hasType = function (tree, scope, type, blacklistTypes) {
  if ((0, _includes2.default)(blacklistTypes, tree.type)) return false;

  if (tree.type === type) return true;

  var state = {
    has: false,
    type: type
  };

  traverse(tree, {
    blacklist: blacklistTypes,
    enter: hasBlacklistedType
  }, scope, state);

  return state.has;
};

traverse.clearCache = function () {
  cache.clear();
};

traverse.clearCache.clearPath = cache.clearPath;
traverse.clearCache.clearScope = cache.clearScope;

traverse.copyCache = function (source, destination) {
  if (cache.path.has(source)) {
    cache.path.set(destination, cache.path.get(source));
  }
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(198);
var global = __webpack_require__(8);
var hide = __webpack_require__(14);
var Iterators = __webpack_require__(32);
var TO_STRING_TAG = __webpack_require__(6)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(125);
var enumBugKeys = __webpack_require__(83);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(49)('meta');
var isObject = __webpack_require__(5);
var has = __webpack_require__(16);
var setDesc = __webpack_require__(11).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(15)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(215), __esModule: true };

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(9);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 38 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(94),
    baseAssignValue = __webpack_require__(140);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(28);
var call = __webpack_require__(335);
var isArrayIter = __webpack_require__(336);
var anObject = __webpack_require__(12);
var toLength = __webpack_require__(79);
var getIterFn = __webpack_require__(126);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var toFinite = __webpack_require__(346);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),
/* 43 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const path = __webpack_require__(45);
const fs = __webpack_require__(26);
let info = JSON.parse(fs.readFileSync(path.join(process.cwd(), "./dist/cam.json"), "utf-8"));
//let tt=fs.readdirSync("./cam.json");
//console.log(info)
//let inputRoot,outputRoot,version,Html2JsObj,unpackagedFile,jsScriptsX,jsScripts,unpackagedFolder,manifest;
exports.config = info.config;
exports.inputRoot = info.inputRoot;
exports.outputRoot = info.outputRoot;
exports.version = info.version;
const resolveInputRoot = function (dir) {
    return path.resolve(info.inputRoot, dir);
};
const resolveOutputRoot = function (dir) {
    return path.resolve(info.outputRoot, dir);
};
exports.unpackagedFile = info.unpackagedFile.map(file => {
    return resolveInputRoot(file);
});
exports.jsScriptsX = info.jsScriptsX.map(file => {
    return resolveInputRoot(file);
});
exports.jsScripts = info.jsScripts.map(file => {
    return resolveInputRoot(file);
});
exports.unpackagedFolder = info.unpackagedFolder.map(file => {
    return resolveInputRoot(file);
});
exports.manifest = info.manifest.map(file => {
    return resolveInputRoot(file);
});
exports.Html2JsMap = new Map();
for (let k of Object.keys(info.Html2JsObj)) {
    let v = info.Html2JsObj[k];
    exports.Html2JsMap.set(resolveInputRoot(k), resolveOutputRoot(v));
}
/*
export let inputRoot: string = "C:\\Users\\Administrator\\Documents\\Hbuilder2\\v3Usb";
export let outputRoot: string = "C:\\Users\\Administrator\\Desktop\\cam";


export const version = "20.1.66";









const resolveInputRoot = function (dir) {
    return path.resolve(inputRoot, dir)
}

const resolveOutputRoot = function (dir) {
    return path.resolve(outputRoot, dir)
}



export const Html2JsMap: Map<string, string> = new Map([
    [resolveInputRoot("./background/background.html"), resolveOutputRoot("./main_background.js")],
    [resolveInputRoot("./setting/setting.html"), resolveOutputRoot("./main_setting.js")],
    [resolveInputRoot("./setting/setup.html"), resolveOutputRoot("./main_setup.js")],
    [resolveInputRoot("./popup/popup.html"), resolveOutputRoot("./main_pop.js")]
]);

export const unpackagedFile = info.map((file) => { return resolveInputRoot(file) });

export const jsScriptsX = ["./foreground/myjs.js"].map((file) => { return resolveInputRoot(file) });
export const jsScripts = ["./common/jquery.js", "./setting/js/web_bluetooth.js"].map((file) => { return resolveInputRoot(file) });


export const unpackagedFolder = [".svn", "unpackage"].map((file) => { return resolveInputRoot(file) });

export const manifest = ["./manifest.json"].map((file) => { return resolveInputRoot(file) });
*/

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const fs = __webpack_require__(26);
class Page {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    operate() {
        this.copyFile(this.from, this.to);
    }
    read(IN) {
        try {
            let Txt = fs.readFileSync(IN, "utf-8");
            return Txt;
        } catch (e) {
            return "";
        }
    }
    write(text, OUT) {
        try {
            fs.writeFileSync(OUT, text);
            return true;
        } catch (e) {
            return false;
        }
    }
    writeFile(text, OUT) {
        fs.writeFile(OUT, text, () => {});
    }
    copyFile(IN, OUT) {
        var rs = fs.createReadStream(IN);
        var ws = fs.createWriteStream(OUT);
        rs.pipe(ws);
    }
}
exports.Page = Page;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(12);
var dPs = __webpack_require__(201);
var enumBugKeys = __webpack_require__(83);
var IE_PROTO = __webpack_require__(81)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(124)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(204).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(11).f;
var has = __webpack_require__(16);
var TAG = __webpack_require__(6)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(74);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 52 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(218), __esModule: true };

/***/ }),
/* 54 */
/***/ (function(module, exports) {



/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(135);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)(module)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(241),
    listCacheDelete = __webpack_require__(242),
    listCacheGet = __webpack_require__(243),
    listCacheHas = __webpack_require__(244),
    listCacheSet = __webpack_require__(245);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(38);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(25);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(263);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 61 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(284),
    Map = __webpack_require__(92),
    Promise = __webpack_require__(285),
    Set = __webpack_require__(150),
    WeakMap = __webpack_require__(286),
    baseGetTag = __webpack_require__(18),
    toSource = __webpack_require__(139);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(18),
    isObjectLike = __webpack_require__(10);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.MESSAGES = undefined;

var _stringify = __webpack_require__(35);

var _stringify2 = _interopRequireDefault(_stringify);

exports.get = get;
exports.parseArgs = parseArgs;

var _util = __webpack_require__(70);

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MESSAGES = exports.MESSAGES = {
  tailCallReassignmentDeopt: "Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence",
  classesIllegalBareSuper: "Illegal use of bare super",
  classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
  scopeDuplicateDeclaration: "Duplicate declaration $1",
  settersNoRest: "Setters aren't allowed to have a rest",
  noAssignmentsInForHead: "No assignments allowed in for-in/of head",
  expectedMemberExpressionOrIdentifier: "Expected type MemberExpression or Identifier",
  invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
  readOnly: "$1 is read-only",
  unknownForHead: "Unknown node type $1 in ForStatement",
  didYouMean: "Did you mean $1?",
  codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.",
  missingTemplatesDirectory: "no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues",
  unsupportedOutputType: "Unsupported output type $1",
  illegalMethodName: "Illegal method name $1",
  lostTrackNodePath: "We lost track of this node's position, likely because the AST was directly manipulated",

  modulesIllegalExportName: "Illegal export $1",
  modulesDuplicateDeclarations: "Duplicate module declarations with the same source but in different scopes",

  undeclaredVariable: "Reference to undeclared variable $1",
  undeclaredVariableType: "Referencing a type alias outside of a type annotation",
  undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",

  traverseNeedsParent: "You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a $1 node without passing scope and parentPath.",
  traverseVerifyRootFunction: "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",
  traverseVerifyVisitorProperty: "You passed `traverse()` a visitor object with the property $1 that has the invalid property $2",
  traverseVerifyNodeType: "You gave us a visitor for the node type $1 but it's not a valid type",

  pluginNotObject: "Plugin $2 specified in $1 was expected to return an object when invoked but returned $3",
  pluginNotFunction: "Plugin $2 specified in $1 was expected to return a function but returned $3",
  pluginUnknown: "Unknown plugin $1 specified in $2 at $3, attempted to resolve relative to $4",
  pluginInvalidProperty: "Plugin $2 specified in $1 provided an invalid property of $3"
};

function get(key) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var msg = MESSAGES[key];
  if (!msg) throw new ReferenceError("Unknown message " + (0, _stringify2.default)(key));

  args = parseArgs(args);

  return msg.replace(/\$(\d+)/g, function (str, i) {
    return args[i - 1];
  });
}

function parseArgs(args) {
  return args.map(function (val) {
    if (val != null && val.inspect) {
      return val.inspect();
    } else {
      try {
        return (0, _stringify2.default)(val) || val + "";
      } catch (e) {
        return util.inspect(val);
      }
    }
  });
}

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.scope = exports.path = undefined;

var _weakMap = __webpack_require__(356);

var _weakMap2 = _interopRequireDefault(_weakMap);

exports.clear = clear;
exports.clearPath = clearPath;
exports.clearScope = clearScope;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var path = exports.path = new _weakMap2.default();
var scope = exports.scope = new _weakMap2.default();

function clear() {
  clearPath();
  clearScope();
}

function clearPath() {
  exports.path = path = new _weakMap2.default();
}

function clearScope() {
  exports.scope = scope = new _weakMap2.default();
}

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var baseMatches = __webpack_require__(415),
    baseMatchesProperty = __webpack_require__(423),
    identity = __webpack_require__(103),
    isArray = __webpack_require__(7),
    property = __webpack_require__(431);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(63);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = __webpack_require__(178);
const parser = __webpack_require__(69);
var walk = __webpack_require__(23).walk;
var match = __webpack_require__(23).match;
var url = "https://www.javascriptobfuscator.com/Javascript-Obfuscator.aspx";
var header = {
    "Origin": "https://www.javascriptobfuscator.com",
    "Upgrade-Insecure-Requests": "1",
    "Content-Type": "application/x-www-form-urlencoded",
    "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36",
    "X-DevTools-Emulate-Network-Conditions-Client-Id": "(38CC8F69A76EA6342E4B31B1A8ABD9D8)",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng",
    "Referer": "https://www.javascriptobfuscator.com/Javascript-Obfuscator.aspx",
    //"Accept-Encoding": "gzip, deflate, br",
    "Accept-Language": "zh-CN,zh;q=0.9",
    "Cookie": "__cfduid=dcf56d9734776950978dd79f220f9a4b51514034909"
};
let postData = {
    "UploadLib_Uploader_js": "1",
    "__EVENTARGUMENT": "",
    "__EVENTTARGET": "ctl00$MainContent$Button1",
    "__EVENTVALIDATION": "/wEdAAxRV/QgRKJa6jGWNpNdeJ8NCJ8xELtYGHfHJig8BNR1A/nd3wctyww89JbDbeLvgrjW/QY5cz+pu3qUjqM+4n5jIWlyEKFxLO5ck+F6M0ODiJ1itZp+2hATYVWj/b++nyR8f2dPhQQre4aI0Iea4dKYmjI5SSrP8/di9FPKAsCRiSDSoNvpe2qp90wnP2HAWzNs9mdJae9TApAJFRRb54f73WbA4XcESfoeI8EInEzA+dxRJK/kVxlULg0AsW337/IhyPlLzNxB/IG4FEUM09ELS59E622Kl2Q2tVkHjKOrKg==",
    "__VIEWSTATE": "/wEPDwUKMTM4MjU3NDgxNw9kFgJmD2QWAgIDD2QWBAIBDxYCHgRUZXh0BfoCPGxpIGNsYXNzPSdsaXN0LWlubGluZS1pdGVtIGctbXgtNCBnLW10LTEwJz48YSBjbGFzcz0nZy1jb2xvci13aGl0ZSBnLWNvbG9yLXByaW1hcnktLWhvdmVyIGctdGV4dC11bmRlcmxpbmUtLW5vbmUtLWhvdmVyJyBocmVmPScvc2lnbmluLmFzcHgnPkFjY291bnQgTG9naW48L2E+PC9saT4KPGxpIGNsYXNzPSdsaXN0LWlubGluZS1pdGVtIGctbXgtNCBnLW10LTEwJz58PC9saT4KPGxpIGNsYXNzPSdsaXN0LWlubGluZS1pdGVtIGctbXgtNCBnLW10LTEwJz48YSBjbGFzcz0nZy1jb2xvci13aGl0ZSBnLWNvbG9yLXByaW1hcnktLWhvdmVyIGctdGV4dC11bmRlcmxpbmUtLW5vbmUtLWhvdmVyJyBocmVmPScvcmVnaXN0ZXIuYXNweCc+UmVnaXN0ZXI8L2E+PC9saT4gZAIHD2QWAgIZDw8WAh4HVmlzaWJsZWdkZBgBBR5fX0NvbnRyb2xzUmVxdWlyZVBvc3RCYWNrS2V5X18WBQUaY3RsMDAkTWFpbkNvbnRlbnQkY2JMaW5lQlIFGmN0bDAwJE1haW5Db250ZW50JGNiSW5kZW50BR1jdGwwMCRNYWluQ29udGVudCRjYkVuY29kZVN0cgUbY3RsMDAkTWFpbkNvbnRlbnQkY2JNb3ZlU3RyBSBjdGwwMCRNYWluQ29udGVudCRjYlJlcGxhY2VOYW1lc2yv/qXn7612SqIWRpHEkuW6yB52C5sDLkfHNHI5V/4G",
    "__VIEWSTATEGENERATOR": "6D198BE1",
    "ctl00$MainContent$TextBox1": "var i = 0;\n\n\nvar y = 0;",
    "ctl00$MainContent$TextBox2": "",
    "ctl00$MainContent$TextBox3": "",
    "ctl00$MainContent$cbEncodeStr": "on",
    "ctl00$MainContent$cbMoveStr": "on",
    "ctl00$MainContent$cbReplaceNames": "on",
    "ctl00$MainContent$uploader1": ""
};
var parseHtml = function pluginName(tree) {
    // do something for tree
    tree.match({ tag: 'textarea' }, function (node) {
        //console.log(node.attrs.id)
        if (node.attrs && node.attrs && node.attrs.id == "ctl00_MainContent_TextBox2") {
            return node;
        }
    });
    // return tree;
};
function xmlescape(text) {
    text = text.replace(/&amp;/g, "&");
    text = text.replace(/&lt;/g, "<");
    text = text.replace(/&gt;/g, ">");
    text = text.replace(/&apos;/g, "'");
    text = text.replace(/&quot;/g, '"');
    return text;
}
;
function encryptCode(inputCode) {
    postData["ctl00$MainContent$TextBox1"] = inputCode;
    let promise = request_1.postMessage(url, postData, header);
    let output = "";
    //console.log("00000000000000000000000000000000000000000")
    return new Promise((resolve, reject) => {
        promise.then(v => {
            let ast = parser(v);
            match.call(ast, { tag: 'textarea' }, node => {
                if (node.attrs && node.attrs && node.attrs.id == "ctl00_MainContent_TextBox2") {
                    output += node.content;
                    return node;
                }
            });
            resolve(xmlescape(output));
        }).catch(e => {
            console.log("error", e);
            reject(e);
        });
    });
}
exports.encryptCode = encryptCode;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Parser = __webpack_require__(117);
var isObject = __webpack_require__(118);
var objectAssign = __webpack_require__(119);

/**
 * @see https://github.com/fb55/htmlparser2/wiki/Parser-options
 */
var defaultOptions = {lowerCaseTags: false, lowerCaseAttributeNames: false};

var defaultDirectives = [{name: '!doctype', start: '<', end: '>'}];

/**
 * Parse html to PostHTMLTree
 * @param  {String} html
 * @param  {Object} [options=defaultOptions]
 * @return {PostHTMLTree}
 */
function postHTMLParser(html, options) {
    var bufArray = [],
        results = [];

    bufArray.last = function() {
        return this[this.length - 1];
    };

    function isDirective(directive, tag) {
        if (directive.name instanceof RegExp) {
            var regex = RegExp(directive.name.source, 'i');

            return regex.test(tag);
        }

        if (tag !== directive.name) {
            return false;
        }

        return true;
    }

    function parserDirective(name, data) {
        var directives = [].concat(defaultDirectives, options.directives || []);
        var last = bufArray.last();

        for (var i = 0; i < directives.length; i++) {
            var directive = directives[i];
            var directiveText = directive.start + data + directive.end;

            name = name.toLowerCase();
            if (isDirective(directive, name)) {
                if (!last) {
                    results.push(directiveText);
                    return;
                }

                last.content || (last.content = []);
                last.content.push(directiveText);
            }
        }
    }

    function normalizeArributes(attrs) {
        var result = {};
        Object.keys(attrs).forEach(function(key) {
            var obj = {};
                obj[key] = attrs[key].replace(/&quot;/g, '"');
            objectAssign(result, obj);
        });

        return result;
    }

    var parser = new Parser({
        onprocessinginstruction: parserDirective,
        oncomment: function(data) {
            var comment = '<!--' + data + '-->',
                last = bufArray.last();

            if (!last) {
                results.push(comment);
                return;
            }

            last.content || (last.content = []);
            last.content.push(comment);
        },
        onopentag: function(tag, attrs) {
            var buf = { tag: tag };

            if (Object.keys(attrs).length) {
                buf.attrs = normalizeArributes(attrs);
            }

            bufArray.push(buf);
        },
        onclosetag: function() {
            var buf = bufArray.pop();

            if (!bufArray.length) {
                results.push(buf);
                return;
            }

            var last = bufArray.last();
            if (!Array.isArray(last.content)) {
                last.content = [];
            }

            last.content.push(buf);
        },
        ontext: function(text) {
            var last = bufArray.last();
            if (!last) {
                results.push(text);
                return;
            }

            last.content || (last.content = []);
            last.content.push(text);
        }
    }, options || defaultOptions);

    parser.write(html);
    parser.end();

    return results;
}

function parserWrapper() {
    var option;

    function parser(html) {
        var opt = objectAssign(defaultOptions, option);
        return postHTMLParser(html, opt);
    }

    if (arguments.length === 1 && isObject(arguments[0])) {
        option = arguments[0];
        return parser;
    }

    option = arguments[1];
    return parser(arguments[0]);
}

module.exports = parserWrapper;
module.exports.defaultOptions = defaultOptions;
module.exports.defaultDirectives = defaultDirectives;


/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function(global) {
/**
 * Render PostHTMLTree to html
 * @param  {Object} tree    PostHTMLTree
 * @param  {Object} options Render options
 * @return {String}         html string
 */
function postHTMLRender(tree, options) {
    options = options || {};

    /**
     * options render
     * @param {Array}  singleTags           single tags array for extend default
     * @param {String} closingSingleTag     option for closing single tag
     *                                      Option:
     *                                          default: `<br>`
     *                                          slash: `<br />`
     *                                          tag: `<br></br>`
     *
     */

    var optSingleTags = options.singleTags,
        closingSingleTag = options.closingSingleTag;

    var SINGLE_TAGS = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen',
                        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];
    var singleTags = {};
    var regexpSingleTags = [];

    for (var i = 0, leni = SINGLE_TAGS.length; i < leni; i++) {
        singleTags[SINGLE_TAGS[i]] = 1;
    }

    if (optSingleTags) {
        for (var j = 0, lenj = optSingleTags.length; j < lenj; j++) {
            if (optSingleTags[j] instanceof RegExp) {
                regexpSingleTags.push(optSingleTags[j]);
            } else {
                singleTags[optSingleTags[j]] = 1;
            }
        }
    }

    return html(tree);

    function html(tree) {

        var buf = '';

        traverse([].concat(tree), function(node) {
            if (!node) return;
            if (typeof node === 'string' || typeof node === 'number') {
                buf += node;
                return;
            }
            if (typeof node.tag === 'boolean' && !node.tag) {
                typeof node.content !== 'object' &&  (buf += node.content);
                return node.content;
            }

            // treat as new root tree if node is an array
            if (Array.isArray(node)) {
                buf += html(node);
                return;
            }

            var tag = node.tag || 'div';
            if (isSingleTag(tag, singleTags, regexpSingleTags)) {
                buf += '<'+ tag + attrs(node.attrs);
                switch (closingSingleTag) {
                    case 'slash':
                        buf += ' />';
                        break;
                    case 'tag':
                        buf += '></' + tag + '>';
                        break;
                    default:
                        buf += '>';
                }
            } else {
                buf += '<' + tag + (node.attrs? attrs(node.attrs): '') + '>' +
                    (node.content? html(node.content): '') +
                    '</' + tag + '>';
            }
        });

        return buf;

        function attrs(obj) {
            var attr = '';
            for (var key in obj) {
                if (
                    typeof obj[key] === 'boolean' &&
                    obj[key]
                ) attr += ' ' + key;
                else if (
                    typeof obj[key] === 'string' ||
                    typeof obj[key] === 'number'
                ) attr += ' ' + key + '="' + obj[key] + '"';
            }
            return attr;
        }
    }
}

function traverse(tree, cb) {
    if (Array.isArray(tree)) {
        for (var i = 0, len = tree.length; i < len; i++) {
            traverse(cb(tree[i]), cb);
        }
    } else if (typeof tree === 'object' && tree.hasOwnProperty('content')) traverse(tree.content, cb);
    return tree;
}

function isSingleTag(tag, strings, regexps) {
    if (strings[tag]) {
        return true;
    }
    for (var i = 0; i < regexps.length; i++) {
        if (tag.match(regexps[i])) {
            return true;
        }
    }
    return false;
}

var defineAsGlobal = true;

/* istanbul ignore next */
if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = postHTMLRender;
    defineAsGlobal = false;
}

/* istanbul ignore next */
if (typeof modules === 'object' && typeof modules.define === 'function') {
    modules.define('postHTMLRender', function(provide) {
        provide(postHTMLRender);
    });
    defineAsGlobal = false;
}

/* istanbul ignore next */
if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {
        module.exports = postHTMLRender;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    defineAsGlobal = false;
}
/* istanbul ignore next */
defineAsGlobal && (global.postHTMLRender = postHTMLRender);

/* istanbul ignore next */
})(typeof window !== 'undefined'? window: global);


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(73);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 73 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 74 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(76);
var $export = __webpack_require__(4);
var redefine = __webpack_require__(78);
var hide = __webpack_require__(14);
var has = __webpack_require__(16);
var Iterators = __webpack_require__(32);
var $iterCreate = __webpack_require__(200);
var setToStringTag = __webpack_require__(50);
var getPrototypeOf = __webpack_require__(205);
var ITERATOR = __webpack_require__(6)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(5);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(14);


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(80);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 80 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(82)('keys');
var uid = __webpack_require__(49);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(8);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 83 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(206)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(75)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(8);
var has = __webpack_require__(16);
var DESCRIPTORS = __webpack_require__(13);
var $export = __webpack_require__(4);
var redefine = __webpack_require__(78);
var META = __webpack_require__(34).KEY;
var $fails = __webpack_require__(15);
var shared = __webpack_require__(82);
var setToStringTag = __webpack_require__(50);
var uid = __webpack_require__(49);
var wks = __webpack_require__(6);
var wksExt = __webpack_require__(86);
var wksDefine = __webpack_require__(87);
var enumKeys = __webpack_require__(210);
var isArray = __webpack_require__(129);
var anObject = __webpack_require__(12);
var isObject = __webpack_require__(5);
var toIObject = __webpack_require__(27);
var toPrimitive = __webpack_require__(77);
var createDesc = __webpack_require__(47);
var _create = __webpack_require__(48);
var gOPNExt = __webpack_require__(211);
var $GOPD = __webpack_require__(131);
var $DP = __webpack_require__(11);
var $keys = __webpack_require__(33);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(130).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(52).f = $propertyIsEnumerable;
  __webpack_require__(88).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(76)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(14)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(6);


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(8);
var core = __webpack_require__(2);
var LIBRARY = __webpack_require__(76);
var wksExt = __webpack_require__(86);
var defineProperty = __webpack_require__(11).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 88 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;

var _for = __webpack_require__(216);

var _for2 = _interopRequireDefault(_for);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
var FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"];
var FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"];
var COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];

var LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&"];
var UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"];

var BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
var EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
var COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
var BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);
var NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
var BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);

var BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
var NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "++", "--", "~"];
var STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"];
var UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);

var INHERIT_KEYS = exports.INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};

var BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = (0, _for2.default)("var used to be block scoped");
var NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = (0, _for2.default)("should not be considered a local binding");

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(136);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(57),
    stackClear = __webpack_require__(246),
    stackDelete = __webpack_require__(247),
    stackGet = __webpack_require__(248),
    stackHas = __webpack_require__(249),
    stackSet = __webpack_require__(250);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(25),
    root = __webpack_require__(9);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(255),
    mapCacheDelete = __webpack_require__(262),
    mapCacheGet = __webpack_require__(264),
    mapCacheHas = __webpack_require__(265),
    mapCacheSet = __webpack_require__(266);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(140),
    eq = __webpack_require__(38);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(9),
    stubFalse = __webpack_require__(271);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)(module)))

/***/ }),
/* 96 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 97 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(142),
    baseKeysIn = __webpack_require__(276),
    isArrayLike = __webpack_require__(21);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(281),
    stubArray = __webpack_require__(145);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(151);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 101 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(38),
    isArrayLike = __webpack_require__(21),
    isIndex = __webpack_require__(96),
    isObject = __webpack_require__(19);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _keys = __webpack_require__(29);

var _keys2 = _interopRequireDefault(_keys);

var _create = __webpack_require__(53);

var _create2 = _interopRequireDefault(_create);

var _map = __webpack_require__(157);

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _includes = __webpack_require__(112);

var _includes2 = _interopRequireDefault(_includes);

var _repeat = __webpack_require__(158);

var _repeat2 = _interopRequireDefault(_repeat);

var _renamer = __webpack_require__(352);

var _renamer2 = _interopRequireDefault(_renamer);

var _index = __webpack_require__(30);

var _index2 = _interopRequireDefault(_index);

var _defaults = __webpack_require__(353);

var _defaults2 = _interopRequireDefault(_defaults);

var _babelMessages = __webpack_require__(64);

var messages = _interopRequireWildcard(_babelMessages);

var _binding2 = __webpack_require__(160);

var _binding3 = _interopRequireDefault(_binding2);

var _globals = __webpack_require__(354);

var _globals2 = _interopRequireDefault(_globals);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

var _cache = __webpack_require__(65);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _crawlCallsCount = 0;

function getCache(path, parentScope, self) {
  var scopes = _cache.scope.get(path.node) || [];

  for (var _iterator = scopes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var scope = _ref;

    if (scope.parent === parentScope && scope.path === path) return scope;
  }

  scopes.push(self);

  if (!_cache.scope.has(path.node)) {
    _cache.scope.set(path.node, scopes);
  }
}

function gatherNodeParts(node, parts) {
  if (t.isModuleDeclaration(node)) {
    if (node.source) {
      gatherNodeParts(node.source, parts);
    } else if (node.specifiers && node.specifiers.length) {
      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var specifier = _ref2;

        gatherNodeParts(specifier, parts);
      }
    } else if (node.declaration) {
      gatherNodeParts(node.declaration, parts);
    }
  } else if (t.isModuleSpecifier(node)) {
    gatherNodeParts(node.local, parts);
  } else if (t.isMemberExpression(node)) {
    gatherNodeParts(node.object, parts);
    gatherNodeParts(node.property, parts);
  } else if (t.isIdentifier(node)) {
    parts.push(node.name);
  } else if (t.isLiteral(node)) {
    parts.push(node.value);
  } else if (t.isCallExpression(node)) {
    gatherNodeParts(node.callee, parts);
  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {
    for (var _iterator3 = node.properties, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var prop = _ref3;

      gatherNodeParts(prop.key || prop.argument, parts);
    }
  }
}

var collectorVisitor = {
  For: function For(path) {
    for (var _iterator4 = t.FOR_INIT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var key = _ref4;

      var declar = path.get(key);
      if (declar.isVar()) path.scope.getFunctionParent().registerBinding("var", declar);
    }
  },
  Declaration: function Declaration(path) {
    if (path.isBlockScoped()) return;

    if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) return;

    path.scope.getFunctionParent().registerDeclaration(path);
  },
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    state.references.push(path);
  },
  ForXStatement: function ForXStatement(path, state) {
    var left = path.get("left");
    if (left.isPattern() || left.isIdentifier()) {
      state.constantViolations.push(left);
    }
  },


  ExportDeclaration: {
    exit: function exit(path) {
      var node = path.node,
          scope = path.scope;

      var declar = node.declaration;
      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
        var _id = declar.id;
        if (!_id) return;

        var binding = scope.getBinding(_id.name);
        if (binding) binding.reference(path);
      } else if (t.isVariableDeclaration(declar)) {
        for (var _iterator5 = declar.declarations, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
          var _ref5;

          if (_isArray5) {
            if (_i5 >= _iterator5.length) break;
            _ref5 = _iterator5[_i5++];
          } else {
            _i5 = _iterator5.next();
            if (_i5.done) break;
            _ref5 = _i5.value;
          }

          var decl = _ref5;

          var ids = t.getBindingIdentifiers(decl);
          for (var name in ids) {
            var _binding = scope.getBinding(name);
            if (_binding) _binding.reference(path);
          }
        }
      }
    }
  },

  LabeledStatement: function LabeledStatement(path) {
    path.scope.getProgramParent().addGlobal(path.node);
    path.scope.getBlockParent().registerDeclaration(path);
  },
  AssignmentExpression: function AssignmentExpression(path, state) {
    state.assignments.push(path);
  },
  UpdateExpression: function UpdateExpression(path, state) {
    state.constantViolations.push(path.get("argument"));
  },
  UnaryExpression: function UnaryExpression(path, state) {
    if (path.node.operator === "delete") {
      state.constantViolations.push(path.get("argument"));
    }
  },
  BlockScoped: function BlockScoped(path) {
    var scope = path.scope;
    if (scope.path === path) scope = scope.parent;
    scope.getBlockParent().registerDeclaration(path);
  },
  ClassDeclaration: function ClassDeclaration(path) {
    var id = path.node.id;
    if (!id) return;

    var name = id.name;
    path.scope.bindings[name] = path.scope.getBinding(name);
  },
  Block: function Block(path) {
    var paths = path.get("body");
    for (var _iterator6 = paths, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
      var _ref6;

      if (_isArray6) {
        if (_i6 >= _iterator6.length) break;
        _ref6 = _iterator6[_i6++];
      } else {
        _i6 = _iterator6.next();
        if (_i6.done) break;
        _ref6 = _i6.value;
      }

      var bodyPath = _ref6;

      if (bodyPath.isFunctionDeclaration()) {
        path.scope.getBlockParent().registerDeclaration(bodyPath);
      }
    }
  }
};

var uid = 0;

var Scope = function () {
  function Scope(path, parentScope) {
    (0, _classCallCheck3.default)(this, Scope);

    if (parentScope && parentScope.block === path.node) {
      return parentScope;
    }

    var cached = getCache(path, parentScope, this);
    if (cached) return cached;

    this.uid = uid++;
    this.parent = parentScope;
    this.hub = path.hub;

    this.parentBlock = path.parent;
    this.block = path.node;
    this.path = path;

    this.labels = new _map2.default();
  }

  Scope.prototype.traverse = function traverse(node, opts, state) {
    (0, _index2.default)(node, opts, this, state, this.path);
  };

  Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";

    var id = this.generateUidIdentifier(name);
    this.push({ id: id });
    return id;
  };

  Scope.prototype.generateUidIdentifier = function generateUidIdentifier() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";

    return t.identifier(this.generateUid(name));
  };

  Scope.prototype.generateUid = function generateUid() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";

    name = t.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");

    var uid = void 0;
    var i = 0;
    do {
      uid = this._generateUid(name, i);
      i++;
    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

    var program = this.getProgramParent();
    program.references[uid] = true;
    program.uids[uid] = true;

    return uid;
  };

  Scope.prototype._generateUid = function _generateUid(name, i) {
    var id = name;
    if (i > 1) id += i;
    return "_" + id;
  };

  Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) {
    var node = parent;

    if (t.isAssignmentExpression(parent)) {
      node = parent.left;
    } else if (t.isVariableDeclarator(parent)) {
      node = parent.id;
    } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {
      node = node.key;
    }

    var parts = [];
    gatherNodeParts(node, parts);

    var id = parts.join("$");
    id = id.replace(/^_/, "") || defaultName || "ref";

    return this.generateUidIdentifier(id.slice(0, 20));
  };

  Scope.prototype.isStatic = function isStatic(node) {
    if (t.isThisExpression(node) || t.isSuper(node)) {
      return true;
    }

    if (t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (binding) {
        return binding.constant;
      } else {
        return this.hasBinding(node.name);
      }
    }

    return false;
  };

  Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
    if (this.isStatic(node)) {
      return null;
    } else {
      var _id2 = this.generateUidIdentifierBasedOnNode(node);
      if (!dontPush) this.push({ id: _id2 });
      return _id2;
    }
  };

  Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
    if (kind === "param") return;

    if (kind === "hoisted" && local.kind === "let") return;

    var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

    if (duplicate) {
      throw this.hub.file.buildCodeFrameError(id, messages.get("scopeDuplicateDeclaration", name), TypeError);
    }
  };

  Scope.prototype.rename = function rename(oldName, newName, block) {
    var binding = this.getBinding(oldName);
    if (binding) {
      newName = newName || this.generateUidIdentifier(oldName).name;
      return new _renamer2.default(binding, oldName, newName).rename(block);
    }
  };

  Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
    if (map[oldName]) {
      map[newName] = value;
      map[oldName] = null;
    }
  };

  Scope.prototype.dump = function dump() {
    var sep = (0, _repeat2.default)("-", 60);
    console.log(sep);
    var scope = this;
    do {
      console.log("#", scope.block.type);
      for (var name in scope.bindings) {
        var binding = scope.bindings[name];
        console.log(" -", name, {
          constant: binding.constant,
          references: binding.references,
          violations: binding.constantViolations.length,
          kind: binding.kind
        });
      }
    } while (scope = scope.parent);
    console.log(sep);
  };

  Scope.prototype.toArray = function toArray(node, i) {
    var file = this.hub.file;

    if (t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (binding && binding.constant && binding.path.isGenericType("Array")) return node;
    }

    if (t.isArrayExpression(node)) {
      return node;
    }

    if (t.isIdentifier(node, { name: "arguments" })) {
      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier("Array"), t.identifier("prototype")), t.identifier("slice")), t.identifier("call")), [node]);
    }

    var helperName = "toArray";
    var args = [node];
    if (i === true) {
      helperName = "toConsumableArray";
    } else if (i) {
      args.push(t.numericLiteral(i));
      helperName = "slicedToArray";
    }
    return t.callExpression(file.addHelper(helperName), args);
  };

  Scope.prototype.hasLabel = function hasLabel(name) {
    return !!this.getLabel(name);
  };

  Scope.prototype.getLabel = function getLabel(name) {
    return this.labels.get(name);
  };

  Scope.prototype.registerLabel = function registerLabel(path) {
    this.labels.set(path.node.label.name, path);
  };

  Scope.prototype.registerDeclaration = function registerDeclaration(path) {
    if (path.isLabeledStatement()) {
      this.registerLabel(path);
    } else if (path.isFunctionDeclaration()) {
      this.registerBinding("hoisted", path.get("id"), path);
    } else if (path.isVariableDeclaration()) {
      var declarations = path.get("declarations");
      for (var _iterator7 = declarations, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
        var _ref7;

        if (_isArray7) {
          if (_i7 >= _iterator7.length) break;
          _ref7 = _iterator7[_i7++];
        } else {
          _i7 = _iterator7.next();
          if (_i7.done) break;
          _ref7 = _i7.value;
        }

        var declar = _ref7;

        this.registerBinding(path.node.kind, declar);
      }
    } else if (path.isClassDeclaration()) {
      this.registerBinding("let", path);
    } else if (path.isImportDeclaration()) {
      var specifiers = path.get("specifiers");
      for (var _iterator8 = specifiers, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {
        var _ref8;

        if (_isArray8) {
          if (_i8 >= _iterator8.length) break;
          _ref8 = _iterator8[_i8++];
        } else {
          _i8 = _iterator8.next();
          if (_i8.done) break;
          _ref8 = _i8.value;
        }

        var specifier = _ref8;

        this.registerBinding("module", specifier);
      }
    } else if (path.isExportDeclaration()) {
      var _declar = path.get("declaration");
      if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
        this.registerDeclaration(_declar);
      }
    } else {
      this.registerBinding("unknown", path);
    }
  };

  Scope.prototype.buildUndefinedNode = function buildUndefinedNode() {
    if (this.hasBinding("undefined")) {
      return t.unaryExpression("void", t.numericLiteral(0), true);
    } else {
      return t.identifier("undefined");
    }
  };

  Scope.prototype.registerConstantViolation = function registerConstantViolation(path) {
    var ids = path.getBindingIdentifiers();
    for (var name in ids) {
      var binding = this.getBinding(name);
      if (binding) binding.reassign(path);
    }
  };

  Scope.prototype.registerBinding = function registerBinding(kind, path) {
    var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;

    if (!kind) throw new ReferenceError("no `kind`");

    if (path.isVariableDeclaration()) {
      var declarators = path.get("declarations");
      for (var _iterator9 = declarators, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {
        var _ref9;

        if (_isArray9) {
          if (_i9 >= _iterator9.length) break;
          _ref9 = _iterator9[_i9++];
        } else {
          _i9 = _iterator9.next();
          if (_i9.done) break;
          _ref9 = _i9.value;
        }

        var declar = _ref9;

        this.registerBinding(kind, declar);
      }
      return;
    }

    var parent = this.getProgramParent();
    var ids = path.getBindingIdentifiers(true);

    for (var name in ids) {
      for (var _iterator10 = ids[name], _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {
        var _ref10;

        if (_isArray10) {
          if (_i10 >= _iterator10.length) break;
          _ref10 = _iterator10[_i10++];
        } else {
          _i10 = _iterator10.next();
          if (_i10.done) break;
          _ref10 = _i10.value;
        }

        var _id3 = _ref10;

        var local = this.getOwnBinding(name);
        if (local) {
          if (local.identifier === _id3) continue;

          this.checkBlockScopedCollisions(local, kind, name, _id3);
        }

        if (local && local.path.isFlow()) local = null;

        parent.references[name] = true;

        this.bindings[name] = new _binding3.default({
          identifier: _id3,
          existing: local,
          scope: this,
          path: bindingPath,
          kind: kind
        });
      }
    }
  };

  Scope.prototype.addGlobal = function addGlobal(node) {
    this.globals[node.name] = node;
  };

  Scope.prototype.hasUid = function hasUid(name) {
    var scope = this;

    do {
      if (scope.uids[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.hasGlobal = function hasGlobal(name) {
    var scope = this;

    do {
      if (scope.globals[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.hasReference = function hasReference(name) {
    var scope = this;

    do {
      if (scope.references[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.isPure = function isPure(node, constantsOnly) {
    if (t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (!binding) return false;
      if (constantsOnly) return binding.constant;
      return true;
    } else if (t.isClass(node)) {
      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) return false;
      return this.isPure(node.body, constantsOnly);
    } else if (t.isClassBody(node)) {
      for (var _iterator11 = node.body, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : (0, _getIterator3.default)(_iterator11);;) {
        var _ref11;

        if (_isArray11) {
          if (_i11 >= _iterator11.length) break;
          _ref11 = _iterator11[_i11++];
        } else {
          _i11 = _iterator11.next();
          if (_i11.done) break;
          _ref11 = _i11.value;
        }

        var method = _ref11;

        if (!this.isPure(method, constantsOnly)) return false;
      }
      return true;
    } else if (t.isBinary(node)) {
      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
    } else if (t.isArrayExpression(node)) {
      for (var _iterator12 = node.elements, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : (0, _getIterator3.default)(_iterator12);;) {
        var _ref12;

        if (_isArray12) {
          if (_i12 >= _iterator12.length) break;
          _ref12 = _iterator12[_i12++];
        } else {
          _i12 = _iterator12.next();
          if (_i12.done) break;
          _ref12 = _i12.value;
        }

        var elem = _ref12;

        if (!this.isPure(elem, constantsOnly)) return false;
      }
      return true;
    } else if (t.isObjectExpression(node)) {
      for (var _iterator13 = node.properties, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : (0, _getIterator3.default)(_iterator13);;) {
        var _ref13;

        if (_isArray13) {
          if (_i13 >= _iterator13.length) break;
          _ref13 = _iterator13[_i13++];
        } else {
          _i13 = _iterator13.next();
          if (_i13.done) break;
          _ref13 = _i13.value;
        }

        var prop = _ref13;

        if (!this.isPure(prop, constantsOnly)) return false;
      }
      return true;
    } else if (t.isClassMethod(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      if (node.kind === "get" || node.kind === "set") return false;
      return true;
    } else if (t.isClassProperty(node) || t.isObjectProperty(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      return this.isPure(node.value, constantsOnly);
    } else if (t.isUnaryExpression(node)) {
      return this.isPure(node.argument, constantsOnly);
    } else {
      return t.isPureish(node);
    }
  };

  Scope.prototype.setData = function setData(key, val) {
    return this.data[key] = val;
  };

  Scope.prototype.getData = function getData(key) {
    var scope = this;
    do {
      var data = scope.data[key];
      if (data != null) return data;
    } while (scope = scope.parent);
  };

  Scope.prototype.removeData = function removeData(key) {
    var scope = this;
    do {
      var data = scope.data[key];
      if (data != null) scope.data[key] = null;
    } while (scope = scope.parent);
  };

  Scope.prototype.init = function init() {
    if (!this.references) this.crawl();
  };

  Scope.prototype.crawl = function crawl() {
    _crawlCallsCount++;
    this._crawl();
    _crawlCallsCount--;
  };

  Scope.prototype._crawl = function _crawl() {
    var path = this.path;

    this.references = (0, _create2.default)(null);
    this.bindings = (0, _create2.default)(null);
    this.globals = (0, _create2.default)(null);
    this.uids = (0, _create2.default)(null);
    this.data = (0, _create2.default)(null);

    if (path.isLoop()) {
      for (var _iterator14 = t.FOR_INIT_KEYS, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : (0, _getIterator3.default)(_iterator14);;) {
        var _ref14;

        if (_isArray14) {
          if (_i14 >= _iterator14.length) break;
          _ref14 = _iterator14[_i14++];
        } else {
          _i14 = _iterator14.next();
          if (_i14.done) break;
          _ref14 = _i14.value;
        }

        var key = _ref14;

        var node = path.get(key);
        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);
      }
    }

    if (path.isFunctionExpression() && path.has("id")) {
      if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path.get("id"), path);
      }
    }

    if (path.isClassExpression() && path.has("id")) {
      if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path);
      }
    }

    if (path.isFunction()) {
      var params = path.get("params");
      for (var _iterator15 = params, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : (0, _getIterator3.default)(_iterator15);;) {
        var _ref15;

        if (_isArray15) {
          if (_i15 >= _iterator15.length) break;
          _ref15 = _iterator15[_i15++];
        } else {
          _i15 = _iterator15.next();
          if (_i15.done) break;
          _ref15 = _i15.value;
        }

        var param = _ref15;

        this.registerBinding("param", param);
      }
    }

    if (path.isCatchClause()) {
      this.registerBinding("let", path);
    }

    var parent = this.getProgramParent();
    if (parent.crawling) return;

    var state = {
      references: [],
      constantViolations: [],
      assignments: []
    };

    this.crawling = true;
    path.traverse(collectorVisitor, state);
    this.crawling = false;

    for (var _iterator16 = state.assignments, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : (0, _getIterator3.default)(_iterator16);;) {
      var _ref16;

      if (_isArray16) {
        if (_i16 >= _iterator16.length) break;
        _ref16 = _iterator16[_i16++];
      } else {
        _i16 = _iterator16.next();
        if (_i16.done) break;
        _ref16 = _i16.value;
      }

      var _path = _ref16;

      var ids = _path.getBindingIdentifiers();
      var programParent = void 0;
      for (var name in ids) {
        if (_path.scope.getBinding(name)) continue;

        programParent = programParent || _path.scope.getProgramParent();
        programParent.addGlobal(ids[name]);
      }

      _path.scope.registerConstantViolation(_path);
    }

    for (var _iterator17 = state.references, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : (0, _getIterator3.default)(_iterator17);;) {
      var _ref17;

      if (_isArray17) {
        if (_i17 >= _iterator17.length) break;
        _ref17 = _iterator17[_i17++];
      } else {
        _i17 = _iterator17.next();
        if (_i17.done) break;
        _ref17 = _i17.value;
      }

      var ref = _ref17;

      var binding = ref.scope.getBinding(ref.node.name);
      if (binding) {
        binding.reference(ref);
      } else {
        ref.scope.getProgramParent().addGlobal(ref.node);
      }
    }

    for (var _iterator18 = state.constantViolations, _isArray18 = Array.isArray(_iterator18), _i18 = 0, _iterator18 = _isArray18 ? _iterator18 : (0, _getIterator3.default)(_iterator18);;) {
      var _ref18;

      if (_isArray18) {
        if (_i18 >= _iterator18.length) break;
        _ref18 = _iterator18[_i18++];
      } else {
        _i18 = _iterator18.next();
        if (_i18.done) break;
        _ref18 = _i18.value;
      }

      var _path2 = _ref18;

      _path2.scope.registerConstantViolation(_path2);
    }
  };

  Scope.prototype.push = function push(opts) {
    var path = this.path;

    if (!path.isBlockStatement() && !path.isProgram()) {
      path = this.getBlockParent().path;
    }

    if (path.isSwitchStatement()) {
      path = this.getFunctionParent().path;
    }

    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
      t.ensureBlock(path.node);
      path = path.get("body");
    }

    var unique = opts.unique;
    var kind = opts.kind || "var";
    var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;

    var dataKey = "declaration:" + kind + ":" + blockHoist;
    var declarPath = !unique && path.getData(dataKey);

    if (!declarPath) {
      var declar = t.variableDeclaration(kind, []);
      declar._generated = true;
      declar._blockHoist = blockHoist;

      var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

      declarPath = _path$unshiftContaine[0];

      if (!unique) path.setData(dataKey, declarPath);
    }

    var declarator = t.variableDeclarator(opts.id, opts.init);
    declarPath.node.declarations.push(declarator);
    this.registerBinding(kind, declarPath.get("declarations").pop());
  };

  Scope.prototype.getProgramParent = function getProgramParent() {
    var scope = this;
    do {
      if (scope.path.isProgram()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a Function or Program...");
  };

  Scope.prototype.getFunctionParent = function getFunctionParent() {
    var scope = this;
    do {
      if (scope.path.isFunctionParent()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a Function or Program...");
  };

  Scope.prototype.getBlockParent = function getBlockParent() {
    var scope = this;
    do {
      if (scope.path.isBlockParent()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
  };

  Scope.prototype.getAllBindings = function getAllBindings() {
    var ids = (0, _create2.default)(null);

    var scope = this;
    do {
      (0, _defaults2.default)(ids, scope.bindings);
      scope = scope.parent;
    } while (scope);

    return ids;
  };

  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
    var ids = (0, _create2.default)(null);

    for (var _iterator19 = arguments, _isArray19 = Array.isArray(_iterator19), _i19 = 0, _iterator19 = _isArray19 ? _iterator19 : (0, _getIterator3.default)(_iterator19);;) {
      var _ref19;

      if (_isArray19) {
        if (_i19 >= _iterator19.length) break;
        _ref19 = _iterator19[_i19++];
      } else {
        _i19 = _iterator19.next();
        if (_i19.done) break;
        _ref19 = _i19.value;
      }

      var kind = _ref19;

      var scope = this;
      do {
        for (var name in scope.bindings) {
          var binding = scope.bindings[name];
          if (binding.kind === kind) ids[name] = binding;
        }
        scope = scope.parent;
      } while (scope);
    }

    return ids;
  };

  Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
    return this.getBindingIdentifier(name) === node;
  };

  Scope.prototype.warnOnFlowBinding = function warnOnFlowBinding(binding) {
    if (_crawlCallsCount === 0 && binding && binding.path.isFlow()) {
      console.warn("\n        You or one of the Babel plugins you are using are using Flow declarations as bindings.\n        Support for this will be removed in version 7. To find out the caller, grep for this\n        message and change it to a `console.trace()`.\n      ");
    }
    return binding;
  };

  Scope.prototype.getBinding = function getBinding(name) {
    var scope = this;

    do {
      var binding = scope.getOwnBinding(name);
      if (binding) return this.warnOnFlowBinding(binding);
    } while (scope = scope.parent);
  };

  Scope.prototype.getOwnBinding = function getOwnBinding(name) {
    return this.warnOnFlowBinding(this.bindings[name]);
  };

  Scope.prototype.getBindingIdentifier = function getBindingIdentifier(name) {
    var info = this.getBinding(name);
    return info && info.identifier;
  };

  Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
    var binding = this.bindings[name];
    return binding && binding.identifier;
  };

  Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
    return !!this.getOwnBinding(name);
  };

  Scope.prototype.hasBinding = function hasBinding(name, noGlobals) {
    if (!name) return false;
    if (this.hasOwnBinding(name)) return true;
    if (this.parentHasBinding(name, noGlobals)) return true;
    if (this.hasUid(name)) return true;
    if (!noGlobals && (0, _includes2.default)(Scope.globals, name)) return true;
    if (!noGlobals && (0, _includes2.default)(Scope.contextVariables, name)) return true;
    return false;
  };

  Scope.prototype.parentHasBinding = function parentHasBinding(name, noGlobals) {
    return this.parent && this.parent.hasBinding(name, noGlobals);
  };

  Scope.prototype.moveBindingTo = function moveBindingTo(name, scope) {
    var info = this.getBinding(name);
    if (info) {
      info.scope.removeOwnBinding(name);
      info.scope = scope;
      scope.bindings[name] = info;
    }
  };

  Scope.prototype.removeOwnBinding = function removeOwnBinding(name) {
    delete this.bindings[name];
  };

  Scope.prototype.removeBinding = function removeBinding(name) {
    var info = this.getBinding(name);
    if (info) {
      info.scope.removeOwnBinding(name);
    }

    var scope = this;
    do {
      if (scope.uids[name]) {
        scope.uids[name] = false;
      }
    } while (scope = scope.parent);
  };

  return Scope;
}();

Scope.globals = (0, _keys2.default)(_globals2.default.builtin);
Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
exports.default = Scope;
module.exports = exports["default"];

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(14);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(8);
var $export = __webpack_require__(4);
var meta = __webpack_require__(34);
var fails = __webpack_require__(15);
var hide = __webpack_require__(14);
var redefineAll = __webpack_require__(106);
var forOf = __webpack_require__(40);
var anInstance = __webpack_require__(107);
var isObject = __webpack_require__(5);
var setToStringTag = __webpack_require__(50);
var dP = __webpack_require__(11).f;
var each = __webpack_require__(109)(0);
var DESCRIPTORS = __webpack_require__(13);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(28);
var IObject = __webpack_require__(72);
var toObject = __webpack_require__(51);
var toLength = __webpack_require__(79);
var asc = __webpack_require__(338);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(4);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(4);
var aFunction = __webpack_require__(122);
var ctx = __webpack_require__(28);
var forOf = __webpack_require__(40);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(153),
    isArrayLike = __webpack_require__(21),
    isString = __webpack_require__(345),
    toInteger = __webpack_require__(42),
    values = __webpack_require__(348);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;


/***/ }),
/* 113 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(7),
    isSymbol = __webpack_require__(63);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ArrayPattern = exports.ObjectPattern = exports.RestProperty = exports.SpreadProperty = exports.SpreadElement = undefined;
exports.Identifier = Identifier;
exports.RestElement = RestElement;
exports.ObjectExpression = ObjectExpression;
exports.ObjectMethod = ObjectMethod;
exports.ObjectProperty = ObjectProperty;
exports.ArrayExpression = ArrayExpression;
exports.RegExpLiteral = RegExpLiteral;
exports.BooleanLiteral = BooleanLiteral;
exports.NullLiteral = NullLiteral;
exports.NumericLiteral = NumericLiteral;
exports.StringLiteral = StringLiteral;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

var _jsesc = __webpack_require__(456);

var _jsesc2 = _interopRequireDefault(_jsesc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function Identifier(node) {
  if (node.variance) {
    if (node.variance === "plus") {
      this.token("+");
    } else if (node.variance === "minus") {
      this.token("-");
    }
  }

  this.word(node.name);
}

function RestElement(node) {
  this.token("...");
  this.print(node.argument, node);
}

exports.SpreadElement = RestElement;
exports.SpreadProperty = RestElement;
exports.RestProperty = RestElement;
function ObjectExpression(node) {
  var props = node.properties;

  this.token("{");
  this.printInnerComments(node);

  if (props.length) {
    this.space();
    this.printList(props, node, { indent: true, statement: true });
    this.space();
  }

  this.token("}");
}

exports.ObjectPattern = ObjectExpression;
function ObjectMethod(node) {
  this.printJoin(node.decorators, node);
  this._method(node);
}

function ObjectProperty(node) {
  this.printJoin(node.decorators, node);

  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) {
      this.print(node.value, node);
      return;
    }

    this.print(node.key, node);

    if (node.shorthand && t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name) {
      return;
    }
  }

  this.token(":");
  this.space();
  this.print(node.value, node);
}

function ArrayExpression(node) {
  var elems = node.elements;
  var len = elems.length;

  this.token("[");
  this.printInnerComments(node);

  for (var i = 0; i < elems.length; i++) {
    var elem = elems[i];
    if (elem) {
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.token(",");
    } else {
      this.token(",");
    }
  }

  this.token("]");
}

exports.ArrayPattern = ArrayExpression;
function RegExpLiteral(node) {
  this.word("/" + node.pattern + "/" + node.flags);
}

function BooleanLiteral(node) {
  this.word(node.value ? "true" : "false");
}

function NullLiteral() {
  this.word("null");
}

function NumericLiteral(node) {
  var raw = this.getPossibleRaw(node);
  var value = node.value + "";
  if (raw == null) {
    this.number(value);
  } else if (this.format.minified) {
    this.number(raw.length < value.length ? raw : value);
  } else {
    this.number(raw);
  }
}

function StringLiteral(node, parent) {
  var raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }

  var opts = {
    quotes: t.isJSX(parent) ? "double" : this.format.quotes,
    wrap: true
  };
  if (this.format.jsonCompatibleStrings) {
    opts.json = true;
  }
  var val = (0, _jsesc2.default)(node.value, opts);

  return this.token(val);
}

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const encrypt_1 = __webpack_require__(68);
exports.encryptCode = encrypt_1.encryptCode;
const fs = __webpack_require__(26);
const posthtml = __webpack_require__(192);
exports.posthtml = posthtml;
const parser = __webpack_require__(69);
exports.parser = parser;
const render = __webpack_require__(71);
exports.render = render;
let walk = __webpack_require__(23).walk;
exports.walk = walk;
let match = __webpack_require__(23).match;
exports.match = match;
function copyFile(IN, OUT) {
    var rs = fs.createReadStream(IN);
    var ws = fs.createWriteStream(OUT);
    rs.pipe(ws);
}
exports.copyFile = copyFile;
function writeFile(text, OUT) {
    //fs.writeFileSync(OUT,text);
    fs.writeFile(OUT, text, () => {
        // console.log(process.uptime())
    });
}
exports.writeFile = writeFile;
function write(text, OUT) {
    try {
        fs.writeFileSync(OUT, text);
        return true;
    } catch (e) {
        return false;
    }
}
exports.write = write;
function read(IN) {
    try {
        let Txt = fs.readFileSync(IN, "utf-8");
        return Txt;
    } catch (e) {
        return "";
    }
}
exports.read = read;
function checkFileName(name) {
    return !new RegExp("[\\u4e00-\\u9fa5]").test(name);
}
exports.checkFileName = checkFileName;
function entries(obj) {
    let arr = [];
    for (let key of Object.keys(obj)) {
        arr.push([key, obj[key]]);
    }
    return arr;
}
exports.entries = entries;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var Tokenizer = __webpack_require__(182);

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	//common self closing svg elements
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
									!!this._options.lowerCaseTags :
									!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
									!!this._options.lowerCaseAttributeNames :
									!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer(this._options, this);

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
}

__webpack_require__(188)(Parser, __webpack_require__(190).EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) this._cbs.ontext(data);
};

Parser.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		);
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
	}

	if(this._cbs.onopentagname) this._cbs.onopentagname(name);
	if(this._cbs.onopentag) this._attribs = {};
};

Parser.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser.prototype.onclosetag = function(name){
	this._updatePosition(1);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
		var pos = this._stack.lastIndexOf(name);
		if(pos !== -1){
			if(this._cbs.onclosetag){
				pos = this._stack.length - pos;
				while(pos--) this._cbs.onclosetag(this._stack.pop());
			}
			else this._stack.length = pos;
		} else if(name === "p" && !this._options.xmlMode){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if(!this._options.xmlMode && (name === "br" || name === "p")){
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

Parser.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
	}
};

Parser.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser.prototype.onattribend = function(){
	if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) this._cbs.oncomment(value);
	if(this._cbs.oncommentend) this._cbs.oncommentend();
};

Parser.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) this._cbs.oncdatastart();
		if(this._cbs.ontext) this._cbs.ontext(value);
		if(this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser.prototype.onerror = function(err){
	if(this._cbs.onerror) this._cbs.onerror(err);
};

Parser.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		);
	}
	if(this._cbs.onend) this._cbs.onend();
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

module.exports = Parser;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */



var isArray = __webpack_require__(191);

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && isArray(val) === false;
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

/* eslint max-len: 0 */

// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.

function makePredicate(words) {
  words = words.split(" ");
  return function (str) {
    return words.indexOf(str) >= 0;
  };
}

// Reserved word lists for various dialects of the language

var reservedWords = {
  6: makePredicate("enum await"),
  strict: makePredicate("implements interface let package private protected public static yield"),
  strictBind: makePredicate("eval arguments")
};

// And the keywords

var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by `bin/generate-identifier-regex.js`.
// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;

    pos += set[i + 1];
    if (pos >= code) return true;
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes);
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

// A second optional argument can be given to further configure
var defaultOptions = {
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // Source filename.
  sourceFilename: undefined,
  // Line from which to start counting source. Useful for
  // integration with other tools.
  startLine: 1,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // TODO
  allowSuperOutsideMethod: false,
  // An array of plugins to enable
  plugins: [],
  // TODO
  strictMode: null
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};
  for (var key in defaultOptions) {
    options[key] = opts && key in opts ? opts[key] : defaultOptions[key];
  }
  return options;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

var TokenType = function TokenType(label) {
  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

var KeywordTokenType = function (_TokenType) {
  inherits(KeywordTokenType, _TokenType);

  function KeywordTokenType(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, KeywordTokenType);

    options.keyword = name;

    return possibleConstructorReturn(this, _TokenType.call(this, name, options));
  }

  return KeywordTokenType;
}(TokenType);

var BinopTokenType = function (_TokenType2) {
  inherits(BinopTokenType, _TokenType2);

  function BinopTokenType(name, prec) {
    classCallCheck(this, BinopTokenType);
    return possibleConstructorReturn(this, _TokenType2.call(this, name, { beforeExpr: beforeExpr, binop: prec }));
  }

  return BinopTokenType;
}(TokenType);

var types = {
  num: new TokenType("num", { startsExpr: startsExpr }),
  regexp: new TokenType("regexp", { startsExpr: startsExpr }),
  string: new TokenType("string", { startsExpr: startsExpr }),
  name: new TokenType("name", { startsExpr: startsExpr }),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  braceBarL: new TokenType("{|", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", { beforeExpr: beforeExpr }),
  semi: new TokenType(";", { beforeExpr: beforeExpr }),
  colon: new TokenType(":", { beforeExpr: beforeExpr }),
  doubleColon: new TokenType("::", { beforeExpr: beforeExpr }),
  dot: new TokenType("."),
  question: new TokenType("?", { beforeExpr: beforeExpr }),
  arrow: new TokenType("=>", { beforeExpr: beforeExpr }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", { beforeExpr: beforeExpr }),
  backQuote: new TokenType("`", { startsExpr: startsExpr }),
  dollarBraceL: new TokenType("${", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  at: new TokenType("@"),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", { beforeExpr: beforeExpr, isAssign: isAssign }),
  assign: new TokenType("_=", { beforeExpr: beforeExpr, isAssign: isAssign }),
  incDec: new TokenType("++/--", { prefix: prefix, postfix: postfix, startsExpr: startsExpr }),
  prefix: new TokenType("prefix", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  logicalOR: new BinopTokenType("||", 1),
  logicalAND: new BinopTokenType("&&", 2),
  bitwiseOR: new BinopTokenType("|", 3),
  bitwiseXOR: new BinopTokenType("^", 4),
  bitwiseAND: new BinopTokenType("&", 5),
  equality: new BinopTokenType("==/!=", 6),
  relational: new BinopTokenType("</>", 7),
  bitShift: new BinopTokenType("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: beforeExpr, binop: 9, prefix: prefix, startsExpr: startsExpr }),
  modulo: new BinopTokenType("%", 10),
  star: new BinopTokenType("*", 10),
  slash: new BinopTokenType("/", 10),
  exponent: new TokenType("**", { beforeExpr: beforeExpr, binop: 11, rightAssociative: true })
};

var keywords = {
  "break": new KeywordTokenType("break"),
  "case": new KeywordTokenType("case", { beforeExpr: beforeExpr }),
  "catch": new KeywordTokenType("catch"),
  "continue": new KeywordTokenType("continue"),
  "debugger": new KeywordTokenType("debugger"),
  "default": new KeywordTokenType("default", { beforeExpr: beforeExpr }),
  "do": new KeywordTokenType("do", { isLoop: isLoop, beforeExpr: beforeExpr }),
  "else": new KeywordTokenType("else", { beforeExpr: beforeExpr }),
  "finally": new KeywordTokenType("finally"),
  "for": new KeywordTokenType("for", { isLoop: isLoop }),
  "function": new KeywordTokenType("function", { startsExpr: startsExpr }),
  "if": new KeywordTokenType("if"),
  "return": new KeywordTokenType("return", { beforeExpr: beforeExpr }),
  "switch": new KeywordTokenType("switch"),
  "throw": new KeywordTokenType("throw", { beforeExpr: beforeExpr }),
  "try": new KeywordTokenType("try"),
  "var": new KeywordTokenType("var"),
  "let": new KeywordTokenType("let"),
  "const": new KeywordTokenType("const"),
  "while": new KeywordTokenType("while", { isLoop: isLoop }),
  "with": new KeywordTokenType("with"),
  "new": new KeywordTokenType("new", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  "this": new KeywordTokenType("this", { startsExpr: startsExpr }),
  "super": new KeywordTokenType("super", { startsExpr: startsExpr }),
  "class": new KeywordTokenType("class"),
  "extends": new KeywordTokenType("extends", { beforeExpr: beforeExpr }),
  "export": new KeywordTokenType("export"),
  "import": new KeywordTokenType("import", { startsExpr: startsExpr }),
  "yield": new KeywordTokenType("yield", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  "null": new KeywordTokenType("null", { startsExpr: startsExpr }),
  "true": new KeywordTokenType("true", { startsExpr: startsExpr }),
  "false": new KeywordTokenType("false", { startsExpr: startsExpr }),
  "in": new KeywordTokenType("in", { beforeExpr: beforeExpr, binop: 7 }),
  "instanceof": new KeywordTokenType("instanceof", { beforeExpr: beforeExpr, binop: 7 }),
  "typeof": new KeywordTokenType("typeof", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  "void": new KeywordTokenType("void", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  "delete": new KeywordTokenType("delete", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr })
};

// Map keyword names to token types.
Object.keys(keywords).forEach(function (name) {
  types["_" + name] = keywords[name];
});

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

var types$1 = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", true),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  functionExpression: new TokContext("function", true)
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  var out = this.state.context.pop();
  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {
    this.state.context.pop();
    this.state.exprAllowed = false;
  } else if (out === types$1.templateQuasi) {
    this.state.exprAllowed = true;
  } else {
    this.state.exprAllowed = !out.isExpr;
  }
};

types.name.updateContext = function (prevType) {
  this.state.exprAllowed = false;

  if (prevType === types._let || prevType === types._const || prevType === types._var) {
    if (lineBreak.test(this.input.slice(this.state.end))) {
      this.state.exprAllowed = true;
    }
  }
};

types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
  this.state.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.state.context.push(types$1.templateQuasi);
  this.state.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
  this.state.exprAllowed = true;
};

types.incDec.updateContext = function () {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = function () {
  if (this.curContext() !== types$1.braceStatement) {
    this.state.context.push(types$1.functionExpression);
  }

  this.state.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types$1.template);
  }
  this.state.exprAllowed = false;
};

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  classCallCheck(this, Position);

  this.line = line;
  this.column = col;
};

var SourceLocation = function SourceLocation(start, end) {
  classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

var State = function () {
  function State() {
    classCallCheck(this, State);
  }

  State.prototype.init = function init(options, input) {
    this.strict = options.strictMode === false ? false : options.sourceType === "module";

    this.input = input;

    this.potentialArrowAt = -1;

    this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.inClassProperty = this.noAnonFunctionType = false;

    this.labels = [];

    this.decorators = [];

    this.tokens = [];

    this.comments = [];

    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];

    this.pos = this.lineStart = 0;
    this.curLine = options.startLine;

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = [types$1.braceStatement];
    this.exprAllowed = true;

    this.containsEsc = this.containsOctal = false;
    this.octalPosition = null;

    this.invalidTemplateEscapePosition = null;

    this.exportedIdentifiers = [];

    return this;
  };

  // TODO


  // TODO


  // Used to signify the start of a potential arrow function


  // Flags to track whether we are in a function, a generator.


  // Labels in scope.


  // Leading decorators.


  // Token store.


  // Comment store.


  // Comment attachment store


  // The current position of the tokenizer in the input.


  // Properties of the current token:
  // Its type


  // For tokens that include more information than their type, the value


  // Its start and end offset


  // And, if locations are used, the {line, column} object
  // corresponding to those offsets


  // Position information for the previous token


  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.


  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.


  // TODO


  // Names of exports store. `default` is stored as a name for both
  // `export default foo;` and `export { foo as default };`.


  State.prototype.curPosition = function curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart);
  };

  State.prototype.clone = function clone(skipArrays) {
    var state = new State();
    for (var key in this) {
      var val = this[key];

      if ((!skipArrays || key === "context") && Array.isArray(val)) {
        val = val.slice();
      }

      state[key] = val;
    }
    return state;
  };

  return State;
}();

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(state) {
  classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new SourceLocation(state.startLoc, state.endLoc);
};

// ## Tokenizer

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  } else {
    return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00);
  }
}

var Tokenizer = function () {
  function Tokenizer(options, input) {
    classCallCheck(this, Tokenizer);

    this.state = new State();
    this.state.init(options, input);
  }

  // Move to the next token

  Tokenizer.prototype.next = function next() {
    if (!this.isLookahead) {
      this.state.tokens.push(new Token(this.state));
    }

    this.state.lastTokEnd = this.state.end;
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  };

  // TODO

  Tokenizer.prototype.eat = function eat(type) {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  // TODO

  Tokenizer.prototype.match = function match(type) {
    return this.state.type === type;
  };

  // TODO

  Tokenizer.prototype.isKeyword = function isKeyword$$1(word) {
    return isKeyword(word);
  };

  // TODO

  Tokenizer.prototype.lookahead = function lookahead() {
    var old = this.state;
    this.state = old.clone(true);

    this.isLookahead = true;
    this.next();
    this.isLookahead = false;

    var curr = this.state.clone(true);
    this.state = old;
    return curr;
  };

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  Tokenizer.prototype.setStrict = function setStrict(strict) {
    this.state.strict = strict;
    if (!this.match(types.num) && !this.match(types.string)) return;
    this.state.pos = this.state.start;
    while (this.state.pos < this.state.lineStart) {
      this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
      --this.state.curLine;
    }
    this.nextToken();
  };

  Tokenizer.prototype.curContext = function curContext() {
    return this.state.context[this.state.context.length - 1];
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  Tokenizer.prototype.nextToken = function nextToken() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();

    this.state.containsOctal = false;
    this.state.octalPosition = null;
    this.state.start = this.state.pos;
    this.state.startLoc = this.state.curPosition();
    if (this.state.pos >= this.input.length) return this.finishToken(types.eof);

    if (curContext.override) {
      return curContext.override(this);
    } else {
      return this.readToken(this.fullCharCodeAtPos());
    }
  };

  Tokenizer.prototype.readToken = function readToken(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code) || code === 92 /* '\' */) {
        return this.readWord();
      } else {
      return this.getTokenFromCode(code);
    }
  };

  Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {
    var code = this.input.charCodeAt(this.state.pos);
    if (code <= 0xd7ff || code >= 0xe000) return code;

    var next = this.input.charCodeAt(this.state.pos + 1);
    return (code << 10) + next - 0x35fdc00;
  };

  Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "CommentBlock" : "CommentLine",
      value: text,
      start: start,
      end: end,
      loc: new SourceLocation(startLoc, endLoc)
    };

    if (!this.isLookahead) {
      this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  };

  Tokenizer.prototype.skipBlockComment = function skipBlockComment() {
    var startLoc = this.state.curPosition();
    var start = this.state.pos;
    var end = this.input.indexOf("*/", this.state.pos += 2);
    if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");

    this.state.pos = end + 2;
    lineBreakG.lastIndex = start;
    var match = void 0;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
      ++this.state.curLine;
      this.state.lineStart = match.index + match[0].length;
    }

    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
  };

  Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {
    var start = this.state.pos;
    var startLoc = this.state.curPosition();
    var ch = this.input.charCodeAt(this.state.pos += startSkip);
    while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
      ++this.state.pos;
      ch = this.input.charCodeAt(this.state.pos);
    }

    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  Tokenizer.prototype.skipSpace = function skipSpace() {
    loop: while (this.state.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.state.pos);
      switch (ch) {
        case 32:case 160:
          // ' '
          ++this.state.pos;
          break;

        case 13:
          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos;
          }

        case 10:case 8232:case 8233:
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          break;

        case 47:
          // '/'
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42:
              // '*'
              this.skipBlockComment();
              break;

            case 47:
              this.skipLineComment(2);
              break;

            default:
              break loop;
          }
          break;

        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.state.pos;
          } else {
            break loop;
          }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  Tokenizer.prototype.finishToken = function finishToken(type, val) {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    var prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //


  Tokenizer.prototype.readToken_dot = function readToken_dot() {
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next >= 48 && next <= 57) {
      return this.readNumber(true);
    }

    var next2 = this.input.charCodeAt(this.state.pos + 2);
    if (next === 46 && next2 === 46) {
      // 46 = dot '.'
      this.state.pos += 3;
      return this.finishToken(types.ellipsis);
    } else {
      ++this.state.pos;
      return this.finishToken(types.dot);
    }
  };

  Tokenizer.prototype.readToken_slash = function readToken_slash() {
    // '/'
    if (this.state.exprAllowed) {
      ++this.state.pos;
      return this.readRegexp();
    }

    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.slash, 1);
    }
  };

  Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {
    // '%*'
    var type = code === 42 ? types.star : types.modulo;
    var width = 1;
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === 42) {
      // '*'
      width++;
      next = this.input.charCodeAt(this.state.pos + 2);
      type = types.exponent;
    }

    if (next === 61) {
      width++;
      type = types.assign;
    }

    return this.finishOp(type, width);
  };

  Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {
    // '|&'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
    if (next === 61) return this.finishOp(types.assign, 2);
    if (code === 124 && next === 125 && this.hasPlugin("flow")) return this.finishOp(types.braceBarR, 2);
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
  };

  Tokenizer.prototype.readToken_caret = function readToken_caret() {
    // '^'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.bitwiseXOR, 1);
    }
  };

  Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {
    // '+-'
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types.incDec, 2);
    }

    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.plusMin, 1);
    }
  };

  Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {
    // '<>'
    var next = this.input.charCodeAt(this.state.pos + 1);
    var size = 1;

    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.state.pos + size) === 61) return this.finishOp(types.assign, size + 1);
      return this.finishOp(types.bitShift, size);
    }

    if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
      if (this.inModule) this.unexpected();
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }

    if (next === 61) {
      // <= | >=
      size = 2;
    }

    return this.finishOp(types.relational, size);
  };

  Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {
    // '=!'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62) {
      // '=>'
      this.state.pos += 2;
      return this.finishToken(types.arrow);
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
  };

  Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {
    switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46:
        // '.'
        return this.readToken_dot();

      // Punctuation tokens.
      case 40:
        ++this.state.pos;return this.finishToken(types.parenL);
      case 41:
        ++this.state.pos;return this.finishToken(types.parenR);
      case 59:
        ++this.state.pos;return this.finishToken(types.semi);
      case 44:
        ++this.state.pos;return this.finishToken(types.comma);
      case 91:
        ++this.state.pos;return this.finishToken(types.bracketL);
      case 93:
        ++this.state.pos;return this.finishToken(types.bracketR);

      case 123:
        if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          return this.finishOp(types.braceBarL, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(types.braceL);
        }

      case 125:
        ++this.state.pos;return this.finishToken(types.braceR);

      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          return this.finishOp(types.doubleColon, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(types.colon);
        }

      case 63:
        ++this.state.pos;return this.finishToken(types.question);
      case 64:
        ++this.state.pos;return this.finishToken(types.at);

      case 96:
        // '`'
        ++this.state.pos;
        return this.finishToken(types.backQuote);

      case 48:
        // '0'
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
        // 1-9
        return this.readNumber(false);

      // Quotes produce strings.
      case 34:case 39:
        // '"', "'"
        return this.readString(code);

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.

      case 47:
        // '/'
        return this.readToken_slash();

      case 37:case 42:
        // '%*'
        return this.readToken_mult_modulo(code);

      case 124:case 38:
        // '|&'
        return this.readToken_pipe_amp(code);

      case 94:
        // '^'
        return this.readToken_caret();

      case 43:case 45:
        // '+-'
        return this.readToken_plus_min(code);

      case 60:case 62:
        // '<>'
        return this.readToken_lt_gt(code);

      case 61:case 33:
        // '=!'
        return this.readToken_eq_excl(code);

      case 126:
        // '~'
        return this.finishOp(types.prefix, 1);
    }

    this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
  };

  Tokenizer.prototype.finishOp = function finishOp(type, size) {
    var str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    return this.finishToken(type, str);
  };

  Tokenizer.prototype.readRegexp = function readRegexp() {
    var start = this.state.pos;
    var escaped = void 0,
        inClass = void 0;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
      var ch = this.input.charAt(this.state.pos);
      if (lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (escaped) {
        escaped = false;
      } else {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      }
      ++this.state.pos;
    }
    var content = this.input.slice(start, this.state.pos);
    ++this.state.pos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = this.readWord1();
    if (mods) {
      var validFlags = /^[gmsiyu]*$/;
      if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    }
    return this.finishToken(types.regexp, {
      pattern: content,
      flags: mods
    });
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  Tokenizer.prototype.readInt = function readInt(radix, len) {
    var start = this.state.pos;
    var total = 0;

    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.state.pos);
      var val = void 0;
      if (code >= 97) {
        val = code - 97 + 10; // a
      } else if (code >= 65) {
        val = code - 65 + 10; // A
      } else if (code >= 48 && code <= 57) {
        val = code - 48; // 0-9
      } else {
        val = Infinity;
      }
      if (val >= radix) break;
      ++this.state.pos;
      total = total * radix + val;
    }
    if (this.state.pos === start || len != null && this.state.pos - start !== len) return null;

    return total;
  };

  Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {
    this.state.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) this.raise(this.state.start + 2, "Expected number in radix " + radix);
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");
    return this.finishToken(types.num, val);
  };

  // Read an integer, octal integer, or floating-point number.

  Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {
    var start = this.state.pos;
    var octal = this.input.charCodeAt(start) === 48; // '0'
    var isFloat = false;

    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
    if (octal && this.state.pos == start + 1) octal = false; // number === 0

    var next = this.input.charCodeAt(this.state.pos);
    if (next === 46 && !octal) {
      // '.'
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }

    if ((next === 69 || next === 101) && !octal) {
      // 'eE'
      next = this.input.charCodeAt(++this.state.pos);
      if (next === 43 || next === 45) ++this.state.pos; // '+-'
      if (this.readInt(10) === null) this.raise(start, "Invalid number");
      isFloat = true;
    }

    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");

    var str = this.input.slice(start, this.state.pos);
    var val = void 0;
    if (isFloat) {
      val = parseFloat(str);
    } else if (!octal || str.length === 1) {
      val = parseInt(str, 10);
    } else if (this.state.strict) {
      this.raise(start, "Invalid number");
    } else if (/[89]/.test(str)) {
      val = parseInt(str, 10);
    } else {
      val = parseInt(str, 8);
    }
    return this.finishToken(types.num, val);
  };

  // Read a string value, interpreting backslash-escapes.

  Tokenizer.prototype.readCodePoint = function readCodePoint(throwOnInvalid) {
    var ch = this.input.charCodeAt(this.state.pos);
    var code = void 0;

    if (ch === 123) {
      // '{'
      var codePos = ++this.state.pos;
      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, throwOnInvalid);
      ++this.state.pos;
      if (code === null) {
        --this.state.invalidTemplateEscapePosition; // to point to the '\'' instead of the 'u'
      } else if (code > 0x10FFFF) {
        if (throwOnInvalid) {
          this.raise(codePos, "Code point out of bounds");
        } else {
          this.state.invalidTemplateEscapePosition = codePos - 2;
          return null;
        }
      }
    } else {
      code = this.readHexChar(4, throwOnInvalid);
    }
    return code;
  };

  Tokenizer.prototype.readString = function readString(quote) {
    var out = "",
        chunkStart = ++this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated string constant");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else {
        if (isNewLine(ch)) this.raise(this.state.start, "Unterminated string constant");
        ++this.state.pos;
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(types.string, out);
  };

  // Reads template string tokens.

  Tokenizer.prototype.readTmplToken = function readTmplToken() {
    var out = "",
        chunkStart = this.state.pos,
        containsInvalid = false;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated template");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        // '`', '${'
        if (this.state.pos === this.state.start && this.match(types.template)) {
          if (ch === 36) {
            this.state.pos += 2;
            return this.finishToken(types.dollarBraceL);
          } else {
            ++this.state.pos;
            return this.finishToken(types.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(types.template, containsInvalid ? null : out);
      }
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        var escaped = this.readEscapedChar(true);
        if (escaped === null) {
          containsInvalid = true;
        } else {
          out += escaped;
        }
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  };

  // Used to read escaped characters

  Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {
    var throwOnInvalid = !inTemplate;
    var ch = this.input.charCodeAt(++this.state.pos);
    ++this.state.pos;
    switch (ch) {
      case 110:
        return "\n"; // 'n' -> '\n'
      case 114:
        return "\r"; // 'r' -> '\r'
      case 120:
        {
          // 'x'
          var code = this.readHexChar(2, throwOnInvalid);
          return code === null ? null : String.fromCharCode(code);
        }
      case 117:
        {
          // 'u'
          var _code = this.readCodePoint(throwOnInvalid);
          return _code === null ? null : codePointToString(_code);
        }
      case 116:
        return "\t"; // 't' -> '\t'
      case 98:
        return "\b"; // 'b' -> '\b'
      case 118:
        return "\x0B"; // 'v' -> '\u000b'
      case 102:
        return "\f"; // 'f' -> '\f'
      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; // '\r\n'
      case 10:
        // ' \n'
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;
        return "";
      default:
        if (ch >= 48 && ch <= 55) {
          var codePos = this.state.pos - 1;
          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          if (octal > 0) {
            if (inTemplate) {
              this.state.invalidTemplateEscapePosition = codePos;
              return null;
            } else if (this.state.strict) {
              this.raise(codePos, "Octal literal in strict mode");
            } else if (!this.state.containsOctal) {
              // These properties are only used to throw an error for an octal which occurs
              // in a directive which occurs prior to a "use strict" directive.
              this.state.containsOctal = true;
              this.state.octalPosition = codePos;
            }
          }
          this.state.pos += octalStr.length - 1;
          return String.fromCharCode(octal);
        }
        return String.fromCharCode(ch);
    }
  };

  // Used to read character escape sequences ('\x', '\u').

  Tokenizer.prototype.readHexChar = function readHexChar(len, throwOnInvalid) {
    var codePos = this.state.pos;
    var n = this.readInt(16, len);
    if (n === null) {
      if (throwOnInvalid) {
        this.raise(codePos, "Bad character escape sequence");
      } else {
        this.state.pos = codePos - 1;
        this.state.invalidTemplateEscapePosition = codePos - 1;
      }
    }
    return n;
  };

  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  Tokenizer.prototype.readWord1 = function readWord1() {
    this.state.containsEsc = false;
    var word = "",
        first = true,
        chunkStart = this.state.pos;
    while (this.state.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) {
        // "\"
        this.state.containsEsc = true;

        word += this.input.slice(chunkStart, this.state.pos);
        var escStart = this.state.pos;

        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          // "u"
          this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

        ++this.state.pos;
        var esc = this.readCodePoint(true);
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {
          this.raise(escStart, "Invalid Unicode escape");
        }

        word += codePointToString(esc);
        chunkStart = this.state.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.state.pos);
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  Tokenizer.prototype.readWord = function readWord() {
    var word = this.readWord1();
    var type = types.name;
    if (!this.state.containsEsc && this.isKeyword(word)) {
      type = keywords[word];
    }
    return this.finishToken(type, word);
  };

  Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {
    if (prevType === types.colon) {
      var parent = this.curContext();
      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {
        return !parent.isExpr;
      }
    }

    if (prevType === types._return) {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }

    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {
      return true;
    }

    if (prevType === types.braceL) {
      return this.curContext() === types$1.braceStatement;
    }

    return !this.state.exprAllowed;
  };

  Tokenizer.prototype.updateContext = function updateContext(prevType) {
    var type = this.state.type;
    var update = void 0;

    if (type.keyword && prevType === types.dot) {
      this.state.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.state.exprAllowed = type.beforeExpr;
    }
  };

  return Tokenizer;
}();

var plugins = {};
var frozenDeprecatedWildcardPluginList = ["jsx", "doExpressions", "objectRestSpread", "decorators", "classProperties", "exportExtensions", "asyncGenerators", "functionBind", "functionSent", "dynamicImport", "flow"];

var Parser = function (_Tokenizer) {
  inherits(Parser, _Tokenizer);

  function Parser(options, input) {
    classCallCheck(this, Parser);

    options = getOptions(options);

    var _this = possibleConstructorReturn(this, _Tokenizer.call(this, options, input));

    _this.options = options;
    _this.inModule = _this.options.sourceType === "module";
    _this.input = input;
    _this.plugins = _this.loadPlugins(_this.options.plugins);
    _this.filename = options.sourceFilename;

    // If enabled, skip leading hashbang line.
    if (_this.state.pos === 0 && _this.input[0] === "#" && _this.input[1] === "!") {
      _this.skipLineComment(2);
    }
    return _this;
  }

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    if (word === "await") {
      return this.inModule;
    } else {
      return reservedWords[6](word);
    }
  };

  Parser.prototype.hasPlugin = function hasPlugin(name) {
    if (this.plugins["*"] && frozenDeprecatedWildcardPluginList.indexOf(name) > -1) {
      return true;
    }

    return !!this.plugins[name];
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadAllPlugins = function loadAllPlugins() {
    var _this2 = this;

    // ensure flow plugin loads last, also ensure estree is not loaded with *
    var pluginNames = Object.keys(plugins).filter(function (name) {
      return name !== "flow" && name !== "estree";
    });
    pluginNames.push("flow");

    pluginNames.forEach(function (name) {
      var plugin = plugins[name];
      if (plugin) plugin(_this2);
    });
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginList) {
    // TODO: Deprecate "*" option in next major version of Babylon
    if (pluginList.indexOf("*") >= 0) {
      this.loadAllPlugins();

      return { "*": true };
    }

    var pluginMap = {};

    if (pluginList.indexOf("flow") >= 0) {
      // ensure flow plugin loads last
      pluginList = pluginList.filter(function (plugin) {
        return plugin !== "flow";
      });
      pluginList.push("flow");
    }

    if (pluginList.indexOf("estree") >= 0) {
      // ensure estree plugin loads first
      pluginList = pluginList.filter(function (plugin) {
        return plugin !== "estree";
      });
      pluginList.unshift("estree");
    }

    for (var _iterator = pluginList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var name = _ref;

      if (!pluginMap[name]) {
        pluginMap[name] = true;

        var plugin = plugins[name];
        if (plugin) plugin(this);
      }
    }

    return pluginMap;
  };

  Parser.prototype.parse = function parse() {
    var file = this.startNode();
    var program = this.startNode();
    this.nextToken();
    return this.parseTopLevel(file, program);
  };

  return Parser;
}(Tokenizer);

var pp = Parser.prototype;

// ## Parser utilities

// TODO

pp.addExtra = function (node, key, val) {
  if (!node) return;

  var extra = node.extra = node.extra || {};
  extra[key] = val;
};

// TODO

pp.isRelational = function (op) {
  return this.match(types.relational) && this.state.value === op;
};

// TODO

pp.expectRelational = function (op) {
  if (this.isRelational(op)) {
    this.next();
  } else {
    this.unexpected(null, types.relational);
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function (name) {
  return this.match(types.name) && this.state.value === name;
};

// Consumes contextual keyword if possible.

pp.eatContextual = function (name) {
  return this.state.value === name && this.eat(types.name);
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function (name, message) {
  if (!this.eatContextual(name)) this.unexpected(null, message);
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function () {
  return this.match(types.eof) || this.match(types.braceR) || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
};

// TODO

pp.isLineTerminator = function () {
  return this.eat(types.semi) || this.canInsertSemicolon();
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function () {
  if (!this.isLineTerminator()) this.unexpected(null, types.semi);
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.

pp.expect = function (type, pos) {
  return this.eat(type) || this.unexpected(pos, type);
};

// Raise an unexpected token error. Can take the expected token type
// instead of a message string.

pp.unexpected = function (pos) {
  var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token";

  if (messageOrType && (typeof messageOrType === "undefined" ? "undefined" : _typeof(messageOrType)) === "object" && messageOrType.label) {
    messageOrType = "Unexpected token, expected " + messageOrType.label;
  }
  this.raise(pos != null ? pos : this.state.start, messageOrType);
};

/* eslint max-len: 0 */

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function (file, program) {
  program.sourceType = this.options.sourceType;

  this.parseBlockBody(program, true, true, types.eof);

  file.program = this.finishNode(program, "Program");
  file.comments = this.state.comments;
  file.tokens = this.state.tokens;

  return this.finishNode(file, "File");
};

var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };

// TODO

pp$1.stmtToDirective = function (stmt) {
  var expr = stmt.expression;

  var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
  var directive = this.startNodeAt(stmt.start, stmt.loc.start);

  var raw = this.input.slice(expr.start, expr.end);
  var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes

  this.addExtra(directiveLiteral, "raw", raw);
  this.addExtra(directiveLiteral, "rawValue", val);

  directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);

  return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function (declaration, topLevel) {
  if (this.match(types.at)) {
    this.parseDecorators(true);
  }

  var starttype = this.state.type;
  var node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case types._break:case types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types._debugger:
      return this.parseDebuggerStatement(node);
    case types._do:
      return this.parseDoStatement(node);
    case types._for:
      return this.parseForStatement(node);
    case types._function:
      if (!declaration) this.unexpected();
      return this.parseFunctionStatement(node);

    case types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);

    case types._if:
      return this.parseIfStatement(node);
    case types._return:
      return this.parseReturnStatement(node);
    case types._switch:
      return this.parseSwitchStatement(node);
    case types._throw:
      return this.parseThrowStatement(node);
    case types._try:
      return this.parseTryStatement(node);

    case types._let:
    case types._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var

    case types._var:
      return this.parseVarStatement(node, starttype);

    case types._while:
      return this.parseWhileStatement(node);
    case types._with:
      return this.parseWithStatement(node);
    case types.braceL:
      return this.parseBlock();
    case types.semi:
      return this.parseEmptyStatement(node);
    case types._export:
    case types._import:
      if (this.hasPlugin("dynamicImport") && this.lookahead().type === types.parenL) break;

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
        }

        if (!this.inModule) {
          this.raise(this.state.start, "'import' and 'export' may appear only with 'sourceType: \"module\"'");
        }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node);

    case types.name:
      if (this.state.value === "async") {
        // peek ahead and see if next token is a function
        var state = this.state.clone();
        this.next();
        if (this.match(types._function) && !this.canInsertSemicolon()) {
          this.expect(types._function);
          return this.parseFunction(node, true, false, true);
        } else {
          this.state = state;
        }
      }
  }

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  var maybeName = this.state.value;
  var expr = this.parseExpression();

  if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
    return this.parseLabeledStatement(node, maybeName, expr);
  } else {
    return this.parseExpressionStatement(node, expr);
  }
};

pp$1.takeDecorators = function (node) {
  if (this.state.decorators.length) {
    node.decorators = this.state.decorators;
    this.state.decorators = [];
  }
};

pp$1.parseDecorators = function (allowExport) {
  while (this.match(types.at)) {
    var decorator = this.parseDecorator();
    this.state.decorators.push(decorator);
  }

  if (allowExport && this.match(types._export)) {
    return;
  }

  if (!this.match(types._class)) {
    this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
  }
};

pp$1.parseDecorator = function () {
  if (!this.hasPlugin("decorators")) {
    this.unexpected();
  }
  var node = this.startNode();
  this.next();
  node.expression = this.parseMaybeAssign();
  return this.finishNode(node, "Decorator");
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword === "break";
  this.next();

  if (this.isLineTerminator()) {
    node.label = null;
  } else if (!this.match(types.name)) {
    this.unexpected();
  } else {
    node.label = this.parseIdentifier();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = void 0;
  for (i = 0; i < this.state.labels.length; ++i) {
    var lab = this.state.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.state.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  this.eat(types.semi);
  return this.finishNode(node, "DoWhileStatement");
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);

  var forAwait = false;
  if (this.hasPlugin("asyncGenerators") && this.state.inAsync && this.isContextual("await")) {
    forAwait = true;
    this.next();
  }
  this.expect(types.parenL);

  if (this.match(types.semi)) {
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, null);
  }

  if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {
    var _init = this.startNode();
    var varKind = this.state.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, "VariableDeclaration");

    if (this.match(types._in) || this.isContextual("of")) {
      if (_init.declarations.length === 1 && !_init.declarations[0].init) {
        return this.parseForIn(node, _init, forAwait);
      }
    }
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, _init);
  }

  var refShorthandDefaultPos = { start: 0 };
  var init = this.parseExpression(true, refShorthandDefaultPos);
  if (this.match(types._in) || this.isContextual("of")) {
    var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
    this.toAssignable(init, undefined, description);
    this.checkLVal(init, undefined, undefined, description);
    return this.parseForIn(node, init, forAwait);
  } else if (refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }
  if (forAwait) {
    this.unexpected();
  }
  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.state.start, "'return' outside of function");
  }

  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.isLineTerminator()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.state.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur = void 0;
  for (var sawDefault; !this.match(types.braceR);) {
    if (this.match(types._case) || this.match(types._default)) {
      var isCase = this.match(types._case);
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.state.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (cur) {
        cur.consequent.push(this.parseStatement(true));
      } else {
        this.unexpected();
      }
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.state.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function (node) {
  this.next();

  node.block = this.parseBlock();
  node.handler = null;

  if (this.match(types._catch)) {
    var clause = this.startNode();
    this.next();

    this.expect(types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true, Object.create(null), "catch clause");
    this.expect(types.parenR);

    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }

  node.guardedHandlers = empty;
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }

  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.state.strict) this.raise(this.state.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr) {
  for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _label = _ref;

    if (_label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }

  var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;
  for (var i = this.state.labels.length - 1; i >= 0; i--) {
    var label = this.state.labels[i];
    if (label.statementStart === node.start) {
      label.statementStart = this.state.start;
      label.kind = kind;
    } else {
      break;
    }
  }

  this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start });
  node.body = this.parseStatement(true);
  this.state.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function (allowDirectives) {
  var node = this.startNode();
  this.expect(types.braceL);
  this.parseBlockBody(node, allowDirectives, false, types.braceR);
  return this.finishNode(node, "BlockStatement");
};

pp$1.isValidDirective = function (stmt) {
  return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
};

pp$1.parseBlockBody = function (node, allowDirectives, topLevel, end) {
  node.body = [];
  node.directives = [];

  var parsedNonDirective = false;
  var oldStrict = void 0;
  var octalPosition = void 0;

  while (!this.eat(end)) {
    if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
      octalPosition = this.state.octalPosition;
    }

    var stmt = this.parseStatement(true, topLevel);

    if (allowDirectives && !parsedNonDirective && this.isValidDirective(stmt)) {
      var directive = this.stmtToDirective(stmt);
      node.directives.push(directive);

      if (oldStrict === undefined && directive.value.value === "use strict") {
        oldStrict = this.state.strict;
        this.setStrict(true);

        if (octalPosition) {
          this.raise(octalPosition, "Octal literal in strict mode");
        }
      }

      continue;
    }

    parsedNonDirective = true;
    node.body.push(stmt);
  }

  if (oldStrict === false) {
    this.setStrict(false);
  }
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.match(types.semi) ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.match(types.parenR) ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "ForStatement");
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function (node, init, forAwait) {
  var type = void 0;
  if (forAwait) {
    this.eatContextual("of");
    type = "ForAwaitStatement";
  } else {
    type = this.match(types._in) ? "ForInStatement" : "ForOfStatement";
    this.next();
  }
  node.left = init;
  node.right = this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

pp$1.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    this.parseVarHead(decl);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === types._const && !(this.match(types._in) || this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
      this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) break;
  }
  return node;
};

pp$1.parseVarHead = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true, undefined, "variable declaration");
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = false;

  this.initFunction(node, isAsync);

  if (this.match(types.star)) {
    if (node.async && !this.hasPlugin("asyncGenerators")) {
      this.unexpected();
    } else {
      node.generator = true;
      this.next();
    }
  }

  if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {
    this.unexpected();
  }

  if (this.match(types.name) || this.match(types._yield)) {
    node.id = this.parseBindingIdentifier();
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.state.inMethod = oldInMethod;

  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR);
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function (node, isStatement, optionalId) {
  this.next();
  this.takeDecorators(node);
  this.parseClassId(node, isStatement, optionalId);
  this.parseClassSuper(node);
  this.parseClassBody(node);
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.isClassProperty = function () {
  return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
};

pp$1.isClassMethod = function () {
  return this.match(types.parenL);
};

pp$1.isNonstaticConstructor = function (method) {
  return !method.computed && !method.static && (method.key.name === "constructor" || // Identifier
  method.key.value === "constructor" // Literal
  );
};

pp$1.parseClassBody = function (node) {
  // class bodies are implicitly strict
  var oldStrict = this.state.strict;
  this.state.strict = true;

  var hadConstructorCall = false;
  var hadConstructor = false;
  var decorators = [];
  var classBody = this.startNode();

  classBody.body = [];

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (this.eat(types.semi)) {
      if (decorators.length > 0) {
        this.raise(this.state.lastTokEnd, "Decorators must not be followed by a semicolon");
      }
      continue;
    }

    if (this.match(types.at)) {
      decorators.push(this.parseDecorator());
      continue;
    }

    var method = this.startNode();

    // steal the decorators if there are any
    if (decorators.length) {
      method.decorators = decorators;
      decorators = [];
    }

    method.static = false;
    if (this.match(types.name) && this.state.value === "static") {
      var key = this.parseIdentifier(true); // eats 'static'
      if (this.isClassMethod()) {
        // a method named 'static'
        method.kind = "method";
        method.computed = false;
        method.key = key;
        this.parseClassMethod(classBody, method, false, false);
        continue;
      } else if (this.isClassProperty()) {
        // a property named 'static'
        method.computed = false;
        method.key = key;
        classBody.body.push(this.parseClassProperty(method));
        continue;
      }
      // otherwise something static
      method.static = true;
    }

    if (this.eat(types.star)) {
      // a generator
      method.kind = "method";
      this.parsePropertyName(method);
      if (this.isNonstaticConstructor(method)) {
        this.raise(method.key.start, "Constructor can't be a generator");
      }
      if (!method.computed && method.static && (method.key.name === "prototype" || method.key.value === "prototype")) {
        this.raise(method.key.start, "Classes may not have static property named prototype");
      }
      this.parseClassMethod(classBody, method, true, false);
    } else {
      var isSimple = this.match(types.name);
      var _key = this.parsePropertyName(method);
      if (!method.computed && method.static && (method.key.name === "prototype" || method.key.value === "prototype")) {
        this.raise(method.key.start, "Classes may not have static property named prototype");
      }
      if (this.isClassMethod()) {
        // a normal method
        if (this.isNonstaticConstructor(method)) {
          if (hadConstructor) {
            this.raise(_key.start, "Duplicate constructor in the same class");
          } else if (method.decorators) {
            this.raise(method.start, "You can't attach decorators to a class constructor");
          }
          hadConstructor = true;
          method.kind = "constructor";
        } else {
          method.kind = "method";
        }
        this.parseClassMethod(classBody, method, false, false);
      } else if (this.isClassProperty()) {
        // a normal property
        if (this.isNonstaticConstructor(method)) {
          this.raise(method.key.start, "Classes may not have a non-static field named 'constructor'");
        }
        classBody.body.push(this.parseClassProperty(method));
      } else if (isSimple && _key.name === "async" && !this.isLineTerminator()) {
        // an async method
        var isGenerator = this.hasPlugin("asyncGenerators") && this.eat(types.star);
        method.kind = "method";
        this.parsePropertyName(method);
        if (this.isNonstaticConstructor(method)) {
          this.raise(method.key.start, "Constructor can't be an async function");
        }
        this.parseClassMethod(classBody, method, isGenerator, true);
      } else if (isSimple && (_key.name === "get" || _key.name === "set") && !(this.isLineTerminator() && this.match(types.star))) {
        // `get\n*` is an uninitialized property named 'get' followed by a generator.
        // a getter or setter
        method.kind = _key.name;
        this.parsePropertyName(method);
        if (this.isNonstaticConstructor(method)) {
          this.raise(method.key.start, "Constructor can't have get/set modifier");
        }
        this.parseClassMethod(classBody, method, false, false);
        this.checkGetterSetterParamCount(method);
      } else if (this.hasPlugin("classConstructorCall") && isSimple && _key.name === "call" && this.match(types.name) && this.state.value === "constructor") {
        // a (deprecated) call constructor
        if (hadConstructorCall) {
          this.raise(method.start, "Duplicate constructor call in the same class");
        } else if (method.decorators) {
          this.raise(method.start, "You can't attach decorators to a class constructor");
        }
        hadConstructorCall = true;
        method.kind = "constructorCall";
        this.parsePropertyName(method); // consume "constructor" and make it the method's name
        this.parseClassMethod(classBody, method, false, false);
      } else if (this.isLineTerminator()) {
        // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
        if (this.isNonstaticConstructor(method)) {
          this.raise(method.key.start, "Classes may not have a non-static field named 'constructor'");
        }
        classBody.body.push(this.parseClassProperty(method));
      } else {
        this.unexpected();
      }
    }
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no method");
  }

  node.body = this.finishNode(classBody, "ClassBody");

  this.state.strict = oldStrict;
};

pp$1.parseClassProperty = function (node) {
  this.state.inClassProperty = true;
  if (this.match(types.eq)) {
    if (!this.hasPlugin("classProperties")) this.unexpected();
    this.next();
    node.value = this.parseMaybeAssign();
  } else {
    node.value = null;
  }
  this.semicolon();
  this.state.inClassProperty = false;
  return this.finishNode(node, "ClassProperty");
};

pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  this.parseMethod(method, isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "ClassMethod"));
};

pp$1.parseClassId = function (node, isStatement, optionalId) {
  if (this.match(types.name)) {
    node.id = this.parseIdentifier();
  } else {
    if (optionalId || !isStatement) {
      node.id = null;
    } else {
      this.unexpected();
    }
  }
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function (node) {
  this.next();
  // export * from '...'
  if (this.match(types.star)) {
    var specifier = this.startNode();
    this.next();
    if (this.hasPlugin("exportExtensions") && this.eatContextual("as")) {
      specifier.exported = this.parseIdentifier();
      node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
      this.parseExportSpecifiersMaybe(node);
      this.parseExportFrom(node, true);
    } else {
      this.parseExportFrom(node, true);
      return this.finishNode(node, "ExportAllDeclaration");
    }
  } else if (this.hasPlugin("exportExtensions") && this.isExportDefaultSpecifier()) {
    var _specifier = this.startNode();
    _specifier.exported = this.parseIdentifier(true);
    node.specifiers = [this.finishNode(_specifier, "ExportDefaultSpecifier")];
    if (this.match(types.comma) && this.lookahead().type === types.star) {
      this.expect(types.comma);
      var _specifier2 = this.startNode();
      this.expect(types.star);
      this.expectContextual("as");
      _specifier2.exported = this.parseIdentifier();
      node.specifiers.push(this.finishNode(_specifier2, "ExportNamespaceSpecifier"));
    } else {
      this.parseExportSpecifiersMaybe(node);
    }
    this.parseExportFrom(node, true);
  } else if (this.eat(types._default)) {
    // export default ...
    var expr = this.startNode();
    var needsSemi = false;
    if (this.eat(types._function)) {
      expr = this.parseFunction(expr, true, false, false, true);
    } else if (this.match(types._class)) {
      expr = this.parseClass(expr, true, true);
    } else {
      needsSemi = true;
      expr = this.parseMaybeAssign();
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    this.checkExport(node, true, true);
    return this.finishNode(node, "ExportDefaultDeclaration");
  } else if (this.shouldParseExportDeclaration()) {
    node.specifiers = [];
    node.source = null;
    node.declaration = this.parseExportDeclaration(node);
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    this.parseExportFrom(node);
  }
  this.checkExport(node, true);
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.parseExportDeclaration = function () {
  return this.parseStatement(true);
};

pp$1.isExportDefaultSpecifier = function () {
  if (this.match(types.name)) {
    return this.state.value !== "async";
  }

  if (!this.match(types._default)) {
    return false;
  }

  var lookahead = this.lookahead();
  return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === "from";
};

pp$1.parseExportSpecifiersMaybe = function (node) {
  if (this.eat(types.comma)) {
    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
  }
};

pp$1.parseExportFrom = function (node, expect) {
  if (this.eatContextual("from")) {
    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
    this.checkExport(node);
  } else {
    if (expect) {
      this.unexpected();
    } else {
      node.source = null;
    }
  }

  this.semicolon();
};

pp$1.shouldParseExportDeclaration = function () {
  return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "let" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isContextual("async");
};

pp$1.checkExport = function (node, checkNames, isDefault) {
  if (checkNames) {
    // Check for duplicate exports
    if (isDefault) {
      // Default exports
      this.checkDuplicateExports(node, "default");
    } else if (node.specifiers && node.specifiers.length) {
      // Named exports
      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var specifier = _ref2;

        this.checkDuplicateExports(specifier, specifier.exported.name);
      }
    } else if (node.declaration) {
      // Exported declarations
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        this.checkDuplicateExports(node, node.declaration.id.name);
      } else if (node.declaration.type === "VariableDeclaration") {
        for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref3 = _i3.value;
          }

          var declaration = _ref3;

          this.checkDeclaration(declaration.id);
        }
      }
    }
  }

  if (this.state.decorators.length) {
    var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
    if (!node.declaration || !isClass) {
      this.raise(node.start, "You can only use decorators on an export when exporting a class");
    }
    this.takeDecorators(node.declaration);
  }
};

pp$1.checkDeclaration = function (node) {
  if (node.type === "ObjectPattern") {
    for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var prop = _ref4;

      this.checkDeclaration(prop);
    }
  } else if (node.type === "ArrayPattern") {
    for (var _iterator5 = node.elements, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray5) {
        if (_i5 >= _iterator5.length) break;
        _ref5 = _iterator5[_i5++];
      } else {
        _i5 = _iterator5.next();
        if (_i5.done) break;
        _ref5 = _i5.value;
      }

      var elem = _ref5;

      if (elem) {
        this.checkDeclaration(elem);
      }
    }
  } else if (node.type === "ObjectProperty") {
    this.checkDeclaration(node.value);
  } else if (node.type === "RestElement" || node.type === "RestProperty") {
    this.checkDeclaration(node.argument);
  } else if (node.type === "Identifier") {
    this.checkDuplicateExports(node, node.name);
  }
};

pp$1.checkDuplicateExports = function (node, name) {
  if (this.state.exportedIdentifiers.indexOf(name) > -1) {
    this.raiseDuplicateExportError(node, name);
  }
  this.state.exportedIdentifiers.push(name);
};

pp$1.raiseDuplicateExportError = function (node, name) {
  this.raise(node.start, name === "default" ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique.");
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function () {
  var nodes = [];
  var first = true;
  var needsFrom = void 0;

  // export { x, y as z } [from '...']
  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    var isDefault = this.match(types._default);
    if (isDefault && !needsFrom) needsFrom = true;

    var node = this.startNode();
    node.local = this.parseIdentifier(isDefault);
    node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }

  // https://github.com/ember-cli/ember-cli/pull/3739
  if (needsFrom && !this.isContextual("from")) {
    this.unexpected();
  }

  return nodes;
};

// Parses import declaration.

pp$1.parseImport = function (node) {
  this.eat(types._import);

  // import '...'
  if (this.match(types.string)) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = [];
    this.parseImportSpecifiers(node);
    this.expectContextual("from");
    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function (node) {
  var first = true;
  if (this.match(types.name)) {
    // import defaultObj, { x, y as z } from '...'
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));
    if (!this.eat(types.comma)) return;
  }

  if (this.match(types.star)) {
    var specifier = this.startNode();
    this.next();
    this.expectContextual("as");
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, true, undefined, "import namespace specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
    return;
  }

  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      // Detect an attempt to deep destructure
      if (this.eat(types.colon)) {
        this.unexpected(null, "ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
      }

      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    this.parseImportSpecifier(node);
  }
};

pp$1.parseImportSpecifier = function (node) {
  var specifier = this.startNode();
  specifier.imported = this.parseIdentifier(true);
  if (this.eatContextual("as")) {
    specifier.local = this.parseIdentifier();
  } else {
    this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
    specifier.local = specifier.imported.__clone();
  }
  this.checkLVal(specifier.local, true, undefined, "import specifier");
  node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
};

pp$1.parseImportSpecifierDefault = function (id, startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.local = id;
  this.checkLVal(node.local, true, undefined, "default import specifier");
  return this.finishNode(node, "ImportDefaultSpecifier");
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function (node, isBinding, contextDescription) {
  if (node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var prop = _ref;

          if (prop.type === "ObjectMethod") {
            if (prop.kind === "get" || prop.kind === "set") {
              this.raise(prop.key.start, "Object pattern can't contain getter or setter");
            } else {
              this.raise(prop.key.start, "Object pattern can't contain methods");
            }
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }
        break;

      case "ObjectProperty":
        this.toAssignable(node.value, isBinding, contextDescription);
        break;

      case "SpreadProperty":
        node.type = "RestProperty";
        var arg = node.argument;
        this.toAssignable(arg, isBinding, contextDescription);
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding, contextDescription);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        {
          var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
          this.raise(node.start, message);
        }
    }
  }
  return node;
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function (exprList, isBinding, contextDescription) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type === "RestElement") {
      --end;
    } else if (last && last.type === "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding, contextDescription);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
        this.unexpected(arg.start);
      }
      --end;
    }
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding, contextDescription);
  }
  return exprList;
};

// Convert list of expression atoms to a list of

pp$2.toReferencedList = function (exprList) {
  return exprList;
};

// Parses spread element.

pp$2.parseSpread = function (refShorthandDefaultPos) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRest = function () {
  var node = this.startNode();
  this.next();
  node.argument = this.parseBindingIdentifier();
  return this.finishNode(node, "RestElement");
};

pp$2.shouldAllowYieldIdentifier = function () {
  return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;
};

pp$2.parseBindingIdentifier = function () {
  return this.parseIdentifier(this.shouldAllowYieldIdentifier());
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function () {
  switch (this.state.type) {
    case types._yield:
      if (this.state.strict || this.state.inGenerator) this.unexpected();
    // fall-through
    case types.name:
      return this.parseIdentifier(true);

    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true);
      return this.finishNode(node, "ArrayPattern");

    case types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp$2.parseBindingList = function (close, allowEmpty) {
  var elts = [];
  var first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
    }
    if (allowEmpty && this.match(types.comma)) {
      elts.push(null);
    } else if (this.eat(close)) {
      break;
    } else if (this.match(types.ellipsis)) {
      elts.push(this.parseAssignableListItemTypes(this.parseRest()));
      this.expect(close);
      break;
    } else {
      var decorators = [];
      while (this.match(types.at)) {
        decorators.push(this.parseDecorator());
      }
      var left = this.parseMaybeDefault();
      if (decorators.length) {
        left.decorators = decorators;
      }
      this.parseAssignableListItemTypes(left);
      elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));
    }
  }
  return elts;
};

pp$2.parseAssignableListItemTypes = function (param) {
  return param;
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  startLoc = startLoc || this.state.startLoc;
  startPos = startPos || this.state.start;
  left = left || this.parseBindingAtom();
  if (!this.eat(types.eq)) return left;

  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

// Verify that a node is an lval  something that can be assigned
// to.

pp$2.checkLVal = function (expr, isBinding, checkClashes, contextDescription) {
  switch (expr.type) {
    case "Identifier":
      this.checkReservedWord(expr.name, expr.start, false, true);

      if (checkClashes) {
        // we need to prefix this with an underscore for the cases where we have a key of
        // `__proto__`. there's a bug in old V8 where the following wouldn't work:
        //
        //   > var obj = Object.create(null);
        //   undefined
        //   > obj.__proto__
        //   null
        //   > obj.__proto__ = true;
        //   true
        //   > obj.__proto__
        //   null
        var key = "_" + expr.name;

        if (checkClashes[key]) {
          this.raise(expr.start, "Argument name clash in strict mode");
        } else {
          checkClashes[key] = true;
        }
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var prop = _ref2;

        if (prop.type === "ObjectProperty") prop = prop.value;
        this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
      }
      break;

    case "ArrayPattern":
      for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var elem = _ref3;

        if (elem) this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
      break;

    case "RestProperty":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest property");
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
      break;

    default:
      {
        var message = (isBinding ? /* istanbul ignore next */"Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
        this.raise(expr.start, message);
      }
  }
};

/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function (prop, propHash) {
  if (prop.computed || prop.kind) return;

  var key = prop.key;
  // It is either an Identifier or a String/NumericLiteral
  var name = key.type === "Identifier" ? key.name : String(key.value);

  if (name === "__proto__") {
    if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
    propHash.proto = true;
  }
};

// Convenience method to parse an Expression only
pp$3.getExpression = function () {
  this.nextToken();
  var expr = this.parseExpression();
  if (!this.match(types.eof)) {
    this.unexpected();
  }
  return expr;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initialization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
  if (this.match(types.comma)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) {
      node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
    }
    this.toReferencedList(node.expressions);
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;

  if (this.match(types._yield) && this.state.inGenerator) {
    var _left = this.parseYield();
    if (afterLeftParse) _left = afterLeftParse.call(this, _left, startPos, startLoc);
    return _left;
  }

  var failOnShorthandAssign = void 0;
  if (refShorthandDefaultPos) {
    failOnShorthandAssign = false;
  } else {
    refShorthandDefaultPos = { start: 0 };
    failOnShorthandAssign = true;
  }

  if (this.match(types.parenL) || this.match(types.name)) {
    this.state.potentialArrowAt = this.state.start;
  }

  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.state.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.state.value;
    node.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;
    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly

    this.checkLVal(left, undefined, undefined, "assignment expression");

    if (left.extra && left.extra.parenthesized) {
      var errorMsg = void 0;
      if (left.type === "ObjectPattern") {
        errorMsg = "`({a}) = 0` use `({a} = 0)`";
      } else if (left.type === "ArrayPattern") {
        errorMsg = "`([a]) = 0` use `([a] = 0)`";
      }
      if (errorMsg) {
        this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
      }
    }

    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }

  return left;
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

  return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
};

pp$3.parseConditional = function (expr, noIn, startPos, startLoc) {
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

// Start the precedence parser.

pp$3.parseExprOps = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  } else {
    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.state.type.binop;
  if (prec != null && (!noIn || !this.match(types._in))) {
    if (prec > minPrec) {
      var node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.left = left;
      node.operator = this.state.value;

      if (node.operator === "**" && left.type === "UnaryExpression" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {
        this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
      }

      var op = this.state.type;
      this.next();

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);

      this.finishNode(node, op === types.logicalOR || op === types.logicalAND ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function (refShorthandDefaultPos) {
  if (this.state.type.prefix) {
    var node = this.startNode();
    var update = this.match(types.incDec);
    node.operator = this.state.value;
    node.prefix = true;
    this.next();

    var argType = this.state.type;
    node.argument = this.parseMaybeUnary();

    this.addExtra(node, "parenthesizedArgument", argType === types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));

    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }

    if (update) {
      this.checkLVal(node.argument, undefined, undefined, "prefix operation");
    } else if (this.state.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raise(node.start, "Deleting local variable in strict mode");
    }

    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  }

  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  while (this.state.type.postfix && !this.canInsertSemicolon()) {
    var _node = this.startNodeAt(startPos, startLoc);
    _node.operator = this.state.value;
    _node.prefix = false;
    _node.argument = expr;
    this.checkLVal(expr, undefined, undefined, "postfix operation");
    this.next();
    expr = this.finishNode(_node, "UpdateExpression");
  }
  return expr;
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function (refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var potentialArrowAt = this.state.potentialArrowAt;
  var expr = this.parseExprAtom(refShorthandDefaultPos);

  if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
    return expr;
  }

  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  }

  return this.parseSubscripts(expr, startPos, startLoc);
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (!noCalls && this.eat(types.doubleColon)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    } else if (this.eat(types.dot)) {
      var _node2 = this.startNodeAt(startPos, startLoc);
      _node2.object = base;
      _node2.property = this.parseIdentifier(true);
      _node2.computed = false;
      base = this.finishNode(_node2, "MemberExpression");
    } else if (this.eat(types.bracketL)) {
      var _node3 = this.startNodeAt(startPos, startLoc);
      _node3.object = base;
      _node3.property = this.parseExpression();
      _node3.computed = true;
      this.expect(types.bracketR);
      base = this.finishNode(_node3, "MemberExpression");
    } else if (!noCalls && this.match(types.parenL)) {
      var possibleAsync = this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
      this.next();

      var _node4 = this.startNodeAt(startPos, startLoc);
      _node4.callee = base;
      _node4.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);
      if (_node4.callee.type === "Import" && _node4.arguments.length !== 1) {
        this.raise(_node4.start, "import() requires exactly one argument");
      }
      base = this.finishNode(_node4, "CallExpression");

      if (possibleAsync && this.shouldParseAsyncArrow()) {
        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);
      } else {
        this.toReferencedList(_node4.arguments);
      }
    } else if (this.match(types.backQuote)) {
      var _node5 = this.startNodeAt(startPos, startLoc);
      _node5.tag = base;
      _node5.quasi = this.parseTemplate(true);
      base = this.finishNode(_node5, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

pp$3.parseCallExpressionArguments = function (close, possibleAsyncArrow) {
  var elts = [];
  var innerParenStart = void 0;
  var first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(close)) break;
    }

    // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
    if (this.match(types.parenL) && !innerParenStart) {
      innerParenStart = this.state.start;
    }

    elts.push(this.parseExprListItem(false, possibleAsyncArrow ? { start: 0 } : undefined, possibleAsyncArrow ? { start: 0 } : undefined));
  }

  // we found an async arrow function so let's not allow any inner parens
  if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
    this.unexpected();
  }

  return elts;
};

pp$3.shouldParseAsyncArrow = function () {
  return this.match(types.arrow);
};

pp$3.parseAsyncArrowFromCallExpression = function (node, call) {
  this.expect(types.arrow);
  return this.parseArrowExpression(node, call.arguments, true);
};

// Parse a no-call expression (like argument of `new` or `::` operators).

pp$3.parseNoCallExpr = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function (refShorthandDefaultPos) {
  var canBeArrow = this.state.potentialArrowAt === this.state.start;
  var node = void 0;

  switch (this.state.type) {
    case types._super:
      if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) {
        this.raise(this.state.start, "'super' outside of function or class");
      }

      node = this.startNode();
      this.next();
      if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
        this.unexpected();
      }
      if (this.match(types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, "super() outside of class constructor");
      }
      return this.finishNode(node, "Super");

    case types._import:
      if (!this.hasPlugin("dynamicImport")) this.unexpected();

      node = this.startNode();
      this.next();
      if (!this.match(types.parenL)) {
        this.unexpected(null, types.parenL);
      }
      return this.finishNode(node, "Import");

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");

    case types._yield:
      if (this.state.inGenerator) this.unexpected();

    case types.name:
      node = this.startNode();
      var allowAwait = this.state.value === "await" && this.state.inAsync;
      var allowYield = this.shouldAllowYieldIdentifier();
      var id = this.parseIdentifier(allowAwait || allowYield);

      if (id.name === "await") {
        if (this.state.inAsync || this.inModule) {
          return this.parseAwait(node);
        }
      } else if (id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
        this.next();
        return this.parseFunction(node, false, false, true);
      } else if (canBeArrow && id.name === "async" && this.match(types.name)) {
        var params = [this.parseIdentifier()];
        this.expect(types.arrow);
        // let foo = bar => {};
        return this.parseArrowExpression(node, params, true);
      }

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        return this.parseArrowExpression(node, [id]);
      }

      return id;

    case types._do:
      if (this.hasPlugin("doExpressions")) {
        var _node6 = this.startNode();
        this.next();
        var oldInFunction = this.state.inFunction;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.state.inFunction = false;
        _node6.body = this.parseBlock(false, true);
        this.state.inFunction = oldInFunction;
        this.state.labels = oldLabels;
        return this.finishNode(_node6, "DoExpression");
      }

    case types.regexp:
      var value = this.state.value;
      node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;

    case types.num:
      return this.parseLiteral(this.state.value, "NumericLiteral");

    case types.string:
      return this.parseLiteral(this.state.value, "StringLiteral");

    case types._null:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");

    case types._true:case types._false:
      node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");

    case types.parenL:
      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);
      this.toReferencedList(node.elements);
      return this.finishNode(node, "ArrayExpression");

    case types.braceL:
      return this.parseObj(false, refShorthandDefaultPos);

    case types._function:
      return this.parseFunctionExpression();

    case types.at:
      this.parseDecorators();

    case types._class:
      node = this.startNode();
      this.takeDecorators(node);
      return this.parseClass(node, false);

    case types._new:
      return this.parseNew();

    case types.backQuote:
      return this.parseTemplate(false);

    case types.doubleColon:
      node = this.startNode();
      this.next();
      node.object = null;
      var callee = node.callee = this.parseNoCallExpr();
      if (callee.type === "MemberExpression") {
        return this.finishNode(node, "BindExpression");
      } else {
        this.raise(callee.start, "Binding should be performed on object property.");
      }

    default:
      this.unexpected();
  }
};

pp$3.parseFunctionExpression = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);
  if (this.state.inGenerator && this.eat(types.dot) && this.hasPlugin("functionSent")) {
    return this.parseMetaProperty(node, meta, "sent");
  } else {
    return this.parseFunction(node, false);
  }
};

pp$3.parseMetaProperty = function (node, meta, propertyName) {
  node.meta = meta;
  node.property = this.parseIdentifier(true);

  if (node.property.name !== propertyName) {
    this.raise(node.property.start, "The only valid meta property for new is " + meta.name + "." + propertyName);
  }

  return this.finishNode(node, "MetaProperty");
};

pp$3.parseLiteral = function (value, type, startPos, startLoc) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;

  var node = this.startNodeAt(startPos, startLoc);
  this.addExtra(node, "rawValue", value);
  this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
  node.value = value;
  this.next();
  return this.finishNode(node, type);
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;

  var val = void 0;
  this.expect(types.parenL);

  var innerStartPos = this.state.start;
  var innerStartLoc = this.state.startLoc;
  var exprList = [];
  var refShorthandDefaultPos = { start: 0 };
  var refNeedsArrowPos = { start: 0 };
  var first = true;
  var spreadStart = void 0;
  var optionalCommaStart = void 0;

  while (!this.match(types.parenR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma, refNeedsArrowPos.start || null);
      if (this.match(types.parenR)) {
        optionalCommaStart = this.state.start;
        break;
      }
    }

    if (this.match(types.ellipsis)) {
      var spreadNodeStartPos = this.state.start;
      var spreadNodeStartLoc = this.state.startLoc;
      spreadStart = this.state.start;
      exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));
      break;
    } else {
      exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
    }
  }

  var innerEndPos = this.state.start;
  var innerEndLoc = this.state.startLoc;
  this.expect(types.parenR);

  var arrowNode = this.startNodeAt(startPos, startLoc);
  if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
    for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var param = _ref;

      if (param.extra && param.extra.parenthesized) this.unexpected(param.extra.parenStart);
    }

    return this.parseArrowExpression(arrowNode, exprList);
  }

  if (!exprList.length) {
    this.unexpected(this.state.lastTokStart);
  }
  if (optionalCommaStart) this.unexpected(optionalCommaStart);
  if (spreadStart) this.unexpected(spreadStart);
  if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
  if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);

  if (exprList.length > 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.toReferencedList(val.expressions);
    this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }

  this.addExtra(val, "parenthesized", true);
  this.addExtra(val, "parenStart", startPos);

  return val;
};

pp$3.shouldParseArrow = function () {
  return !this.canInsertSemicolon();
};

pp$3.parseArrow = function (node) {
  if (this.eat(types.arrow)) {
    return node;
  }
};

pp$3.parseParenItem = function (node) {
  return node;
};

// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call  at
// least, not without wrapping it in parentheses. Thus, it uses the

pp$3.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);

  if (this.eat(types.dot)) {
    var metaProp = this.parseMetaProperty(node, meta, "target");

    if (!this.state.inFunction) {
      this.raise(metaProp.property.start, "new.target can only be used in functions");
    }

    return metaProp;
  }

  node.callee = this.parseNoCallExpr();

  if (this.eat(types.parenL)) {
    node.arguments = this.parseExprList(types.parenR);
    this.toReferencedList(node.arguments);
  } else {
    node.arguments = [];
  }

  return this.finishNode(node, "NewExpression");
};

// Parse template expression.

pp$3.parseTemplateElement = function (isTagged) {
  var elem = this.startNode();
  if (this.state.value === null) {
    if (!isTagged || !this.hasPlugin("templateInvalidEscapes")) {
      this.raise(this.state.invalidTemplateEscapePosition, "Invalid escape sequence in template");
    } else {
      this.state.invalidTemplateEscapePosition = null;
    }
  }
  elem.value = {
    raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
    cooked: this.state.value
  };
  this.next();
  elem.tail = this.match(types.backQuote);
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function (isTagged) {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement(isTagged);
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement(isTagged));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function (isPattern, refShorthandDefaultPos) {
  var decorators = [];
  var propHash = Object.create(null);
  var first = true;
  var node = this.startNode();

  node.properties = [];
  this.next();

  var firstRestLocation = null;

  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    while (this.match(types.at)) {
      decorators.push(this.parseDecorator());
    }

    var prop = this.startNode(),
        isGenerator = false,
        isAsync = false,
        startPos = void 0,
        startLoc = void 0;
    if (decorators.length) {
      prop.decorators = decorators;
      decorators = [];
    }

    if (this.hasPlugin("objectRestSpread") && this.match(types.ellipsis)) {
      prop = this.parseSpread(isPattern ? { start: 0 } : undefined);
      prop.type = isPattern ? "RestProperty" : "SpreadProperty";
      if (isPattern) this.toAssignable(prop.argument, true, "object pattern");
      node.properties.push(prop);
      if (isPattern) {
        var position = this.state.start;
        if (firstRestLocation !== null) {
          this.unexpected(firstRestLocation, "Cannot have multiple rest elements when destructuring");
        } else if (this.eat(types.braceR)) {
          break;
        } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {
          // TODO: temporary rollback
          // this.unexpected(position, "A trailing comma is not permitted after the rest element");
          continue;
        } else {
          firstRestLocation = position;
          continue;
        }
      } else {
        continue;
      }
    }

    prop.method = false;
    prop.shorthand = false;

    if (isPattern || refShorthandDefaultPos) {
      startPos = this.state.start;
      startLoc = this.state.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(types.star);
    }

    if (!isPattern && this.isContextual("async")) {
      if (isGenerator) this.unexpected();

      var asyncId = this.parseIdentifier();
      if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {
        prop.key = asyncId;
        prop.computed = false;
      } else {
        isAsync = true;
        if (this.hasPlugin("asyncGenerators")) isGenerator = this.eat(types.star);
        this.parsePropertyName(prop);
      }
    } else {
      this.parsePropertyName(prop);
    }

    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
    this.checkPropClash(prop, propHash);

    if (prop.shorthand) {
      this.addExtra(prop, "shorthand", true);
    }

    node.properties.push(prop);
  }

  if (firstRestLocation !== null) {
    this.unexpected(firstRestLocation, "The rest element has to be the last element when destructuring");
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no property");
  }

  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.isGetterOrSetterMethod = function (prop, isPattern) {
  return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || // get "string"() {}
  this.match(types.num) || // get 1() {}
  this.match(types.bracketL) || // get ["string"]() {}
  this.match(types.name) || // get foo() {}
  this.state.type.keyword // get debugger() {}
  );
};

// get methods aren't allowed to have any parameters
// set methods must have exactly 1 parameter
pp$3.checkGetterSetterParamCount = function (method) {
  var paramCount = method.kind === "get" ? 0 : 1;
  if (method.params.length !== paramCount) {
    var start = method.start;
    if (method.kind === "get") {
      this.raise(start, "getter should have no params");
    } else {
      this.raise(start, "setter should have exactly one param");
    }
  }
};

pp$3.parseObjectMethod = function (prop, isGenerator, isAsync, isPattern) {
  if (isAsync || isGenerator || this.match(types.parenL)) {
    if (isPattern) this.unexpected();
    prop.kind = "method";
    prop.method = true;
    this.parseMethod(prop, isGenerator, isAsync);

    return this.finishNode(prop, "ObjectMethod");
  }

  if (this.isGetterOrSetterMethod(prop, isPattern)) {
    if (isGenerator || isAsync) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    this.parseMethod(prop);
    this.checkGetterSetterParamCount(prop);

    return this.finishNode(prop, "ObjectMethod");
  }
};

pp$3.parseObjectProperty = function (prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);

    return this.finishNode(prop, "ObjectProperty");
  }

  if (!prop.computed && prop.key.type === "Identifier") {
    this.checkReservedWord(prop.key.name, prop.key.start, true, true);

    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else if (this.match(types.eq) && refShorthandDefaultPos) {
      if (!refShorthandDefaultPos.start) {
        refShorthandDefaultPos.start = this.state.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else {
      prop.value = prop.key.__clone();
    }
    prop.shorthand = true;

    return this.finishNode(prop, "ObjectProperty");
  }
};

pp$3.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
  var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);

  if (!node) this.unexpected();

  return node;
};

pp$3.parsePropertyName = function (prop) {
  if (this.eat(types.bracketL)) {
    prop.computed = true;
    prop.key = this.parseMaybeAssign();
    this.expect(types.bracketR);
  } else {
    prop.computed = false;
    var oldInPropertyName = this.state.inPropertyName;
    this.state.inPropertyName = true;
    prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    this.state.inPropertyName = oldInPropertyName;
  }
  return prop.key;
};

// Initialize empty function node.

pp$3.initFunction = function (node, isAsync) {
  node.id = null;
  node.generator = false;
  node.expression = false;
  node.async = !!isAsync;
};

// Parse object or class method.

pp$3.parseMethod = function (node, isGenerator, isAsync) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = node.kind || true;
  this.initFunction(node, isAsync);
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR);
  node.generator = !!isGenerator;
  this.parseFunctionBody(node);
  this.state.inMethod = oldInMethod;
  return node;
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function (node, params, isAsync) {
  this.initFunction(node, isAsync);
  node.params = this.toAssignableList(params, true, "arrow function parameters");
  this.parseFunctionBody(node, true);
  return this.finishNode(node, "ArrowFunctionExpression");
};

pp$3.isStrictBody = function (node, isExpression) {
  if (!isExpression && node.body.directives.length) {
    for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var directive = _ref2;

      if (directive.value.value === "use strict") {
        return true;
      }
    }
  }

  return false;
};

// Parse function body and check parameters.
pp$3.parseFunctionBody = function (node, allowExpression) {
  var isExpression = allowExpression && !this.match(types.braceL);

  var oldInAsync = this.state.inAsync;
  this.state.inAsync = node.async;
  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = this.state.inFunction;
    var oldInGen = this.state.inGenerator;
    var oldLabels = this.state.labels;
    this.state.inFunction = true;this.state.inGenerator = node.generator;this.state.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.state.inFunction = oldInFunc;this.state.inGenerator = oldInGen;this.state.labels = oldLabels;
  }
  this.state.inAsync = oldInAsync;

  // If this is a strict mode function, verify that argument names
  // are not repeated, and it does not try to bind the words `eval`
  // or `arguments`.
  var isStrict = this.isStrictBody(node, isExpression);
  // Also check when allowExpression === true for arrow functions
  var checkLVal = this.state.strict || allowExpression || isStrict;

  if (isStrict && node.id && node.id.type === "Identifier" && node.id.name === "yield") {
    this.raise(node.id.start, "Binding yield in strict mode");
  }

  if (checkLVal) {
    var nameHash = Object.create(null);
    var oldStrict = this.state.strict;
    if (isStrict) this.state.strict = true;
    if (node.id) {
      this.checkLVal(node.id, true, undefined, "function name");
    }
    for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var param = _ref3;

      if (isStrict && param.type !== "Identifier") {
        this.raise(param.start, "Non-simple parameter in strict mode");
      }
      this.checkLVal(param, true, nameHash, "function parameter list");
    }
    this.state.strict = oldStrict;
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) {
  var elts = [];
  var first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(close)) break;
    }

    elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
  }
  return elts;
};

pp$3.parseExprListItem = function (allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {
  var elt = void 0;
  if (allowEmpty && this.match(types.comma)) {
    elt = null;
  } else if (this.match(types.ellipsis)) {
    elt = this.parseSpread(refShorthandDefaultPos);
  } else {
    elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);
  }
  return elt;
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdentifier = function (liberal) {
  var node = this.startNode();
  if (!liberal) {
    this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);
  }

  if (this.match(types.name)) {
    node.name = this.state.value;
  } else if (this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }

  if (!liberal && node.name === "await" && this.state.inAsync) {
    this.raise(node.start, "invalid use of await inside of an async function");
  }

  node.loc.identifierName = node.name;

  this.next();
  return this.finishNode(node, "Identifier");
};

pp$3.checkReservedWord = function (word, startLoc, checkKeywords, isBinding) {
  if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {
    this.raise(startLoc, word + " is a reserved word");
  }

  if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {
    this.raise(startLoc, word + " is a reserved word in strict mode");
  }
};

// Parses await expression inside async function.

pp$3.parseAwait = function (node) {
  // istanbul ignore next: this condition is checked at the call site so won't be hit here
  if (!this.state.inAsync) {
    this.unexpected();
  }
  if (this.match(types.star)) {
    this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
  }
  node.argument = this.parseMaybeUnary();
  return this.finishNode(node, "AwaitExpression");
};

// Parses yield expression inside generator.

pp$3.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

// Start an AST node, attaching a start offset.

var pp$4 = Parser.prototype;
var commentKeys = ["leadingComments", "trailingComments", "innerComments"];

var Node = function () {
  function Node(pos, loc, filename) {
    classCallCheck(this, Node);

    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (filename) this.loc.filename = filename;
  }

  Node.prototype.__clone = function __clone() {
    var node2 = new Node();
    for (var key in this) {
      // Do not clone comments that are already attached to the node
      if (commentKeys.indexOf(key) < 0) {
        node2[key] = this[key];
      }
    }

    return node2;
  };

  return Node;
}();

pp$4.startNode = function () {
  return new Node(this.state.start, this.state.startLoc, this.filename);
};

pp$4.startNodeAt = function (pos, loc) {
  return new Node(pos, loc, this.filename);
};

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  node.loc.end = loc;
  this.processComment(node);
  return node;
}

// Finish an AST node, adding `type` and `end` properties.

pp$4.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
};

// Finish node at given position

pp$4.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

var pp$5 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$5.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  throw err;
};

/* eslint max-len: 0 */

/**
 * Based on the comment attachment algorithm used in espree and estraverse.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function last(stack) {
  return stack[stack.length - 1];
}

var pp$6 = Parser.prototype;

pp$6.addComment = function (comment) {
  if (this.filename) comment.loc.filename = this.filename;
  this.state.trailingComments.push(comment);
  this.state.leadingComments.push(comment);
};

pp$6.processComment = function (node) {
  if (node.type === "Program" && node.body.length > 0) return;

  var stack = this.state.commentStack;

  var firstChild = void 0,
      lastChild = void 0,
      trailingComments = void 0,
      i = void 0,
      j = void 0;

  if (this.state.trailingComments.length > 0) {
    // If the first comment in trailingComments comes after the
    // current node, then we're good - all comments in the array will
    // come after the node and so it's safe to add them as official
    // trailingComments.
    if (this.state.trailingComments[0].start >= node.end) {
      trailingComments = this.state.trailingComments;
      this.state.trailingComments = [];
    } else {
      // Otherwise, if the first comment doesn't come after the
      // current node, that means we have a mix of leading and trailing
      // comments in the array and that leadingComments contains the
      // same items as trailingComments. Reset trailingComments to
      // zero items and we'll handle this by evaluating leadingComments
      // later.
      this.state.trailingComments.length = 0;
    }
  } else {
    var lastInStack = last(stack);
    if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
      trailingComments = lastInStack.trailingComments;
      lastInStack.trailingComments = null;
    }
  }

  // Eating the stack.
  if (stack.length > 0 && last(stack).start >= node.start) {
    firstChild = stack.pop();
  }

  while (stack.length > 0 && last(stack).start >= node.start) {
    lastChild = stack.pop();
  }

  if (!lastChild && firstChild) lastChild = firstChild;

  // Attach comments that follow a trailing comma on the last
  // property in an object literal or a trailing comma in function arguments
  // as trailing comments
  if (firstChild && this.state.leadingComments.length > 0) {
    var lastComment = last(this.state.leadingComments);

    if (firstChild.type === "ObjectProperty") {
      if (lastComment.start >= node.start) {
        if (this.state.commentPreviousNode) {
          for (j = 0; j < this.state.leadingComments.length; j++) {
            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
              this.state.leadingComments.splice(j, 1);
              j--;
            }
          }

          if (this.state.leadingComments.length > 0) {
            firstChild.trailingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        }
      }
    } else if (node.type === "CallExpression" && node.arguments && node.arguments.length) {
      var lastArg = last(node.arguments);

      if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) {
        if (this.state.commentPreviousNode) {
          if (this.state.leadingComments.length > 0) {
            lastArg.trailingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        }
      }
    }
  }

  if (lastChild) {
    if (lastChild.leadingComments) {
      if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {
        node.leadingComments = lastChild.leadingComments;
        lastChild.leadingComments = null;
      } else {
        // A leading comment for an anonymous class had been stolen by its first ClassMethod,
        // so this takes back the leading comment.
        // See also: https://github.com/eslint/espree/issues/158
        for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
          if (lastChild.leadingComments[i].end <= node.start) {
            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
            break;
          }
        }
      }
    }
  } else if (this.state.leadingComments.length > 0) {
    if (last(this.state.leadingComments).end <= node.start) {
      if (this.state.commentPreviousNode) {
        for (j = 0; j < this.state.leadingComments.length; j++) {
          if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
            this.state.leadingComments.splice(j, 1);
            j--;
          }
        }
      }
      if (this.state.leadingComments.length > 0) {
        node.leadingComments = this.state.leadingComments;
        this.state.leadingComments = [];
      }
    } else {
      // https://github.com/eslint/espree/issues/2
      //
      // In special cases, such as return (without a value) and
      // debugger, all comments will end up as leadingComments and
      // will otherwise be eliminated. This step runs when the
      // commentStack is empty and there are comments left
      // in leadingComments.
      //
      // This loop figures out the stopping point between the actual
      // leading and trailing comments by finding the location of the
      // first comment that comes after the given node.
      for (i = 0; i < this.state.leadingComments.length; i++) {
        if (this.state.leadingComments[i].end > node.start) {
          break;
        }
      }

      // Split the array based on the location of the first comment
      // that comes after the node. Keep in mind that this could
      // result in an empty array, and if so, the array must be
      // deleted.
      node.leadingComments = this.state.leadingComments.slice(0, i);
      if (node.leadingComments.length === 0) {
        node.leadingComments = null;
      }

      // Similarly, trailing comments are attached later. The variable
      // must be reset to null if there are no trailing comments.
      trailingComments = this.state.leadingComments.slice(i);
      if (trailingComments.length === 0) {
        trailingComments = null;
      }
    }
  }

  this.state.commentPreviousNode = node;

  if (trailingComments) {
    if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
      node.innerComments = trailingComments;
    } else {
      node.trailingComments = trailingComments;
    }
  }

  stack.push(node);
};

var pp$7 = Parser.prototype;

pp$7.estreeParseRegExpLiteral = function (_ref) {
  var pattern = _ref.pattern,
      flags = _ref.flags;

  var regex = null;
  try {
    regex = new RegExp(pattern, flags);
  } catch (e) {
    // In environments that don't support these flags value will
    // be null as the regex can't be represented natively.
  }
  var node = this.estreeParseLiteral(regex);
  node.regex = { pattern: pattern, flags: flags };

  return node;
};

pp$7.estreeParseLiteral = function (value) {
  return this.parseLiteral(value, "Literal");
};

pp$7.directiveToStmt = function (directive) {
  var directiveLiteral = directive.value;

  var stmt = this.startNodeAt(directive.start, directive.loc.start);
  var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);

  expression.value = directiveLiteral.value;
  expression.raw = directiveLiteral.extra.raw;

  stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
  stmt.directive = directiveLiteral.extra.raw.slice(1, -1);

  return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
};

function isSimpleProperty(node) {
  return node && node.type === "Property" && node.kind === "init" && node.method === false;
}

var estreePlugin = function (instance) {
  instance.extend("checkDeclaration", function (inner) {
    return function (node) {
      if (isSimpleProperty(node)) {
        this.checkDeclaration(node.value);
      } else {
        inner.call(this, node);
      }
    };
  });

  instance.extend("checkGetterSetterParamCount", function () {
    return function (prop) {
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.start;
        if (prop.kind === "get") {
          this.raise(start, "getter should have no params");
        } else {
          this.raise(start, "setter should have exactly one param");
        }
      }
    };
  });

  instance.extend("checkLVal", function (inner) {
    return function (expr, isBinding, checkClashes) {
      var _this = this;

      switch (expr.type) {
        case "ObjectPattern":
          expr.properties.forEach(function (prop) {
            _this.checkLVal(prop.type === "Property" ? prop.value : prop, isBinding, checkClashes, "object destructuring pattern");
          });
          break;
        default:
          for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
            args[_key - 3] = arguments[_key];
          }

          inner.call.apply(inner, [this, expr, isBinding, checkClashes].concat(args));
      }
    };
  });

  instance.extend("checkPropClash", function () {
    return function (prop, propHash) {
      if (prop.computed || !isSimpleProperty(prop)) return;

      var key = prop.key;
      // It is either an Identifier or a String/NumericLiteral
      var name = key.type === "Identifier" ? key.name : String(key.value);

      if (name === "__proto__") {
        if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
        propHash.proto = true;
      }
    };
  });

  instance.extend("isStrictBody", function () {
    return function (node, isExpression) {
      if (!isExpression && node.body.body.length > 0) {
        for (var _iterator = node.body.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref2 = _i.value;
          }

          var directive = _ref2;

          if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") {
            if (directive.expression.value === "use strict") return true;
          } else {
            // Break for the first non literal expression
            break;
          }
        }
      }

      return false;
    };
  });

  instance.extend("isValidDirective", function () {
    return function (stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
    };
  });

  instance.extend("stmtToDirective", function (inner) {
    return function (stmt) {
      var directive = inner.call(this, stmt);
      var value = stmt.expression.value;

      // Reset value to the actual value as in estree mode we want
      // the stmt to have the real value and not the raw value
      directive.value.value = value;

      return directive;
    };
  });

  instance.extend("parseBlockBody", function (inner) {
    return function (node) {
      var _this2 = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      inner.call.apply(inner, [this, node].concat(args));

      node.directives.reverse().forEach(function (directive) {
        node.body.unshift(_this2.directiveToStmt(directive));
      });
      delete node.directives;
    };
  });

  instance.extend("parseClassMethod", function () {
    return function (classBody, method, isGenerator, isAsync) {
      this.parseMethod(method, isGenerator, isAsync);
      if (method.typeParameters) {
        method.value.typeParameters = method.typeParameters;
        delete method.typeParameters;
      }
      classBody.body.push(this.finishNode(method, "MethodDefinition"));
    };
  });

  instance.extend("parseExprAtom", function (inner) {
    return function () {
      switch (this.state.type) {
        case types.regexp:
          return this.estreeParseRegExpLiteral(this.state.value);

        case types.num:
        case types.string:
          return this.estreeParseLiteral(this.state.value);

        case types._null:
          return this.estreeParseLiteral(null);

        case types._true:
          return this.estreeParseLiteral(true);

        case types._false:
          return this.estreeParseLiteral(false);

        default:
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          return inner.call.apply(inner, [this].concat(args));
      }
    };
  });

  instance.extend("parseLiteral", function (inner) {
    return function () {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var node = inner.call.apply(inner, [this].concat(args));
      node.raw = node.extra.raw;
      delete node.extra;

      return node;
    };
  });

  instance.extend("parseMethod", function (inner) {
    return function (node) {
      var funcNode = this.startNode();
      funcNode.kind = node.kind; // provide kind, so inner method correctly sets state

      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      funcNode = inner.call.apply(inner, [this, funcNode].concat(args));
      delete funcNode.kind;
      node.value = this.finishNode(funcNode, "FunctionExpression");

      return node;
    };
  });

  instance.extend("parseObjectMethod", function (inner) {
    return function () {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var node = inner.call.apply(inner, [this].concat(args));

      if (node) {
        if (node.kind === "method") node.kind = "init";
        node.type = "Property";
      }

      return node;
    };
  });

  instance.extend("parseObjectProperty", function (inner) {
    return function () {
      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var node = inner.call.apply(inner, [this].concat(args));

      if (node) {
        node.kind = "init";
        node.type = "Property";
      }

      return node;
    };
  });

  instance.extend("toAssignable", function (inner) {
    return function (node, isBinding) {
      for (var _len8 = arguments.length, args = Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {
        args[_key8 - 2] = arguments[_key8];
      }

      if (isSimpleProperty(node)) {
        this.toAssignable.apply(this, [node.value, isBinding].concat(args));

        return node;
      } else if (node.type === "ObjectExpression") {
        node.type = "ObjectPattern";
        for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref3 = _i2.value;
          }

          var prop = _ref3;

          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          } else if (prop.method) {
            this.raise(prop.key.start, "Object pattern can't contain methods");
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }

        return node;
      }

      return inner.call.apply(inner, [this, node, isBinding].concat(args));
    };
  });
};

/* eslint max-len: 0 */

var primitiveTypes = ["any", "mixed", "empty", "bool", "boolean", "number", "string", "void", "null"];

var pp$8 = Parser.prototype;

pp$8.flowParseTypeInitialiser = function (tok) {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(tok || types.colon);

  var type = this.flowParseType();
  this.state.inType = oldInType;
  return type;
};

pp$8.flowParsePredicate = function () {
  var node = this.startNode();
  var moduloLoc = this.state.startLoc;
  var moduloPos = this.state.start;
  this.expect(types.modulo);
  var checksLoc = this.state.startLoc;
  this.expectContextual("checks");
  // Force '%' and 'checks' to be adjacent
  if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
    this.raise(moduloPos, "Spaces between % and checks are not allowed here.");
  }
  if (this.eat(types.parenL)) {
    node.expression = this.parseExpression();
    this.expect(types.parenR);
    return this.finishNode(node, "DeclaredPredicate");
  } else {
    return this.finishNode(node, "InferredPredicate");
  }
};

pp$8.flowParseTypeAndPredicateInitialiser = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(types.colon);
  var type = null;
  var predicate = null;
  if (this.match(types.modulo)) {
    this.state.inType = oldInType;
    predicate = this.flowParsePredicate();
  } else {
    type = this.flowParseType();
    this.state.inType = oldInType;
    if (this.match(types.modulo)) {
      predicate = this.flowParsePredicate();
    }
  }
  return [type, predicate];
};

pp$8.flowParseDeclareClass = function (node) {
  this.next();
  this.flowParseInterfaceish(node, true);
  return this.finishNode(node, "DeclareClass");
};

pp$8.flowParseDeclareFunction = function (node) {
  this.next();

  var id = node.id = this.parseIdentifier();

  var typeNode = this.startNode();
  var typeContainer = this.startNode();

  if (this.isRelational("<")) {
    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    typeNode.typeParameters = null;
  }

  this.expect(types.parenL);
  var tmp = this.flowParseFunctionTypeParams();
  typeNode.params = tmp.params;
  typeNode.rest = tmp.rest;
  this.expect(types.parenR);
  var predicate = null;

  var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();

  typeNode.returnType = _flowParseTypeAndPred[0];
  predicate = _flowParseTypeAndPred[1];

  typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
  typeContainer.predicate = predicate;
  id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");

  this.finishNode(id, id.type);

  this.semicolon();

  return this.finishNode(node, "DeclareFunction");
};

pp$8.flowParseDeclare = function (node) {
  if (this.match(types._class)) {
    return this.flowParseDeclareClass(node);
  } else if (this.match(types._function)) {
    return this.flowParseDeclareFunction(node);
  } else if (this.match(types._var)) {
    return this.flowParseDeclareVariable(node);
  } else if (this.isContextual("module")) {
    if (this.lookahead().type === types.dot) {
      return this.flowParseDeclareModuleExports(node);
    } else {
      return this.flowParseDeclareModule(node);
    }
  } else if (this.isContextual("type")) {
    return this.flowParseDeclareTypeAlias(node);
  } else if (this.isContextual("opaque")) {
    return this.flowParseDeclareOpaqueType(node);
  } else if (this.isContextual("interface")) {
    return this.flowParseDeclareInterface(node);
  } else if (this.match(types._export)) {
    return this.flowParseDeclareExportDeclaration(node);
  } else {
    this.unexpected();
  }
};

pp$8.flowParseDeclareExportDeclaration = function (node) {
  this.expect(types._export);
  if (this.isContextual("opaque") // declare export opaque ...
  ) {
      node.declaration = this.flowParseDeclare(this.startNode());
      node.default = false;

      return this.finishNode(node, "DeclareExportDeclaration");
    }

  throw this.unexpected();
};

pp$8.flowParseDeclareVariable = function (node) {
  this.next();
  node.id = this.flowParseTypeAnnotatableIdentifier();
  this.semicolon();
  return this.finishNode(node, "DeclareVariable");
};

pp$8.flowParseDeclareModule = function (node) {
  this.next();

  if (this.match(types.string)) {
    node.id = this.parseExprAtom();
  } else {
    node.id = this.parseIdentifier();
  }

  var bodyNode = node.body = this.startNode();
  var body = bodyNode.body = [];
  this.expect(types.braceL);
  while (!this.match(types.braceR)) {
    var _bodyNode = this.startNode();

    if (this.match(types._import)) {
      var lookahead = this.lookahead();
      if (lookahead.value !== "type" && lookahead.value !== "typeof") {
        this.unexpected(null, "Imports within a `declare module` body must always be `import type` or `import typeof`");
      }

      this.parseImport(_bodyNode);
    } else {
      this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");

      _bodyNode = this.flowParseDeclare(_bodyNode, true);
    }

    body.push(_bodyNode);
  }
  this.expect(types.braceR);

  this.finishNode(bodyNode, "BlockStatement");
  return this.finishNode(node, "DeclareModule");
};

pp$8.flowParseDeclareModuleExports = function (node) {
  this.expectContextual("module");
  this.expect(types.dot);
  this.expectContextual("exports");
  node.typeAnnotation = this.flowParseTypeAnnotation();
  this.semicolon();

  return this.finishNode(node, "DeclareModuleExports");
};

pp$8.flowParseDeclareTypeAlias = function (node) {
  this.next();
  this.flowParseTypeAlias(node);
  return this.finishNode(node, "DeclareTypeAlias");
};

pp$8.flowParseDeclareOpaqueType = function (node) {
  this.next();
  this.flowParseOpaqueType(node, true);
  return this.finishNode(node, "DeclareOpaqueType");
};

pp$8.flowParseDeclareInterface = function (node) {
  this.next();
  this.flowParseInterfaceish(node);
  return this.finishNode(node, "DeclareInterface");
};

// Interfaces

pp$8.flowParseInterfaceish = function (node) {
  node.id = this.parseIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.extends = [];
  node.mixins = [];

  if (this.eat(types._extends)) {
    do {
      node.extends.push(this.flowParseInterfaceExtends());
    } while (this.eat(types.comma));
  }

  if (this.isContextual("mixins")) {
    this.next();
    do {
      node.mixins.push(this.flowParseInterfaceExtends());
    } while (this.eat(types.comma));
  }

  node.body = this.flowParseObjectType(true, false, false);
};

pp$8.flowParseInterfaceExtends = function () {
  var node = this.startNode();

  node.id = this.flowParseQualifiedTypeIdentifier();
  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  } else {
    node.typeParameters = null;
  }

  return this.finishNode(node, "InterfaceExtends");
};

pp$8.flowParseInterface = function (node) {
  this.flowParseInterfaceish(node, false);
  return this.finishNode(node, "InterfaceDeclaration");
};

pp$8.flowParseRestrictedIdentifier = function (liberal) {
  if (primitiveTypes.indexOf(this.state.value) > -1) {
    this.raise(this.state.start, "Cannot overwrite primitive type " + this.state.value);
  }

  return this.parseIdentifier(liberal);
};

// Type aliases

pp$8.flowParseTypeAlias = function (node) {
  node.id = this.flowParseRestrictedIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.right = this.flowParseTypeInitialiser(types.eq);
  this.semicolon();

  return this.finishNode(node, "TypeAlias");
};

// Opaque type aliases

pp$8.flowParseOpaqueType = function (node, declare) {
  this.expectContextual("type");
  node.id = this.flowParseRestrictedIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  // Parse the supertype
  node.supertype = null;
  if (this.match(types.colon)) {
    node.supertype = this.flowParseTypeInitialiser(types.colon);
  }

  node.impltype = null;
  if (!declare) {
    node.impltype = this.flowParseTypeInitialiser(types.eq);
  }
  this.semicolon();

  return this.finishNode(node, "OpaqueType");
};

// Type annotations

pp$8.flowParseTypeParameter = function () {
  var node = this.startNode();

  var variance = this.flowParseVariance();

  var ident = this.flowParseTypeAnnotatableIdentifier();
  node.name = ident.name;
  node.variance = variance;
  node.bound = ident.typeAnnotation;

  if (this.match(types.eq)) {
    this.eat(types.eq);
    node.default = this.flowParseType();
  }

  return this.finishNode(node, "TypeParameter");
};

pp$8.flowParseTypeParameterDeclaration = function () {
  var oldInType = this.state.inType;
  var node = this.startNode();
  node.params = [];

  this.state.inType = true;

  // istanbul ignore else: this condition is already checked at all call sites
  if (this.isRelational("<") || this.match(types.jsxTagStart)) {
    this.next();
  } else {
    this.unexpected();
  }

  do {
    node.params.push(this.flowParseTypeParameter());
    if (!this.isRelational(">")) {
      this.expect(types.comma);
    }
  } while (!this.isRelational(">"));
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterDeclaration");
};

pp$8.flowParseTypeParameterInstantiation = function () {
  var node = this.startNode();
  var oldInType = this.state.inType;
  node.params = [];

  this.state.inType = true;

  this.expectRelational("<");
  while (!this.isRelational(">")) {
    node.params.push(this.flowParseType());
    if (!this.isRelational(">")) {
      this.expect(types.comma);
    }
  }
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterInstantiation");
};

pp$8.flowParseObjectPropertyKey = function () {
  return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
};

pp$8.flowParseObjectTypeIndexer = function (node, isStatic, variance) {
  node.static = isStatic;

  this.expect(types.bracketL);
  if (this.lookahead().type === types.colon) {
    node.id = this.flowParseObjectPropertyKey();
    node.key = this.flowParseTypeInitialiser();
  } else {
    node.id = null;
    node.key = this.flowParseType();
  }
  this.expect(types.bracketR);
  node.value = this.flowParseTypeInitialiser();
  node.variance = variance;

  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeIndexer");
};

pp$8.flowParseObjectTypeMethodish = function (node) {
  node.params = [];
  node.rest = null;
  node.typeParameters = null;

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  }

  this.expect(types.parenL);
  while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
    node.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(types.parenR)) {
      this.expect(types.comma);
    }
  }

  if (this.eat(types.ellipsis)) {
    node.rest = this.flowParseFunctionTypeParam();
  }
  this.expect(types.parenR);
  node.returnType = this.flowParseTypeInitialiser();

  return this.finishNode(node, "FunctionTypeAnnotation");
};

pp$8.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {
  var node = this.startNodeAt(startPos, startLoc);
  node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
  node.static = isStatic;
  node.key = key;
  node.optional = false;
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeProperty");
};

pp$8.flowParseObjectTypeCallProperty = function (node, isStatic) {
  var valueNode = this.startNode();
  node.static = isStatic;
  node.value = this.flowParseObjectTypeMethodish(valueNode);
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeCallProperty");
};

pp$8.flowParseObjectType = function (allowStatic, allowExact, allowSpread) {
  var oldInType = this.state.inType;
  this.state.inType = true;

  var nodeStart = this.startNode();
  var node = void 0;
  var propertyKey = void 0;
  var isStatic = false;

  nodeStart.callProperties = [];
  nodeStart.properties = [];
  nodeStart.indexers = [];

  var endDelim = void 0;
  var exact = void 0;
  if (allowExact && this.match(types.braceBarL)) {
    this.expect(types.braceBarL);
    endDelim = types.braceBarR;
    exact = true;
  } else {
    this.expect(types.braceL);
    endDelim = types.braceR;
    exact = false;
  }

  nodeStart.exact = exact;

  while (!this.match(endDelim)) {
    var optional = false;
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    node = this.startNode();
    if (allowStatic && this.isContextual("static") && this.lookahead().type !== types.colon) {
      this.next();
      isStatic = true;
    }

    var variancePos = this.state.start;
    var variance = this.flowParseVariance();

    if (this.match(types.bracketL)) {
      nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
    } else if (this.match(types.parenL) || this.isRelational("<")) {
      if (variance) {
        this.unexpected(variancePos);
      }
      nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
    } else {
      if (this.match(types.ellipsis)) {
        if (!allowSpread) {
          this.unexpected(null, "Spread operator cannot appear in class or interface definitions");
        }
        if (variance) {
          this.unexpected(variance.start, "Spread properties cannot have variance");
        }
        this.expect(types.ellipsis);
        node.argument = this.flowParseType();
        this.flowObjectTypeSemicolon();
        nodeStart.properties.push(this.finishNode(node, "ObjectTypeSpreadProperty"));
      } else {
        propertyKey = this.flowParseObjectPropertyKey();
        if (this.isRelational("<") || this.match(types.parenL)) {
          // This is a method property
          if (variance) {
            this.unexpected(variance.start);
          }
          nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
        } else {
          if (this.eat(types.question)) {
            optional = true;
          }
          node.key = propertyKey;
          node.value = this.flowParseTypeInitialiser();
          node.optional = optional;
          node.static = isStatic;
          node.variance = variance;
          this.flowObjectTypeSemicolon();
          nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
        }
      }
    }

    isStatic = false;
  }

  this.expect(endDelim);

  var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");

  this.state.inType = oldInType;

  return out;
};

pp$8.flowObjectTypeSemicolon = function () {
  if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
    this.unexpected();
  }
};

pp$8.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;
  var node = id || this.parseIdentifier();

  while (this.eat(types.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.qualification = node;
    node2.id = this.parseIdentifier();
    node = this.finishNode(node2, "QualifiedTypeIdentifier");
  }

  return node;
};

pp$8.flowParseGenericType = function (startPos, startLoc, id) {
  var node = this.startNodeAt(startPos, startLoc);

  node.typeParameters = null;
  node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  }

  return this.finishNode(node, "GenericTypeAnnotation");
};

pp$8.flowParseTypeofType = function () {
  var node = this.startNode();
  this.expect(types._typeof);
  node.argument = this.flowParsePrimaryType();
  return this.finishNode(node, "TypeofTypeAnnotation");
};

pp$8.flowParseTupleType = function () {
  var node = this.startNode();
  node.types = [];
  this.expect(types.bracketL);
  // We allow trailing commas
  while (this.state.pos < this.input.length && !this.match(types.bracketR)) {
    node.types.push(this.flowParseType());
    if (this.match(types.bracketR)) break;
    this.expect(types.comma);
  }
  this.expect(types.bracketR);
  return this.finishNode(node, "TupleTypeAnnotation");
};

pp$8.flowParseFunctionTypeParam = function () {
  var name = null;
  var optional = false;
  var typeAnnotation = null;
  var node = this.startNode();
  var lh = this.lookahead();
  if (lh.type === types.colon || lh.type === types.question) {
    name = this.parseIdentifier();
    if (this.eat(types.question)) {
      optional = true;
    }
    typeAnnotation = this.flowParseTypeInitialiser();
  } else {
    typeAnnotation = this.flowParseType();
  }
  node.name = name;
  node.optional = optional;
  node.typeAnnotation = typeAnnotation;
  return this.finishNode(node, "FunctionTypeParam");
};

pp$8.reinterpretTypeAsFunctionTypeParam = function (type) {
  var node = this.startNodeAt(type.start, type.loc.start);
  node.name = null;
  node.optional = false;
  node.typeAnnotation = type;
  return this.finishNode(node, "FunctionTypeParam");
};

pp$8.flowParseFunctionTypeParams = function () {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var ret = { params: params, rest: null };
  while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
    ret.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(types.parenR)) {
      this.expect(types.comma);
    }
  }
  if (this.eat(types.ellipsis)) {
    ret.rest = this.flowParseFunctionTypeParam();
  }
  return ret;
};

pp$8.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {
  switch (id.name) {
    case "any":
      return this.finishNode(node, "AnyTypeAnnotation");

    case "void":
      return this.finishNode(node, "VoidTypeAnnotation");

    case "bool":
    case "boolean":
      return this.finishNode(node, "BooleanTypeAnnotation");

    case "mixed":
      return this.finishNode(node, "MixedTypeAnnotation");

    case "empty":
      return this.finishNode(node, "EmptyTypeAnnotation");

    case "number":
      return this.finishNode(node, "NumberTypeAnnotation");

    case "string":
      return this.finishNode(node, "StringTypeAnnotation");

    default:
      return this.flowParseGenericType(startPos, startLoc, id);
  }
};

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
pp$8.flowParsePrimaryType = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var node = this.startNode();
  var tmp = void 0;
  var type = void 0;
  var isGroupedType = false;
  var oldNoAnonFunctionType = this.state.noAnonFunctionType;

  switch (this.state.type) {
    case types.name:
      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

    case types.braceL:
      return this.flowParseObjectType(false, false, true);

    case types.braceBarL:
      return this.flowParseObjectType(false, true, true);

    case types.bracketL:
      return this.flowParseTupleType();

    case types.relational:
      if (this.state.value === "<") {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
        this.expect(types.parenL);
        tmp = this.flowParseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(types.parenR);

        this.expect(types.arrow);

        node.returnType = this.flowParseType();

        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      break;

    case types.parenL:
      this.next();

      // Check to see if this is actually a grouped type
      if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
        if (this.match(types.name)) {
          var token = this.lookahead().type;
          isGroupedType = token !== types.question && token !== types.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        this.state.noAnonFunctionType = false;
        type = this.flowParseType();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
          this.expect(types.parenR);
          return type;
        } else {
          // Eat a comma if there is one
          this.eat(types.comma);
        }
      }

      if (type) {
        tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
      } else {
        tmp = this.flowParseFunctionTypeParams();
      }

      node.params = tmp.params;
      node.rest = tmp.rest;

      this.expect(types.parenR);

      this.expect(types.arrow);

      node.returnType = this.flowParseType();

      node.typeParameters = null;

      return this.finishNode(node, "FunctionTypeAnnotation");

    case types.string:
      return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

    case types._true:case types._false:
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteralTypeAnnotation");

    case types.plusMin:
      if (this.state.value === "-") {
        this.next();
        if (!this.match(types.num)) this.unexpected(null, "Unexpected token, expected number");

        return this.parseLiteral(-this.state.value, "NumericLiteralTypeAnnotation", node.start, node.loc.start);
      }

      this.unexpected();
    case types.num:
      return this.parseLiteral(this.state.value, "NumericLiteralTypeAnnotation");

    case types._null:
      node.value = this.match(types._null);
      this.next();
      return this.finishNode(node, "NullLiteralTypeAnnotation");

    case types._this:
      node.value = this.match(types._this);
      this.next();
      return this.finishNode(node, "ThisTypeAnnotation");

    case types.star:
      this.next();
      return this.finishNode(node, "ExistentialTypeParam");

    default:
      if (this.state.type.keyword === "typeof") {
        return this.flowParseTypeofType();
      }
  }

  this.unexpected();
};

pp$8.flowParsePostfixType = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var type = this.flowParsePrimaryType();
  while (!this.canInsertSemicolon() && this.match(types.bracketL)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.elementType = type;
    this.expect(types.bracketL);
    this.expect(types.bracketR);
    type = this.finishNode(node, "ArrayTypeAnnotation");
  }
  return type;
};

pp$8.flowParsePrefixType = function () {
  var node = this.startNode();
  if (this.eat(types.question)) {
    node.typeAnnotation = this.flowParsePrefixType();
    return this.finishNode(node, "NullableTypeAnnotation");
  } else {
    return this.flowParsePostfixType();
  }
};

pp$8.flowParseAnonFunctionWithoutParens = function () {
  var param = this.flowParsePrefixType();
  if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
    var node = this.startNodeAt(param.start, param.loc.start);
    node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
    node.rest = null;
    node.returnType = this.flowParseType();
    node.typeParameters = null;
    return this.finishNode(node, "FunctionTypeAnnotation");
  }
  return param;
};

pp$8.flowParseIntersectionType = function () {
  var node = this.startNode();
  this.eat(types.bitwiseAND);
  var type = this.flowParseAnonFunctionWithoutParens();
  node.types = [type];
  while (this.eat(types.bitwiseAND)) {
    node.types.push(this.flowParseAnonFunctionWithoutParens());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
};

pp$8.flowParseUnionType = function () {
  var node = this.startNode();
  this.eat(types.bitwiseOR);
  var type = this.flowParseIntersectionType();
  node.types = [type];
  while (this.eat(types.bitwiseOR)) {
    node.types.push(this.flowParseIntersectionType());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
};

pp$8.flowParseType = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  var type = this.flowParseUnionType();
  this.state.inType = oldInType;
  return type;
};

pp$8.flowParseTypeAnnotation = function () {
  var node = this.startNode();
  node.typeAnnotation = this.flowParseTypeInitialiser();
  return this.finishNode(node, "TypeAnnotation");
};

pp$8.flowParseTypeAndPredicateAnnotation = function () {
  var node = this.startNode();

  var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser();

  node.typeAnnotation = _flowParseTypeAndPred2[0];
  node.predicate = _flowParseTypeAndPred2[1];

  return this.finishNode(node, "TypeAnnotation");
};

pp$8.flowParseTypeAnnotatableIdentifier = function () {
  var ident = this.flowParseRestrictedIdentifier();
  if (this.match(types.colon)) {
    ident.typeAnnotation = this.flowParseTypeAnnotation();
    this.finishNode(ident, ident.type);
  }
  return ident;
};

pp$8.typeCastToParameter = function (node) {
  node.expression.typeAnnotation = node.typeAnnotation;

  return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
};

pp$8.flowParseVariance = function () {
  var variance = null;
  if (this.match(types.plusMin)) {
    if (this.state.value === "+") {
      variance = "plus";
    } else if (this.state.value === "-") {
      variance = "minus";
    }
    this.next();
  }
  return variance;
};

var flowPlugin = function (instance) {
  // plain function return types: function name(): string {}
  instance.extend("parseFunctionBody", function (inner) {
    return function (node, allowExpression) {
      if (this.match(types.colon) && !allowExpression) {
        // if allowExpression is true then we're parsing an arrow function and if
        // there's a return type then it's been handled elsewhere
        node.returnType = this.flowParseTypeAndPredicateAnnotation();
      }

      return inner.call(this, node, allowExpression);
    };
  });

  // interfaces
  instance.extend("parseStatement", function (inner) {
    return function (declaration, topLevel) {
      // strict mode handling of `interface` since it's a reserved word
      if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
        var node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      } else {
        return inner.call(this, declaration, topLevel);
      }
    };
  });

  // declares, interfaces and type aliases
  instance.extend("parseExpressionStatement", function (inner) {
    return function (node, expr) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(types.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          } else if (expr.name === "opaque") {
            return this.flowParseOpaqueType(node, false);
          }
        }
      }

      return inner.call(this, node, expr);
    };
  });

  // export type
  instance.extend("shouldParseExportDeclaration", function (inner) {
    return function () {
      return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || inner.call(this);
    };
  });

  instance.extend("isExportDefaultSpecifier", function (inner) {
    return function () {
      if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque")) {
        return false;
      }

      return inner.call(this);
    };
  });

  instance.extend("parseConditional", function (inner) {
    return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      // only do the expensive clone if there is a question mark
      // and if we come from inside parens
      if (refNeedsArrowPos && this.match(types.question)) {
        var state = this.state.clone();
        try {
          return inner.call(this, expr, noIn, startPos, startLoc);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            refNeedsArrowPos.start = err.pos || this.state.start;
            return expr;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      return inner.call(this, expr, noIn, startPos, startLoc);
    };
  });

  instance.extend("parseParenItem", function (inner) {
    return function (node, startPos, startLoc) {
      node = inner.call(this, node, startPos, startLoc);
      if (this.eat(types.question)) {
        node.optional = true;
      }

      if (this.match(types.colon)) {
        var typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();

        return this.finishNode(typeCastNode, "TypeCastExpression");
      }

      return node;
    };
  });

  instance.extend("parseExport", function (inner) {
    return function (node) {
      node = inner.call(this, node);
      if (node.type === "ExportNamedDeclaration") {
        node.exportKind = node.exportKind || "value";
      }
      return node;
    };
  });

  instance.extend("parseExportDeclaration", function (inner) {
    return function (node) {
      if (this.isContextual("type")) {
        node.exportKind = "type";

        var declarationNode = this.startNode();
        this.next();

        if (this.match(types.braceL)) {
          // export type { foo, bar };
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          // export type Foo = Bar;
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("opaque")) {
        node.exportKind = "type";

        var _declarationNode = this.startNode();
        this.next();
        // export opaque type Foo = Bar;
        return this.flowParseOpaqueType(_declarationNode, false);
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        var _declarationNode2 = this.startNode();
        this.next();
        return this.flowParseInterface(_declarationNode2);
      } else {
        return inner.call(this, node);
      }
    };
  });

  instance.extend("parseClassId", function (inner) {
    return function (node) {
      inner.apply(this, arguments);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    };
  });

  // don't consider `void` to be a keyword as then it'll use the void token type
  // and set startExpr
  instance.extend("isKeyword", function (inner) {
    return function (name) {
      if (this.state.inType && name === "void") {
        return false;
      } else {
        return inner.call(this, name);
      }
    };
  });

  // ensure that inside flow types, we bypass the jsx parser plugin
  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types.relational, 1);
      } else {
        return inner.call(this, code);
      }
    };
  });

  // don't lex any token as a jsx one inside a flow type
  instance.extend("jsx_readToken", function (inner) {
    return function () {
      if (!this.state.inType) return inner.call(this);
    };
  });

  instance.extend("toAssignable", function (inner) {
    return function (node, isBinding, contextDescription) {
      if (node.type === "TypeCastExpression") {
        return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);
      } else {
        return inner.call(this, node, isBinding, contextDescription);
      }
    };
  });

  // turn type casts that we found in function parameter head into type annotated params
  instance.extend("toAssignableList", function (inner) {
    return function (exprList, isBinding, contextDescription) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return inner.call(this, exprList, isBinding, contextDescription);
    };
  });

  // this is a list of nodes, from something like a call expression, we need to filter the
  // type casts that we've found that are illegal in this context
  instance.extend("toReferencedList", function () {
    return function (exprList) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
          this.raise(expr.start, "Unexpected type cast");
        }
      }

      return exprList;
    };
  });

  // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents
  // the position where this function is called
  instance.extend("parseExprListItem", function (inner) {
    return function () {
      var container = this.startNode();

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var node = inner.call.apply(inner, [this].concat(args));
      if (this.match(types.colon)) {
        container._exprListItem = true;
        container.expression = node;
        container.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(container, "TypeCastExpression");
      } else {
        return node;
      }
    };
  });

  instance.extend("checkLVal", function (inner) {
    return function (node) {
      if (node.type !== "TypeCastExpression") {
        return inner.apply(this, arguments);
      }
    };
  });

  // parse class property type annotations
  instance.extend("parseClassProperty", function (inner) {
    return function (node) {
      delete node.variancePos;
      if (this.match(types.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return inner.call(this, node);
    };
  });

  // determine whether or not we're currently in the position where a class method would appear
  instance.extend("isClassMethod", function (inner) {
    return function () {
      return this.isRelational("<") || inner.call(this);
    };
  });

  // determine whether or not we're currently in the position where a class property would appear
  instance.extend("isClassProperty", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  instance.extend("isNonstaticConstructor", function (inner) {
    return function (method) {
      return !this.match(types.colon) && inner.call(this, method);
    };
  });

  // parse type parameters for class methods
  instance.extend("parseClassMethod", function (inner) {
    return function (classBody, method) {
      if (method.variance) {
        this.unexpected(method.variancePos);
      }
      delete method.variance;
      delete method.variancePos;
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      inner.call.apply(inner, [this, classBody, method].concat(args));
    };
  });

  // parse a the super class type parameters and implements
  instance.extend("parseClassSuper", function (inner) {
    return function (node, isStatement) {
      inner.call(this, node, isStatement);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual("implements")) {
        this.next();
        var implemented = node.implements = [];
        do {
          var _node = this.startNode();
          _node.id = this.parseIdentifier();
          if (this.isRelational("<")) {
            _node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            _node.typeParameters = null;
          }
          implemented.push(this.finishNode(_node, "ClassImplements"));
        } while (this.eat(types.comma));
      }
    };
  });

  instance.extend("parsePropertyName", function (inner) {
    return function (node) {
      var variancePos = this.state.start;
      var variance = this.flowParseVariance();
      var key = inner.call(this, node);
      node.variance = variance;
      node.variancePos = variancePos;
      return key;
    };
  });

  // parse type parameters for object method shorthand
  instance.extend("parseObjPropValue", function (inner) {
    return function (prop) {
      if (prop.variance) {
        this.unexpected(prop.variancePos);
      }
      delete prop.variance;
      delete prop.variancePos;

      var typeParameters = void 0;

      // method shorthand
      if (this.isRelational("<")) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(types.parenL)) this.unexpected();
      }

      inner.apply(this, arguments);

      // add typeParameters if we found them
      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    };
  });

  instance.extend("parseAssignableListItemTypes", function () {
    return function (param) {
      if (this.eat(types.question)) {
        param.optional = true;
      }
      if (this.match(types.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      }
      this.finishNode(param, param.type);
      return param;
    };
  });

  instance.extend("parseMaybeDefault", function (inner) {
    return function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var node = inner.apply(this, args);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`");
      }

      return node;
    };
  });

  // parse typeof and type imports
  instance.extend("parseImportSpecifiers", function (inner) {
    return function (node) {
      node.importKind = "value";

      var kind = null;
      if (this.match(types._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }
      if (kind) {
        var lh = this.lookahead();
        if (lh.type === types.name && lh.value !== "from" || lh.type === types.braceL || lh.type === types.star) {
          this.next();
          node.importKind = kind;
        }
      }

      inner.call(this, node);
    };
  });

  // parse import-type/typeof shorthand
  instance.extend("parseImportSpecifier", function () {
    return function (node) {
      var specifier = this.startNode();
      var firstIdentLoc = this.state.start;
      var firstIdent = this.parseIdentifier(true);

      var specifierTypeKind = null;
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }

      var isBinding = false;
      if (this.isContextual("as")) {
        var as_ident = this.parseIdentifier(true);
        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
          // `import {type as ,` or `import {type as }`
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = as_ident.__clone();
        } else {
          // `import {type as foo`
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
        // `import {type foo`
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = specifier.imported.__clone();
        }
      } else {
        isBinding = true;
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = specifier.imported.__clone();
      }

      if ((node.importKind === "type" || node.importKind === "typeof") && (specifier.importKind === "type" || specifier.importKind === "typeof")) {
        this.raise(firstIdentLoc, "`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`");
      }

      if (isBinding) this.checkReservedWord(specifier.local.name, specifier.start, true, true);

      this.checkLVal(specifier.local, true, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    };
  });

  // parse function type parameters - function foo<T>() {}
  instance.extend("parseFunctionParams", function (inner) {
    return function (node) {
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      inner.call(this, node);
    };
  });

  // parse flow type annotations on variable declarator heads - let foo: string = bar
  instance.extend("parseVarHead", function (inner) {
    return function (decl) {
      inner.call(this, decl);
      if (this.match(types.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(decl.id, decl.id.type);
      }
    };
  });

  // parse the return type of an async arrow function - let foo = (async (): number => {});
  instance.extend("parseAsyncArrowFromCallExpression", function (inner) {
    return function (node, call) {
      if (this.match(types.colon)) {
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }

      return inner.call(this, node, call);
    };
  });

  // todo description
  instance.extend("shouldParseAsyncArrow", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  // We need to support type parameter declarations for arrow functions. This
  // is tricky. There are three situations we need to handle
  //
  // 1. This is either JSX or an arrow function. We'll try JSX first. If that
  //    fails, we'll try an arrow function. If that fails, we'll throw the JSX
  //    error.
  // 2. This is an arrow function. We'll parse the type parameter declaration,
  //    parse the rest, make sure the rest is an arrow function, and go from
  //    there
  // 3. This is neither. Just call the inner function
  instance.extend("parseMaybeAssign", function (inner) {
    return function () {
      var jsxError = null;

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      if (types.jsxTagStart && this.match(types.jsxTagStart)) {
        var state = this.state.clone();
        try {
          return inner.apply(this, args);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;

            // Remove `tc.j_expr` and `tc.j_oTag` from context added
            // by parsing `jsxTagStart` to stop the JSX plugin from
            // messing with the tokens
            this.state.context.length -= 2;

            jsxError = err;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      if (jsxError != null || this.isRelational("<")) {
        var arrowExpression = void 0;
        var typeParameters = void 0;
        try {
          typeParameters = this.flowParseTypeParameterDeclaration();

          arrowExpression = inner.apply(this, args);
          arrowExpression.typeParameters = typeParameters;
          arrowExpression.start = typeParameters.start;
          arrowExpression.loc.start = typeParameters.loc.start;
        } catch (err) {
          throw jsxError || err;
        }

        if (arrowExpression.type === "ArrowFunctionExpression") {
          return arrowExpression;
        } else if (jsxError != null) {
          throw jsxError;
        } else {
          this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
        }
      }

      return inner.apply(this, args);
    };
  });

  // handle return types for arrow functions
  instance.extend("parseArrow", function (inner) {
    return function (node) {
      if (this.match(types.colon)) {
        var state = this.state.clone();
        try {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          var returnType = this.flowParseTypeAndPredicateAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;

          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(types.arrow)) this.unexpected();
          // assign after it is clear it is an arrow
          node.returnType = returnType;
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      return inner.call(this, node);
    };
  });

  instance.extend("shouldParseArrow", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });
};

// Adapted from String.fromcodepoint to export the function without modifying String
/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */

// The MIT License (MIT)
// Copyright (c) Mathias Bynens
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
// associated documentation files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var fromCodePoint = String.fromCodePoint;

if (!fromCodePoint) {
  var stringFromCharCode = String.fromCharCode;
  var floor = Math.floor;
  fromCodePoint = function fromCodePoint() {
    var MAX_SIZE = 0x4000;
    var codeUnits = [];
    var highSurrogate = void 0;
    var lowSurrogate = void 0;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return "";
    }
    var result = "";
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
      codePoint < 0 || // not a valid Unicode code point
      codePoint > 0x10FFFF || // not a valid Unicode code point
      floor(codePoint) != codePoint // not an integer
      ) {
          throw RangeError("Invalid code point: " + codePoint);
        }
      if (codePoint <= 0xFFFF) {
        // BMP code point
        codeUnits.push(codePoint);
      } else {
        // Astral code point; split in surrogate halves
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = codePoint % 0x400 + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index + 1 == length || codeUnits.length > MAX_SIZE) {
        result += stringFromCharCode.apply(null, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  };
}

var fromCodePoint$1 = fromCodePoint;

var XHTMLEntities = {
  quot: "\"",
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  "int": "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};

var HEX_NUMBER = /^[\da-fA-F]+$/;
var DECIMAL_NUMBER = /^\d+$/;

types$1.j_oTag = new TokContext("<tag", false);
types$1.j_cTag = new TokContext("</tag", false);
types$1.j_expr = new TokContext("<tag>...</tag>", true, true);

types.jsxName = new TokenType("jsxName");
types.jsxText = new TokenType("jsxText", { beforeExpr: true });
types.jsxTagStart = new TokenType("jsxTagStart", { startsExpr: true });
types.jsxTagEnd = new TokenType("jsxTagEnd");

types.jsxTagStart.updateContext = function () {
  this.state.context.push(types$1.j_expr); // treat as beginning of JSX expression
  this.state.context.push(types$1.j_oTag); // start opening tag context
  this.state.exprAllowed = false;
};

types.jsxTagEnd.updateContext = function (prevType) {
  var out = this.state.context.pop();
  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === types$1.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

var pp$9 = Parser.prototype;

// Reads inline JSX contents token.

pp$9.jsxReadToken = function () {
  var out = "";
  var chunkStart = this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated JSX contents");
    }

    var ch = this.input.charCodeAt(this.state.pos);

    switch (ch) {
      case 60: // "<"
      case 123:
        // "{"
        if (this.state.pos === this.state.start) {
          if (ch === 60 && this.state.exprAllowed) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagStart);
          }
          return this.getTokenFromCode(ch);
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(types.jsxText, out);

      case 38:
        // "&"
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
        break;

      default:
        if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(true);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
    }
  }
};

pp$9.jsxReadNewLine = function (normalizeCRLF) {
  var ch = this.input.charCodeAt(this.state.pos);
  var out = void 0;
  ++this.state.pos;
  if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
    ++this.state.pos;
    out = normalizeCRLF ? "\n" : "\r\n";
  } else {
    out = String.fromCharCode(ch);
  }
  ++this.state.curLine;
  this.state.lineStart = this.state.pos;

  return out;
};

pp$9.jsxReadString = function (quote) {
  var out = "";
  var chunkStart = ++this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated string constant");
    }

    var ch = this.input.charCodeAt(this.state.pos);
    if (ch === quote) break;
    if (ch === 38) {
      // "&"
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadEntity();
      chunkStart = this.state.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadNewLine(false);
      chunkStart = this.state.pos;
    } else {
      ++this.state.pos;
    }
  }
  out += this.input.slice(chunkStart, this.state.pos++);
  return this.finishToken(types.string, out);
};

pp$9.jsxReadEntity = function () {
  var str = "";
  var count = 0;
  var entity = void 0;
  var ch = this.input[this.state.pos];

  var startPos = ++this.state.pos;
  while (this.state.pos < this.input.length && count++ < 10) {
    ch = this.input[this.state.pos++];
    if (ch === ";") {
      if (str[0] === "#") {
        if (str[1] === "x") {
          str = str.substr(2);
          if (HEX_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 16));
        } else {
          str = str.substr(1);
          if (DECIMAL_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 10));
        }
      } else {
        entity = XHTMLEntities[str];
      }
      break;
    }
    str += ch;
  }
  if (!entity) {
    this.state.pos = startPos;
    return "&";
  }
  return entity;
};

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can"t contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

pp$9.jsxReadWord = function () {
  var ch = void 0;
  var start = this.state.pos;
  do {
    ch = this.input.charCodeAt(++this.state.pos);
  } while (isIdentifierChar(ch) || ch === 45); // "-"
  return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
};

// Transforms JSX element name to string.

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }
}

// Parse next token as JSX identifier

pp$9.jsxParseIdentifier = function () {
  var node = this.startNode();
  if (this.match(types.jsxName)) {
    node.name = this.state.value;
  } else if (this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "JSXIdentifier");
};

// Parse namespaced identifier.

pp$9.jsxParseNamespacedName = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var name = this.jsxParseIdentifier();
  if (!this.eat(types.colon)) return name;

  var node = this.startNodeAt(startPos, startLoc);
  node.namespace = name;
  node.name = this.jsxParseIdentifier();
  return this.finishNode(node, "JSXNamespacedName");
};

// Parses element name in any form - namespaced, member
// or single identifier.

pp$9.jsxParseElementName = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var node = this.jsxParseNamespacedName();
  while (this.eat(types.dot)) {
    var newNode = this.startNodeAt(startPos, startLoc);
    newNode.object = node;
    newNode.property = this.jsxParseIdentifier();
    node = this.finishNode(newNode, "JSXMemberExpression");
  }
  return node;
};

// Parses any type of JSX attribute value.

pp$9.jsxParseAttributeValue = function () {
  var node = void 0;
  switch (this.state.type) {
    case types.braceL:
      node = this.jsxParseExpressionContainer();
      if (node.expression.type === "JSXEmptyExpression") {
        this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
      } else {
        return node;
      }

    case types.jsxTagStart:
    case types.string:
      node = this.parseExprAtom();
      node.extra = null;
      return node;

    default:
      this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
  }
};

// JSXEmptyExpression is unique type since it doesn't actually parse anything,
// and so it should start at the end of last read token (left brace) and finish
// at the beginning of the next one (right brace).

pp$9.jsxParseEmptyExpression = function () {
  var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
  return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
};

// Parse JSX spread child

pp$9.jsxParseSpreadChild = function () {
  var node = this.startNode();
  this.expect(types.braceL);
  this.expect(types.ellipsis);
  node.expression = this.parseExpression();
  this.expect(types.braceR);

  return this.finishNode(node, "JSXSpreadChild");
};

// Parses JSX expression enclosed into curly brackets.


pp$9.jsxParseExpressionContainer = function () {
  var node = this.startNode();
  this.next();
  if (this.match(types.braceR)) {
    node.expression = this.jsxParseEmptyExpression();
  } else {
    node.expression = this.parseExpression();
  }
  this.expect(types.braceR);
  return this.finishNode(node, "JSXExpressionContainer");
};

// Parses following JSX attribute name-value pair.

pp$9.jsxParseAttribute = function () {
  var node = this.startNode();
  if (this.eat(types.braceL)) {
    this.expect(types.ellipsis);
    node.argument = this.parseMaybeAssign();
    this.expect(types.braceR);
    return this.finishNode(node, "JSXSpreadAttribute");
  }
  node.name = this.jsxParseNamespacedName();
  node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
  return this.finishNode(node, "JSXAttribute");
};

// Parses JSX opening tag starting after "<".

pp$9.jsxParseOpeningElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.attributes = [];
  node.name = this.jsxParseElementName();
  while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
    node.attributes.push(this.jsxParseAttribute());
  }
  node.selfClosing = this.eat(types.slash);
  this.expect(types.jsxTagEnd);
  return this.finishNode(node, "JSXOpeningElement");
};

// Parses JSX closing tag starting after "</".

pp$9.jsxParseClosingElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.name = this.jsxParseElementName();
  this.expect(types.jsxTagEnd);
  return this.finishNode(node, "JSXClosingElement");
};

// Parses entire JSX element, including it"s opening tag
// (starting after "<"), attributes, contents and closing tag.

pp$9.jsxParseElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  var children = [];
  var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
  var closingElement = null;

  if (!openingElement.selfClosing) {
    contents: for (;;) {
      switch (this.state.type) {
        case types.jsxTagStart:
          startPos = this.state.start;startLoc = this.state.startLoc;
          this.next();
          if (this.eat(types.slash)) {
            closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
            break contents;
          }
          children.push(this.jsxParseElementAt(startPos, startLoc));
          break;

        case types.jsxText:
          children.push(this.parseExprAtom());
          break;

        case types.braceL:
          if (this.lookahead().type === types.ellipsis) {
            children.push(this.jsxParseSpreadChild());
          } else {
            children.push(this.jsxParseExpressionContainer());
          }

          break;

        // istanbul ignore next - should never happen
        default:
          this.unexpected();
      }
    }

    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
      this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
    }
  }

  node.openingElement = openingElement;
  node.closingElement = closingElement;
  node.children = children;
  if (this.match(types.relational) && this.state.value === "<") {
    this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
  }
  return this.finishNode(node, "JSXElement");
};

// Parses entire JSX element from current position.

pp$9.jsxParseElement = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  this.next();
  return this.jsxParseElementAt(startPos, startLoc);
};

var jsxPlugin = function (instance) {
  instance.extend("parseExprAtom", function (inner) {
    return function (refShortHandDefaultPos) {
      if (this.match(types.jsxText)) {
        var node = this.parseLiteral(this.state.value, "JSXText");
        // https://github.com/babel/babel/issues/2078
        node.extra = null;
        return node;
      } else if (this.match(types.jsxTagStart)) {
        return this.jsxParseElement();
      } else {
        return inner.call(this, refShortHandDefaultPos);
      }
    };
  });

  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inPropertyName) return inner.call(this, code);

      var context = this.curContext();

      if (context === types$1.j_expr) {
        return this.jsxReadToken();
      }

      if (context === types$1.j_oTag || context === types$1.j_cTag) {
        if (isIdentifierStart(code)) {
          return this.jsxReadWord();
        }

        if (code === 62) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagEnd);
        }

        if ((code === 34 || code === 39) && context === types$1.j_oTag) {
          return this.jsxReadString(code);
        }
      }

      if (code === 60 && this.state.exprAllowed) {
        ++this.state.pos;
        return this.finishToken(types.jsxTagStart);
      }

      return inner.call(this, code);
    };
  });

  instance.extend("updateContext", function (inner) {
    return function (prevType) {
      if (this.match(types.braceL)) {
        var curContext = this.curContext();
        if (curContext === types$1.j_oTag) {
          this.state.context.push(types$1.braceExpression);
        } else if (curContext === types$1.j_expr) {
          this.state.context.push(types$1.templateQuasi);
        } else {
          inner.call(this, prevType);
        }
        this.state.exprAllowed = true;
      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
        this.state.context.push(types$1.j_cTag); // reconsider as closing tag context
        this.state.exprAllowed = false;
      } else {
        return inner.call(this, prevType);
      }
    };
  });
};

plugins.estree = estreePlugin;
plugins.flow = flowPlugin;
plugins.jsx = jsxPlugin;

function parse(input, options) {
  return new Parser(options, input).parse();
}

function parseExpression(input, options) {
  var parser = new Parser(options, input);
  if (parser.options.strictMode) {
    parser.state.strict = true;
  }
  return parser.getExpression();
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = types;


/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(13) && !__webpack_require__(15)(function () {
  return Object.defineProperty(__webpack_require__(124)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
var document = __webpack_require__(8).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(16);
var toIObject = __webpack_require__(27);
var arrayIndexOf = __webpack_require__(202)(false);
var IE_PROTO = __webpack_require__(81)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(127);
var ITERATOR = __webpack_require__(6)('iterator');
var Iterators = __webpack_require__(32);
module.exports = __webpack_require__(2).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(73);
var TAG = __webpack_require__(6)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = undefined;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var ReferencedIdentifier = exports.ReferencedIdentifier = {
  types: ["Identifier", "JSXIdentifier"],
  checkPath: function checkPath(_ref, opts) {
    var node = _ref.node,
        parent = _ref.parent;

    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {
      if (t.isJSXIdentifier(node, opts)) {
        if (_babelTypes.react.isCompatTag(node.name)) return false;
      } else {
        return false;
      }
    }

    return t.isReferenced(node, parent);
  }
};

var ReferencedMemberExpression = exports.ReferencedMemberExpression = {
  types: ["MemberExpression"],
  checkPath: function checkPath(_ref2) {
    var node = _ref2.node,
        parent = _ref2.parent;

    return t.isMemberExpression(node) && t.isReferenced(node, parent);
  }
};

var BindingIdentifier = exports.BindingIdentifier = {
  types: ["Identifier"],
  checkPath: function checkPath(_ref3) {
    var node = _ref3.node,
        parent = _ref3.parent;

    return t.isIdentifier(node) && t.isBinding(node, parent);
  }
};

var Statement = exports.Statement = {
  types: ["Statement"],
  checkPath: function checkPath(_ref4) {
    var node = _ref4.node,
        parent = _ref4.parent;

    if (t.isStatement(node)) {
      if (t.isVariableDeclaration(node)) {
        if (t.isForXStatement(parent, { left: node })) return false;
        if (t.isForStatement(parent, { init: node })) return false;
      }

      return true;
    } else {
      return false;
    }
  }
};

var Expression = exports.Expression = {
  types: ["Expression"],
  checkPath: function checkPath(path) {
    if (path.isIdentifier()) {
      return path.isReferencedIdentifier();
    } else {
      return t.isExpression(path.node);
    }
  }
};

var Scope = exports.Scope = {
  types: ["Scopable"],
  checkPath: function checkPath(path) {
    return t.isScope(path.node, path.parent);
  }
};

var Referenced = exports.Referenced = {
  checkPath: function checkPath(path) {
    return t.isReferenced(path.node, path.parent);
  }
};

var BlockScoped = exports.BlockScoped = {
  checkPath: function checkPath(path) {
    return t.isBlockScoped(path.node);
  }
};

var Var = exports.Var = {
  types: ["VariableDeclaration"],
  checkPath: function checkPath(path) {
    return t.isVar(path.node);
  }
};

var User = exports.User = {
  checkPath: function checkPath(path) {
    return path.node && !!path.node.loc;
  }
};

var Generated = exports.Generated = {
  checkPath: function checkPath(path) {
    return !path.isUser();
  }
};

var Pure = exports.Pure = {
  checkPath: function checkPath(path, opts) {
    return path.scope.isPure(path.node, opts);
  }
};

var Flow = exports.Flow = {
  types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
  checkPath: function checkPath(_ref5) {
    var node = _ref5.node;

    if (t.isFlow(node)) {
      return true;
    } else if (t.isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (t.isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (t.isImportSpecifier(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  }
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(73);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(125);
var hiddenKeys = __webpack_require__(83).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(52);
var createDesc = __webpack_require__(47);
var toIObject = __webpack_require__(27);
var toPrimitive = __webpack_require__(77);
var has = __webpack_require__(16);
var IE8_DOM_DEFINE = __webpack_require__(123);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _create = __webpack_require__(53);

var _create2 = _interopRequireDefault(_create);

exports.getBindingIdentifiers = getBindingIdentifiers;
exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;

var _index = __webpack_require__(0);

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getBindingIdentifiers(node, duplicates, outerOnly) {
  var search = [].concat(node);
  var ids = (0, _create2.default)(null);

  while (search.length) {
    var id = search.shift();
    if (!id) continue;

    var keys = t.getBindingIdentifiers.keys[id.type];

    if (t.isIdentifier(id)) {
      if (duplicates) {
        var _ids = ids[id.name] = ids[id.name] || [];
        _ids.push(id);
      } else {
        ids[id.name] = id;
      }
      continue;
    }

    if (t.isExportDeclaration(id)) {
      if (t.isDeclaration(id.declaration)) {
        search.push(id.declaration);
      }
      continue;
    }

    if (outerOnly) {
      if (t.isFunctionDeclaration(id)) {
        search.push(id.id);
        continue;
      }

      if (t.isFunctionExpression(id)) {
        continue;
      }
    }

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }

  return ids;
}

getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],

  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],

  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],

  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],

  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],

  ClassDeclaration: ["id"],
  ClassExpression: ["id"],

  RestElement: ["argument"],
  UpdateExpression: ["argument"],

  RestProperty: ["argument"],
  ObjectProperty: ["value"],

  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],

  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};

function getOuterBindingIdentifiers(node, duplicates) {
  return getBindingIdentifiers(node, duplicates, true);
}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = __webpack_require__(227);
    exports.code = __webpack_require__(134);
    exports.keyword = __webpack_require__(228);
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 134 */
/***/ (function(module, exports) {

/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 135 */
/***/ (function(module, exports) {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;


/***/ }),
/* 136 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(240);

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(18),
    isObject = __webpack_require__(19);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(141);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(25);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(269),
    isArguments = __webpack_require__(143),
    isArray = __webpack_require__(7),
    isBuffer = __webpack_require__(95),
    isIndex = __webpack_require__(96),
    isTypedArray = __webpack_require__(144);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(270),
    isObjectLike = __webpack_require__(10);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(272),
    baseUnary = __webpack_require__(55),
    nodeUtil = __webpack_require__(56);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 145 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(147),
    getPrototype = __webpack_require__(90),
    getSymbols = __webpack_require__(99),
    stubArray = __webpack_require__(145);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(149),
    getSymbols = __webpack_require__(99),
    keys = __webpack_require__(20);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(147),
    isArray = __webpack_require__(7);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(25),
    root = __webpack_require__(9);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(9);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(93),
    setCacheAdd = __webpack_require__(301),
    setCacheHas = __webpack_require__(302);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(101),
    baseIsNaN = __webpack_require__(304),
    strictIndexOf = __webpack_require__(305);

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),
/* 154 */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(319);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(103),
    overRest = __webpack_require__(326),
    setToString = __webpack_require__(328);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(332), __esModule: true };

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var baseRepeat = __webpack_require__(350),
    isIterateeCall = __webpack_require__(104),
    toInteger = __webpack_require__(42),
    toString = __webpack_require__(159);

/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
function repeat(string, n, guard) {
  if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  return baseRepeat(toString(string), n);
}

module.exports = repeat;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(351);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Binding = function () {
  function Binding(_ref) {
    var existing = _ref.existing,
        identifier = _ref.identifier,
        scope = _ref.scope,
        path = _ref.path,
        kind = _ref.kind;
    (0, _classCallCheck3.default)(this, Binding);

    this.identifier = identifier;
    this.scope = scope;
    this.path = path;
    this.kind = kind;

    this.constantViolations = [];
    this.constant = true;

    this.referencePaths = [];
    this.referenced = false;
    this.references = 0;

    this.clearValue();

    if (existing) {
      this.constantViolations = [].concat(existing.path, existing.constantViolations, this.constantViolations);
    }
  }

  Binding.prototype.deoptValue = function deoptValue() {
    this.clearValue();
    this.hasDeoptedValue = true;
  };

  Binding.prototype.setValue = function setValue(value) {
    if (this.hasDeoptedValue) return;
    this.hasValue = true;
    this.value = value;
  };

  Binding.prototype.clearValue = function clearValue() {
    this.hasDeoptedValue = false;
    this.hasValue = false;
    this.value = null;
  };

  Binding.prototype.reassign = function reassign(path) {
    this.constant = false;
    if (this.constantViolations.indexOf(path) !== -1) {
      return;
    }
    this.constantViolations.push(path);
  };

  Binding.prototype.reference = function reference(path) {
    if (this.referencePaths.indexOf(path) !== -1) {
      return;
    }
    this.referenced = true;
    this.references++;
    this.referencePaths.push(path);
  };

  Binding.prototype.dereference = function dereference() {
    this.references--;
    this.referenced = !!this.references;
  };

  return Binding;
}();

exports.default = Binding;
module.exports = exports["default"];

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(33);
var gOPS = __webpack_require__(88);
var pIE = __webpack_require__(52);
var toObject = __webpack_require__(51);
var IObject = __webpack_require__(72);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(15)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(106);
var getWeak = __webpack_require__(34).getWeak;
var anObject = __webpack_require__(12);
var isObject = __webpack_require__(5);
var anInstance = __webpack_require__(107);
var forOf = __webpack_require__(40);
var createArrayMethod = __webpack_require__(109);
var $has = __webpack_require__(16);
var validate = __webpack_require__(41);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Hub = function Hub(file, options) {
  (0, _classCallCheck3.default)(this, Hub);

  this.file = file;
  this.options = options;
};

exports.default = Hub;
module.exports = exports["default"];

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(166);
var util = __webpack_require__(43);
var ArraySet = __webpack_require__(167).ArraySet;
var MappingList = __webpack_require__(400).MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(399);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(43);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee = __webpack_require__(66),
    isArrayLike = __webpack_require__(21),
    keys = __webpack_require__(20);

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(417),
    isObjectLike = __webpack_require__(10);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(152),
    arraySome = __webpack_require__(418),
    cacheHas = __webpack_require__(154);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(19);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),
/* 172 */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(174),
    toKey = __webpack_require__(67);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(7),
    isKey = __webpack_require__(114),
    stringToPath = __webpack_require__(425),
    toString = __webpack_require__(159);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = __webpack_require__(29);

var _keys2 = _interopRequireDefault(_keys);

exports.needsWhitespace = needsWhitespace;
exports.needsWhitespaceBefore = needsWhitespaceBefore;
exports.needsWhitespaceAfter = needsWhitespaceAfter;
exports.needsParens = needsParens;

var _whitespace = __webpack_require__(440);

var _whitespace2 = _interopRequireDefault(_whitespace);

var _parentheses = __webpack_require__(448);

var parens = _interopRequireWildcard(_parentheses);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function expandAliases(obj) {
  var newObj = {};

  function add(type, func) {
    var fn = newObj[type];
    newObj[type] = fn ? function (node, parent, stack) {
      var result = fn(node, parent, stack);

      return result == null ? func(node, parent, stack) : result;
    } : func;
  }

  for (var _iterator = (0, _keys2.default)(obj), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var type = _ref;


    var aliases = t.FLIPPED_ALIAS_KEYS[type];
    if (aliases) {
      for (var _iterator2 = aliases, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var alias = _ref2;

        add(alias, obj[type]);
      }
    } else {
      add(type, obj[type]);
    }
  }

  return newObj;
}

var expandedParens = expandAliases(parens);
var expandedWhitespaceNodes = expandAliases(_whitespace2.default.nodes);
var expandedWhitespaceList = expandAliases(_whitespace2.default.list);

function find(obj, node, parent, printStack) {
  var fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}

function isOrHasCallExpression(node) {
  if (t.isCallExpression(node)) {
    return true;
  }

  if (t.isMemberExpression(node)) {
    return isOrHasCallExpression(node.object) || !node.computed && isOrHasCallExpression(node.property);
  } else {
    return false;
  }
}

function needsWhitespace(node, parent, type) {
  if (!node) return 0;

  if (t.isExpressionStatement(node)) {
    node = node.expression;
  }

  var linesInfo = find(expandedWhitespaceNodes, node, parent);

  if (!linesInfo) {
    var items = find(expandedWhitespaceList, node, parent);
    if (items) {
      for (var i = 0; i < items.length; i++) {
        linesInfo = needsWhitespace(items[i], node, type);
        if (linesInfo) break;
      }
    }
  }

  return linesInfo && linesInfo[type] || 0;
}

function needsWhitespaceBefore(node, parent) {
  return needsWhitespace(node, parent, "before");
}

function needsWhitespaceAfter(node, parent) {
  return needsWhitespace(node, parent, "after");
}

function needsParens(node, parent, printStack) {
  if (!parent) return false;

  if (t.isNewExpression(parent) && parent.callee === node) {
    if (isOrHasCallExpression(node)) return true;
  }

  return find(expandedParens, node, parent, printStack);
}

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const PageFactory_1 = __webpack_require__(177);
const fs = __webpack_require__(26);
const path = __webpack_require__(45);
const conf_1 = __webpack_require__(44);
//import { doFile } from './common/ffs';
//doFile()
// let t:PageFactory = new PageFactory();
// console.log(t.fileMap)
copyFolder("/");
function copyFolder(relativePath) {
    let inputFile = path.join(conf_1.inputRoot, relativePath);
    let outputFile = path.join(conf_1.outputRoot, relativePath);
    if (!fs.existsSync(inputFile)) {
        throw new Error("there is no " + inputFile);
    }
    let stats = fs.statSync(inputFile);
    if (stats.isDirectory()) {
        if (conf_1.unpackagedFolder.indexOf(inputFile) > -1) {} else {
            let floder = PageFactory_1.PageFactory.createFolder(inputFile, outputFile);
            floder.operate();
            let files = fs.readdirSync(inputFile);
            files.forEach(function (file, index) {
                let from = path.join(relativePath, file);
                // console.log(from)
                copyFolder(from);
            });
        }
    } else if (!stats.isDirectory()) {
        let page = PageFactory_1.PageFactory.createPage(inputFile, outputFile);
        page.operate();
    }
}

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const conf_1 = __webpack_require__(44);
const Tools_1 = __webpack_require__(116);
const Page_1 = __webpack_require__(46);
const HtmlPage_1 = __webpack_require__(195);
const Folder_1 = __webpack_require__(460);
const scriptPage_1 = __webpack_require__(461);
const manifestPage_1 = __webpack_require__(462);
class emptyFile {
    operate() {}
}
class PageFactory {
    // static Html2JsMap: Map<string, string> = Html2JsMap;
    // static unpackagedFile = unpackagedFile;
    static createPage(inputPath, outputPath) {
        if (conf_1.unpackagedFile.indexOf(inputPath) > -1 || !Tools_1.checkFileName(inputPath)) {
            return new emptyFile();
        } else if (inputPath.endsWith(".html")) {
            // return new emptyFile()
            //let map =  PageFactory.Html2JsMap;
            if (conf_1.Html2JsMap.has(inputPath)) {
                return new HtmlPage_1.HtmlPage(inputPath, outputPath, conf_1.Html2JsMap.get(inputPath));
            } else {
                return new Page_1.Page(inputPath, outputPath);
            }
        } else if (inputPath.endsWith(".js")) {
            if (conf_1.jsScripts.indexOf(inputPath) > -1) {
                return new scriptPage_1.scriptPage(inputPath, outputPath);
            } else if (conf_1.jsScriptsX.indexOf(inputPath) > -1) {
                return new scriptPage_1.scriptPage(inputPath, outputPath, true);
            } else {
                return new emptyFile();
            }
        } else if (conf_1.manifest.indexOf(inputPath) > -1) {
            return new manifestPage_1.manifestPage(inputPath, outputPath);
        } else {
            return new Page_1.Page(inputPath, outputPath);
        }
    }
    static createFolder(inputPath, outputPath) {
        if (conf_1.unpackagedFolder.indexOf(inputPath) > -1 || !Tools_1.checkFileName(inputPath)) {
            return null;
        } else {
            return new Folder_1.Folder(outputPath);
        }
    }
}
exports.PageFactory = PageFactory;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const https = __webpack_require__(179);
const querystring = __webpack_require__(180);
const url = __webpack_require__(181);
function postMessage(...args) {
    let _url = args[0];
    let postData = args[1] || {};
    let headers = args[2] || {};
    return new Promise((resolve, reject) => {
        let urlData = url.parse(_url);
        let pData = querystring.stringify(postData);
        let default_headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            'Content-Length': Buffer.byteLength(pData)
        };
        let options = {
            hostname: urlData.hostname,
            port: urlData.port || "443",
            path: urlData.path,
            method: 'POST',
            //secureProtocol: 'SSLv3_method',
            headers: Object.assign(default_headers, headers)
        };
        //console.log(options)
        //console.log("http-----------",process.uptime())
        let req = https.request(options, function (res) {
            let chunks = "";
            res.setEncoding('utf8');
            res.on('data', function (chunk) {
                chunks += `${chunk}`;
            });
            res.on('end', function () {
                resolve(chunks);
                //console.log("get-----------",process.uptime())
            });
        });
        req.on('error', function (err) {
            reject(err);
        });
        req.write(pData);
        req.end();
    });
}
exports.postMessage = postMessage;

/***/ }),
/* 179 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),
/* 181 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Tokenizer;

var decodeCodePoint = __webpack_require__(183),
    entityMap = __webpack_require__(185),
    legacyMap = __webpack_require__(186),
    xmlMap    = __webpack_require__(187),

    i = 0,

    TEXT                      = i++,
    BEFORE_TAG_NAME           = i++, //after <
    IN_TAG_NAME               = i++,
    IN_SELF_CLOSING_TAG       = i++,
    BEFORE_CLOSING_TAG_NAME   = i++,
    IN_CLOSING_TAG_NAME       = i++,
    AFTER_CLOSING_TAG_NAME    = i++,

    //attributes
    BEFORE_ATTRIBUTE_NAME     = i++,
    IN_ATTRIBUTE_NAME         = i++,
    AFTER_ATTRIBUTE_NAME      = i++,
    BEFORE_ATTRIBUTE_VALUE    = i++,
    IN_ATTRIBUTE_VALUE_DQ     = i++, // "
    IN_ATTRIBUTE_VALUE_SQ     = i++, // '
    IN_ATTRIBUTE_VALUE_NQ     = i++,

    //declarations
    BEFORE_DECLARATION        = i++, // !
    IN_DECLARATION            = i++,

    //processing instructions
    IN_PROCESSING_INSTRUCTION = i++, // ?

    //comments
    BEFORE_COMMENT            = i++,
    IN_COMMENT                = i++,
    AFTER_COMMENT_1           = i++,
    AFTER_COMMENT_2           = i++,

    //cdata
    BEFORE_CDATA_1            = i++, // [
    BEFORE_CDATA_2            = i++, // C
    BEFORE_CDATA_3            = i++, // D
    BEFORE_CDATA_4            = i++, // A
    BEFORE_CDATA_5            = i++, // T
    BEFORE_CDATA_6            = i++, // A
    IN_CDATA                  = i++, // [
    AFTER_CDATA_1             = i++, // ]
    AFTER_CDATA_2             = i++, // ]

    //special tags
    BEFORE_SPECIAL            = i++, //S
    BEFORE_SPECIAL_END        = i++,   //S

    BEFORE_SCRIPT_1           = i++, //C
    BEFORE_SCRIPT_2           = i++, //R
    BEFORE_SCRIPT_3           = i++, //I
    BEFORE_SCRIPT_4           = i++, //P
    BEFORE_SCRIPT_5           = i++, //T
    AFTER_SCRIPT_1            = i++, //C
    AFTER_SCRIPT_2            = i++, //R
    AFTER_SCRIPT_3            = i++, //I
    AFTER_SCRIPT_4            = i++, //P
    AFTER_SCRIPT_5            = i++, //T

    BEFORE_STYLE_1            = i++, //T
    BEFORE_STYLE_2            = i++, //Y
    BEFORE_STYLE_3            = i++, //L
    BEFORE_STYLE_4            = i++, //E
    AFTER_STYLE_1             = i++, //T
    AFTER_STYLE_2             = i++, //Y
    AFTER_STYLE_3             = i++, //L
    AFTER_STYLE_4             = i++, //E

    BEFORE_ENTITY             = i++, //&
    BEFORE_NUMERIC_ENTITY     = i++, //#
    IN_NAMED_ENTITY           = i++,
    IN_NUMERIC_ENTITY         = i++,
    IN_HEX_ENTITY             = i++, //X

    j = 0,

    SPECIAL_NONE              = j++,
    SPECIAL_SCRIPT            = j++,
    SPECIAL_STYLE             = j++;

function whitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function characterState(char, SUCCESS){
	return function(c){
		if(c === char) this._state = SUCCESS;
	};
}

function ifElseState(upper, SUCCESS, FAILURE){
	var lower = upper.toLowerCase();

	if(upper === lower){
		return function(c){
			if(c === lower){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function(c){
			if(c === lower || c === upper){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function consumeSpecialNameChar(upper, NEXT_STATE){
	var lower = upper.toLowerCase();

	return function(c){
		if(c === lower || c === upper){
			this._state = NEXT_STATE;
		} else {
			this._state = IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function Tokenizer(options, cbs){
	this._state = TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = TEXT;
	this._special = SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

Tokenizer.prototype._stateText = function(c){
	if(c === "<"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._state = BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._baseState = TEXT;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeTagName = function(c){
	if(c === "/"){
		this._state = BEFORE_CLOSING_TAG_NAME;
	} else if(c === "<"){
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
		this._state = TEXT;
	} else if(c === "!"){
		this._state = BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if(c === "?"){
		this._state = IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
						BEFORE_SPECIAL : IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInTagName = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._emitToken("onopentagname");
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateBeforeCloseingTagName = function(c){
	if(whitespace(c));
	else if(c === ">"){
		this._state = TEXT;
	} else if(this._special !== SPECIAL_NONE){
		if(c === "s" || c === "S"){
			this._state = BEFORE_SPECIAL_END;
		} else {
			this._state = TEXT;
			this._index--;
		}
	} else {
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInCloseingTagName = function(c){
	if(c === ">" || whitespace(c)){
		this._emitToken("onclosetag");
		this._state = AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterCloseingTagName = function(c){
	//skip everything until ">"
	if(c === ">"){
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeAttributeName = function(c){
	if(c === ">"){
		this._cbs.onopentagend();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c === "/"){
		this._state = IN_SELF_CLOSING_TAG;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInSelfClosingTag = function(c){
	if(c === ">"){
		this._cbs.onselfclosingtag();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateInAttributeName = function(c){
	if(c === "=" || c === "/" || c === ">" || whitespace(c)){
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterAttributeName = function(c){
	if(c === "="){
		this._state = BEFORE_ATTRIBUTE_VALUE;
	} else if(c === "/" || c === ">"){
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(!whitespace(c)){
		this._cbs.onattribend();
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeAttributeValue = function(c){
	if(c === "\""){
		this._state = IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if(c === "'"){
		this._state = IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c){
	if(c === "\""){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c){
	if(c === "'"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c){
	if(whitespace(c) || c === ">"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeDeclaration = function(c){
	this._state = c === "[" ? BEFORE_CDATA_1 :
					c === "-" ? BEFORE_COMMENT :
						IN_DECLARATION;
};

Tokenizer.prototype._stateInDeclaration = function(c){
	if(c === ">"){
		this._cbs.ondeclaration(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateInProcessingInstruction = function(c){
	if(c === ">"){
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeComment = function(c){
	if(c === "-"){
		this._state = IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
	}
};

Tokenizer.prototype._stateInComment = function(c){
	if(c === "-") this._state = AFTER_COMMENT_1;
};

Tokenizer.prototype._stateAfterComment1 = function(c){
	if(c === "-"){
		this._state = AFTER_COMMENT_2;
	} else {
		this._state = IN_COMMENT;
	}
};

Tokenizer.prototype._stateAfterComment2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "-"){
		this._state = IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

Tokenizer.prototype._stateBeforeCdata6 = function(c){
	if(c === "["){
		this._state = IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
		this._index--;
	}
};

Tokenizer.prototype._stateInCdata = function(c){
	if(c === "]") this._state = AFTER_CDATA_1;
};

Tokenizer.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2);

Tokenizer.prototype._stateAfterCdata2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "]") {
		this._state = IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

Tokenizer.prototype._stateBeforeSpecial = function(c){
	if(c === "c" || c === "C"){
		this._state = BEFORE_SCRIPT_1;
	} else if(c === "t" || c === "T"){
		this._state = BEFORE_STYLE_1;
	} else {
		this._state = IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

Tokenizer.prototype._stateBeforeSpecialEnd = function(c){
	if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
		this._state = AFTER_SCRIPT_1;
	} else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
		this._state = AFTER_STYLE_1;
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

Tokenizer.prototype._stateBeforeScript5 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_SCRIPT;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

Tokenizer.prototype._stateAfterScript5 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

Tokenizer.prototype._stateBeforeStyle4 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_STYLE;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

Tokenizer.prototype._stateAfterStyle4 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict = function(){
	//offset = 1
	if(this._sectionStart + 1 < this._index){
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? xmlMap : entityMap;

		if(map.hasOwnProperty(entity)){
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};


//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity = function(){
	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if(limit > 6) limit = 6; //the max length of legacy entities is 6

	while(limit >= 2){ //the min length of legacy entities is 2
		var entity = this._buffer.substr(start, limit);

		if(legacyMap.hasOwnProperty(entity)){
			this._emitPartial(legacyMap[entity]);
			this._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

Tokenizer.prototype._stateInNamedEntity = function(c){
	if(c === ";"){
		this._parseNamedEntityStrict();
		if(this._sectionStart + 1 < this._index && !this._xmlMode){
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
		if(this._xmlMode);
		else if(this._sectionStart + 1 === this._index);
		else if(this._baseState !== TEXT){
			if(c !== "="){
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

Tokenizer.prototype._decodeNumericEntity = function(offset, base){
	var sectionStart = this._sectionStart + offset;

	if(sectionStart !== this._index){
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

Tokenizer.prototype._stateInNumericEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if(c < "0" || c > "9"){
		if(!this._xmlMode){
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._stateInHexEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
		if(!this._xmlMode){
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._cleanup = function (){
	if(this._sectionStart < 0){
		this._buffer = "";
		this._bufferOffset += this._index;
		this._index = 0;
	} else if(this._running){
		if(this._state === TEXT){
			if(this._sectionStart !== this._index){
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if(this._sectionStart === this._index){
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
Tokenizer.prototype.write = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".write() after done!"));

	this._buffer += chunk;
	this._parse();
};

Tokenizer.prototype._parse = function(){
	while(this._index < this._buffer.length && this._running){
		var c = this._buffer.charAt(this._index);
		if(this._state === TEXT) {
			this._stateText(c);
		} else if(this._state === BEFORE_TAG_NAME){
			this._stateBeforeTagName(c);
		} else if(this._state === IN_TAG_NAME) {
			this._stateInTagName(c);
		} else if(this._state === BEFORE_CLOSING_TAG_NAME){
			this._stateBeforeCloseingTagName(c);
		} else if(this._state === IN_CLOSING_TAG_NAME){
			this._stateInCloseingTagName(c);
		} else if(this._state === AFTER_CLOSING_TAG_NAME){
			this._stateAfterCloseingTagName(c);
		} else if(this._state === IN_SELF_CLOSING_TAG){
			this._stateInSelfClosingTag(c);
		}

		/*
		*	attributes
		*/
		else if(this._state === BEFORE_ATTRIBUTE_NAME){
			this._stateBeforeAttributeName(c);
		} else if(this._state === IN_ATTRIBUTE_NAME){
			this._stateInAttributeName(c);
		} else if(this._state === AFTER_ATTRIBUTE_NAME){
			this._stateAfterAttributeName(c);
		} else if(this._state === BEFORE_ATTRIBUTE_VALUE){
			this._stateBeforeAttributeValue(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_DQ){
			this._stateInAttributeValueDoubleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_SQ){
			this._stateInAttributeValueSingleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_NQ){
			this._stateInAttributeValueNoQuotes(c);
		}

		/*
		*	declarations
		*/
		else if(this._state === BEFORE_DECLARATION){
			this._stateBeforeDeclaration(c);
		} else if(this._state === IN_DECLARATION){
			this._stateInDeclaration(c);
		}

		/*
		*	processing instructions
		*/
		else if(this._state === IN_PROCESSING_INSTRUCTION){
			this._stateInProcessingInstruction(c);
		}

		/*
		*	comments
		*/
		else if(this._state === BEFORE_COMMENT){
			this._stateBeforeComment(c);
		} else if(this._state === IN_COMMENT){
			this._stateInComment(c);
		} else if(this._state === AFTER_COMMENT_1){
			this._stateAfterComment1(c);
		} else if(this._state === AFTER_COMMENT_2){
			this._stateAfterComment2(c);
		}

		/*
		*	cdata
		*/
		else if(this._state === BEFORE_CDATA_1){
			this._stateBeforeCdata1(c);
		} else if(this._state === BEFORE_CDATA_2){
			this._stateBeforeCdata2(c);
		} else if(this._state === BEFORE_CDATA_3){
			this._stateBeforeCdata3(c);
		} else if(this._state === BEFORE_CDATA_4){
			this._stateBeforeCdata4(c);
		} else if(this._state === BEFORE_CDATA_5){
			this._stateBeforeCdata5(c);
		} else if(this._state === BEFORE_CDATA_6){
			this._stateBeforeCdata6(c);
		} else if(this._state === IN_CDATA){
			this._stateInCdata(c);
		} else if(this._state === AFTER_CDATA_1){
			this._stateAfterCdata1(c);
		} else if(this._state === AFTER_CDATA_2){
			this._stateAfterCdata2(c);
		}

		/*
		* special tags
		*/
		else if(this._state === BEFORE_SPECIAL){
			this._stateBeforeSpecial(c);
		} else if(this._state === BEFORE_SPECIAL_END){
			this._stateBeforeSpecialEnd(c);
		}

		/*
		* script
		*/
		else if(this._state === BEFORE_SCRIPT_1){
			this._stateBeforeScript1(c);
		} else if(this._state === BEFORE_SCRIPT_2){
			this._stateBeforeScript2(c);
		} else if(this._state === BEFORE_SCRIPT_3){
			this._stateBeforeScript3(c);
		} else if(this._state === BEFORE_SCRIPT_4){
			this._stateBeforeScript4(c);
		} else if(this._state === BEFORE_SCRIPT_5){
			this._stateBeforeScript5(c);
		}

		else if(this._state === AFTER_SCRIPT_1){
			this._stateAfterScript1(c);
		} else if(this._state === AFTER_SCRIPT_2){
			this._stateAfterScript2(c);
		} else if(this._state === AFTER_SCRIPT_3){
			this._stateAfterScript3(c);
		} else if(this._state === AFTER_SCRIPT_4){
			this._stateAfterScript4(c);
		} else if(this._state === AFTER_SCRIPT_5){
			this._stateAfterScript5(c);
		}

		/*
		* style
		*/
		else if(this._state === BEFORE_STYLE_1){
			this._stateBeforeStyle1(c);
		} else if(this._state === BEFORE_STYLE_2){
			this._stateBeforeStyle2(c);
		} else if(this._state === BEFORE_STYLE_3){
			this._stateBeforeStyle3(c);
		} else if(this._state === BEFORE_STYLE_4){
			this._stateBeforeStyle4(c);
		}

		else if(this._state === AFTER_STYLE_1){
			this._stateAfterStyle1(c);
		} else if(this._state === AFTER_STYLE_2){
			this._stateAfterStyle2(c);
		} else if(this._state === AFTER_STYLE_3){
			this._stateAfterStyle3(c);
		} else if(this._state === AFTER_STYLE_4){
			this._stateAfterStyle4(c);
		}

		/*
		* entities
		*/
		else if(this._state === BEFORE_ENTITY){
			this._stateBeforeEntity(c);
		} else if(this._state === BEFORE_NUMERIC_ENTITY){
			this._stateBeforeNumericEntity(c);
		} else if(this._state === IN_NAMED_ENTITY){
			this._stateInNamedEntity(c);
		} else if(this._state === IN_NUMERIC_ENTITY){
			this._stateInNumericEntity(c);
		} else if(this._state === IN_HEX_ENTITY){
			this._stateInHexEntity(c);
		}

		else {
			this._cbs.onerror(Error("unknown _state"), this._state);
		}

		this._index++;
	}

	this._cleanup();
};

Tokenizer.prototype.pause = function(){
	this._running = false;
};
Tokenizer.prototype.resume = function(){
	this._running = true;

	if(this._index < this._buffer.length){
		this._parse();
	}
	if(this._ended){
		this._finish();
	}
};

Tokenizer.prototype.end = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".end() after done!"));
	if(chunk) this.write(chunk);

	this._ended = true;

	if(this._running) this._finish();
};

Tokenizer.prototype._finish = function(){
	//if there is remaining data, emit it in a reasonable way
	if(this._sectionStart < this._index){
		this._handleTrailingData();
	}

	this._cbs.onend();
};

Tokenizer.prototype._handleTrailingData = function(){
	var data = this._buffer.substr(this._sectionStart);

	if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
		this._cbs.oncdata(data);
	} else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
		this._cbs.oncomment(data);
	} else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
		this._parseLegacyEntity();
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(2, 10);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(3, 16);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(
		this._state !== IN_TAG_NAME &&
		this._state !== BEFORE_ATTRIBUTE_NAME &&
		this._state !== BEFORE_ATTRIBUTE_VALUE &&
		this._state !== AFTER_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_VALUE_SQ &&
		this._state !== IN_ATTRIBUTE_VALUE_DQ &&
		this._state !== IN_ATTRIBUTE_VALUE_NQ &&
		this._state !== IN_CLOSING_TAG_NAME
	){
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

Tokenizer.prototype.reset = function(){
	Tokenizer.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
};

Tokenizer.prototype.getAbsoluteIndex = function(){
	return this._bufferOffset + this._index;
};

Tokenizer.prototype._getSection = function(){
	return this._buffer.substring(this._sectionStart, this._index);
};

Tokenizer.prototype._emitToken = function(name){
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

Tokenizer.prototype._emitPartial = function(value){
	if(this._baseState !== TEXT){
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var decodeMap = __webpack_require__(184);

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap){
		codePoint = decodeMap[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}


/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = {"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}

/***/ }),
/* 185 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\"","QUOT":"\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}

/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"","aacute":"","Acirc":"","acirc":"","acute":"","AElig":"","aelig":"","Agrave":"","agrave":"","amp":"&","AMP":"&","Aring":"","aring":"","Atilde":"","atilde":"","Auml":"","auml":"","brvbar":"","Ccedil":"","ccedil":"","cedil":"","cent":"","copy":"","COPY":"","curren":"","deg":"","divide":"","Eacute":"","eacute":"","Ecirc":"","ecirc":"","Egrave":"","egrave":"","ETH":"","eth":"","Euml":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","GT":">","Iacute":"","iacute":"","Icirc":"","icirc":"","iexcl":"","Igrave":"","igrave":"","iquest":"","Iuml":"","iuml":"","laquo":"","lt":"<","LT":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","Ntilde":"","ntilde":"","Oacute":"","oacute":"","Ocirc":"","ocirc":"","Ograve":"","ograve":"","ordf":"","ordm":"","Oslash":"","oslash":"","Otilde":"","otilde":"","Ouml":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\"","QUOT":"\"","raquo":"","reg":"","REG":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","THORN":"","thorn":"","times":"","Uacute":"","uacute":"","Ucirc":"","ucirc":"","Ugrave":"","ugrave":"","uml":"","Uuml":"","uuml":"","Yacute":"","yacute":"","yen":"","yuml":""}

/***/ }),
/* 187 */
/***/ (function(module, exports) {

module.exports = {"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__(70);
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  module.exports = __webpack_require__(189);
}


/***/ }),
/* 189 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 191 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var pkg = __webpack_require__(193)
var api = __webpack_require__(23)

var parser = __webpack_require__(194)
var render = __webpack_require__(71)

/**
 * @author Ivan Voischev (@voischev),
 *         Anton Winogradov (@awinogradov),
 *         Alexej Yaroshevich (@zxqfox),
 *         Vasiliy (@Yeti-or)
 *
 * @requires api
 * @requires posthtml-parser
 * @requires posthtml-render
 *
 * @constructor PostHTML
 * @param {Array} plugins - An array of PostHTML plugins
 */
function PostHTML (plugins) {
/**
 * PostHTML Instance
 *
 * @prop plugins
 * @prop options
 */
  this.version = pkg.version
  this.name = pkg.name
  this.plugins = typeof plugins === 'function' ? [plugins] : plugins || []
}

/**
 * @requires posthtml-parser
 *
 * @param   {String} html - Input (HTML)
 * @returns {Array}  tree - PostHTMLTree (JSON)
 */
PostHTML.parser = parser
/**
 * @requires posthtml-render
 *
 * @param   {Array}  tree - PostHTMLTree (JSON)
 * @returns {String} html - HTML
 */
PostHTML.render = render

/**
* @this posthtml
* @param   {Function} plugin - A PostHTML plugin
* @returns {Constructor} - this(PostHTML)
*
* **Usage**
* ```js
* ph.use((tree) => { tag: 'div', content: tree })
*   .process('<html>..</html>', {})
*   .then((result) => result))
* ```
*/
PostHTML.prototype.use = function () {
  [].push.apply(this.plugins, arguments)
  return this
}

/**
 * @param   {String} html - Input (HTML)
 * @param   {?Object} options - PostHTML Options
 * @returns {Object<{html: String, tree: PostHTMLTree}>} - Sync Mode
 * @returns {Promise<{html: String, tree: PostHTMLTree}>} - Async Mode (default)
 *
 * **Usage**
 *
 * **Sync**
 * ```js
 * ph.process('<html>..</html>', { sync: true }).html
 * ```
 *
 * **Async**
 * ```js
 * ph.process('<html>..</html>', {}).then((result) => result))
 * ```
 */
PostHTML.prototype.process = function (tree, options) {
  /**
   * ## PostHTML Options
   *
   * @type {Object}
   * @prop {?Boolean} options.sync - enables sync mode, plugins will run synchronously, throws an error when used with async plugins
   * @prop {?Function} options.parser - use custom parser, replaces default (posthtml-parser)
   * @prop {?Function} options.render - use custom render, replaces default (posthtml-render)
   * @prop {?Boolean} options.skipParse - disable parsing
   */
  options = options || {}

  if (options.parser) parser = options.parser
  if (options.render) render = options.render

  tree = options.skipParse
    ? tree || []
    : parser(tree, options)

  tree.options = options
  tree.processor = this

  // sync mode
  if (options.sync === true) {
    this.plugins.forEach(function (plugin) {
      api(tree)

      var result

      if (plugin.length === 2 || isPromise(result = plugin(tree))) {
        throw new Error(
          'Cant process contents in sync mode because of async plugin: ' + plugin.name
        )
      }
      // return the previous tree unless result is fulfilled
      tree = result || tree
    })

    return lazyResult(render, tree)
  }

  // async mode
  var i = 0

  var next = function (result, cb) {
    // all plugins called
    if (this.plugins.length <= i) {
      cb(null, result)
      return
    }

    // little helper to go to the next iteration
    function _next (res) {
      return next(res || result, cb)
    }

    // (re)extend the object
    api(result)

    // call next
    var plugin = this.plugins[i++]

    if (plugin.length === 2) {
      plugin(result, function (err, res) {
        if (err) return cb(err)
        _next(res)
      })
      return
    }

    // sync and promised plugins
    var err = null

    var res = tryCatch(function () {
      return plugin(result)
    }, function (e) {
      err = e
      return e
    })

    if (err) {
      cb(err)
      return
    }

    if (isPromise(res)) {
      res.then(_next).catch(cb)
      return
    }

    _next(res)
  }.bind(this)

  return new Promise(function (resolve, reject) {
    next(tree, function (err, tree) {
      if (err) reject(err)
      else resolve(lazyResult(render, tree))
    })
  })
}

/**
 * @exports posthtml
 *
 * @param  {Array} plugins
 * @return {Function} posthtml
 *
 * **Usage**
 * ```js
 * import posthtml from 'posthtml'
 * import plugin from 'posthtml-plugin'
 *
 * const ph = posthtml([ plugin() ])
 * ```
 */
module.exports = function (plugins) {
  return new PostHTML(plugins)
}

/**
 * Checks if parameter is a Promise (or thenable) object.
 *
 * @private
 *
 * @param   {*} promise - Target `{}` to test
 * @returns {Boolean}
 */
function isPromise (promise) {
  return !!promise && typeof promise.then === 'function'
}

/**
 * Simple try/catch helper, if exists, returns result
 *
 * @private
 *
 * @param   {Function} tryFn - try block
 * @param   {Function} catchFn - catch block
 * @returns {?*}
 */
function tryCatch (tryFn, catchFn) {
  try {
    return tryFn()
  } catch (err) {
    catchFn(err)
  }
}

 /**
 * Wraps the PostHTMLTree within an object using a getter to render HTML on demand.
 *
 * @private
 *
 * @param   {Function} render
 * @param   {Array}    tree
 * @returns {Object<{html: String, tree: Array}>}
 */
function lazyResult (render, tree) {
  return {
    get html () {
      return render(tree, tree.options)
    },
    tree: tree,
    messages: tree.messages
  }
}


/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = {"name":"posthtml","version":"0.11.2","description":"HTML/XML processor","keywords":["html","xml","postproccessor","parser","transform","transformations","manipulation","preprocessor","processor"],"main":"lib","files":["lib"],"engines":{"node":">=0.10.0"},"dependencies":{"posthtml-parser":"^0.3.3","posthtml-render":"^1.1.0"},"devDependencies":{"chai":"^3.0.0","chai-as-promised":"^6.0.0","chai-subset":"^1.1.0","es6-promise":"^4.0.5","istanbul":"^0.4.2","jsdoc-to-markdown":"^3.0.0","mocha":"^3.4.0","mversion":"^1.10.0","object.assign":"^4.0.3","standard":"^10.0.2","standard-version":"^4.2.0"},"scripts":{"lint":"standard","test":"npm run lint && mocha -R dot && npm run cover","clean":"rm -rf coverage jsdoc-api","cover":"istanbul cover --report text --report html --report lcov node_modules/mocha/bin/_mocha -- -R tap","docs:api":"jsdoc2md lib/api.js > docs/api.md","docs:core":"jsdoc2md lib/index.js > docs/core.md","release":"standard-version"},"author":"Anton Winogradov <winogradovaa@gmail.com>","contributors":[{"name":"Ivan Voischev","email":"voischev.ivan@ya.ru"},{"name":"Anton Winogradov","email":"winogradovaa@gmail.com"},{"name":"Alexej Yaroshevich","email":"zxqfox@gmail.com"}],"homepage":"https://github.com/posthtml/posthtml","repository":"https://github.com/posthtml/posthtml.git","bugs":"https://github.com/posthtml/posthtml/issues","license":"MIT","_from":"posthtml@0.11.2","_resolved":"http://registry.npm.taobao.org/posthtml/download/posthtml-0.11.2.tgz"}

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Parser = __webpack_require__(117);
var isObject = __webpack_require__(118);
var objectAssign = __webpack_require__(119);

/**
 * @see https://github.com/fb55/htmlparser2/wiki/Parser-options
 */
var defaultOptions = {lowerCaseTags: false, lowerCaseAttributeNames: false};

var defaultDirectives = [{name: '!doctype', start: '<', end: '>'}];

/**
 * Parse html to PostHTMLTree
 * @param  {String} html
 * @param  {Object} [options=defaultOptions]
 * @return {PostHTMLTree}
 */
function postHTMLParser(html, options) {
    var bufArray = [],
        results = [];

    bufArray.last = function() {
        return this[this.length - 1];
    };

    function parserDirective(name, data) {
        var directives = [].concat(defaultDirectives, options.directives || []);
        var last = bufArray.last();

        for (var i = 0; i < directives.length; i++) {
            var directive = directives[i];
            var directiveText = directive.start + data + directive.end;

            if (name.toLowerCase() === directive.name) {
                if (!last) {
                    results.push(directiveText);
                    return;
                }

                last.content || (last.content = []);
                last.content.push(directiveText);
            }
        }
    }

    function normalizeArributes(attrs) {
        var result = {};
        Object.keys(attrs).forEach(function(key) {
            var obj = {};
                obj[key] = attrs[key].replace(/&quot;/g, '"');
            objectAssign(result, obj);
        });

        return result;
    }

    var parser = new Parser({
        onprocessinginstruction: parserDirective,
        oncomment: function(data) {
            var comment = '<!--' + data + '-->',
                last = bufArray.last();

            if (!last) {
                results.push(comment);
                return;
            }

            last.content || (last.content = []);
            last.content.push(comment);
        },
        onopentag: function(tag, attrs) {
            var buf = { tag: tag };

            if (Object.keys(attrs).length) {
                buf.attrs = normalizeArributes(attrs);
            }

            bufArray.push(buf);
        },
        onclosetag: function() {
            var buf = bufArray.pop();

            if (!bufArray.length) {
                results.push(buf);
                return;
            }

            var last = bufArray.last();
            if (!Array.isArray(last.content)) {
                last.content = [];
            }

            last.content.push(buf);
        },
        ontext: function(text) {
            var last = bufArray.last();
            if (!last) {
                results.push(text);
                return;
            }

            last.content || (last.content = []);
            last.content.push(text);
        }
    }, options || defaultOptions);

    parser.write(html);
    parser.end();

    return results;
}

function parserWrapper() {
    var option;

    function parser(html) {
        var opt = objectAssign(defaultOptions, option);
        return postHTMLParser(html, opt);
    }

    if (arguments.length === 1 && isObject(arguments[0])) {
        option = arguments[0];
        return parser;
    }

    option = arguments[1];
    return parser(arguments[0]);
}

module.exports = parserWrapper;
module.exports.defaultOptions = defaultOptions;
module.exports.defaultDirectives = defaultDirectives;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const Page_1 = __webpack_require__(46);
const encrypt_1 = __webpack_require__(68);
const astQuery_1 = __webpack_require__(196);
const parser = __webpack_require__(69);
const render = __webpack_require__(71);
const path = __webpack_require__(45);
let walk = __webpack_require__(23).walk;
let match = __webpack_require__(23).match;
const conf_1 = __webpack_require__(44);
console.log(conf_1.config);
//import {read,writeFile} from "../common/Tools";
class HtmlPage extends Page_1.Page {
    constructor(from, to, JsOutPath) {
        super(from, to);
        this.fromDir = path.dirname(from);
        this.JsOutPath = JsOutPath;
    }
    read(IN) {
        let text = super.read(IN);
        if (IN.endsWith("config.js")) {
            let tree = astQuery_1.program(text);
            for (let k of Object.keys(conf_1.config)) {
                let v = conf_1.config[k];
                tree.setVariable(k, v);
            }
            text = tree.generator();
            //tree.setVariable()
        }
        return text;
    }
    parseHtml() {
        this.content = this.read(this.from);
        let ast = parser(this.content);
        ast = this.parseHtmlScript(ast);
        this.content = render(ast);
    }
    parseHtmlScript(ast) {
        //let ast =  parser(this.content);
        let links = [];
        let ast1 = match.call(ast, [{ tag: 'script' }], node => {
            let root = this.fromDir;
            if (node && node.tag == "script" && node.attrs && node.attrs.src) {
                let p = path.resolve(root, node.attrs.src);
                links.push(p);
            }
            return {
                tag: false,
                content: ""
            };
        });
        this.scripts = links;
        let tt1 = match.call(ast1, [{ tag: 'head' }], node => {
            let script_path = path.relative(path.dirname(this.to), this.JsOutPath);
            var script_node = { tag: 'script', attrs: { src: script_path } };
            if (node && node.tag == "head") {
                node.content.push(script_node);
            }
            return node;
        });
        return tt1;
    }
    mergeScript() {
        let text = "";
        this.scripts.forEach(link => {
            text += ";" + this.read(link);
        });
        return text;
    }
    operate() {
        this.parseHtml();
        this.writeFile(this.content, this.to);
        let txt = this.mergeScript();
        let p = encrypt_1.encryptCode(txt);
        p.then(data => {
            this.writeFile(data, this.JsOutPath);
        }).catch(e => {
            console.log("----->", e);
        });
    }
}
exports.HtmlPage = HtmlPage;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const babylon = __webpack_require__(120);
const babel_traverse_1 = __webpack_require__(30);
const babel_generator_1 = __webpack_require__(386);
var types = __webpack_require__(0);
function program(js) {
    return new jsParser(js);
}
exports.program = program;
class jsParser {
    constructor(code) {
        this.Kmap = new Object();
        this.program(code);
    }
    program(code) {
        this.ast = babylon.parse(code);
    }
    setVariable(k, v) {
        this.Kmap[k] = v;
    }
    traverse() {
        let self = this;
        babel_traverse_1.default(this.ast, {
            enter(path) {
                let node = path.node;
                if (path.parentPath) {
                    let parentNode = path.parentPath.node;
                    let id = parentNode.id;
                    let init = parentNode.init;
                    if (path.parentPath.isVariableDeclarator({ init: node }) && path.isLiteral() && parentNode && types.isIdentifier(id) && self.Kmap[id.name]) {
                        let v = self.Kmap[id.name];
                        node.value = v;
                    }
                }
            }
        });
    }
    generator() {
        this.traverse();
        return babel_generator_1.default(this.ast).code;
    }
}
// let code1 = generator(ast);
// console.log(code1);

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31);
__webpack_require__(84);
module.exports = __webpack_require__(207);


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(199);
var step = __webpack_require__(121);
var Iterators = __webpack_require__(32);
var toIObject = __webpack_require__(27);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(75)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 199 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(48);
var descriptor = __webpack_require__(47);
var setToStringTag = __webpack_require__(50);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(14)(IteratorPrototype, __webpack_require__(6)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(11);
var anObject = __webpack_require__(12);
var getKeys = __webpack_require__(33);

module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(27);
var toLength = __webpack_require__(79);
var toAbsoluteIndex = __webpack_require__(203);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(80);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(8).document;
module.exports = document && document.documentElement;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(16);
var toObject = __webpack_require__(51);
var IE_PROTO = __webpack_require__(81)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(80);
var defined = __webpack_require__(74);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(12);
var get = __webpack_require__(126);
module.exports = __webpack_require__(2).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(209), __esModule: true };

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(85);
module.exports = __webpack_require__(2).Object.getOwnPropertySymbols;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(33);
var gOPS = __webpack_require__(88);
var pIE = __webpack_require__(52);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(27);
var gOPN = __webpack_require__(130).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(213);
module.exports = __webpack_require__(2).Object.keys;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(51);
var $keys = __webpack_require__(33);

__webpack_require__(214)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(4);
var core = __webpack_require__(2);
var fails = __webpack_require__(15);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(2);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(217), __esModule: true };

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(85);
module.exports = __webpack_require__(2).Symbol['for'];


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(219);
var $Object = __webpack_require__(2).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(4);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(48) });


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _keys = __webpack_require__(29);

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __webpack_require__(17);

var _typeof3 = _interopRequireDefault(_typeof2);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.isBinding = isBinding;
exports.isReferenced = isReferenced;
exports.isValidIdentifier = isValidIdentifier;
exports.isLet = isLet;
exports.isBlockScoped = isBlockScoped;
exports.isVar = isVar;
exports.isSpecifierDefault = isSpecifierDefault;
exports.isScope = isScope;
exports.isImmutable = isImmutable;
exports.isNodesEquivalent = isNodesEquivalent;

var _retrievers = __webpack_require__(132);

var _esutils = __webpack_require__(133);

var _esutils2 = _interopRequireDefault(_esutils);

var _index = __webpack_require__(0);

var t = _interopRequireWildcard(_index);

var _constants = __webpack_require__(89);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBinding(node, parent) {
  var keys = _retrievers.getBindingIdentifiers.keys[parent.type];
  if (keys) {
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = parent[key];
      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }

  return false;
}

function isReferenced(node, parent) {
  switch (parent.type) {
    case "BindExpression":
      return parent.object === node || parent.callee === node;

    case "MemberExpression":
    case "JSXMemberExpression":
      if (parent.property === node && parent.computed) {
        return true;
      } else if (parent.object === node) {
        return true;
      } else {
        return false;
      }

    case "MetaProperty":
      return false;

    case "ObjectProperty":
      if (parent.key === node) {
        return parent.computed;
      }

    case "VariableDeclarator":
      return parent.id !== node;

    case "ArrowFunctionExpression":
    case "FunctionDeclaration":
    case "FunctionExpression":
      for (var _iterator = parent.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var param = _ref;

        if (param === node) return false;
      }

      return parent.id !== node;

    case "ExportSpecifier":
      if (parent.source) {
        return false;
      } else {
        return parent.local === node;
      }

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;

    case "JSXAttribute":
      return parent.name !== node;

    case "ClassProperty":
      if (parent.key === node) {
        return parent.computed;
      } else {
        return parent.value === node;
      }

    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;

    case "ClassDeclaration":
    case "ClassExpression":
      return parent.id !== node;

    case "ClassMethod":
    case "ObjectMethod":
      return parent.key === node && parent.computed;

    case "LabeledStatement":
      return false;

    case "CatchClause":
      return parent.param !== node;

    case "RestElement":
      return false;

    case "AssignmentExpression":
      return parent.right === node;

    case "AssignmentPattern":
      return parent.right === node;

    case "ObjectPattern":
    case "ArrayPattern":
      return false;
  }

  return true;
}

function isValidIdentifier(name) {
  if (typeof name !== "string" || _esutils2.default.keyword.isReservedWordES6(name, true)) {
    return false;
  } else if (name === "await") {
    return false;
  } else {
    return _esutils2.default.keyword.isIdentifierNameES6(name);
  }
}

function isLet(node) {
  return t.isVariableDeclaration(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

function isBlockScoped(node) {
  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);
}

function isVar(node) {
  return t.isVariableDeclaration(node, { kind: "var" }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

function isSpecifierDefault(specifier) {
  return t.isImportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, { name: "default" });
}

function isScope(node, parent) {
  if (t.isBlockStatement(node) && t.isFunction(parent, { body: node })) {
    return false;
  }

  return t.isScopable(node);
}

function isImmutable(node) {
  if (t.isType(node.type, "Immutable")) return true;

  if (t.isIdentifier(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }

  return false;
}

function isNodesEquivalent(a, b) {
  if ((typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) !== "object" || (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) !== "object" || a == null || b == null) {
    return a === b;
  }

  if (a.type !== b.type) {
    return false;
  }

  var fields = (0, _keys2.default)(t.NODE_FIELDS[a.type] || a.type);

  for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var field = _ref2;

    if ((0, _typeof3.default)(a[field]) !== (0, _typeof3.default)(b[field])) {
      return false;
    }

    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false;
      }
      if (a[field].length !== b[field].length) {
        return false;
      }

      for (var i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false;
        }
      }
      continue;
    }

    if (!isNodesEquivalent(a[field], b[field])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(222), __esModule: true };

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(84);
__webpack_require__(31);
module.exports = __webpack_require__(86).f('iterator');


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(224), __esModule: true };

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(85);
__webpack_require__(54);
__webpack_require__(225);
__webpack_require__(226);
module.exports = __webpack_require__(2).Symbol;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(87)('asyncIterator');


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(87)('observable');


/***/ }),
/* 227 */
/***/ (function(module, exports) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = __webpack_require__(134);

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _maxSafeInteger = __webpack_require__(230);

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

var _stringify = __webpack_require__(35);

var _stringify2 = _interopRequireDefault(_stringify);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.toComputedKey = toComputedKey;
exports.toSequenceExpression = toSequenceExpression;
exports.toKeyAlias = toKeyAlias;
exports.toIdentifier = toIdentifier;
exports.toBindingIdentifierName = toBindingIdentifierName;
exports.toStatement = toStatement;
exports.toExpression = toExpression;
exports.toBlock = toBlock;
exports.valueToNode = valueToNode;

var _isPlainObject = __webpack_require__(233);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _isRegExp = __webpack_require__(236);

var _isRegExp2 = _interopRequireDefault(_isRegExp);

var _index = __webpack_require__(0);

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toComputedKey(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;

  if (!node.computed) {
    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);
  }
  return key;
}

function gatherSequenceExpressions(nodes, scope, declars) {
  var exprs = [];
  var ensureLastUndefined = true;

  for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var node = _ref;

    ensureLastUndefined = false;

    if (t.isExpression(node)) {
      exprs.push(node);
    } else if (t.isExpressionStatement(node)) {
      exprs.push(node.expression);
    } else if (t.isVariableDeclaration(node)) {
      if (node.kind !== "var") return;

      for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var declar = _ref2;

        var bindings = t.getBindingIdentifiers(declar);
        for (var key in bindings) {
          declars.push({
            kind: node.kind,
            id: bindings[key]
          });
        }

        if (declar.init) {
          exprs.push(t.assignmentExpression("=", declar.id, declar.init));
        }
      }

      ensureLastUndefined = true;
    } else if (t.isIfStatement(node)) {
      var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
      var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
      if (!consequent || !alternate) return;

      exprs.push(t.conditionalExpression(node.test, consequent, alternate));
    } else if (t.isBlockStatement(node)) {
      var body = gatherSequenceExpressions(node.body, scope, declars);
      if (!body) return;

      exprs.push(body);
    } else if (t.isEmptyStatement(node)) {
      ensureLastUndefined = true;
    } else {
      return;
    }
  }

  if (ensureLastUndefined) {
    exprs.push(scope.buildUndefinedNode());
  }

  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return t.sequenceExpression(exprs);
  }
}

function toSequenceExpression(nodes, scope) {
  if (!nodes || !nodes.length) return;

  var declars = [];
  var result = gatherSequenceExpressions(nodes, scope, declars);
  if (!result) return;

  for (var _iterator3 = declars, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
    var _ref3;

    if (_isArray3) {
      if (_i3 >= _iterator3.length) break;
      _ref3 = _iterator3[_i3++];
    } else {
      _i3 = _iterator3.next();
      if (_i3.done) break;
      _ref3 = _i3.value;
    }

    var declar = _ref3;

    scope.push(declar);
  }

  return result;
}

function toKeyAlias(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;

  var alias = void 0;

  if (node.kind === "method") {
    return toKeyAlias.increment() + "";
  } else if (t.isIdentifier(key)) {
    alias = key.name;
  } else if (t.isStringLiteral(key)) {
    alias = (0, _stringify2.default)(key.value);
  } else {
    alias = (0, _stringify2.default)(t.removePropertiesDeep(t.cloneDeep(key)));
  }

  if (node.computed) {
    alias = "[" + alias + "]";
  }

  if (node.static) {
    alias = "static:" + alias;
  }

  return alias;
}

toKeyAlias.uid = 0;

toKeyAlias.increment = function () {
  if (toKeyAlias.uid >= _maxSafeInteger2.default) {
    return toKeyAlias.uid = 0;
  } else {
    return toKeyAlias.uid++;
  }
};

function toIdentifier(name) {
  name = name + "";

  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");

  name = name.replace(/^[-0-9]+/, "");

  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!t.isValidIdentifier(name)) {
    name = "_" + name;
  }

  return name || "_";
}

function toBindingIdentifierName(name) {
  name = toIdentifier(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}

function toStatement(node, ignore) {
  if (t.isStatement(node)) {
    return node;
  }

  var mustHaveId = false;
  var newType = void 0;

  if (t.isClass(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if (t.isFunction(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if (t.isAssignmentExpression(node)) {
    return t.expressionStatement(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error("cannot turn " + node.type + " to a statement");
    }
  }

  node.type = newType;

  return node;
}

function toExpression(node) {
  if (t.isExpressionStatement(node)) {
    node = node.expression;
  }

  if (t.isExpression(node)) {
    return node;
  }

  if (t.isClass(node)) {
    node.type = "ClassExpression";
  } else if (t.isFunction(node)) {
    node.type = "FunctionExpression";
  }

  if (!t.isExpression(node)) {
    throw new Error("cannot turn " + node.type + " to an expression");
  }

  return node;
}

function toBlock(node, parent) {
  if (t.isBlockStatement(node)) {
    return node;
  }

  if (t.isEmptyStatement(node)) {
    node = [];
  }

  if (!Array.isArray(node)) {
    if (!t.isStatement(node)) {
      if (t.isFunction(parent)) {
        node = t.returnStatement(node);
      } else {
        node = t.expressionStatement(node);
      }
    }

    node = [node];
  }

  return t.blockStatement(node);
}

function valueToNode(value) {
  if (value === undefined) {
    return t.identifier("undefined");
  }

  if (value === true || value === false) {
    return t.booleanLiteral(value);
  }

  if (value === null) {
    return t.nullLiteral();
  }

  if (typeof value === "string") {
    return t.stringLiteral(value);
  }

  if (typeof value === "number") {
    return t.numericLiteral(value);
  }

  if ((0, _isRegExp2.default)(value)) {
    var pattern = value.source;
    var flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return t.regExpLiteral(pattern, flags);
  }

  if (Array.isArray(value)) {
    return t.arrayExpression(value.map(t.valueToNode));
  }

  if ((0, _isPlainObject2.default)(value)) {
    var props = [];
    for (var key in value) {
      var nodeKey = void 0;
      if (t.isValidIdentifier(key)) {
        nodeKey = t.identifier(key);
      } else {
        nodeKey = t.stringLiteral(key);
      }
      props.push(t.objectProperty(nodeKey, t.valueToNode(value[key])));
    }
    return t.objectExpression(props);
  }

  throw new Error("don't know how to turn this value into a node");
}

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(231), __esModule: true };

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(232);
module.exports = 0x1fffffffffffff;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(4);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(18),
    getPrototype = __webpack_require__(90),
    isObjectLike = __webpack_require__(10);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 235 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsRegExp = __webpack_require__(237),
    baseUnary = __webpack_require__(55),
    nodeUtil = __webpack_require__(56);

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

module.exports = isRegExp;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(18),
    isObjectLike = __webpack_require__(10);

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.createUnionTypeAnnotation = createUnionTypeAnnotation;
exports.removeTypeDuplicates = removeTypeDuplicates;
exports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;

var _index = __webpack_require__(0);

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function createUnionTypeAnnotation(types) {
  var flattened = removeTypeDuplicates(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return t.unionTypeAnnotation(flattened);
  }
}

function removeTypeDuplicates(nodes) {
  var generics = {};
  var bases = {};

  var typeGroups = [];

  var types = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if (t.isAnyTypeAnnotation(node)) {
      return [node];
    }

    if (t.isFlowBaseAnnotation(node)) {
      bases[node.type] = node;
      continue;
    }

    if (t.isUnionTypeAnnotation(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }
      continue;
    }

    if (t.isGenericTypeAnnotation(node)) {
      var name = node.id.name;

      if (generics[name]) {
        var existing = generics[name];
        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }

      continue;
    }

    types.push(node);
  }

  for (var type in bases) {
    types.push(bases[type]);
  }

  for (var _name in generics) {
    types.push(generics[_name]);
  }

  return types;
}

function createTypeAnnotationBasedOnTypeof(type) {
  if (type === "string") {
    return t.stringTypeAnnotation();
  } else if (type === "number") {
    return t.numberTypeAnnotation();
  } else if (type === "undefined") {
    return t.voidTypeAnnotation();
  } else if (type === "boolean") {
    return t.booleanTypeAnnotation();
  } else if (type === "function") {
    return t.genericTypeAnnotation(t.identifier("Function"));
  } else if (type === "object") {
    return t.genericTypeAnnotation(t.identifier("Object"));
  } else if (type === "symbol") {
    return t.genericTypeAnnotation(t.identifier("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function toFastproperties(o) {
	function Sub() {}
	Sub.prototype = o;
	var receiver = new Sub(); // create an instance
	function ic() { return typeof receiver.foo; } // perform access
	ic(); 
	ic();
	return o;
	eval("o" + o); // ensure no dead code elimination
}


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(91),
    arrayEach = __webpack_require__(267),
    assignValue = __webpack_require__(94),
    baseAssign = __webpack_require__(268),
    baseAssignIn = __webpack_require__(275),
    cloneBuffer = __webpack_require__(278),
    copyArray = __webpack_require__(279),
    copySymbols = __webpack_require__(280),
    copySymbolsIn = __webpack_require__(282),
    getAllKeys = __webpack_require__(148),
    getAllKeysIn = __webpack_require__(283),
    getTag = __webpack_require__(62),
    initCloneArray = __webpack_require__(287),
    initCloneByTag = __webpack_require__(288),
    initCloneObject = __webpack_require__(293),
    isArray = __webpack_require__(7),
    isBuffer = __webpack_require__(95),
    isMap = __webpack_require__(295),
    isObject = __webpack_require__(19),
    isSet = __webpack_require__(297),
    keys = __webpack_require__(20);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });

    return result;
  }

  if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });

    return result;
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 241 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(58);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(58);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(58);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(58);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(57);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 247 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 248 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 249 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(57),
    Map = __webpack_require__(92),
    MapCache = __webpack_require__(93);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(138),
    isMasked = __webpack_require__(252),
    isObject = __webpack_require__(19),
    toSource = __webpack_require__(139);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(253);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(9);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 254 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(256),
    ListCache = __webpack_require__(57),
    Map = __webpack_require__(92);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(257),
    hashDelete = __webpack_require__(258),
    hashGet = __webpack_require__(259),
    hashHas = __webpack_require__(260),
    hashSet = __webpack_require__(261);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(59);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 258 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(59);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(59);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(59);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(60);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 263 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(60);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(60);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(60);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 267 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(39),
    keys = __webpack_require__(20);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 269 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(18),
    isObjectLike = __webpack_require__(10);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 271 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(18),
    isLength = __webpack_require__(97),
    isObjectLike = __webpack_require__(10);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(61),
    nativeKeys = __webpack_require__(274);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(136);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(39),
    keysIn = __webpack_require__(98);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(19),
    isPrototype = __webpack_require__(61),
    nativeKeysIn = __webpack_require__(277);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 277 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(9);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)(module)))

/***/ }),
/* 279 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(39),
    getSymbols = __webpack_require__(99);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 281 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(39),
    getSymbolsIn = __webpack_require__(146);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(149),
    getSymbolsIn = __webpack_require__(146),
    keysIn = __webpack_require__(98);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(25),
    root = __webpack_require__(9);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(25),
    root = __webpack_require__(9);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(25),
    root = __webpack_require__(9);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 287 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(100),
    cloneDataView = __webpack_require__(289),
    cloneRegExp = __webpack_require__(290),
    cloneSymbol = __webpack_require__(291),
    cloneTypedArray = __webpack_require__(292);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(100);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 290 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(100);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(294),
    getPrototype = __webpack_require__(90),
    isPrototype = __webpack_require__(61);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(19);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(296),
    baseUnary = __webpack_require__(55),
    nodeUtil = __webpack_require__(56);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(62),
    isObjectLike = __webpack_require__(10);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(298),
    baseUnary = __webpack_require__(55),
    nodeUtil = __webpack_require__(56);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(62),
    isObjectLike = __webpack_require__(10);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

var baseUniq = __webpack_require__(300);

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? baseUniq(array) : [];
}

module.exports = uniq;


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(152),
    arrayIncludes = __webpack_require__(303),
    arrayIncludesWith = __webpack_require__(306),
    cacheHas = __webpack_require__(154),
    createSet = __webpack_require__(307),
    setToArray = __webpack_require__(102);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),
/* 301 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 302 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(153);

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),
/* 304 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),
/* 305 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),
/* 306 */
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(150),
    noop = __webpack_require__(308),
    setToArray = __webpack_require__(102);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),
/* 308 */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(22);

__webpack_require__(310);

__webpack_require__(311);

__webpack_require__(312);

__webpack_require__(313);

__webpack_require__(314);

__webpack_require__(315);

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _index = __webpack_require__(0);

var t = _interopRequireWildcard(_index);

var _constants = __webpack_require__(89);

var _index2 = __webpack_require__(22);

var _index3 = _interopRequireDefault(_index2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

(0, _index3.default)("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});

(0, _index3.default)("AssignmentExpression", {
  fields: {
    operator: {
      validate: (0, _index2.assertValueType)("string")
    },
    left: {
      validate: (0, _index2.assertNodeType)("LVal")
    },
    right: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});

(0, _index3.default)("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: _index2.assertOneOf.apply(undefined, _constants.BINARY_OPERATORS)
    },
    left: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});

(0, _index3.default)("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _index2.assertNodeType)("DirectiveLiteral")
    }
  }
});

(0, _index3.default)("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _index2.assertValueType)("string")
    }
  }
});

(0, _index3.default)("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});

(0, _index3.default)("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _index2.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});

(0, _index3.default)("CallExpression", {
  visitor: ["callee", "arguments"],
  fields: {
    callee: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression", "SpreadElement")))
    }
  },
  aliases: ["Expression"]
});

(0, _index3.default)("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _index2.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable"]
});

(0, _index3.default)("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});

(0, _index3.default)("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _index2.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});

(0, _index3.default)("DebuggerStatement", {
  aliases: ["Statement"]
});

(0, _index3.default)("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index2.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});

(0, _index3.default)("EmptyStatement", {
  aliases: ["Statement"]
});

(0, _index3.default)("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});

(0, _index3.default)("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _index2.assertNodeType)("Program")
    }
  }
});

(0, _index3.default)("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _index2.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index2.assertNodeType)("Statement")
    }
  }
});

(0, _index3.default)("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _index2.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _index2.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _index2.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _index2.assertNodeType)("Statement")
    }
  }
});

(0, _index3.default)("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: {
    id: {
      validate: (0, _index2.assertNodeType)("Identifier")
    },
    params: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    }
  },
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"]
});

(0, _index3.default)("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: {
    id: {
      validate: (0, _index2.assertNodeType)("Identifier"),
      optional: true
    },
    params: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    }
  }
});

(0, _index3.default)("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation"],
  aliases: ["Expression", "LVal"],
  fields: {
    name: {
      validate: function validate(node, key, val) {
        if (!t.isValidIdentifier(val)) {}
      }
    },
    decorators: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
    }
  }
});

(0, _index3.default)("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _index2.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _index2.assertNodeType)("Statement")
    }
  }
});

(0, _index3.default)("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _index2.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _index2.assertNodeType)("Statement")
    }
  }
});

(0, _index3.default)("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _index2.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _index3.default)("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _index2.assertValueType)("number")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _index3.default)("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _index3.default)("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _index2.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _index3.default)("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Literal"],
  fields: {
    pattern: {
      validate: (0, _index2.assertValueType)("string")
    },
    flags: {
      validate: (0, _index2.assertValueType)("string"),
      default: ""
    }
  }
});

(0, _index3.default)("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: _index2.assertOneOf.apply(undefined, _constants.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  }
});

(0, _index3.default)("MemberExpression", {
  builder: ["object", "property", "computed"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: {
    object: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    property: {
      validate: function validate(node, key, val) {
        var expectedType = node.computed ? "Expression" : "Identifier";
        (0, _index2.assertNodeType)(expectedType)(node, key, val);
      }
    },
    computed: {
      default: false
    }
  }
});

(0, _index3.default)("NewExpression", {
  visitor: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression", "SpreadElement")))
    }
  }
});

(0, _index3.default)("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives"],
  fields: {
    directives: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "FunctionParent"]
});

(0, _index3.default)("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadProperty")))
    }
  }
});

(0, _index3.default)("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed"],
  fields: {
    kind: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("string"), (0, _index2.assertOneOf)("method", "get", "set")),
      default: "method"
    },
    computed: {
      validate: (0, _index2.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    decorators: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    }
  },
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});

(0, _index3.default)("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", "decorators"],
  fields: {
    computed: {
      validate: (0, _index2.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    value: {
      validate: (0, _index2.assertNodeType)("Expression", "Pattern", "RestElement")
    },
    shorthand: {
      validate: (0, _index2.assertValueType)("boolean"),
      default: false
    },
    decorators: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator"))),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"]
});

(0, _index3.default)("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  aliases: ["LVal"],
  fields: {
    argument: {
      validate: (0, _index2.assertNodeType)("LVal")
    },
    decorators: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
    }
  }
});

(0, _index3.default)("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _index2.assertNodeType)("Expression"),
      optional: true
    }
  }
});

(0, _index3.default)("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
});

(0, _index3.default)("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression"),
      optional: true
    },
    consequent: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
    }
  }
});

(0, _index3.default)("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("SwitchCase")))
    }
  }
});

(0, _index3.default)("ThisExpression", {
  aliases: ["Expression"]
});

(0, _index3.default)("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  }
});

(0, _index3.default)("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    },
    handler: {
      optional: true,
      handler: (0, _index2.assertNodeType)("BlockStatement")
    },
    finalizer: {
      optional: true,
      validate: (0, _index2.assertNodeType)("BlockStatement")
    }
  }
});

(0, _index3.default)("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    operator: {
      validate: _index2.assertOneOf.apply(undefined, _constants.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});

(0, _index3.default)("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    operator: {
      validate: _index2.assertOneOf.apply(undefined, _constants.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
});

(0, _index3.default)("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    kind: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("string"), (0, _index2.assertOneOf)("var", "let", "const"))
    },
    declarations: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("VariableDeclarator")))
    }
  }
});

(0, _index3.default)("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: (0, _index2.assertNodeType)("LVal")
    },
    init: {
      optional: true,
      validate: (0, _index2.assertNodeType)("Expression")
    }
  }
});

(0, _index3.default)("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement", "Statement")
    }
  }
});

(0, _index3.default)("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      object: (0, _index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement", "Statement")
    }
  }
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _index = __webpack_require__(22);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("AssignmentPattern", {
  visitor: ["left", "right"],
  aliases: ["Pattern", "LVal"],
  fields: {
    left: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    right: {
      validate: (0, _index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  aliases: ["Pattern", "LVal"],
  fields: {
    elements: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: {
    params: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _index.assertNodeType)("BlockStatement", "Expression")
    },
    async: {
      validate: (0, _index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _index2.default)("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ClassMethod", "ClassProperty")))
    }
  }
});

(0, _index2.default)("ClassDeclaration", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
  fields: {
    id: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _index.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("ClassExpression", {
  inherits: "ClassDeclaration",
  aliases: ["Scopable", "Class", "Expression", "Pureish"],
  fields: {
    id: {
      optional: true,
      validate: (0, _index.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _index.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, _index.assertNodeType)("StringLiteral")
    }
  }
});

(0, _index2.default)("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _index.assertNodeType)("FunctionDeclaration", "ClassDeclaration", "Expression")
    }
  }
});

(0, _index2.default)("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _index.assertNodeType)("Declaration"),
      optional: true
    },
    specifiers: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ExportSpecifier")))
    },
    source: {
      validate: (0, _index.assertNodeType)("StringLiteral"),
      optional: true
    }
  }
});

(0, _index2.default)("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("ForOfStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _index.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _index.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index.assertNodeType)("Statement")
    }
  }
});

(0, _index2.default)("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _index.assertNodeType)("StringLiteral")
    }
  }
});

(0, _index2.default)("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    importKind: {
      validate: (0, _index.assertOneOf)(null, "type", "typeof")
    }
  }
});

(0, _index2.default)("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, _index.assertValueType)("string")
    },
    property: {
      validate: (0, _index.assertValueType)("string")
    }
  }
});

(0, _index2.default)("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: {
    kind: {
      validate: (0, _index.chain)((0, _index.assertValueType)("string"), (0, _index.assertOneOf)("get", "set", "method", "constructor")),
      default: "method"
    },
    computed: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    },
    static: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _index.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    params: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _index.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    }
  }
});

(0, _index2.default)("ObjectPattern", {
  visitor: ["properties", "typeAnnotation"],
  aliases: ["Pattern", "LVal"],
  fields: {
    properties: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("RestProperty", "Property")))
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("Super", {
  aliases: ["Expression"]
});

(0, _index2.default)("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _index.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _index.assertNodeType)("TemplateLiteral")
    }
  }
});

(0, _index2.default)("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {},
    tail: {
      validate: (0, _index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _index2.default)("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Expression")))
    }
  }
});

(0, _index2.default)("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, _index.assertValueType)("boolean"),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _index = __webpack_require__(22);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("BooleanLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed"],
  aliases: ["Property"],
  fields: {
    computed: {
      validate: (0, _index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _index2.default)("DeclareClass", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareInterface", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareModule", {
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareOpaqueType", {
  visitor: ["id", "typeParameters", "supertype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareExportDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("ExistentialTypeParam", {
  aliases: ["Flow"]
});

(0, _index2.default)("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("InterfaceDeclaration", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"]
});

(0, _index2.default)("EmptyTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"]
});

(0, _index2.default)("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("NumericLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("StringLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("StringTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("OpaqueType", {
  visitor: ["id", "typeParameters", "impltype", "supertype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("TypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {}
});

(0, _index2.default)("TypeParameter", {
  visitor: ["bound"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeParameterDeclaration", {
  visitor: ["params"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeParameterInstantiation", {
  visitor: ["params"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _index2.default)("ObjectTypeIndexer", {
  visitor: ["id", "key", "value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _index2.default)("ObjectTypeProperty", {
  visitor: ["key", "value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _index2.default)("ObjectTypeSpreadProperty", {
  visitor: ["argument"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _index2.default)("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _index = __webpack_require__(22);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: true,
      validate: (0, _index.assertNodeType)("JSXElement", "StringLiteral", "JSXExpressionContainer")
    }
  }
});

(0, _index2.default)("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
    }
  }
});

(0, _index2.default)("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: (0, _index.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: true,
      validate: (0, _index.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement")))
    }
  }
});

(0, _index2.default)("JSXEmptyExpression", {
  aliases: ["JSX", "Expression"]
});

(0, _index2.default)("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX", "Expression"],
  fields: {
    name: {
      validate: (0, _index.assertValueType)("string")
    }
  }
});

(0, _index2.default)("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX", "Expression"],
  fields: {
    object: {
      validate: (0, _index.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, _index.assertNodeType)("JSXIdentifier")
    }
  }
});

(0, _index2.default)("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: (0, _index.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, _index.assertNodeType)("JSXIdentifier")
    }
  }
});

(0, _index2.default)("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
    },
    selfClosing: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    },
    attributes: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    }
  }
});

(0, _index2.default)("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _index.assertValueType)("string")
    }
  }
});

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _index = __webpack_require__(22);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("Noop", {
  visitor: []
});

(0, _index2.default)("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _index = __webpack_require__(22);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("ForAwaitStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _index.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _index.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index.assertNodeType)("Statement")
    }
  }
});

(0, _index2.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: {}
});

(0, _index2.default)("Import", {
  aliases: ["Expression"]
});

(0, _index2.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, _index.assertNodeType)("BlockStatement")
    }
  }
});

(0, _index2.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("RestProperty", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("LVal")
    }
  }
});

(0, _index2.default)("SpreadProperty", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isReactComponent = undefined;
exports.isCompatTag = isCompatTag;
exports.buildChildren = buildChildren;

var _index = __webpack_require__(0);

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var isReactComponent = exports.isReactComponent = t.buildMatchMemberExpression("React.Component");

function isCompatTag(tagName) {
  return !!tagName && /^[a-z]|\-/.test(tagName);
}

function cleanJSXElementLiteralChild(child, args) {
  var lines = child.value.split(/\r\n|\n|\r/);

  var lastNonEmptyLine = 0;

  for (var i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  var str = "";

  for (var _i = 0; _i < lines.length; _i++) {
    var line = lines[_i];

    var isFirstLine = _i === 0;
    var isLastLine = _i === lines.length - 1;
    var isLastNonEmptyLine = _i === lastNonEmptyLine;

    var trimmedLine = line.replace(/\t/g, " ");

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }

    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) args.push(t.stringLiteral(str));
}

function buildChildren(node) {
  var elems = [];

  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];

    if (t.isJSXText(child)) {
      cleanJSXElementLiteralChild(child, elems);
      continue;
    }

    if (t.isJSXExpressionContainer(child)) child = child.expression;
    if (t.isJSXEmptyExpression(child)) continue;

    elems.push(child);
  }

  return elems;
}

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(318);
} else {
  module.exports = __webpack_require__(320);
}


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(155);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 319 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(321);
var util = __webpack_require__(70);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(155);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(26);
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(322);
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),
/* 321 */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),
/* 322 */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var NODE_ENV = process.env.NODE_ENV;

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(94),
    copyObject = __webpack_require__(39),
    createAssigner = __webpack_require__(325),
    isArrayLike = __webpack_require__(21),
    isPrototype = __webpack_require__(61),
    keys = __webpack_require__(20);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(156),
    isIterateeCall = __webpack_require__(104);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(327);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 327 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(329),
    shortOut = __webpack_require__(331);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(330),
    defineProperty = __webpack_require__(141),
    identity = __webpack_require__(103);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 330 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 331 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54);
__webpack_require__(84);
__webpack_require__(31);
__webpack_require__(333);
__webpack_require__(340);
__webpack_require__(343);
__webpack_require__(344);
module.exports = __webpack_require__(2).Map;


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(334);
var validate = __webpack_require__(41);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(108)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(11).f;
var create = __webpack_require__(48);
var redefineAll = __webpack_require__(106);
var ctx = __webpack_require__(28);
var anInstance = __webpack_require__(107);
var forOf = __webpack_require__(40);
var $iterDefine = __webpack_require__(75);
var step = __webpack_require__(121);
var setSpecies = __webpack_require__(337);
var DESCRIPTORS = __webpack_require__(13);
var fastKey = __webpack_require__(34).fastKey;
var validate = __webpack_require__(41);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(12);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(32);
var ITERATOR = __webpack_require__(6)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(8);
var core = __webpack_require__(2);
var dP = __webpack_require__(11);
var DESCRIPTORS = __webpack_require__(13);
var SPECIES = __webpack_require__(6)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(339);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
var isArray = __webpack_require__(129);
var SPECIES = __webpack_require__(6)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(4);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(341)('Map') });


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(127);
var from = __webpack_require__(342);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(40);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(110)('Map');


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(111)('Map');


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(18),
    isArray = __webpack_require__(7),
    isObjectLike = __webpack_require__(10);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

var toNumber = __webpack_require__(347);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(19),
    isSymbol = __webpack_require__(63);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(349),
    keys = __webpack_require__(20);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(113);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),
/* 350 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

module.exports = baseRepeat;


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36),
    arrayMap = __webpack_require__(113),
    isArray = __webpack_require__(7),
    isSymbol = __webpack_require__(63);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _binding = __webpack_require__(160);

var _binding2 = _interopRequireDefault(_binding);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var renameVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
    var node = _ref.node;

    if (node.name === state.oldName) {
      node.name = state.newName;
    }
  },
  Scope: function Scope(path, state) {
    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
      path.skip();
    }
  },
  "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(path, state) {
    var ids = path.getOuterBindingIdentifiers();

    for (var name in ids) {
      if (name === state.oldName) ids[name].name = state.newName;
    }
  }
};

var Renamer = function () {
  function Renamer(binding, oldName, newName) {
    (0, _classCallCheck3.default)(this, Renamer);

    this.newName = newName;
    this.oldName = oldName;
    this.binding = binding;
  }

  Renamer.prototype.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
    var exportDeclar = parentDeclar.parentPath.isExportDeclaration() && parentDeclar.parentPath;
    if (!exportDeclar) return;

    var isDefault = exportDeclar.isExportDefaultDeclaration();

    if (isDefault && (parentDeclar.isFunctionDeclaration() || parentDeclar.isClassDeclaration()) && !parentDeclar.node.id) {
      parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier("default");
    }

    var bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers();
    var specifiers = [];

    for (var name in bindingIdentifiers) {
      var localName = name === this.oldName ? this.newName : name;
      var exportedName = isDefault ? "default" : name;
      specifiers.push(t.exportSpecifier(t.identifier(localName), t.identifier(exportedName)));
    }

    if (specifiers.length) {
      var aliasDeclar = t.exportNamedDeclaration(null, specifiers);

      if (parentDeclar.isFunctionDeclaration()) {
        aliasDeclar._blockHoist = 3;
      }

      exportDeclar.insertAfter(aliasDeclar);
      exportDeclar.replaceWith(parentDeclar.node);
    }
  };

  Renamer.prototype.rename = function rename(block) {
    var binding = this.binding,
        oldName = this.oldName,
        newName = this.newName;
    var scope = binding.scope,
        path = binding.path;


    var parentDeclar = path.find(function (path) {
      return path.isDeclaration() || path.isFunctionExpression();
    });
    if (parentDeclar) {
      this.maybeConvertFromExportDeclaration(parentDeclar);
    }

    scope.traverse(block || scope.block, renameVisitor, this);

    if (!block) {
      scope.removeOwnBinding(oldName);
      scope.bindings[newName] = binding;
      this.binding.identifier.name = newName;
    }

    if (binding.type === "hoisted") {}
  };

  return Renamer;
}();

exports.default = Renamer;
module.exports = exports["default"];

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(156),
    eq = __webpack_require__(38),
    isIterateeCall = __webpack_require__(104),
    keysIn = __webpack_require__(98);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(355);


/***/ }),
/* 355 */
/***/ (function(module, exports) {

module.exports = {"builtin":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"System":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es6":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"System":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AutocompleteErrorEvent":false,"BarProp":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"blur":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"CDATASection":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClientRect":false,"ClientRectList":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConvolverNode":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSAnimation":false,"CSSFontFaceRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CSSTransition":false,"CSSUnknownRule":false,"CSSViewportRule":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"Debug":false,"defaultStatus":false,"defaultstatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentTimeline":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMParser":false,"DOMSettableTokenList":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ElementTimeControl":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"FederatedCredential":false,"fetch":false,"File":false,"FileError":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAppletElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBlockquoteElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLIsIndexElement":false,"HTMLKeygenElement":false,"HTMLLabelElement":false,"HTMLLayerElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBEnvironment":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"Image":false,"ImageBitmap":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"InputMethodContext":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":false,"Location":false,"locationbar":false,"matchMedia":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyError":false,"MediaKeyEvent":false,"MediaKeyMessageEvent":false,"MediaKeys":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaSource":false,"MediaRecorder":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"navigator":false,"Navigator":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"onbeforeunload":true,"onblur":true,"onerror":true,"onfocus":true,"onload":true,"onresize":true,"onunload":true,"open":false,"openDatabase":false,"opener":false,"opera":false,"Option":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"parent":false,"PasswordCredential":false,"Path2D":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"Plugin":false,"PluginArray":false,"PopStateEvent":false,"postMessage":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"RadioNodeList":false,"Range":false,"ReadableByteStream":false,"ReadableStream":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"resizeTo":false,"Response":false,"RTCIceCandidate":false,"RTCSessionDescription":false,"RTCPeerConnection":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedKeyframeList":false,"SharedWorker":false,"showModalDialog":false,"SiteBoundCredential":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"status":false,"statusbar":false,"stop":false,"Storage":false,"StorageEvent":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAltGlyphDefElement":false,"SVGAltGlyphElement":false,"SVGAltGlyphItemElement":false,"SVGAngle":false,"SVGAnimateColorElement":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPathData":false,"SVGAnimatedPoints":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGColor":false,"SVGColorProfileElement":false,"SVGColorProfileRule":false,"SVGComponentTransferFunctionElement":false,"SVGCSSRule":false,"SVGCursorElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGDocument":false,"SVGElement":false,"SVGElementInstance":false,"SVGElementInstanceList":false,"SVGEllipseElement":false,"SVGEvent":false,"SVGExternalResourcesRequired":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGFilterPrimitiveStandardAttributes":false,"SVGFitToViewBox":false,"SVGFontElement":false,"SVGFontFaceElement":false,"SVGFontFaceFormatElement":false,"SVGFontFaceNameElement":false,"SVGFontFaceSrcElement":false,"SVGFontFaceUriElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGlyphElement":false,"SVGGlyphRefElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGHKernElement":false,"SVGICCColor":false,"SVGImageElement":false,"SVGLangSpace":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGLocatable":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMissingGlyphElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPaint":false,"SVGPathElement":false,"SVGPathSeg":false,"SVGPathSegArcAbs":false,"SVGPathSegArcRel":false,"SVGPathSegClosePath":false,"SVGPathSegCurvetoCubicAbs":false,"SVGPathSegCurvetoCubicRel":false,"SVGPathSegCurvetoCubicSmoothAbs":false,"SVGPathSegCurvetoCubicSmoothRel":false,"SVGPathSegCurvetoQuadraticAbs":false,"SVGPathSegCurvetoQuadraticRel":false,"SVGPathSegCurvetoQuadraticSmoothAbs":false,"SVGPathSegCurvetoQuadraticSmoothRel":false,"SVGPathSegLinetoAbs":false,"SVGPathSegLinetoHorizontalAbs":false,"SVGPathSegLinetoHorizontalRel":false,"SVGPathSegLinetoRel":false,"SVGPathSegLinetoVerticalAbs":false,"SVGPathSegLinetoVerticalRel":false,"SVGPathSegList":false,"SVGPathSegMovetoAbs":false,"SVGPathSegMovetoRel":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGRenderingIntent":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStylable":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTests":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformable":false,"SVGTransformList":false,"SVGTRefElement":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGURIReference":false,"SVGUseElement":false,"SVGViewElement":false,"SVGViewSpec":false,"SVGVKernElement":false,"SVGZoomAndPan":false,"SVGZoomEvent":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeEvent":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"VTTCue":false,"WaveShaperNode":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLTexture":false,"WebGLUniformLocation":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"XDomainRequest":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestProgressEvent":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathException":false,"XPathExpression":false,"XPathNamespace":false,"XPathNSResolver":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"arguments":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"GLOBAL":false,"global":false,"Intl":false,"module":false,"process":false,"require":false,"root":false,"setImmediate":false,"setInterval":false,"setTimeout":false},"commonjs":{"exports":true,"module":false,"require":false,"global":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"check":false,"describe":false,"expect":false,"gen":false,"it":false,"fdescribe":false,"fit":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"Java":false,"java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"Y":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ls":false,"ln":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"$":false,"_":false,"Accounts":false,"AccountsClient":false,"AccountsServer":false,"AccountsCommon":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPServer":false,"DDPRateLimiter":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"caches":false,"Cache":false,"CacheStorage":false,"Client":false,"clients":false,"Clients":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"FetchEvent":false,"importScripts":false,"registration":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"skipWaiting":false,"WindowClient":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false},"protractor":{"$":false,"$$":false,"browser":false,"By":false,"by":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false}}

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(357), __esModule: true };

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54);
__webpack_require__(31);
__webpack_require__(358);
__webpack_require__(359);
__webpack_require__(360);
module.exports = __webpack_require__(2).WeakMap;


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(109)(0);
var redefine = __webpack_require__(78);
var meta = __webpack_require__(34);
var assign = __webpack_require__(161);
var weak = __webpack_require__(162);
var isObject = __webpack_require__(5);
var fails = __webpack_require__(15);
var validate = __webpack_require__(41);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(108)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(110)('WeakMap');


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(111)('WeakMap');


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.findParent = findParent;
exports.find = find;
exports.getFunctionParent = getFunctionParent;
exports.getStatementParent = getStatementParent;
exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
exports.getAncestry = getAncestry;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
exports.inType = inType;
exports.inShadow = inShadow;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

var _index = __webpack_require__(24);

var _index2 = _interopRequireDefault(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findParent(callback) {
  var path = this;
  while (path = path.parentPath) {
    if (callback(path)) return path;
  }
  return null;
}

function find(callback) {
  var path = this;
  do {
    if (callback(path)) return path;
  } while (path = path.parentPath);
  return null;
}

function getFunctionParent() {
  return this.findParent(function (path) {
    return path.isFunction() || path.isProgram();
  });
}

function getStatementParent() {
  var path = this;
  do {
    if (Array.isArray(path.container)) {
      return path;
    }
  } while (path = path.parentPath);
}

function getEarliestCommonAncestorFrom(paths) {
  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
    var earliest = void 0;
    var keys = t.VISITOR_KEYS[deepest.type];

    for (var _iterator = ancestries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var ancestry = _ref;

      var path = ancestry[i + 1];

      if (!earliest) {
        earliest = path;
        continue;
      }

      if (path.listKey && earliest.listKey === path.listKey) {
        if (path.key < earliest.key) {
          earliest = path;
          continue;
        }
      }

      var earliestKeyIndex = keys.indexOf(earliest.parentKey);
      var currentKeyIndex = keys.indexOf(path.parentKey);
      if (earliestKeyIndex > currentKeyIndex) {
        earliest = path;
      }
    }

    return earliest;
  });
}

function getDeepestCommonAncestorFrom(paths, filter) {
  var _this = this;

  if (!paths.length) {
    return this;
  }

  if (paths.length === 1) {
    return paths[0];
  }

  var minDepth = Infinity;

  var lastCommonIndex = void 0,
      lastCommon = void 0;

  var ancestries = paths.map(function (path) {
    var ancestry = [];

    do {
      ancestry.unshift(path);
    } while ((path = path.parentPath) && path !== _this);

    if (ancestry.length < minDepth) {
      minDepth = ancestry.length;
    }

    return ancestry;
  });

  var first = ancestries[0];

  depthLoop: for (var i = 0; i < minDepth; i++) {
    var shouldMatch = first[i];

    for (var _iterator2 = ancestries, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var ancestry = _ref2;

      if (ancestry[i] !== shouldMatch) {
        break depthLoop;
      }
    }

    lastCommonIndex = i;
    lastCommon = shouldMatch;
  }

  if (lastCommon) {
    if (filter) {
      return filter(lastCommon, lastCommonIndex, ancestries);
    } else {
      return lastCommon;
    }
  } else {
    throw new Error("Couldn't find intersection");
  }
}

function getAncestry() {
  var path = this;
  var paths = [];
  do {
    paths.push(path);
  } while (path = path.parentPath);
  return paths;
}

function isAncestor(maybeDescendant) {
  return maybeDescendant.isDescendant(this);
}

function isDescendant(maybeAncestor) {
  return !!this.findParent(function (parent) {
    return parent === maybeAncestor;
  });
}

function inType() {
  var path = this;
  while (path) {
    for (var _iterator3 = arguments, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var type = _ref3;

      if (path.node.type === type) return true;
    }
    path = path.parentPath;
  }

  return false;
}

function inShadow(key) {
  var parentFn = this.isFunction() ? this : this.findParent(function (p) {
    return p.isFunction();
  });
  if (!parentFn) return;

  if (parentFn.isFunctionExpression() || parentFn.isFunctionDeclaration()) {
    var shadow = parentFn.node.shadow;

    if (shadow && (!key || shadow[key] !== false)) {
      return parentFn;
    }
  } else if (parentFn.isArrowFunctionExpression()) {
    return parentFn;
  }

  return null;
}

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.getTypeAnnotation = getTypeAnnotation;
exports._getTypeAnnotation = _getTypeAnnotation;
exports.isBaseType = isBaseType;
exports.couldBeBaseType = couldBeBaseType;
exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
exports.isGenericType = isGenericType;

var _inferers = __webpack_require__(363);

var inferers = _interopRequireWildcard(_inferers);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getTypeAnnotation() {
  if (this.typeAnnotation) return this.typeAnnotation;

  var type = this._getTypeAnnotation() || t.anyTypeAnnotation();
  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;
  return this.typeAnnotation = type;
}

function _getTypeAnnotation() {
  var node = this.node;

  if (!node) {
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      var declar = this.parentPath.parentPath;
      var declarParent = declar.parentPath;

      if (declar.key === "left" && declarParent.isForInStatement()) {
        return t.stringTypeAnnotation();
      }

      if (declar.key === "left" && declarParent.isForOfStatement()) {
        return t.anyTypeAnnotation();
      }

      return t.voidTypeAnnotation();
    } else {
      return;
    }
  }

  if (node.typeAnnotation) {
    return node.typeAnnotation;
  }

  var inferer = inferers[node.type];
  if (inferer) {
    return inferer.call(this, node);
  }

  inferer = inferers[this.parentPath.type];
  if (inferer && inferer.validParent) {
    return this.parentPath.getTypeAnnotation();
  }
}

function isBaseType(baseName, soft) {
  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}

function _isBaseType(baseName, type, soft) {
  if (baseName === "string") {
    return t.isStringTypeAnnotation(type);
  } else if (baseName === "number") {
    return t.isNumberTypeAnnotation(type);
  } else if (baseName === "boolean") {
    return t.isBooleanTypeAnnotation(type);
  } else if (baseName === "any") {
    return t.isAnyTypeAnnotation(type);
  } else if (baseName === "mixed") {
    return t.isMixedTypeAnnotation(type);
  } else if (baseName === "empty") {
    return t.isEmptyTypeAnnotation(type);
  } else if (baseName === "void") {
    return t.isVoidTypeAnnotation(type);
  } else {
    if (soft) {
      return false;
    } else {
      throw new Error("Unknown base type " + baseName);
    }
  }
}

function couldBeBaseType(name) {
  var type = this.getTypeAnnotation();
  if (t.isAnyTypeAnnotation(type)) return true;

  if (t.isUnionTypeAnnotation(type)) {
    for (var _iterator = type.types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var type2 = _ref;

      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
        return true;
      }
    }
    return false;
  } else {
    return _isBaseType(name, type, true);
  }
}

function baseTypeStrictlyMatches(right) {
  var left = this.getTypeAnnotation();
  right = right.getTypeAnnotation();

  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {
    return right.type === left.type;
  }
}

function isGenericType(genericName) {
  var type = this.getTypeAnnotation();
  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, { name: genericName });
}

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = exports.Identifier = undefined;

var _infererReference = __webpack_require__(364);

Object.defineProperty(exports, "Identifier", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_infererReference).default;
  }
});
exports.VariableDeclarator = VariableDeclarator;
exports.TypeCastExpression = TypeCastExpression;
exports.NewExpression = NewExpression;
exports.TemplateLiteral = TemplateLiteral;
exports.UnaryExpression = UnaryExpression;
exports.BinaryExpression = BinaryExpression;
exports.LogicalExpression = LogicalExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.SequenceExpression = SequenceExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.UpdateExpression = UpdateExpression;
exports.StringLiteral = StringLiteral;
exports.NumericLiteral = NumericLiteral;
exports.BooleanLiteral = BooleanLiteral;
exports.NullLiteral = NullLiteral;
exports.RegExpLiteral = RegExpLiteral;
exports.ObjectExpression = ObjectExpression;
exports.ArrayExpression = ArrayExpression;
exports.RestElement = RestElement;
exports.CallExpression = CallExpression;
exports.TaggedTemplateExpression = TaggedTemplateExpression;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VariableDeclarator() {
  var id = this.get("id");

  if (id.isIdentifier()) {
    return this.get("init").getTypeAnnotation();
  } else {
    return;
  }
}

function TypeCastExpression(node) {
  return node.typeAnnotation;
}

TypeCastExpression.validParent = true;

function NewExpression(node) {
  if (this.get("callee").isIdentifier()) {
    return t.genericTypeAnnotation(node.callee);
  }
}

function TemplateLiteral() {
  return t.stringTypeAnnotation();
}

function UnaryExpression(node) {
  var operator = node.operator;

  if (operator === "void") {
    return t.voidTypeAnnotation();
  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.numberTypeAnnotation();
  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.stringTypeAnnotation();
  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.booleanTypeAnnotation();
  }
}

function BinaryExpression(node) {
  var operator = node.operator;

  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t.numberTypeAnnotation();
  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t.booleanTypeAnnotation();
  } else if (operator === "+") {
    var right = this.get("right");
    var left = this.get("left");

    if (left.isBaseType("number") && right.isBaseType("number")) {
      return t.numberTypeAnnotation();
    } else if (left.isBaseType("string") || right.isBaseType("string")) {
      return t.stringTypeAnnotation();
    }

    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);
  }
}

function LogicalExpression() {
  return t.createUnionTypeAnnotation([this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()]);
}

function ConditionalExpression() {
  return t.createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()]);
}

function SequenceExpression() {
  return this.get("expressions").pop().getTypeAnnotation();
}

function AssignmentExpression() {
  return this.get("right").getTypeAnnotation();
}

function UpdateExpression(node) {
  var operator = node.operator;
  if (operator === "++" || operator === "--") {
    return t.numberTypeAnnotation();
  }
}

function StringLiteral() {
  return t.stringTypeAnnotation();
}

function NumericLiteral() {
  return t.numberTypeAnnotation();
}

function BooleanLiteral() {
  return t.booleanTypeAnnotation();
}

function NullLiteral() {
  return t.nullLiteralTypeAnnotation();
}

function RegExpLiteral() {
  return t.genericTypeAnnotation(t.identifier("RegExp"));
}

function ObjectExpression() {
  return t.genericTypeAnnotation(t.identifier("Object"));
}

function ArrayExpression() {
  return t.genericTypeAnnotation(t.identifier("Array"));
}

function RestElement() {
  return ArrayExpression();
}

RestElement.validParent = true;

function Func() {
  return t.genericTypeAnnotation(t.identifier("Function"));
}

exports.FunctionExpression = Func;
exports.ArrowFunctionExpression = Func;
exports.FunctionDeclaration = Func;
exports.ClassExpression = Func;
exports.ClassDeclaration = Func;
function CallExpression() {
  return resolveCall(this.get("callee"));
}

function TaggedTemplateExpression() {
  return resolveCall(this.get("tag"));
}

function resolveCall(callee) {
  callee = callee.resolve();

  if (callee.isFunction()) {
    if (callee.is("async")) {
      if (callee.is("generator")) {
        return t.genericTypeAnnotation(t.identifier("AsyncIterator"));
      } else {
        return t.genericTypeAnnotation(t.identifier("Promise"));
      }
    } else {
      if (callee.node.returnType) {
        return callee.node.returnType;
      } else {}
    }
  }
}

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.default = function (node) {
  if (!this.isReferenced()) return;

  var binding = this.scope.getBinding(node.name);
  if (binding) {
    if (binding.identifier.typeAnnotation) {
      return binding.identifier.typeAnnotation;
    } else {
      return getTypeAnnotationBindingConstantViolations(this, node.name);
    }
  }

  if (node.name === "undefined") {
    return t.voidTypeAnnotation();
  } else if (node.name === "NaN" || node.name === "Infinity") {
    return t.numberTypeAnnotation();
  } else if (node.name === "arguments") {}
};

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getTypeAnnotationBindingConstantViolations(path, name) {
  var binding = path.scope.getBinding(name);

  var types = [];
  path.typeAnnotation = t.unionTypeAnnotation(types);

  var functionConstantViolations = [];
  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);

  var testType = getConditionalAnnotation(path, name);
  if (testType) {
    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);

    constantViolations = constantViolations.filter(function (path) {
      return testConstantViolations.indexOf(path) < 0;
    });

    types.push(testType.typeAnnotation);
  }

  if (constantViolations.length) {
    constantViolations = constantViolations.concat(functionConstantViolations);

    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var violation = _ref;

      types.push(violation.getTypeAnnotation());
    }
  }

  if (types.length) {
    return t.createUnionTypeAnnotation(types);
  }
}

function getConstantViolationsBefore(binding, path, functions) {
  var violations = binding.constantViolations.slice();
  violations.unshift(binding.path);
  return violations.filter(function (violation) {
    violation = violation.resolve();
    var status = violation._guessExecutionStatusRelativeTo(path);
    if (functions && status === "function") functions.push(violation);
    return status === "before";
  });
}

function inferAnnotationFromBinaryExpression(name, path) {
  var operator = path.node.operator;

  var right = path.get("right").resolve();
  var left = path.get("left").resolve();

  var target = void 0;
  if (left.isIdentifier({ name: name })) {
    target = right;
  } else if (right.isIdentifier({ name: name })) {
    target = left;
  }
  if (target) {
    if (operator === "===") {
      return target.getTypeAnnotation();
    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return t.numberTypeAnnotation();
    } else {
      return;
    }
  } else {
    if (operator !== "===") return;
  }

  var typeofPath = void 0;
  var typePath = void 0;
  if (left.isUnaryExpression({ operator: "typeof" })) {
    typeofPath = left;
    typePath = right;
  } else if (right.isUnaryExpression({ operator: "typeof" })) {
    typeofPath = right;
    typePath = left;
  }
  if (!typePath && !typeofPath) return;

  typePath = typePath.resolve();
  if (!typePath.isLiteral()) return;

  var typeValue = typePath.node.value;
  if (typeof typeValue !== "string") return;

  if (!typeofPath.get("argument").isIdentifier({ name: name })) return;

  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);
}

function getParentConditionalPath(path) {
  var parentPath = void 0;
  while (parentPath = path.parentPath) {
    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
      if (path.key === "test") {
        return;
      } else {
        return parentPath;
      }
    } else {
      path = parentPath;
    }
  }
}

function getConditionalAnnotation(path, name) {
  var ifStatement = getParentConditionalPath(path);
  if (!ifStatement) return;

  var test = ifStatement.get("test");
  var paths = [test];
  var types = [];

  do {
    var _path = paths.shift().resolve();

    if (_path.isLogicalExpression()) {
      paths.push(_path.get("left"));
      paths.push(_path.get("right"));
    }

    if (_path.isBinaryExpression()) {
      var type = inferAnnotationFromBinaryExpression(name, _path);
      if (type) types.push(type);
    }
  } while (paths.length);

  if (types.length) {
    return {
      typeAnnotation: t.createUnionTypeAnnotation(types),
      ifStatement: ifStatement
    };
  } else {
    return getConditionalAnnotation(ifStatement, name);
  }
}
module.exports = exports["default"];

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.replaceWithMultiple = replaceWithMultiple;
exports.replaceWithSourceString = replaceWithSourceString;
exports.replaceWith = replaceWith;
exports._replaceWith = _replaceWith;
exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
exports.replaceInline = replaceInline;

var _babelCodeFrame = __webpack_require__(366);

var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame);

var _index = __webpack_require__(30);

var _index2 = _interopRequireDefault(_index);

var _index3 = __webpack_require__(24);

var _index4 = _interopRequireDefault(_index3);

var _babylon = __webpack_require__(120);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hoistVariablesVisitor = {
  Function: function Function(path) {
    path.skip();
  },
  VariableDeclaration: function VariableDeclaration(path) {
    if (path.node.kind !== "var") return;

    var bindings = path.getBindingIdentifiers();
    for (var key in bindings) {
      path.scope.push({ id: bindings[key] });
    }

    var exprs = [];

    for (var _iterator = path.node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var declar = _ref;

      if (declar.init) {
        exprs.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
      }
    }

    path.replaceWithMultiple(exprs);
  }
};

function replaceWithMultiple(nodes) {
  this.resync();

  nodes = this._verifyNodeList(nodes);
  t.inheritLeadingComments(nodes[0], this.node);
  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);
  this.node = this.container[this.key] = null;
  this.insertAfter(nodes);

  if (this.node) {
    this.requeue();
  } else {
    this.remove();
  }
}

function replaceWithSourceString(replacement) {
  this.resync();

  try {
    replacement = "(" + replacement + ")";
    replacement = (0, _babylon.parse)(replacement);
  } catch (err) {
    var loc = err.loc;
    if (loc) {
      err.message += " - make sure this is an expression.";
      err.message += "\n" + (0, _babelCodeFrame2.default)(replacement, loc.line, loc.column + 1);
    }
    throw err;
  }

  replacement = replacement.program.body[0].expression;
  _index2.default.removeProperties(replacement);
  return this.replaceWith(replacement);
}

function replaceWith(replacement) {
  this.resync();

  if (this.removed) {
    throw new Error("You can't replace this node, we've already removed it");
  }

  if (replacement instanceof _index4.default) {
    replacement = replacement.node;
  }

  if (!replacement) {
    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
  }

  if (this.node === replacement) {
    return;
  }

  if (this.isProgram() && !t.isProgram(replacement)) {
    throw new Error("You can only replace a Program root node with another Program node");
  }

  if (Array.isArray(replacement)) {
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
  }

  if (typeof replacement === "string") {
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
  }

  if (this.isNodeType("Statement") && t.isExpression(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
      replacement = t.expressionStatement(replacement);
    }
  }

  if (this.isNodeType("Expression") && t.isStatement(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
      return this.replaceExpressionWithStatements([replacement]);
    }
  }

  var oldNode = this.node;
  if (oldNode) {
    t.inheritsComments(replacement, oldNode);
    t.removeComments(oldNode);
  }

  this._replaceWith(replacement);
  this.type = replacement.type;

  this.setScope();

  this.requeue();
}

function _replaceWith(node) {
  if (!this.container) {
    throw new ReferenceError("Container is falsy");
  }

  if (this.inList) {
    t.validate(this.parent, this.key, [node]);
  } else {
    t.validate(this.parent, this.key, node);
  }

  this.debug(function () {
    return "Replace with " + (node && node.type);
  });

  this.node = this.container[this.key] = node;
}

function replaceExpressionWithStatements(nodes) {
  this.resync();

  var toSequenceExpression = t.toSequenceExpression(nodes, this.scope);

  if (t.isSequenceExpression(toSequenceExpression)) {
    var exprs = toSequenceExpression.expressions;

    if (exprs.length >= 2 && this.parentPath.isExpressionStatement()) {
      this._maybePopFromStatements(exprs);
    }

    if (exprs.length === 1) {
      this.replaceWith(exprs[0]);
    } else {
      this.replaceWith(toSequenceExpression);
    }
  } else if (toSequenceExpression) {
    this.replaceWith(toSequenceExpression);
  } else {
    var container = t.functionExpression(null, [], t.blockStatement(nodes));
    container.shadow = true;

    this.replaceWith(t.callExpression(container, []));
    this.traverse(hoistVariablesVisitor);

    var completionRecords = this.get("callee").getCompletionRecords();
    for (var _iterator2 = completionRecords, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var path = _ref2;

      if (!path.isExpressionStatement()) continue;

      var loop = path.findParent(function (path) {
        return path.isLoop();
      });
      if (loop) {
        var uid = loop.getData("expressionReplacementReturnUid");

        if (!uid) {
          var callee = this.get("callee");
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", t.returnStatement(uid));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = t.identifier(uid.name);
        }

        path.get("expression").replaceWith(t.assignmentExpression("=", uid, path.node.expression));
      } else {
        path.replaceWith(t.returnStatement(path.node.expression));
      }
    }

    return this.node;
  }
}

function replaceInline(nodes) {
  this.resync();

  if (Array.isArray(nodes)) {
    if (Array.isArray(this.container)) {
      nodes = this._verifyNodeList(nodes);
      this._containerInsertAfter(nodes);
      return this.remove();
    } else {
      return this.replaceWithMultiple(nodes);
    }
  } else {
    return this.replaceWith(nodes);
  }
}

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (rawLines, lineNumber, colNumber) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  colNumber = Math.max(colNumber, 0);

  var highlighted = opts.highlightCode && _chalk2.default.supportsColor || opts.forceColor;
  var chalk = _chalk2.default;
  if (opts.forceColor) {
    chalk = new _chalk2.default.constructor({ enabled: true });
  }
  var maybeHighlight = function maybeHighlight(chalkFn, string) {
    return highlighted ? chalkFn(string) : string;
  };
  var defs = getDefs(chalk);
  if (highlighted) rawLines = highlight(defs, rawLines);

  var linesAbove = opts.linesAbove || 2;
  var linesBelow = opts.linesBelow || 3;

  var lines = rawLines.split(NEWLINE);
  var start = Math.max(lineNumber - (linesAbove + 1), 0);
  var end = Math.min(lines.length, lineNumber + linesBelow);

  if (!lineNumber && !colNumber) {
    start = 0;
    end = lines.length;
  }

  var numberMaxWidth = String(end).length;

  var frame = lines.slice(start, end).map(function (line, index) {
    var number = start + 1 + index;
    var paddedNumber = (" " + number).slice(-numberMaxWidth);
    var gutter = " " + paddedNumber + " | ";
    if (number === lineNumber) {
      var markerLine = "";
      if (colNumber) {
        var markerSpacing = line.slice(0, colNumber - 1).replace(/[^\t]/g, " ");
        markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^")].join("");
      }
      return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
    } else {
      return " " + maybeHighlight(defs.gutter, gutter) + line;
    }
  }).join("\n");

  if (highlighted) {
    return chalk.reset(frame);
  } else {
    return frame;
  }
};

var _jsTokens = __webpack_require__(367);

var _jsTokens2 = _interopRequireDefault(_jsTokens);

var _esutils = __webpack_require__(133);

var _esutils2 = _interopRequireDefault(_esutils);

var _chalk = __webpack_require__(368);

var _chalk2 = _interopRequireDefault(_chalk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDefs(chalk) {
  return {
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsx_tag: chalk.yellow,
    punctuator: chalk.yellow,

    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold,
    gutter: chalk.grey,
    marker: chalk.red.bold
  };
}

var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

var JSX_TAG = /^[a-z][\w-]*$/i;

var BRACKET = /^[()\[\]{}]$/;

function getTokenType(match) {
  var _match$slice = match.slice(-2),
      offset = _match$slice[0],
      text = _match$slice[1];

  var token = (0, _jsTokens.matchToToken)(match);

  if (token.type === "name") {
    if (_esutils2.default.keyword.isReservedWordES6(token.value)) {
      return "keyword";
    }

    if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
      return "jsx_tag";
    }

    if (token.value[0] !== token.value[0].toLowerCase()) {
      return "capitalized";
    }
  }

  if (token.type === "punctuator" && BRACKET.test(token.value)) {
    return "bracket";
  }

  return token.type;
}

function highlight(defs, text) {
  return text.replace(_jsTokens2.default, function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var type = getTokenType(args);
    var colorize = defs[type];
    if (colorize) {
      return args[0].split(NEWLINE).map(function (str) {
        return colorize(str);
      }).join("\n");
    } else {
      return args[0];
    }
  });
}

module.exports = exports["default"];

/***/ }),
/* 367 */
/***/ (function(module, exports) {

// Copyright 2014, 2015, 2016, 2017 Simon Lydell
// License: MIT. (See LICENSE.)

Object.defineProperty(exports, "__esModule", {
  value: true
})

// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g

exports.matchToToken = function(match) {
  var token = {type: "invalid", value: match[0]}
       if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4])
  else if (match[ 5]) token.type = "comment"
  else if (match[ 6]) token.type = "comment", token.closed = !!match[7]
  else if (match[ 8]) token.type = "regex"
  else if (match[ 9]) token.type = "number"
  else if (match[10]) token.type = "name"
  else if (match[11]) token.type = "punctuator"
  else if (match[12]) token.type = "whitespace"
  return token
}


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var escapeStringRegexp = __webpack_require__(369);
var ansiStyles = __webpack_require__(370);
var stripAnsi = __webpack_require__(371);
var hasAnsi = __webpack_require__(372);
var supportsColor = __webpack_require__(373);
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)(module)))

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(163)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(163);
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(17);

var _typeof3 = _interopRequireDefault(_typeof2);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = __webpack_require__(157);

var _map2 = _interopRequireDefault(_map);

exports.evaluateTruthy = evaluateTruthy;
exports.evaluate = evaluate;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VALID_CALLEES = ["String", "Number", "Math"];
var INVALID_METHODS = ["random"];

function evaluateTruthy() {
  var res = this.evaluate();
  if (res.confident) return !!res.value;
}

function evaluate() {
  var confident = true;
  var deoptPath = void 0;
  var seen = new _map2.default();

  function deopt(path) {
    if (!confident) return;
    deoptPath = path;
    confident = false;
  }

  var value = evaluate(this);
  if (!confident) value = undefined;
  return {
    confident: confident,
    deopt: deoptPath,
    value: value
  };

  function evaluate(path) {
    var node = path.node;


    if (seen.has(node)) {
      var existing = seen.get(node);
      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path);
        return;
      }
    } else {
      var item = { resolved: false };
      seen.set(node, item);

      var val = _evaluate(path);
      if (confident) {
        item.resolved = true;
        item.value = val;
      }
      return val;
    }
  }

  function _evaluate(path) {
    if (!confident) return;

    var node = path.node;


    if (path.isSequenceExpression()) {
      var exprs = path.get("expressions");
      return evaluate(exprs[exprs.length - 1]);
    }

    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return node.value;
    }

    if (path.isNullLiteral()) {
      return null;
    }

    if (path.isTemplateLiteral()) {
      var str = "";

      var i = 0;
      var _exprs = path.get("expressions");

      for (var _iterator = node.quasis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var elem = _ref;

        if (!confident) break;

        str += elem.value.cooked;

        var expr = _exprs[i++];
        if (expr) str += String(evaluate(expr));
      }

      if (!confident) return;
      return str;
    }

    if (path.isConditionalExpression()) {
      var testResult = evaluate(path.get("test"));
      if (!confident) return;
      if (testResult) {
        return evaluate(path.get("consequent"));
      } else {
        return evaluate(path.get("alternate"));
      }
    }

    if (path.isExpressionWrapper()) {
      return evaluate(path.get("expression"));
    }

    if (path.isMemberExpression() && !path.parentPath.isCallExpression({ callee: node })) {
      var property = path.get("property");
      var object = path.get("object");

      if (object.isLiteral() && property.isIdentifier()) {
        var _value = object.node.value;
        var type = typeof _value === "undefined" ? "undefined" : (0, _typeof3.default)(_value);
        if (type === "number" || type === "string") {
          return _value[property.node.name];
        }
      }
    }

    if (path.isReferencedIdentifier()) {
      var binding = path.scope.getBinding(node.name);

      if (binding && binding.constantViolations.length > 0) {
        return deopt(binding.path);
      }

      if (binding && path.node.start < binding.path.node.end) {
        return deopt(binding.path);
      }

      if (binding && binding.hasValue) {
        return binding.value;
      } else {
        if (node.name === "undefined") {
          return binding ? deopt(binding.path) : undefined;
        } else if (node.name === "Infinity") {
          return binding ? deopt(binding.path) : Infinity;
        } else if (node.name === "NaN") {
          return binding ? deopt(binding.path) : NaN;
        }

        var resolved = path.resolve();
        if (resolved === path) {
          return deopt(path);
        } else {
          return evaluate(resolved);
        }
      }
    }

    if (path.isUnaryExpression({ prefix: true })) {
      if (node.operator === "void") {
        return undefined;
      }

      var argument = path.get("argument");
      if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }

      var arg = evaluate(argument);
      if (!confident) return;
      switch (node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return typeof arg === "undefined" ? "undefined" : (0, _typeof3.default)(arg);
      }
    }

    if (path.isArrayExpression()) {
      var arr = [];
      var elems = path.get("elements");
      for (var _iterator2 = elems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var _elem = _ref2;

        _elem = _elem.evaluate();

        if (_elem.confident) {
          arr.push(_elem.value);
        } else {
          return deopt(_elem);
        }
      }
      return arr;
    }

    if (path.isObjectExpression()) {
      var obj = {};
      var props = path.get("properties");
      for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var prop = _ref3;

        if (prop.isObjectMethod() || prop.isSpreadProperty()) {
          return deopt(prop);
        }
        var keyPath = prop.get("key");
        var key = keyPath;
        if (prop.node.computed) {
          key = key.evaluate();
          if (!key.confident) {
            return deopt(keyPath);
          }
          key = key.value;
        } else if (key.isIdentifier()) {
          key = key.node.name;
        } else {
          key = key.node.value;
        }
        var valuePath = prop.get("value");
        var _value2 = valuePath.evaluate();
        if (!_value2.confident) {
          return deopt(valuePath);
        }
        _value2 = _value2.value;
        obj[key] = _value2;
      }
      return obj;
    }

    if (path.isLogicalExpression()) {
      var wasConfident = confident;
      var left = evaluate(path.get("left"));
      var leftConfident = confident;
      confident = wasConfident;
      var right = evaluate(path.get("right"));
      var rightConfident = confident;
      confident = leftConfident && rightConfident;

      switch (node.operator) {
        case "||":
          if (left && leftConfident) {
            confident = true;
            return left;
          }

          if (!confident) return;

          return left || right;
        case "&&":
          if (!left && leftConfident || !right && rightConfident) {
            confident = true;
          }

          if (!confident) return;

          return left && right;
      }
    }

    if (path.isBinaryExpression()) {
      var _left = evaluate(path.get("left"));
      if (!confident) return;
      var _right = evaluate(path.get("right"));
      if (!confident) return;

      switch (node.operator) {
        case "-":
          return _left - _right;
        case "+":
          return _left + _right;
        case "/":
          return _left / _right;
        case "*":
          return _left * _right;
        case "%":
          return _left % _right;
        case "**":
          return Math.pow(_left, _right);
        case "<":
          return _left < _right;
        case ">":
          return _left > _right;
        case "<=":
          return _left <= _right;
        case ">=":
          return _left >= _right;
        case "==":
          return _left == _right;
        case "!=":
          return _left != _right;
        case "===":
          return _left === _right;
        case "!==":
          return _left !== _right;
        case "|":
          return _left | _right;
        case "&":
          return _left & _right;
        case "^":
          return _left ^ _right;
        case "<<":
          return _left << _right;
        case ">>":
          return _left >> _right;
        case ">>>":
          return _left >>> _right;
      }
    }

    if (path.isCallExpression()) {
      var callee = path.get("callee");
      var context = void 0;
      var func = void 0;

      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
        func = global[node.callee.name];
      }

      if (callee.isMemberExpression()) {
        var _object = callee.get("object");
        var _property = callee.get("property");

        if (_object.isIdentifier() && _property.isIdentifier() && VALID_CALLEES.indexOf(_object.node.name) >= 0 && INVALID_METHODS.indexOf(_property.node.name) < 0) {
          context = global[_object.node.name];
          func = context[_property.node.name];
        }

        if (_object.isLiteral() && _property.isIdentifier()) {
          var _type = (0, _typeof3.default)(_object.node.value);
          if (_type === "string" || _type === "number") {
            context = _object.node.value;
            func = context[_property.node.name];
          }
        }
      }

      if (func) {
        var args = path.get("arguments").map(evaluate);
        if (!confident) return;

        return func.apply(context, args);
      }
    }

    deopt(path);
  }
}

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.toComputedKey = toComputedKey;
exports.ensureBlock = ensureBlock;
exports.arrowFunctionToShadowed = arrowFunctionToShadowed;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function toComputedKey() {
  var node = this.node;

  var key = void 0;
  if (this.isMemberExpression()) {
    key = node.property;
  } else if (this.isProperty() || this.isMethod()) {
    key = node.key;
  } else {
    throw new ReferenceError("todo");
  }

  if (!node.computed) {
    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);
  }

  return key;
}

function ensureBlock() {
  return t.ensureBlock(this.node);
}

function arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return;

  this.ensureBlock();

  var node = this.node;

  node.expression = false;
  node.type = "FunctionExpression";
  node.shadow = node.shadow || true;
}

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.is = undefined;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.matchesPattern = matchesPattern;
exports.has = has;
exports.isStatic = isStatic;
exports.isnt = isnt;
exports.equals = equals;
exports.isNodeType = isNodeType;
exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
exports.isCompletionRecord = isCompletionRecord;
exports.isStatementOrBlock = isStatementOrBlock;
exports.referencesImport = referencesImport;
exports.getSource = getSource;
exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
exports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
exports.resolve = resolve;
exports._resolve = _resolve;

var _includes = __webpack_require__(112);

var _includes2 = _interopRequireDefault(_includes);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matchesPattern(pattern, allowPartial) {
  if (!this.isMemberExpression()) return false;

  var parts = pattern.split(".");
  var search = [this.node];
  var i = 0;

  function matches(name) {
    var part = parts[i];
    return part === "*" || name === part;
  }

  while (search.length) {
    var node = search.shift();

    if (allowPartial && i === parts.length) {
      return true;
    }

    if (t.isIdentifier(node)) {
      if (!matches(node.name)) return false;
    } else if (t.isLiteral(node)) {
      if (!matches(node.value)) return false;
    } else if (t.isMemberExpression(node)) {
      if (node.computed && !t.isLiteral(node.property)) {
        return false;
      } else {
        search.unshift(node.property);
        search.unshift(node.object);
        continue;
      }
    } else if (t.isThisExpression(node)) {
      if (!matches("this")) return false;
    } else {
      return false;
    }

    if (++i > parts.length) {
      return false;
    }
  }

  return i === parts.length;
}

function has(key) {
  var val = this.node && this.node[key];
  if (val && Array.isArray(val)) {
    return !!val.length;
  } else {
    return !!val;
  }
}

function isStatic() {
  return this.scope.isStatic(this.node);
}

var is = exports.is = has;

function isnt(key) {
  return !this.has(key);
}

function equals(key, value) {
  return this.node[key] === value;
}

function isNodeType(type) {
  return t.isType(this.type, type);
}

function canHaveVariableDeclarationOrExpression() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}

function canSwapBetweenExpressionAndStatement(replacement) {
  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
    return false;
  }

  if (this.isExpression()) {
    return t.isBlockStatement(replacement);
  } else if (this.isBlockStatement()) {
    return t.isExpression(replacement);
  }

  return false;
}

function isCompletionRecord(allowInsideFunction) {
  var path = this;
  var first = true;

  do {
    var container = path.container;

    if (path.isFunction() && !first) {
      return !!allowInsideFunction;
    }

    first = false;

    if (Array.isArray(container) && path.key !== container.length - 1) {
      return false;
    }
  } while ((path = path.parentPath) && !path.isProgram());

  return true;
}

function isStatementOrBlock() {
  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {
    return false;
  } else {
    return (0, _includes2.default)(t.STATEMENT_OR_BLOCK_KEYS, this.key);
  }
}

function referencesImport(moduleSource, importName) {
  if (!this.isReferencedIdentifier()) return false;

  var binding = this.scope.getBinding(this.node.name);
  if (!binding || binding.kind !== "module") return false;

  var path = binding.path;
  var parent = path.parentPath;
  if (!parent.isImportDeclaration()) return false;

  if (parent.node.source.value === moduleSource) {
    if (!importName) return true;
  } else {
    return false;
  }

  if (path.isImportDefaultSpecifier() && importName === "default") {
    return true;
  }

  if (path.isImportNamespaceSpecifier() && importName === "*") {
    return true;
  }

  if (path.isImportSpecifier() && path.node.imported.name === importName) {
    return true;
  }

  return false;
}

function getSource() {
  var node = this.node;
  if (node.end) {
    return this.hub.file.code.slice(node.start, node.end);
  } else {
    return "";
  }
}

function willIMaybeExecuteBefore(target) {
  return this._guessExecutionStatusRelativeTo(target) !== "after";
}

function _guessExecutionStatusRelativeTo(target) {
  var targetFuncParent = target.scope.getFunctionParent();
  var selfFuncParent = this.scope.getFunctionParent();

  if (targetFuncParent.node !== selfFuncParent.node) {
    var status = this._guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent);
    if (status) {
      return status;
    } else {
      target = targetFuncParent.path;
    }
  }

  var targetPaths = target.getAncestry();
  if (targetPaths.indexOf(this) >= 0) return "after";

  var selfPaths = this.getAncestry();

  var commonPath = void 0;
  var targetIndex = void 0;
  var selfIndex = void 0;
  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
    var selfPath = selfPaths[selfIndex];
    targetIndex = targetPaths.indexOf(selfPath);
    if (targetIndex >= 0) {
      commonPath = selfPath;
      break;
    }
  }
  if (!commonPath) {
    return "before";
  }

  var targetRelationship = targetPaths[targetIndex - 1];
  var selfRelationship = selfPaths[selfIndex - 1];
  if (!targetRelationship || !selfRelationship) {
    return "before";
  }

  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {
    return targetRelationship.key > selfRelationship.key ? "before" : "after";
  }

  var targetKeyPosition = t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);
  var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);
  return targetKeyPosition > selfKeyPosition ? "before" : "after";
}

function _guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent) {
  var targetFuncPath = targetFuncParent.path;
  if (!targetFuncPath.isFunctionDeclaration()) return;

  var binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);

  if (!binding.references) return "before";

  var referencePaths = binding.referencePaths;

  for (var _iterator = referencePaths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var path = _ref;

    if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
      return;
    }
  }

  var allStatus = void 0;

  for (var _iterator2 = referencePaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var _path = _ref2;

    var childOfFunction = !!_path.find(function (path) {
      return path.node === targetFuncPath.node;
    });
    if (childOfFunction) continue;

    var status = this._guessExecutionStatusRelativeTo(_path);

    if (allStatus) {
      if (allStatus !== status) return;
    } else {
      allStatus = status;
    }
  }

  return allStatus;
}

function resolve(dangerous, resolved) {
  return this._resolve(dangerous, resolved) || this;
}

function _resolve(dangerous, resolved) {
  if (resolved && resolved.indexOf(this) >= 0) return;

  resolved = resolved || [];
  resolved.push(this);

  if (this.isVariableDeclarator()) {
    if (this.get("id").isIdentifier()) {
      return this.get("init").resolve(dangerous, resolved);
    } else {}
  } else if (this.isReferencedIdentifier()) {
    var binding = this.scope.getBinding(this.node.name);
    if (!binding) return;

    if (!binding.constant) return;

    if (binding.kind === "module") return;

    if (binding.path !== this) {
      var ret = binding.path.resolve(dangerous, resolved);

      if (this.find(function (parent) {
        return parent.node === ret.node;
      })) return;
      return ret;
    }
  } else if (this.isTypeCastExpression()) {
    return this.get("expression").resolve(dangerous, resolved);
  } else if (dangerous && this.isMemberExpression()) {

    var targetKey = this.toComputedKey();
    if (!t.isLiteral(targetKey)) return;

    var targetName = targetKey.value;

    var target = this.get("object").resolve(dangerous, resolved);

    if (target.isObjectExpression()) {
      var props = target.get("properties");
      for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var prop = _ref3;

        if (!prop.isProperty()) continue;

        var key = prop.get("key");

        var match = prop.isnt("computed") && key.isIdentifier({ name: targetName });

        match = match || key.isLiteral({ value: targetName });

        if (match) return prop.get("value").resolve(dangerous, resolved);
      }
    } else if (target.isArrayExpression() && !isNaN(+targetName)) {
      var elems = target.get("elements");
      var elem = elems[targetName];
      if (elem) return elem.resolve(dangerous, resolved);
    }
  }
}

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.call = call;
exports._call = _call;
exports.isBlacklisted = isBlacklisted;
exports.visit = visit;
exports.skip = skip;
exports.skipKey = skipKey;
exports.stop = stop;
exports.setScope = setScope;
exports.setContext = setContext;
exports.resync = resync;
exports._resyncParent = _resyncParent;
exports._resyncKey = _resyncKey;
exports._resyncList = _resyncList;
exports._resyncRemoved = _resyncRemoved;
exports.popContext = popContext;
exports.pushContext = pushContext;
exports.setup = setup;
exports.setKey = setKey;
exports.requeue = requeue;
exports._getQueueContexts = _getQueueContexts;

var _index = __webpack_require__(30);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function call(key) {
  var opts = this.opts;

  this.debug(function () {
    return key;
  });

  if (this.node) {
    if (this._call(opts[key])) return true;
  }

  if (this.node) {
    return this._call(opts[this.node.type] && opts[this.node.type][key]);
  }

  return false;
}

function _call(fns) {
  if (!fns) return false;

  for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var fn = _ref;

    if (!fn) continue;

    var node = this.node;
    if (!node) return true;

    var ret = fn.call(this.state, this, this.state);
    if (ret) throw new Error("Unexpected return value from visitor method " + fn);

    if (this.node !== node) return true;

    if (this.shouldStop || this.shouldSkip || this.removed) return true;
  }

  return false;
}

function isBlacklisted() {
  var blacklist = this.opts.blacklist;
  return blacklist && blacklist.indexOf(this.node.type) > -1;
}

function visit() {
  if (!this.node) {
    return false;
  }

  if (this.isBlacklisted()) {
    return false;
  }

  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
    return false;
  }

  if (this.call("enter") || this.shouldSkip) {
    this.debug(function () {
      return "Skip...";
    });
    return this.shouldStop;
  }

  this.debug(function () {
    return "Recursing into...";
  });
  _index2.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);

  this.call("exit");

  return this.shouldStop;
}

function skip() {
  this.shouldSkip = true;
}

function skipKey(key) {
  this.skipKeys[key] = true;
}

function stop() {
  this.shouldStop = true;
  this.shouldSkip = true;
}

function setScope() {
  if (this.opts && this.opts.noScope) return;

  var target = this.context && this.context.scope;

  if (!target) {
    var path = this.parentPath;
    while (path && !target) {
      if (path.opts && path.opts.noScope) return;

      target = path.scope;
      path = path.parentPath;
    }
  }

  this.scope = this.getScope(target);
  if (this.scope) this.scope.init();
}

function setContext(context) {
  this.shouldSkip = false;
  this.shouldStop = false;
  this.removed = false;
  this.skipKeys = {};

  if (context) {
    this.context = context;
    this.state = context.state;
    this.opts = context.opts;
  }

  this.setScope();

  return this;
}

function resync() {
  if (this.removed) return;

  this._resyncParent();
  this._resyncList();
  this._resyncKey();
}

function _resyncParent() {
  if (this.parentPath) {
    this.parent = this.parentPath.node;
  }
}

function _resyncKey() {
  if (!this.container) return;

  if (this.node === this.container[this.key]) return;

  if (Array.isArray(this.container)) {
    for (var i = 0; i < this.container.length; i++) {
      if (this.container[i] === this.node) {
        return this.setKey(i);
      }
    }
  } else {
    for (var key in this.container) {
      if (this.container[key] === this.node) {
        return this.setKey(key);
      }
    }
  }

  this.key = null;
}

function _resyncList() {
  if (!this.parent || !this.inList) return;

  var newContainer = this.parent[this.listKey];
  if (this.container === newContainer) return;

  this.container = newContainer || null;
}

function _resyncRemoved() {
  if (this.key == null || !this.container || this.container[this.key] !== this.node) {
    this._markRemoved();
  }
}

function popContext() {
  this.contexts.pop();
  this.setContext(this.contexts[this.contexts.length - 1]);
}

function pushContext(context) {
  this.contexts.push(context);
  this.setContext(context);
}

function setup(parentPath, container, listKey, key) {
  this.inList = !!listKey;
  this.listKey = listKey;
  this.parentKey = listKey || key;
  this.container = container;

  this.parentPath = parentPath || this.parentPath;
  this.setKey(key);
}

function setKey(key) {
  this.key = key;
  this.node = this.container[this.key];
  this.type = this.node && this.node.type;
}

function requeue() {
  var pathToQueue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

  if (pathToQueue.removed) return;

  var contexts = this.contexts;

  for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var context = _ref2;

    context.maybeQueue(pathToQueue);
  }
}

function _getQueueContexts() {
  var path = this;
  var contexts = this.contexts;
  while (!contexts.length) {
    path = path.parentPath;
    contexts = path.contexts;
  }
  return contexts;
}

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.remove = remove;
exports._callRemovalHooks = _callRemovalHooks;
exports._remove = _remove;
exports._markRemoved = _markRemoved;
exports._assertUnremoved = _assertUnremoved;

var _removalHooks = __webpack_require__(379);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function remove() {
  this._assertUnremoved();

  this.resync();

  if (this._callRemovalHooks()) {
    this._markRemoved();
    return;
  }

  this.shareCommentsWithSiblings();
  this._remove();
  this._markRemoved();
}

function _callRemovalHooks() {
  for (var _iterator = _removalHooks.hooks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var fn = _ref;

    if (fn(this, this.parentPath)) return true;
  }
}

function _remove() {
  if (Array.isArray(this.container)) {
    this.container.splice(this.key, 1);
    this.updateSiblingKeys(this.key, -1);
  } else {
    this._replaceWith(null);
  }
}

function _markRemoved() {
  this.shouldSkip = true;
  this.removed = true;
  this.node = null;
}

function _assertUnremoved() {
  if (this.removed) {
    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
}

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var hooks = exports.hooks = [function (self, parent) {
  var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

  if (removeParent) {
    parent.remove();
    return true;
  }
}, function (self, parent) {
  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
    parent.replaceWith(parent.node.expressions[0]);
    return true;
  }
}, function (self, parent) {
  if (parent.isBinary()) {
    if (self.key === "left") {
      parent.replaceWith(parent.node.right);
    } else {
      parent.replaceWith(parent.node.left);
    }
    return true;
  }
}, function (self, parent) {
  if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
    self.replaceWith({
      type: "BlockStatement",
      body: []
    });
    return true;
  }
}];

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(17);

var _typeof3 = _interopRequireDefault(_typeof2);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.insertBefore = insertBefore;
exports._containerInsert = _containerInsert;
exports._containerInsertBefore = _containerInsertBefore;
exports._containerInsertAfter = _containerInsertAfter;
exports._maybePopFromStatements = _maybePopFromStatements;
exports.insertAfter = insertAfter;
exports.updateSiblingKeys = updateSiblingKeys;
exports._verifyNodeList = _verifyNodeList;
exports.unshiftContainer = unshiftContainer;
exports.pushContainer = pushContainer;
exports.hoist = hoist;

var _cache = __webpack_require__(65);

var _hoister = __webpack_require__(381);

var _hoister2 = _interopRequireDefault(_hoister);

var _index = __webpack_require__(24);

var _index2 = _interopRequireDefault(_index);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function insertBefore(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
    return this.parentPath.insertBefore(nodes);
  } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
    if (this.node) nodes.push(this.node);
    this.replaceExpressionWithStatements(nodes);
  } else {
    this._maybePopFromStatements(nodes);
    if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      if (this.node) nodes.push(this.node);
      this._replaceWith(t.blockStatement(nodes));
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }

  return [this];
}

function _containerInsert(from, nodes) {
  this.updateSiblingKeys(from, nodes.length);

  var paths = [];

  for (var i = 0; i < nodes.length; i++) {
    var to = from + i;
    var node = nodes[i];
    this.container.splice(to, 0, node);

    if (this.context) {
      var path = this.context.create(this.parent, this.container, to, this.listKey);

      if (this.context.queue) path.pushContext(this.context);
      paths.push(path);
    } else {
      paths.push(_index2.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key: to
      }));
    }
  }

  var contexts = this._getQueueContexts();

  for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _path = _ref;

    _path.setScope();
    _path.debug(function () {
      return "Inserted.";
    });

    for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var context = _ref2;

      context.maybeQueue(_path, true);
    }
  }

  return paths;
}

function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}

function _containerInsertAfter(nodes) {
  return this._containerInsert(this.key + 1, nodes);
}

function _maybePopFromStatements(nodes) {
  var last = nodes[nodes.length - 1];
  var isIdentifier = t.isIdentifier(last) || t.isExpressionStatement(last) && t.isIdentifier(last.expression);

  if (isIdentifier && !this.isCompletionRecord()) {
    nodes.pop();
  }
}

function insertAfter(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
    return this.parentPath.insertAfter(nodes);
  } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
    if (this.node) {
      var temp = this.scope.generateDeclaredUidIdentifier();
      nodes.unshift(t.expressionStatement(t.assignmentExpression("=", temp, this.node)));
      nodes.push(t.expressionStatement(temp));
    }
    this.replaceExpressionWithStatements(nodes);
  } else {
    this._maybePopFromStatements(nodes);
    if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      if (this.node) nodes.unshift(this.node);
      this._replaceWith(t.blockStatement(nodes));
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }

  return [this];
}

function updateSiblingKeys(fromIndex, incrementBy) {
  if (!this.parent) return;

  var paths = _cache.path.get(this.parent);
  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (path.key >= fromIndex) {
      path.key += incrementBy;
    }
  }
}

function _verifyNodeList(nodes) {
  if (!nodes) {
    return [];
  }

  if (nodes.constructor !== Array) {
    nodes = [nodes];
  }

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var msg = void 0;

    if (!node) {
      msg = "has falsy node";
    } else if ((typeof node === "undefined" ? "undefined" : (0, _typeof3.default)(node)) !== "object") {
      msg = "contains a non-object node";
    } else if (!node.type) {
      msg = "without a type";
    } else if (node instanceof _index2.default) {
      msg = "has a NodePath when it expected a raw object";
    }

    if (msg) {
      var type = Array.isArray(node) ? "array" : typeof node === "undefined" ? "undefined" : (0, _typeof3.default)(node);
      throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
    }
  }

  return nodes;
}

function unshiftContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  var path = _index2.default.get({
    parentPath: this,
    parent: this.node,
    container: this.node[listKey],
    listKey: listKey,
    key: 0
  });

  return path.insertBefore(nodes);
}

function pushContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  var container = this.node[listKey];
  var path = _index2.default.get({
    parentPath: this,
    parent: this.node,
    container: container,
    listKey: listKey,
    key: container.length
  });

  return path.replaceWithMultiple(nodes);
}

function hoist() {
  var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;

  var hoister = new _hoister2.default(this, scope);
  return hoister.run();
}

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var referenceVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (path.isJSXIdentifier() && _babelTypes.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
      return;
    }

    if (path.node.name === "this") {
      var scope = path.scope;
      do {
        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) break;
      } while (scope = scope.parent);
      if (scope) state.breakOnScopePaths.push(scope.path);
    }

    var binding = path.scope.getBinding(path.node.name);
    if (!binding) return;

    if (binding !== state.scope.getBinding(path.node.name)) return;

    state.bindings[path.node.name] = binding;
  }
};

var PathHoister = function () {
  function PathHoister(path, scope) {
    (0, _classCallCheck3.default)(this, PathHoister);

    this.breakOnScopePaths = [];

    this.bindings = {};

    this.scopes = [];

    this.scope = scope;
    this.path = path;

    this.attachAfter = false;
  }

  PathHoister.prototype.isCompatibleScope = function isCompatibleScope(scope) {
    for (var key in this.bindings) {
      var binding = this.bindings[key];
      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
        return false;
      }
    }

    return true;
  };

  PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {
    var scope = this.path.scope;
    do {
      if (this.isCompatibleScope(scope)) {
        this.scopes.push(scope);
      } else {
        break;
      }

      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
        break;
      }
    } while (scope = scope.parent);
  };

  PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {
    var path = this._getAttachmentPath();
    if (!path) return;

    var targetScope = path.scope;

    if (targetScope.path === path) {
      targetScope = path.scope.parent;
    }

    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
      for (var name in this.bindings) {
        if (!targetScope.hasOwnBinding(name)) continue;

        var binding = this.bindings[name];

        if (binding.kind === "param") continue;

        if (this.getAttachmentParentForPath(binding.path).key > path.key) {
          this.attachAfter = true;
          path = binding.path;

          for (var _iterator = binding.constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var violationPath = _ref;

            if (this.getAttachmentParentForPath(violationPath).key > path.key) {
              path = violationPath;
            }
          }
        }
      }
    }

    if (path.parentPath.isExportDeclaration()) {
      path = path.parentPath;
    }

    return path;
  };

  PathHoister.prototype._getAttachmentPath = function _getAttachmentPath() {
    var scopes = this.scopes;

    var scope = scopes.pop();

    if (!scope) return;

    if (scope.path.isFunction()) {
      if (this.hasOwnParamBindings(scope)) {
        if (this.scope === scope) return;

        return scope.path.get("body").get("body")[0];
      } else {
        return this.getNextScopeAttachmentParent();
      }
    } else if (scope.path.isProgram()) {
      return this.getNextScopeAttachmentParent();
    }
  };

  PathHoister.prototype.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
    var scope = this.scopes.pop();
    if (scope) return this.getAttachmentParentForPath(scope.path);
  };

  PathHoister.prototype.getAttachmentParentForPath = function getAttachmentParentForPath(path) {
    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement() || path.isVariableDeclarator() && path.parentPath.node !== null && path.parentPath.node.declarations.length > 1) return path;
    } while (path = path.parentPath);
  };

  PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(scope) {
    for (var name in this.bindings) {
      if (!scope.hasOwnBinding(name)) continue;

      var binding = this.bindings[name];

      if (binding.kind === "param" && binding.constant) return true;
    }
    return false;
  };

  PathHoister.prototype.run = function run() {
    var node = this.path.node;
    if (node._hoisted) return;
    node._hoisted = true;

    this.path.traverse(referenceVisitor, this);

    this.getCompatibleScopes();

    var attachTo = this.getAttachmentPath();
    if (!attachTo) return;

    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;

    var uid = attachTo.scope.generateUidIdentifier("ref");
    var declarator = t.variableDeclarator(uid, this.path.node);

    var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
    attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration("var", [declarator])]);

    var parent = this.path.parentPath;
    if (parent.isJSXElement() && this.path.container === parent.node.children) {
      uid = t.JSXExpressionContainer(uid);
    }

    this.path.replaceWith(uid);
  };

  return PathHoister;
}();

exports.default = PathHoister;
module.exports = exports["default"];

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _create = __webpack_require__(53);

var _create2 = _interopRequireDefault(_create);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.getStatementParent = getStatementParent;
exports.getOpposite = getOpposite;
exports.getCompletionRecords = getCompletionRecords;
exports.getSibling = getSibling;
exports.getPrevSibling = getPrevSibling;
exports.getNextSibling = getNextSibling;
exports.getAllNextSiblings = getAllNextSiblings;
exports.getAllPrevSiblings = getAllPrevSiblings;
exports.get = get;
exports._getKey = _getKey;
exports._getPattern = _getPattern;
exports.getBindingIdentifiers = getBindingIdentifiers;
exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;

var _index = __webpack_require__(24);

var _index2 = _interopRequireDefault(_index);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getStatementParent() {
  var path = this;

  do {
    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
      break;
    } else {
      path = path.parentPath;
    }
  } while (path);

  if (path && (path.isProgram() || path.isFile())) {
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  }

  return path;
}

function getOpposite() {
  if (this.key === "left") {
    return this.getSibling("right");
  } else if (this.key === "right") {
    return this.getSibling("left");
  }
}

function getCompletionRecords() {
  var paths = [];

  var add = function add(path) {
    if (path) paths = paths.concat(path.getCompletionRecords());
  };

  if (this.isIfStatement()) {
    add(this.get("consequent"));
    add(this.get("alternate"));
  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
    add(this.get("body"));
  } else if (this.isProgram() || this.isBlockStatement()) {
    add(this.get("body").pop());
  } else if (this.isFunction()) {
    return this.get("body").getCompletionRecords();
  } else if (this.isTryStatement()) {
    add(this.get("block"));
    add(this.get("handler"));
    add(this.get("finalizer"));
  } else {
    paths.push(this);
  }

  return paths;
}

function getSibling(key) {
  return _index2.default.get({
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: key
  });
}

function getPrevSibling() {
  return this.getSibling(this.key - 1);
}

function getNextSibling() {
  return this.getSibling(this.key + 1);
}

function getAllNextSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(++_key);
  var siblings = [];
  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(++_key);
  }
  return siblings;
}

function getAllPrevSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(--_key);
  var siblings = [];
  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(--_key);
  }
  return siblings;
}

function get(key, context) {
  if (context === true) context = this.context;
  var parts = key.split(".");
  if (parts.length === 1) {
    return this._getKey(key, context);
  } else {
    return this._getPattern(parts, context);
  }
}

function _getKey(key, context) {
  var _this = this;

  var node = this.node;
  var container = node[key];

  if (Array.isArray(container)) {
    return container.map(function (_, i) {
      return _index2.default.get({
        listKey: key,
        parentPath: _this,
        parent: node,
        container: container,
        key: i
      }).setContext(context);
    });
  } else {
    return _index2.default.get({
      parentPath: this,
      parent: node,
      container: node,
      key: key
    }).setContext(context);
  }
}

function _getPattern(parts, context) {
  var path = this;
  for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var part = _ref;

    if (part === ".") {
      path = path.parentPath;
    } else {
      if (Array.isArray(path)) {
        path = path[part];
      } else {
        path = path.get(part, context);
      }
    }
  }
  return path;
}

function getBindingIdentifiers(duplicates) {
  return t.getBindingIdentifiers(this.node, duplicates);
}

function getOuterBindingIdentifiers(duplicates) {
  return t.getOuterBindingIdentifiers(this.node, duplicates);
}

function getBindingIdentifierPaths() {
  var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var path = this;
  var search = [].concat(path);
  var ids = (0, _create2.default)(null);

  while (search.length) {
    var id = search.shift();
    if (!id) continue;
    if (!id.node) continue;

    var keys = t.getBindingIdentifiers.keys[id.node.type];

    if (id.isIdentifier()) {
      if (duplicates) {
        var _ids = ids[id.node.name] = ids[id.node.name] || [];
        _ids.push(id);
      } else {
        ids[id.node.name] = id;
      }
      continue;
    }

    if (id.isExportDeclaration()) {
      var declaration = id.get("declaration");
      if (declaration.isDeclaration()) {
        search.push(declaration);
      }
      continue;
    }

    if (outerOnly) {
      if (id.isFunctionDeclaration()) {
        search.push(id.get("id"));
        continue;
      }
      if (id.isFunctionExpression()) {
        continue;
      }
    }

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var child = id.get(key);
        if (Array.isArray(child) || child.node) {
          search = search.concat(child);
        }
      }
    }
  }

  return ids;
}

function getOuterBindingIdentifierPaths(duplicates) {
  return this.getBindingIdentifierPaths(duplicates, true);
}

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
exports.addComment = addComment;
exports.addComments = addComments;
function shareCommentsWithSiblings() {
  if (typeof this.key === "string") return;

  var node = this.node;
  if (!node) return;

  var trailing = node.trailingComments;
  var leading = node.leadingComments;
  if (!trailing && !leading) return;

  var prev = this.getSibling(this.key - 1);
  var next = this.getSibling(this.key + 1);

  if (!prev.node) prev = next;
  if (!next.node) next = prev;

  prev.addComments("trailing", leading);
  next.addComments("leading", trailing);
}

function addComment(type, content, line) {
  this.addComments(type, [{
    type: line ? "CommentLine" : "CommentBlock",
    value: content
  }]);
}

function addComments(type, comments) {
  if (!comments) return;

  var node = this.node;
  if (!node) return;

  var key = type + "Comments";

  if (node[key]) {
    node[key] = node[key].concat(comments);
  } else {
    node[key] = comments;
  }
}

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _path2 = __webpack_require__(24);

var _path3 = _interopRequireDefault(_path2);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var testing = process.env.NODE_ENV === "test";

var TraversalContext = function () {
  function TraversalContext(scope, opts, state, parentPath) {
    (0, _classCallCheck3.default)(this, TraversalContext);
    this.queue = null;

    this.parentPath = parentPath;
    this.scope = scope;
    this.state = state;
    this.opts = opts;
  }

  TraversalContext.prototype.shouldVisit = function shouldVisit(node) {
    var opts = this.opts;
    if (opts.enter || opts.exit) return true;

    if (opts[node.type]) return true;

    var keys = t.VISITOR_KEYS[node.type];
    if (!keys || !keys.length) return false;

    for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var key = _ref;

      if (node[key]) return true;
    }

    return false;
  };

  TraversalContext.prototype.create = function create(node, obj, key, listKey) {
    return _path3.default.get({
      parentPath: this.parentPath,
      parent: node,
      container: obj,
      key: key,
      listKey: listKey
    });
  };

  TraversalContext.prototype.maybeQueue = function maybeQueue(path, notPriority) {
    if (this.trap) {
      throw new Error("Infinite cycle detected");
    }

    if (this.queue) {
      if (notPriority) {
        this.queue.push(path);
      } else {
        this.priorityQueue.push(path);
      }
    }
  };

  TraversalContext.prototype.visitMultiple = function visitMultiple(container, parent, listKey) {
    if (container.length === 0) return false;

    var queue = [];

    for (var key = 0; key < container.length; key++) {
      var node = container[key];
      if (node && this.shouldVisit(node)) {
        queue.push(this.create(parent, container, key, listKey));
      }
    }

    return this.visitQueue(queue);
  };

  TraversalContext.prototype.visitSingle = function visitSingle(node, key) {
    if (this.shouldVisit(node[key])) {
      return this.visitQueue([this.create(node, node, key)]);
    } else {
      return false;
    }
  };

  TraversalContext.prototype.visitQueue = function visitQueue(queue) {
    this.queue = queue;
    this.priorityQueue = [];

    var visited = [];
    var stop = false;

    for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var path = _ref2;

      path.resync();

      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
        path.pushContext(this);
      }

      if (path.key === null) continue;

      if (testing && queue.length >= 10000) {
        this.trap = true;
      }

      if (visited.indexOf(path.node) >= 0) continue;
      visited.push(path.node);

      if (path.visit()) {
        stop = true;
        break;
      }

      if (this.priorityQueue.length) {
        stop = this.visitQueue(this.priorityQueue);
        this.priorityQueue = [];
        this.queue = queue;
        if (stop) break;
      }
    }

    for (var _iterator3 = queue, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var _path = _ref3;

      _path.popContext();
    }

    this.queue = null;

    return stop;
  };

  TraversalContext.prototype.visit = function visit(node, key) {
    var nodes = node[key];
    if (!nodes) return false;

    if (Array.isArray(nodes)) {
      return this.visitMultiple(nodes, node, key);
    } else {
      return this.visitSingle(node, key);
    }
  };

  return TraversalContext;
}();

exports.default = TraversalContext;
module.exports = exports["default"];

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(17);

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = __webpack_require__(29);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.explode = explode;
exports.verify = verify;
exports.merge = merge;

var _virtualTypes = __webpack_require__(128);

var virtualTypes = _interopRequireWildcard(_virtualTypes);

var _babelMessages = __webpack_require__(64);

var messages = _interopRequireWildcard(_babelMessages);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

var _clone = __webpack_require__(137);

var _clone2 = _interopRequireDefault(_clone);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function explode(visitor) {
  if (visitor._exploded) return visitor;
  visitor._exploded = true;

  for (var nodeType in visitor) {
    if (shouldIgnoreKey(nodeType)) continue;

    var parts = nodeType.split("|");
    if (parts.length === 1) continue;

    var fns = visitor[nodeType];
    delete visitor[nodeType];

    for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var part = _ref;

      visitor[part] = fns;
    }
  }

  verify(visitor);

  delete visitor.__esModule;

  ensureEntranceObjects(visitor);

  ensureCallbackArrays(visitor);

  for (var _iterator2 = (0, _keys2.default)(visitor), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var _nodeType3 = _ref2;

    if (shouldIgnoreKey(_nodeType3)) continue;

    var wrapper = virtualTypes[_nodeType3];
    if (!wrapper) continue;

    var _fns2 = visitor[_nodeType3];
    for (var type in _fns2) {
      _fns2[type] = wrapCheck(wrapper, _fns2[type]);
    }

    delete visitor[_nodeType3];

    if (wrapper.types) {
      for (var _iterator4 = wrapper.types, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var _type = _ref4;

        if (visitor[_type]) {
          mergePair(visitor[_type], _fns2);
        } else {
          visitor[_type] = _fns2;
        }
      }
    } else {
      mergePair(visitor, _fns2);
    }
  }

  for (var _nodeType in visitor) {
    if (shouldIgnoreKey(_nodeType)) continue;

    var _fns = visitor[_nodeType];

    var aliases = t.FLIPPED_ALIAS_KEYS[_nodeType];

    var deprecratedKey = t.DEPRECATED_KEYS[_nodeType];
    if (deprecratedKey) {
      console.trace("Visitor defined for " + _nodeType + " but it has been renamed to " + deprecratedKey);
      aliases = [deprecratedKey];
    }

    if (!aliases) continue;

    delete visitor[_nodeType];

    for (var _iterator3 = aliases, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var alias = _ref3;

      var existing = visitor[alias];
      if (existing) {
        mergePair(existing, _fns);
      } else {
        visitor[alias] = (0, _clone2.default)(_fns);
      }
    }
  }

  for (var _nodeType2 in visitor) {
    if (shouldIgnoreKey(_nodeType2)) continue;

    ensureCallbackArrays(visitor[_nodeType2]);
  }

  return visitor;
}

function verify(visitor) {
  if (visitor._verified) return;

  if (typeof visitor === "function") {
    throw new Error(messages.get("traverseVerifyRootFunction"));
  }

  for (var nodeType in visitor) {
    if (nodeType === "enter" || nodeType === "exit") {
      validateVisitorMethods(nodeType, visitor[nodeType]);
    }

    if (shouldIgnoreKey(nodeType)) continue;

    if (t.TYPES.indexOf(nodeType) < 0) {
      throw new Error(messages.get("traverseVerifyNodeType", nodeType));
    }

    var visitors = visitor[nodeType];
    if ((typeof visitors === "undefined" ? "undefined" : (0, _typeof3.default)(visitors)) === "object") {
      for (var visitorKey in visitors) {
        if (visitorKey === "enter" || visitorKey === "exit") {
          validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
        } else {
          throw new Error(messages.get("traverseVerifyVisitorProperty", nodeType, visitorKey));
        }
      }
    }
  }

  visitor._verified = true;
}

function validateVisitorMethods(path, val) {
  var fns = [].concat(val);
  for (var _iterator5 = fns, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
    var _ref5;

    if (_isArray5) {
      if (_i5 >= _iterator5.length) break;
      _ref5 = _iterator5[_i5++];
    } else {
      _i5 = _iterator5.next();
      if (_i5.done) break;
      _ref5 = _i5.value;
    }

    var fn = _ref5;

    if (typeof fn !== "function") {
      throw new TypeError("Non-function found defined in " + path + " with type " + (typeof fn === "undefined" ? "undefined" : (0, _typeof3.default)(fn)));
    }
  }
}

function merge(visitors) {
  var states = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var wrapper = arguments[2];

  var rootVisitor = {};

  for (var i = 0; i < visitors.length; i++) {
    var visitor = visitors[i];
    var state = states[i];

    explode(visitor);

    for (var type in visitor) {
      var visitorType = visitor[type];

      if (state || wrapper) {
        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
      }

      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
      mergePair(nodeVisitor, visitorType);
    }
  }

  return rootVisitor;
}

function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
  var newVisitor = {};

  var _loop = function _loop(key) {
    var fns = oldVisitor[key];

    if (!Array.isArray(fns)) return "continue";

    fns = fns.map(function (fn) {
      var newFn = fn;

      if (state) {
        newFn = function newFn(path) {
          return fn.call(state, path, state);
        };
      }

      if (wrapper) {
        newFn = wrapper(state.key, key, newFn);
      }

      return newFn;
    });

    newVisitor[key] = fns;
  };

  for (var key in oldVisitor) {
    var _ret = _loop(key);

    if (_ret === "continue") continue;
  }

  return newVisitor;
}

function ensureEntranceObjects(obj) {
  for (var key in obj) {
    if (shouldIgnoreKey(key)) continue;

    var fns = obj[key];
    if (typeof fns === "function") {
      obj[key] = { enter: fns };
    }
  }
}

function ensureCallbackArrays(obj) {
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
}

function wrapCheck(wrapper, fn) {
  var newFn = function newFn(path) {
    if (wrapper.checkPath(path)) {
      return fn.apply(this, arguments);
    }
  };
  newFn.toString = function () {
    return fn.toString();
  };
  return newFn;
}

function shouldIgnoreKey(key) {
  if (key[0] === "_") return true;

  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

  if (key === "blacklist" || key === "noScope" || key === "skipKeys") return true;

  return false;
}

function mergePair(dest, src) {
  for (var key in src) {
    dest[key] = [].concat(dest[key] || [], src[key]);
  }
}

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.CodeGenerator = undefined;

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(387);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(388);

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = function (ast, opts, code) {
  var gen = new Generator(ast, opts, code);
  return gen.generate();
};

var _detectIndent = __webpack_require__(393);

var _detectIndent2 = _interopRequireDefault(_detectIndent);

var _sourceMap = __webpack_require__(397);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _babelMessages = __webpack_require__(64);

var messages = _interopRequireWildcard(_babelMessages);

var _printer = __webpack_require__(405);

var _printer2 = _interopRequireDefault(_printer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Generator = function (_Printer) {
  (0, _inherits3.default)(Generator, _Printer);

  function Generator(ast) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var code = arguments[2];
    (0, _classCallCheck3.default)(this, Generator);

    var tokens = ast.tokens || [];
    var format = normalizeOptions(code, opts, tokens);
    var map = opts.sourceMaps ? new _sourceMap2.default(opts, code) : null;

    var _this = (0, _possibleConstructorReturn3.default)(this, _Printer.call(this, format, map, tokens));

    _this.ast = ast;
    return _this;
  }

  Generator.prototype.generate = function generate() {
    return _Printer.prototype.generate.call(this, this.ast);
  };

  return Generator;
}(_printer2.default);

function normalizeOptions(code, opts, tokens) {
  var style = "  ";
  if (code && typeof code === "string") {
    var indent = (0, _detectIndent2.default)(code).indent;
    if (indent && indent !== " ") style = indent;
  }

  var format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    retainFunctionParens: opts.retainFunctionParens,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    quotes: opts.quotes || findCommonStringDelimiter(code, tokens),
    jsonCompatibleStrings: opts.jsonCompatibleStrings,
    indent: {
      adjustMultilineComment: true,
      style: style,
      base: 0
    },
    flowCommaSeparator: opts.flowCommaSeparator
  };

  if (format.minified) {
    format.compact = true;

    format.shouldPrintComment = format.shouldPrintComment || function () {
      return format.comments;
    };
  } else {
    format.shouldPrintComment = format.shouldPrintComment || function (value) {
      return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
    };
  }

  if (format.compact === "auto") {
    format.compact = code.length > 500000;

    if (format.compact) {
      console.error("[BABEL] " + messages.get("codeGeneratorDeopt", opts.filename, "500KB"));
    }
  }

  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }

  return format;
}

function findCommonStringDelimiter(code, tokens) {
  var DEFAULT_STRING_DELIMITER = "double";
  if (!code) {
    return DEFAULT_STRING_DELIMITER;
  }

  var occurrences = {
    single: 0,
    double: 0
  };

  var checked = 0;

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (token.type.label !== "string") continue;

    var raw = code.slice(token.start, token.end);
    if (raw[0] === "'") {
      occurrences.single++;
    } else {
      occurrences.double++;
    }

    checked++;
    if (checked >= 3) break;
  }
  if (occurrences.single > occurrences.double) {
    return "single";
  } else {
    return "double";
  }
}

var CodeGenerator = exports.CodeGenerator = function () {
  function CodeGenerator(ast, opts, code) {
    (0, _classCallCheck3.default)(this, CodeGenerator);

    this._generator = new Generator(ast, opts, code);
  }

  CodeGenerator.prototype.generate = function generate() {
    return this._generator.generate();
  };

  return CodeGenerator;
}();

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(17);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(389);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(53);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(17);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(390), __esModule: true };

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(391);
module.exports = __webpack_require__(2).Object.setPrototypeOf;


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(4);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(392).set });


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(5);
var anObject = __webpack_require__(12);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(28)(Function.call, __webpack_require__(131).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable guard-for-in */

var repeating = __webpack_require__(394);

// detect either spaces or tabs but not both to properly handle tabs
// for indentation and spaces for alignment
var INDENT_RE = /^(?:( )+|\t+)/;

function getMostUsed(indents) {
	var result = 0;
	var maxUsed = 0;
	var maxWeight = 0;

	for (var n in indents) {
		var indent = indents[n];
		var u = indent[0];
		var w = indent[1];

		if (u > maxUsed || u === maxUsed && w > maxWeight) {
			maxUsed = u;
			maxWeight = w;
			result = Number(n);
		}
	}

	return result;
}

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	// used to see if tabs or spaces are the most used
	var tabs = 0;
	var spaces = 0;

	// remember the size of previous line's indentation
	var prev = 0;

	// remember how many indents/unindents as occurred for a given size
	// and how much lines follow a given indentation
	//
	// indents = {
	//    3: [1, 0],
	//    4: [1, 5],
	//    5: [1, 0],
	//   12: [1, 0],
	// }
	var indents = {};

	// pointer to the array of last used indent
	var current;

	// whether the last action was an indent (opposed to an unindent)
	var isIndent;

	str.split(/\n/g).forEach(function (line) {
		if (!line) {
			// ignore empty lines
			return;
		}

		var indent;
		var matches = line.match(INDENT_RE);

		if (!matches) {
			indent = 0;
		} else {
			indent = matches[0].length;

			if (matches[1]) {
				spaces++;
			} else {
				tabs++;
			}
		}

		var diff = indent - prev;
		prev = indent;

		if (diff) {
			// an indent or unindent has been detected

			isIndent = diff > 0;

			current = indents[isIndent ? diff : -diff];

			if (current) {
				current[0]++;
			} else {
				current = indents[diff] = [1, 0];
			}
		} else if (current) {
			// if the last action was an indent, increment the weight
			current[1] += Number(isIndent);
		}
	});

	var amount = getMostUsed(indents);

	var type;
	var actual;
	if (!amount) {
		type = null;
		actual = '';
	} else if (spaces >= tabs) {
		type = 'space';
		actual = repeating(' ', amount);
	} else {
		type = 'tab';
		actual = repeating('\t', amount);
	}

	return {
		amount: amount,
		type: type,
		indent: actual
	};
};


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isFinite = __webpack_require__(395);

module.exports = function (str, n) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected `input` to be a string');
	}

	if (n < 0 || !isFinite(n)) {
		throw new TypeError('Expected `count` to be a positive finite number');
	}

	var ret = '';

	do {
		if (n & 1) {
			ret += str;
		}

		str += str;
	} while ((n >>= 1));

	return ret;
};


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var numberIsNan = __webpack_require__(396);

module.exports = Number.isFinite || function (val) {
	return !(typeof val !== 'number' || numberIsNan(val) || val === Infinity || val === -Infinity);
};


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Number.isNaN || function (x) {
	return x !== x;
};


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _keys = __webpack_require__(29);

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __webpack_require__(17);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _sourceMap = __webpack_require__(398);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SourceMap = function () {
  function SourceMap(opts, code) {
    (0, _classCallCheck3.default)(this, SourceMap);

    this._cachedMap = null;
    this._code = code;
    this._opts = opts;
    this._rawMappings = [];
  }

  SourceMap.prototype.get = function get() {
    if (!this._cachedMap) {
      var map = this._cachedMap = new _sourceMap2.default.SourceMapGenerator({
        file: this._opts.sourceMapTarget,
        sourceRoot: this._opts.sourceRoot
      });

      var code = this._code;
      if (typeof code === "string") {
        map.setSourceContent(this._opts.sourceFileName, code);
      } else if ((typeof code === "undefined" ? "undefined" : (0, _typeof3.default)(code)) === "object") {
        (0, _keys2.default)(code).forEach(function (sourceFileName) {
          map.setSourceContent(sourceFileName, code[sourceFileName]);
        });
      }

      this._rawMappings.forEach(map.addMapping, map);
    }

    return this._cachedMap.toJSON();
  };

  SourceMap.prototype.getRawMappings = function getRawMappings() {
    return this._rawMappings.slice();
  };

  SourceMap.prototype.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename) {
    if (this._lastGenLine !== generatedLine && line === null) return;

    if (this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
      return;
    }

    this._cachedMap = null;
    this._lastGenLine = generatedLine;
    this._lastSourceLine = line;
    this._lastSourceColumn = column;

    this._rawMappings.push({
      name: identifierName || undefined,
      generated: {
        line: generatedLine,
        column: generatedColumn
      },
      source: line == null ? undefined : filename || this._opts.sourceFileName,
      original: line == null ? undefined : {
        line: line,
        column: column
      }
    });
  };

  return SourceMap;
}();

exports.default = SourceMap;
module.exports = exports["default"];

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(165).SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(401).SourceMapConsumer;
exports.SourceNode = __webpack_require__(404).SourceNode;


/***/ }),
/* 399 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(43);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(43);
var binarySearch = __webpack_require__(402);
var ArraySet = __webpack_require__(167).ArraySet;
var base64VLQ = __webpack_require__(166);
var quickSort = __webpack_require__(403).quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),
/* 402 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),
/* 403 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(165).SourceMapGenerator;
var util = __webpack_require__(43);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(406);

var _assign2 = _interopRequireDefault(_assign);

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = __webpack_require__(35);

var _stringify2 = _interopRequireDefault(_stringify);

var _weakSet = __webpack_require__(409);

var _weakSet2 = _interopRequireDefault(_weakSet);

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _find = __webpack_require__(414);

var _find2 = _interopRequireDefault(_find);

var _findLast = __webpack_require__(435);

var _findLast2 = _interopRequireDefault(_findLast);

var _isInteger = __webpack_require__(437);

var _isInteger2 = _interopRequireDefault(_isInteger);

var _repeat = __webpack_require__(158);

var _repeat2 = _interopRequireDefault(_repeat);

var _buffer = __webpack_require__(438);

var _buffer2 = _interopRequireDefault(_buffer);

var _node = __webpack_require__(175);

var n = _interopRequireWildcard(_node);

var _whitespace = __webpack_require__(449);

var _whitespace2 = _interopRequireDefault(_whitespace);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SCIENTIFIC_NOTATION = /e/i;
var ZERO_DECIMAL_INTEGER = /\.0+$/;
var NON_DECIMAL_LITERAL = /^0[box]/;

var Printer = function () {
  function Printer(format, map, tokens) {
    (0, _classCallCheck3.default)(this, Printer);
    this.inForStatementInitCounter = 0;
    this._printStack = [];
    this._indent = 0;
    this._insideAux = false;
    this._printedCommentStarts = {};
    this._parenPushNewlineState = null;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new _weakSet2.default();
    this._endsWithInteger = false;
    this._endsWithWord = false;

    this.format = format || {};
    this._buf = new _buffer2.default(map);
    this._whitespace = tokens.length > 0 ? new _whitespace2.default(tokens) : null;
  }

  Printer.prototype.generate = function generate(ast) {
    this.print(ast);
    this._maybeAddAuxComment();

    return this._buf.get();
  };

  Printer.prototype.indent = function indent() {
    if (this.format.compact || this.format.concise) return;

    this._indent++;
  };

  Printer.prototype.dedent = function dedent() {
    if (this.format.compact || this.format.concise) return;

    this._indent--;
  };

  Printer.prototype.semicolon = function semicolon() {
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this._maybeAddAuxComment();
    this._append(";", !force);
  };

  Printer.prototype.rightBrace = function rightBrace() {
    if (this.format.minified) {
      this._buf.removeLastSemicolon();
    }
    this.token("}");
  };

  Printer.prototype.space = function space() {
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (this.format.compact) return;

    if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
      this._space();
    }
  };

  Printer.prototype.word = function word(str) {
    if (this._endsWithWord) this._space();

    this._maybeAddAuxComment();
    this._append(str);

    this._endsWithWord = true;
  };

  Printer.prototype.number = function number(str) {
    this.word(str);

    this._endsWithInteger = (0, _isInteger2.default)(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
  };

  Printer.prototype.token = function token(str) {
    if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
      this._space();
    }

    this._maybeAddAuxComment();
    this._append(str);
  };

  Printer.prototype.newline = function newline(i) {
    if (this.format.retainLines || this.format.compact) return;

    if (this.format.concise) {
      this.space();
      return;
    }

    if (this.endsWith("\n\n")) return;

    if (typeof i !== "number") i = 1;

    i = Math.min(2, i);
    if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
    if (i <= 0) return;

    for (var j = 0; j < i; j++) {
      this._newline();
    }
  };

  Printer.prototype.endsWith = function endsWith(str) {
    return this._buf.endsWith(str);
  };

  Printer.prototype.removeTrailingNewline = function removeTrailingNewline() {
    this._buf.removeTrailingNewline();
  };

  Printer.prototype.source = function source(prop, loc) {
    this._catchUp(prop, loc);

    this._buf.source(prop, loc);
  };

  Printer.prototype.withSource = function withSource(prop, loc, cb) {
    this._catchUp(prop, loc);

    this._buf.withSource(prop, loc, cb);
  };

  Printer.prototype._space = function _space() {
    this._append(" ", true);
  };

  Printer.prototype._newline = function _newline() {
    this._append("\n", true);
  };

  Printer.prototype._append = function _append(str) {
    var queue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    this._maybeAddParen(str);
    this._maybeIndent(str);

    if (queue) this._buf.queue(str);else this._buf.append(str);

    this._endsWithWord = false;
    this._endsWithInteger = false;
  };

  Printer.prototype._maybeIndent = function _maybeIndent(str) {
    if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
      this._buf.queue(this._getIndent());
    }
  };

  Printer.prototype._maybeAddParen = function _maybeAddParen(str) {
    var parenPushNewlineState = this._parenPushNewlineState;
    if (!parenPushNewlineState) return;
    this._parenPushNewlineState = null;

    var i = void 0;
    for (i = 0; i < str.length && str[i] === " "; i++) {
      continue;
    }if (i === str.length) return;

    var cha = str[i];
    if (cha === "\n" || cha === "/") {
      this.token("(");
      this.indent();
      parenPushNewlineState.printed = true;
    }
  };

  Printer.prototype._catchUp = function _catchUp(prop, loc) {
    if (!this.format.retainLines) return;

    var pos = loc ? loc[prop] : null;
    if (pos && pos.line !== null) {
      var count = pos.line - this._buf.getCurrentLine();

      for (var i = 0; i < count; i++) {
        this._newline();
      }
    }
  };

  Printer.prototype._getIndent = function _getIndent() {
    return (0, _repeat2.default)(this.format.indent.style, this._indent);
  };

  Printer.prototype.startTerminatorless = function startTerminatorless() {
    return this._parenPushNewlineState = {
      printed: false
    };
  };

  Printer.prototype.endTerminatorless = function endTerminatorless(state) {
    if (state.printed) {
      this.dedent();
      this.newline();
      this.token(")");
    }
  };

  Printer.prototype.print = function print(node, parent) {
    var _this = this;

    if (!node) return;

    var oldConcise = this.format.concise;
    if (node._compact) {
      this.format.concise = true;
    }

    var printMethod = this[node.type];
    if (!printMethod) {
      throw new ReferenceError("unknown node of type " + (0, _stringify2.default)(node.type) + " with constructor " + (0, _stringify2.default)(node && node.constructor.name));
    }

    this._printStack.push(node);

    var oldInAux = this._insideAux;
    this._insideAux = !node.loc;
    this._maybeAddAuxComment(this._insideAux && !oldInAux);

    var needsParens = n.needsParens(node, parent, this._printStack);
    if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
      needsParens = true;
    }
    if (needsParens) this.token("(");

    this._printLeadingComments(node, parent);

    var loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;
    this.withSource("start", loc, function () {
      _this[node.type](node, parent);
    });

    this._printTrailingComments(node, parent);

    if (needsParens) this.token(")");

    this._printStack.pop();

    this.format.concise = oldConcise;
    this._insideAux = oldInAux;
  };

  Printer.prototype._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {
    if (enteredPositionlessNode) this._printAuxBeforeComment();
    if (!this._insideAux) this._printAuxAfterComment();
  };

  Printer.prototype._printAuxBeforeComment = function _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = true;

    var comment = this.format.auxiliaryCommentBefore;
    if (comment) {
      this._printComment({
        type: "CommentBlock",
        value: comment
      });
    }
  };

  Printer.prototype._printAuxAfterComment = function _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = false;

    var comment = this.format.auxiliaryCommentAfter;
    if (comment) {
      this._printComment({
        type: "CommentBlock",
        value: comment
      });
    }
  };

  Printer.prototype.getPossibleRaw = function getPossibleRaw(node) {
    var extra = node.extra;
    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
      return extra.raw;
    }
  };

  Printer.prototype.printJoin = function printJoin(nodes, parent) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!nodes || !nodes.length) return;

    if (opts.indent) this.indent();

    var newlineOpts = {
      addNewlines: opts.addNewlines
    };

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;

      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);

      this.print(node, parent);

      if (opts.iterator) {
        opts.iterator(node, i);
      }

      if (opts.separator && i < nodes.length - 1) {
        opts.separator.call(this);
      }

      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
    }

    if (opts.indent) this.dedent();
  };

  Printer.prototype.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {
    var indent = !!node.leadingComments;
    if (indent) this.indent();
    this.print(node, parent);
    if (indent) this.dedent();
  };

  Printer.prototype.printBlock = function printBlock(parent) {
    var node = parent.body;

    if (!t.isEmptyStatement(node)) {
      this.space();
    }

    this.print(node, parent);
  };

  Printer.prototype._printTrailingComments = function _printTrailingComments(node, parent) {
    this._printComments(this._getComments(false, node, parent));
  };

  Printer.prototype._printLeadingComments = function _printLeadingComments(node, parent) {
    this._printComments(this._getComments(true, node, parent));
  };

  Printer.prototype.printInnerComments = function printInnerComments(node) {
    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (!node.innerComments) return;
    if (indent) this.indent();
    this._printComments(node.innerComments);
    if (indent) this.dedent();
  };

  Printer.prototype.printSequence = function printSequence(nodes, parent) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    opts.statement = true;
    return this.printJoin(nodes, parent, opts);
  };

  Printer.prototype.printList = function printList(items, parent) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (opts.separator == null) {
      opts.separator = commaSeparator;
    }

    return this.printJoin(items, parent, opts);
  };

  Printer.prototype._printNewline = function _printNewline(leading, node, parent, opts) {
    var _this2 = this;

    if (this.format.retainLines || this.format.compact) return;

    if (this.format.concise) {
      this.space();
      return;
    }

    var lines = 0;

    if (node.start != null && !node._ignoreUserWhitespace && this._whitespace) {
      if (leading) {
        var _comments = node.leadingComments;
        var _comment = _comments && (0, _find2.default)(_comments, function (comment) {
          return !!comment.loc && _this2.format.shouldPrintComment(comment.value);
        });

        lines = this._whitespace.getNewlinesBefore(_comment || node);
      } else {
        var _comments2 = node.trailingComments;
        var _comment2 = _comments2 && (0, _findLast2.default)(_comments2, function (comment) {
          return !!comment.loc && _this2.format.shouldPrintComment(comment.value);
        });

        lines = this._whitespace.getNewlinesAfter(_comment2 || node);
      }
    } else {
      if (!leading) lines++;
      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;

      var needs = n.needsWhitespaceAfter;
      if (leading) needs = n.needsWhitespaceBefore;
      if (needs(node, parent)) lines++;

      if (!this._buf.hasContent()) lines = 0;
    }

    this.newline(lines);
  };

  Printer.prototype._getComments = function _getComments(leading, node) {
    return node && (leading ? node.leadingComments : node.trailingComments) || [];
  };

  Printer.prototype._printComment = function _printComment(comment) {
    var _this3 = this;

    if (!this.format.shouldPrintComment(comment.value)) return;

    if (comment.ignore) return;

    if (this._printedComments.has(comment)) return;
    this._printedComments.add(comment);

    if (comment.start != null) {
      if (this._printedCommentStarts[comment.start]) return;
      this._printedCommentStarts[comment.start] = true;
    }

    this.newline(this._whitespace ? this._whitespace.getNewlinesBefore(comment) : 0);

    if (!this.endsWith("[") && !this.endsWith("{")) this.space();

    var val = comment.type === "CommentLine" ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

    if (comment.type === "CommentBlock" && this.format.indent.adjustMultilineComment) {
      var offset = comment.loc && comment.loc.start.column;
      if (offset) {
        var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
        val = val.replace(newlineRegex, "\n");
      }

      var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
      val = val.replace(/\n(?!$)/g, "\n" + (0, _repeat2.default)(" ", indentSize));
    }

    this.withSource("start", comment.loc, function () {
      _this3._append(val);
    });

    this.newline((this._whitespace ? this._whitespace.getNewlinesAfter(comment) : 0) + (comment.type === "CommentLine" ? -1 : 0));
  };

  Printer.prototype._printComments = function _printComments(comments) {
    if (!comments || !comments.length) return;

    for (var _iterator = comments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _comment3 = _ref;

      this._printComment(_comment3);
    }
  };

  return Printer;
}();

exports.default = Printer;


function commaSeparator() {
  this.token(",");
  this.space();
}

var _arr = [__webpack_require__(450), __webpack_require__(451), __webpack_require__(452), __webpack_require__(453), __webpack_require__(454), __webpack_require__(455), __webpack_require__(115), __webpack_require__(457), __webpack_require__(458), __webpack_require__(459)];
for (var _i2 = 0; _i2 < _arr.length; _i2++) {
  var generator = _arr[_i2];
  (0, _assign2.default)(Printer.prototype, generator);
}
module.exports = exports["default"];

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(407), __esModule: true };

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(408);
module.exports = __webpack_require__(2).Object.assign;


/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(4);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(161) });


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(410), __esModule: true };

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54);
__webpack_require__(31);
__webpack_require__(411);
__webpack_require__(412);
__webpack_require__(413);
module.exports = __webpack_require__(2).WeakSet;


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(162);
var validate = __webpack_require__(41);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(108)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(110)('WeakSet');


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(111)('WeakSet');


/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

var createFind = __webpack_require__(168),
    findIndex = __webpack_require__(434);

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(416),
    getMatchData = __webpack_require__(422),
    matchesStrictComparable = __webpack_require__(172);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(91),
    baseIsEqual = __webpack_require__(169);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(91),
    equalArrays = __webpack_require__(170),
    equalByTag = __webpack_require__(419),
    equalObjects = __webpack_require__(421),
    getTag = __webpack_require__(62),
    isArray = __webpack_require__(7),
    isBuffer = __webpack_require__(95),
    isTypedArray = __webpack_require__(144);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 418 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(36),
    Uint8Array = __webpack_require__(151),
    eq = __webpack_require__(38),
    equalArrays = __webpack_require__(170),
    mapToArray = __webpack_require__(420),
    setToArray = __webpack_require__(102);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 420 */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(148);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(171),
    keys = __webpack_require__(20);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(169),
    get = __webpack_require__(424),
    hasIn = __webpack_require__(428),
    isKey = __webpack_require__(114),
    isStrictComparable = __webpack_require__(171),
    matchesStrictComparable = __webpack_require__(172),
    toKey = __webpack_require__(67);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(173);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(426);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(427);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(93);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(429),
    hasPath = __webpack_require__(430);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 429 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(174),
    isArguments = __webpack_require__(143),
    isArray = __webpack_require__(7),
    isIndex = __webpack_require__(96),
    isLength = __webpack_require__(97),
    toKey = __webpack_require__(67);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(432),
    basePropertyDeep = __webpack_require__(433),
    isKey = __webpack_require__(114),
    toKey = __webpack_require__(67);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),
/* 432 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(173);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(101),
    baseIteratee = __webpack_require__(66),
    toInteger = __webpack_require__(42);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

var createFind = __webpack_require__(168),
    findLastIndex = __webpack_require__(436);

/**
 * This method is like `_.find` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * _.findLast([1, 2, 3, 4], function(n) {
 *   return n % 2 == 1;
 * });
 * // => 3
 */
var findLast = createFind(findLastIndex);

module.exports = findLast;


/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(101),
    baseIteratee = __webpack_require__(66),
    toInteger = __webpack_require__(42);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = fromIndex < 0
      ? nativeMax(length + index, 0)
      : nativeMin(index, length - 1);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);
}

module.exports = findLastIndex;


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(42);

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function isInteger(value) {
  return typeof value == 'number' && value == toInteger(value);
}

module.exports = isInteger;


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _trimRight = __webpack_require__(439);

var _trimRight2 = _interopRequireDefault(_trimRight);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SPACES_RE = /^[ \t]+$/;

var Buffer = function () {
  function Buffer(map) {
    (0, _classCallCheck3.default)(this, Buffer);
    this._map = null;
    this._buf = [];
    this._last = "";
    this._queue = [];
    this._position = {
      line: 1,
      column: 0
    };
    this._sourcePosition = {
      identifierName: null,
      line: null,
      column: null,
      filename: null
    };

    this._map = map;
  }

  Buffer.prototype.get = function get() {
    this._flush();

    var map = this._map;
    var result = {
      code: (0, _trimRight2.default)(this._buf.join("")),
      map: null,
      rawMappings: map && map.getRawMappings()
    };

    if (map) {
      Object.defineProperty(result, "map", {
        configurable: true,
        enumerable: true,
        get: function get() {
          return this.map = map.get();
        },
        set: function set(value) {
          Object.defineProperty(this, "map", { value: value, writable: true });
        }
      });
    }

    return result;
  };

  Buffer.prototype.append = function append(str) {
    this._flush();
    var _sourcePosition = this._sourcePosition,
        line = _sourcePosition.line,
        column = _sourcePosition.column,
        filename = _sourcePosition.filename,
        identifierName = _sourcePosition.identifierName;

    this._append(str, line, column, identifierName, filename);
  };

  Buffer.prototype.queue = function queue(str) {
    if (str === "\n") while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
      this._queue.shift();
    }var _sourcePosition2 = this._sourcePosition,
        line = _sourcePosition2.line,
        column = _sourcePosition2.column,
        filename = _sourcePosition2.filename,
        identifierName = _sourcePosition2.identifierName;

    this._queue.unshift([str, line, column, identifierName, filename]);
  };

  Buffer.prototype._flush = function _flush() {
    var item = void 0;
    while (item = this._queue.pop()) {
      this._append.apply(this, item);
    }
  };

  Buffer.prototype._append = function _append(str, line, column, identifierName, filename) {
    if (this._map && str[0] !== "\n") {
      this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename);
    }

    this._buf.push(str);
    this._last = str[str.length - 1];

    for (var i = 0; i < str.length; i++) {
      if (str[i] === "\n") {
        this._position.line++;
        this._position.column = 0;
      } else {
        this._position.column++;
      }
    }
  };

  Buffer.prototype.removeTrailingNewline = function removeTrailingNewline() {
    if (this._queue.length > 0 && this._queue[0][0] === "\n") this._queue.shift();
  };

  Buffer.prototype.removeLastSemicolon = function removeLastSemicolon() {
    if (this._queue.length > 0 && this._queue[0][0] === ";") this._queue.shift();
  };

  Buffer.prototype.endsWith = function endsWith(suffix) {
    if (suffix.length === 1) {
      var last = void 0;
      if (this._queue.length > 0) {
        var str = this._queue[0][0];
        last = str[str.length - 1];
      } else {
        last = this._last;
      }

      return last === suffix;
    }

    var end = this._last + this._queue.reduce(function (acc, item) {
      return item[0] + acc;
    }, "");
    if (suffix.length <= end.length) {
      return end.slice(-suffix.length) === suffix;
    }

    return false;
  };

  Buffer.prototype.hasContent = function hasContent() {
    return this._queue.length > 0 || !!this._last;
  };

  Buffer.prototype.source = function source(prop, loc) {
    if (prop && !loc) return;

    var pos = loc ? loc[prop] : null;

    this._sourcePosition.identifierName = loc && loc.identifierName || null;
    this._sourcePosition.line = pos ? pos.line : null;
    this._sourcePosition.column = pos ? pos.column : null;
    this._sourcePosition.filename = loc && loc.filename || null;
  };

  Buffer.prototype.withSource = function withSource(prop, loc, cb) {
    if (!this._map) return cb();

    var originalLine = this._sourcePosition.line;
    var originalColumn = this._sourcePosition.column;
    var originalFilename = this._sourcePosition.filename;
    var originalIdentifierName = this._sourcePosition.identifierName;

    this.source(prop, loc);

    cb();

    this._sourcePosition.line = originalLine;
    this._sourcePosition.column = originalColumn;
    this._sourcePosition.filename = originalFilename;
    this._sourcePosition.identifierName = originalIdentifierName;
  };

  Buffer.prototype.getCurrentColumn = function getCurrentColumn() {
    var extra = this._queue.reduce(function (acc, item) {
      return item[0] + acc;
    }, "");
    var lastIndex = extra.lastIndexOf("\n");

    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
  };

  Buffer.prototype.getCurrentLine = function getCurrentLine() {
    var extra = this._queue.reduce(function (acc, item) {
      return item[0] + acc;
    }, "");

    var count = 0;
    for (var i = 0; i < extra.length; i++) {
      if (extra[i] === "\n") count++;
    }

    return this._position.line + count;
  };

  return Buffer;
}();

exports.default = Buffer;
module.exports = exports["default"];

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (str) {
	var tail = str.length;

	while (/[\s\uFEFF\u00A0]/.test(str[tail - 1])) {
		tail--;
	}

	return str.slice(0, tail);
};


/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _map = __webpack_require__(441);

var _map2 = _interopRequireDefault(_map);

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function crawl(node) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (t.isMemberExpression(node)) {
    crawl(node.object, state);
    if (node.computed) crawl(node.property, state);
  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
    crawl(node.left, state);
    crawl(node.right, state);
  } else if (t.isCallExpression(node)) {
    state.hasCall = true;
    crawl(node.callee, state);
  } else if (t.isFunction(node)) {
    state.hasFunction = true;
  } else if (t.isIdentifier(node)) {
    state.hasHelper = state.hasHelper || isHelper(node.callee);
  }

  return state;
}

function isHelper(node) {
  if (t.isMemberExpression(node)) {
    return isHelper(node.object) || isHelper(node.property);
  } else if (t.isIdentifier(node)) {
    return node.name === "require" || node.name[0] === "_";
  } else if (t.isCallExpression(node)) {
    return isHelper(node.callee);
  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
  } else {
    return false;
  }
}

function isType(node) {
  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);
}

exports.nodes = {
  AssignmentExpression: function AssignmentExpression(node) {
    var state = crawl(node.right);
    if (state.hasCall && state.hasHelper || state.hasFunction) {
      return {
        before: state.hasFunction,
        after: true
      };
    }
  },
  SwitchCase: function SwitchCase(node, parent) {
    return {
      before: node.consequent.length || parent.cases[0] === node
    };
  },
  LogicalExpression: function LogicalExpression(node) {
    if (t.isFunction(node.left) || t.isFunction(node.right)) {
      return {
        after: true
      };
    }
  },
  Literal: function Literal(node) {
    if (node.value === "use strict") {
      return {
        after: true
      };
    }
  },
  CallExpression: function CallExpression(node) {
    if (t.isFunction(node.callee) || isHelper(node)) {
      return {
        before: true,
        after: true
      };
    }
  },
  VariableDeclaration: function VariableDeclaration(node) {
    for (var i = 0; i < node.declarations.length; i++) {
      var declar = node.declarations[i];

      var enabled = isHelper(declar.id) && !isType(declar.init);
      if (!enabled) {
        var state = crawl(declar.init);
        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
      }

      if (enabled) {
        return {
          before: true,
          after: true
        };
      }
    }
  },
  IfStatement: function IfStatement(node) {
    if (t.isBlockStatement(node.consequent)) {
      return {
        before: true,
        after: true
      };
    }
  }
};

exports.nodes.ObjectProperty = exports.nodes.ObjectTypeProperty = exports.nodes.ObjectMethod = exports.nodes.SpreadProperty = function (node, parent) {
  if (parent.properties[0] === node) {
    return {
      before: true
    };
  }
};

exports.list = {
  VariableDeclaration: function VariableDeclaration(node) {
    return (0, _map2.default)(node.declarations, "init");
  },
  ArrayExpression: function ArrayExpression(node) {
    return node.elements;
  },
  ObjectExpression: function ObjectExpression(node) {
    return node.properties;
  }
};

[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
  var type = _ref[0],
      amounts = _ref[1];

  if (typeof amounts === "boolean") {
    amounts = { after: amounts, before: amounts };
  }
  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
    exports.nodes[type] = function () {
      return amounts;
    };
  });
});

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(113),
    baseIteratee = __webpack_require__(66),
    baseMap = __webpack_require__(442),
    isArray = __webpack_require__(7);

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(443),
    isArrayLike = __webpack_require__(21);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(444),
    createBaseEach = __webpack_require__(447);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(445),
    keys = __webpack_require__(20);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(446);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 446 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(21);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.AwaitExpression = exports.FunctionTypeAnnotation = undefined;
exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.UpdateExpression = UpdateExpression;
exports.ObjectExpression = ObjectExpression;
exports.DoExpression = DoExpression;
exports.Binary = Binary;
exports.BinaryExpression = BinaryExpression;
exports.SequenceExpression = SequenceExpression;
exports.YieldExpression = YieldExpression;
exports.ClassExpression = ClassExpression;
exports.UnaryLike = UnaryLike;
exports.FunctionExpression = FunctionExpression;
exports.ArrowFunctionExpression = ArrowFunctionExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.AssignmentExpression = AssignmentExpression;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var PRECEDENCE = {
  "||": 0,
  "&&": 1,
  "|": 2,
  "^": 3,
  "&": 4,
  "==": 5,
  "===": 5,
  "!=": 5,
  "!==": 5,
  "<": 6,
  ">": 6,
  "<=": 6,
  ">=": 6,
  in: 6,
  instanceof: 6,
  ">>": 7,
  "<<": 7,
  ">>>": 7,
  "+": 8,
  "-": 8,
  "*": 9,
  "/": 9,
  "%": 9,
  "**": 10
};

function NullableTypeAnnotation(node, parent) {
  return t.isArrayTypeAnnotation(parent);
}

exports.FunctionTypeAnnotation = NullableTypeAnnotation;
function UpdateExpression(node, parent) {
  return t.isMemberExpression(parent) && parent.object === node;
}

function ObjectExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerArrow: true });
}

function DoExpression(node, parent, printStack) {
  return isFirstInStatement(printStack);
}

function Binary(node, parent) {
  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || t.isMemberExpression(parent) && parent.object === node || t.isAwaitExpression(parent)) {
    return true;
  }

  if (t.isBinary(parent)) {
    var parentOp = parent.operator;
    var parentPos = PRECEDENCE[parentOp];

    var nodeOp = node.operator;
    var nodePos = PRECEDENCE[nodeOp];

    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {
      return true;
    }
  }

  return false;
}

function BinaryExpression(node, parent) {
  return node.operator === "in" && (t.isVariableDeclarator(parent) || t.isFor(parent));
}

function SequenceExpression(node, parent) {

  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {
    return false;
  }

  return true;
}

function YieldExpression(node, parent) {
  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isConditionalExpression(parent) && node === parent.test;
}

exports.AwaitExpression = YieldExpression;
function ClassExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerDefaultExports: true });
}

function UnaryLike(node, parent) {
  return t.isMemberExpression(parent, { object: node }) || t.isCallExpression(parent, { callee: node }) || t.isNewExpression(parent, { callee: node });
}

function FunctionExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerDefaultExports: true });
}

function ArrowFunctionExpression(node, parent) {
  if (t.isExportDeclaration(parent) || t.isBinaryExpression(parent) || t.isLogicalExpression(parent) || t.isUnaryExpression(parent) || t.isTaggedTemplateExpression(parent)) {
    return true;
  }

  return UnaryLike(node, parent);
}

function ConditionalExpression(node, parent) {
  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, { test: node }) || t.isAwaitExpression(parent)) {
    return true;
  }

  return UnaryLike(node, parent);
}

function AssignmentExpression(node) {
  if (t.isObjectPattern(node.left)) {
    return true;
  } else {
    return ConditionalExpression.apply(undefined, arguments);
  }
}

function isFirstInStatement(printStack) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$considerArrow = _ref.considerArrow,
      considerArrow = _ref$considerArrow === undefined ? false : _ref$considerArrow,
      _ref$considerDefaultE = _ref.considerDefaultExports,
      considerDefaultExports = _ref$considerDefaultE === undefined ? false : _ref$considerDefaultE;

  var i = printStack.length - 1;
  var node = printStack[i];
  i--;
  var parent = printStack[i];
  while (i > 0) {
    if (t.isExpressionStatement(parent, { expression: node }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, { declaration: node }) || considerArrow && t.isArrowFunctionExpression(parent, { body: node })) {
      return true;
    }

    if (t.isCallExpression(parent, { callee: node }) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isMemberExpression(parent, { object: node }) || t.isConditional(parent, { test: node }) || t.isBinary(parent, { left: node }) || t.isAssignmentExpression(parent, { left: node })) {
      node = parent;
      i--;
      parent = printStack[i];
    } else {
      return false;
    }
  }

  return false;
}

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _classCallCheck2 = __webpack_require__(3);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Whitespace = function () {
  function Whitespace(tokens) {
    (0, _classCallCheck3.default)(this, Whitespace);

    this.tokens = tokens;
    this.used = {};
  }

  Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(node) {
    var startToken = void 0;
    var endToken = void 0;
    var tokens = this.tokens;

    var index = this._findToken(function (token) {
      return token.start - node.start;
    }, 0, tokens.length);
    if (index >= 0) {
      while (index && node.start === tokens[index - 1].start) {
        --index;
      }startToken = tokens[index - 1];
      endToken = tokens[index];
    }

    return this._getNewlinesBetween(startToken, endToken);
  };

  Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(node) {
    var startToken = void 0;
    var endToken = void 0;
    var tokens = this.tokens;

    var index = this._findToken(function (token) {
      return token.end - node.end;
    }, 0, tokens.length);
    if (index >= 0) {
      while (index && node.end === tokens[index - 1].end) {
        --index;
      }startToken = tokens[index];
      endToken = tokens[index + 1];
      if (endToken && endToken.type.label === ",") endToken = tokens[index + 2];
    }

    if (endToken && endToken.type.label === "eof") {
      return 1;
    } else {
      return this._getNewlinesBetween(startToken, endToken);
    }
  };

  Whitespace.prototype._getNewlinesBetween = function _getNewlinesBetween(startToken, endToken) {
    if (!endToken || !endToken.loc) return 0;

    var start = startToken ? startToken.loc.end.line : 1;
    var end = endToken.loc.start.line;
    var lines = 0;

    for (var line = start; line < end; line++) {
      if (typeof this.used[line] === "undefined") {
        this.used[line] = true;
        lines++;
      }
    }

    return lines;
  };

  Whitespace.prototype._findToken = function _findToken(test, start, end) {
    if (start >= end) return -1;
    var middle = start + end >>> 1;
    var match = test(this.tokens[middle]);
    if (match < 0) {
      return this._findToken(test, middle + 1, end);
    } else if (match > 0) {
      return this._findToken(test, start, middle);
    } else if (match === 0) {
      return middle;
    }
    return -1;
  };

  return Whitespace;
}();

exports.default = Whitespace;
module.exports = exports["default"];

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.TaggedTemplateExpression = TaggedTemplateExpression;
exports.TemplateElement = TemplateElement;
exports.TemplateLiteral = TemplateLiteral;
function TaggedTemplateExpression(node) {
  this.print(node.tag, node);
  this.print(node.quasi, node);
}

function TemplateElement(node, parent) {
  var isFirst = parent.quasis[0] === node;
  var isLast = parent.quasis[parent.quasis.length - 1] === node;

  var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");

  this.token(value);
}

function TemplateLiteral(node) {
  var quasis = node.quasis;

  for (var i = 0; i < quasis.length; i++) {
    this.print(quasis[i], node);

    if (i + 1 < quasis.length) {
      this.print(node.expressions[i], node);
    }
  }
}

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.LogicalExpression = exports.BinaryExpression = exports.AwaitExpression = exports.YieldExpression = undefined;
exports.UnaryExpression = UnaryExpression;
exports.DoExpression = DoExpression;
exports.ParenthesizedExpression = ParenthesizedExpression;
exports.UpdateExpression = UpdateExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.NewExpression = NewExpression;
exports.SequenceExpression = SequenceExpression;
exports.ThisExpression = ThisExpression;
exports.Super = Super;
exports.Decorator = Decorator;
exports.CallExpression = CallExpression;
exports.Import = Import;
exports.EmptyStatement = EmptyStatement;
exports.ExpressionStatement = ExpressionStatement;
exports.AssignmentPattern = AssignmentPattern;
exports.AssignmentExpression = AssignmentExpression;
exports.BindExpression = BindExpression;
exports.MemberExpression = MemberExpression;
exports.MetaProperty = MetaProperty;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

var _node = __webpack_require__(175);

var n = _interopRequireWildcard(_node);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function UnaryExpression(node) {
  if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof") {
    this.word(node.operator);
    this.space();
  } else {
    this.token(node.operator);
  }

  this.print(node.argument, node);
}

function DoExpression(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
}

function ParenthesizedExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.token(")");
}

function UpdateExpression(node) {
  if (node.prefix) {
    this.token(node.operator);
    this.print(node.argument, node);
  } else {
    this.print(node.argument, node);
    this.token(node.operator);
  }
}

function ConditionalExpression(node) {
  this.print(node.test, node);
  this.space();
  this.token("?");
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(":");
  this.space();
  this.print(node.alternate, node);
}

function NewExpression(node, parent) {
  this.word("new");
  this.space();
  this.print(node.callee, node);
  if (node.arguments.length === 0 && this.format.minified && !t.isCallExpression(parent, { callee: node }) && !t.isMemberExpression(parent) && !t.isNewExpression(parent)) return;

  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}

function SequenceExpression(node) {
  this.printList(node.expressions, node);
}

function ThisExpression() {
  this.word("this");
}

function Super() {
  this.word("super");
}

function Decorator(node) {
  this.token("@");
  this.print(node.expression, node);
  this.newline();
}

function commaSeparatorNewline() {
  this.token(",");
  this.newline();

  if (!this.endsWith("\n")) this.space();
}

function CallExpression(node) {
  this.print(node.callee, node);

  this.token("(");

  var isPrettyCall = node._prettyCall;

  var separator = void 0;
  if (isPrettyCall) {
    separator = commaSeparatorNewline;
    this.newline();
    this.indent();
  }

  this.printList(node.arguments, node, { separator: separator });

  if (isPrettyCall) {
    this.newline();
    this.dedent();
  }

  this.token(")");
}

function Import() {
  this.word("import");
}

function buildYieldAwait(keyword) {
  return function (node) {
    this.word(keyword);

    if (node.delegate) {
      this.token("*");
    }

    if (node.argument) {
      this.space();
      var terminatorState = this.startTerminatorless();
      this.print(node.argument, node);
      this.endTerminatorless(terminatorState);
    }
  };
}

var YieldExpression = exports.YieldExpression = buildYieldAwait("yield");
var AwaitExpression = exports.AwaitExpression = buildYieldAwait("await");

function EmptyStatement() {
  this.semicolon(true);
}

function ExpressionStatement(node) {
  this.print(node.expression, node);
  this.semicolon();
}

function AssignmentPattern(node) {
  this.print(node.left, node);
  if (node.left.optional) this.token("?");
  this.print(node.left.typeAnnotation, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
}

function AssignmentExpression(node, parent) {
  var parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);

  if (parens) {
    this.token("(");
  }

  this.print(node.left, node);

  this.space();
  if (node.operator === "in" || node.operator === "instanceof") {
    this.word(node.operator);
  } else {
    this.token(node.operator);
  }
  this.space();

  this.print(node.right, node);

  if (parens) {
    this.token(")");
  }
}

function BindExpression(node) {
  this.print(node.object, node);
  this.token("::");
  this.print(node.callee, node);
}

exports.BinaryExpression = AssignmentExpression;
exports.LogicalExpression = AssignmentExpression;
function MemberExpression(node) {
  this.print(node.object, node);

  if (!node.computed && t.isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }

  var computed = node.computed;
  if (t.isLiteral(node.property) && typeof node.property.value === "number") {
    computed = true;
  }

  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    this.token(".");
    this.print(node.property, node);
  }
}

function MetaProperty(node) {
  this.print(node.meta, node);
  this.token(".");
  this.print(node.property, node);
}

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForAwaitStatement = exports.ForOfStatement = exports.ForInStatement = undefined;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.WithStatement = WithStatement;
exports.IfStatement = IfStatement;
exports.ForStatement = ForStatement;
exports.WhileStatement = WhileStatement;
exports.DoWhileStatement = DoWhileStatement;
exports.LabeledStatement = LabeledStatement;
exports.TryStatement = TryStatement;
exports.CatchClause = CatchClause;
exports.SwitchStatement = SwitchStatement;
exports.SwitchCase = SwitchCase;
exports.DebuggerStatement = DebuggerStatement;
exports.VariableDeclaration = VariableDeclaration;
exports.VariableDeclarator = VariableDeclarator;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function WithStatement(node) {
  this.word("with");
  this.space();
  this.token("(");
  this.print(node.object, node);
  this.token(")");
  this.printBlock(node);
}

function IfStatement(node) {
  this.word("if");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.space();

  var needsBlock = node.alternate && t.isIfStatement(getLastStatement(node.consequent));
  if (needsBlock) {
    this.token("{");
    this.newline();
    this.indent();
  }

  this.printAndIndentOnComments(node.consequent, node);

  if (needsBlock) {
    this.dedent();
    this.newline();
    this.token("}");
  }

  if (node.alternate) {
    if (this.endsWith("}")) this.space();
    this.word("else");
    this.space();
    this.printAndIndentOnComments(node.alternate, node);
  }
}

function getLastStatement(statement) {
  if (!t.isStatement(statement.body)) return statement;
  return getLastStatement(statement.body);
}

function ForStatement(node) {
  this.word("for");
  this.space();
  this.token("(");

  this.inForStatementInitCounter++;
  this.print(node.init, node);
  this.inForStatementInitCounter--;
  this.token(";");

  if (node.test) {
    this.space();
    this.print(node.test, node);
  }
  this.token(";");

  if (node.update) {
    this.space();
    this.print(node.update, node);
  }

  this.token(")");
  this.printBlock(node);
}

function WhileStatement(node) {
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.printBlock(node);
}

var buildForXStatement = function buildForXStatement(op) {
  return function (node) {
    this.word("for");
    this.space();
    if (op === "await") {
      this.word("await");
      this.space();
    }
    this.token("(");

    this.print(node.left, node);
    this.space();
    this.word(op === "await" ? "of" : op);
    this.space();
    this.print(node.right, node);
    this.token(")");
    this.printBlock(node);
  };
};

var ForInStatement = exports.ForInStatement = buildForXStatement("in");
var ForOfStatement = exports.ForOfStatement = buildForXStatement("of");
var ForAwaitStatement = exports.ForAwaitStatement = buildForXStatement("await");

function DoWhileStatement(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
  this.space();
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.semicolon();
}

function buildLabelStatement(prefix) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "label";

  return function (node) {
    this.word(prefix);

    var label = node[key];
    if (label) {
      this.space();

      var terminatorState = this.startTerminatorless();
      this.print(label, node);
      this.endTerminatorless(terminatorState);
    }

    this.semicolon();
  };
}

var ContinueStatement = exports.ContinueStatement = buildLabelStatement("continue");
var ReturnStatement = exports.ReturnStatement = buildLabelStatement("return", "argument");
var BreakStatement = exports.BreakStatement = buildLabelStatement("break");
var ThrowStatement = exports.ThrowStatement = buildLabelStatement("throw", "argument");

function LabeledStatement(node) {
  this.print(node.label, node);
  this.token(":");
  this.space();
  this.print(node.body, node);
}

function TryStatement(node) {
  this.word("try");
  this.space();
  this.print(node.block, node);
  this.space();

  if (node.handlers) {
    this.print(node.handlers[0], node);
  } else {
    this.print(node.handler, node);
  }

  if (node.finalizer) {
    this.space();
    this.word("finally");
    this.space();
    this.print(node.finalizer, node);
  }
}

function CatchClause(node) {
  this.word("catch");
  this.space();
  this.token("(");
  this.print(node.param, node);
  this.token(")");
  this.space();
  this.print(node.body, node);
}

function SwitchStatement(node) {
  this.word("switch");
  this.space();
  this.token("(");
  this.print(node.discriminant, node);
  this.token(")");
  this.space();
  this.token("{");

  this.printSequence(node.cases, node, {
    indent: true,
    addNewlines: function addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    }
  });

  this.token("}");
}

function SwitchCase(node) {
  if (node.test) {
    this.word("case");
    this.space();
    this.print(node.test, node);
    this.token(":");
  } else {
    this.word("default");
    this.token(":");
  }

  if (node.consequent.length) {
    this.newline();
    this.printSequence(node.consequent, node, { indent: true });
  }
}

function DebuggerStatement() {
  this.word("debugger");
  this.semicolon();
}

function variableDeclarationIdent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (var i = 0; i < 4; i++) {
    this.space(true);
  }
}

function constDeclarationIdent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (var i = 0; i < 6; i++) {
    this.space(true);
  }
}

function VariableDeclaration(node, parent) {
  this.word(node.kind);
  this.space();

  var hasInits = false;

  if (!t.isFor(parent)) {
    for (var _iterator = node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var declar = _ref;

      if (declar.init) {
        hasInits = true;
      }
    }
  }

  var separator = void 0;
  if (hasInits) {
    separator = node.kind === "const" ? constDeclarationIdent : variableDeclarationIdent;
  }

  this.printList(node.declarations, node, { separator: separator });

  if (t.isFor(parent)) {
    if (parent.left === node || parent.init === node) return;
  }

  this.semicolon();
}

function VariableDeclarator(node) {
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  if (node.init) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.init, node);
  }
}

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ClassDeclaration = ClassDeclaration;
exports.ClassBody = ClassBody;
exports.ClassProperty = ClassProperty;
exports.ClassMethod = ClassMethod;
function ClassDeclaration(node) {
  this.printJoin(node.decorators, node);
  this.word("class");

  if (node.id) {
    this.space();
    this.print(node.id, node);
  }

  this.print(node.typeParameters, node);

  if (node.superClass) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.superClass, node);
    this.print(node.superTypeParameters, node);
  }

  if (node.implements) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }

  this.space();
  this.print(node.body, node);
}

exports.ClassExpression = ClassDeclaration;
function ClassBody(node) {
  this.token("{");
  this.printInnerComments(node);
  if (node.body.length === 0) {
    this.token("}");
  } else {
    this.newline();

    this.indent();
    this.printSequence(node.body, node);
    this.dedent();

    if (!this.endsWith("\n")) this.newline();

    this.rightBrace();
  }
}

function ClassProperty(node) {
  this.printJoin(node.decorators, node);

  if (node.static) {
    this.word("static");
    this.space();
  }
  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    this._variance(node);
    this.print(node.key, node);
  }
  this.print(node.typeAnnotation, node);
  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }
  this.semicolon();
}

function ClassMethod(node) {
  this.printJoin(node.decorators, node);

  if (node.static) {
    this.word("static");
    this.space();
  }

  if (node.kind === "constructorCall") {
    this.word("call");
    this.space();
  }

  this._method(node);
}

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.FunctionDeclaration = undefined;
exports._params = _params;
exports._method = _method;
exports.FunctionExpression = FunctionExpression;
exports.ArrowFunctionExpression = ArrowFunctionExpression;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _params(node) {
  var _this = this;

  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.params, node, {
    iterator: function iterator(node) {
      if (node.optional) _this.token("?");
      _this.print(node.typeAnnotation, node);
    }
  });
  this.token(")");

  if (node.returnType) {
    this.print(node.returnType, node);
  }
}

function _method(node) {
  var kind = node.kind;
  var key = node.key;

  if (kind === "method" || kind === "init") {
    if (node.generator) {
      this.token("*");
    }
  }

  if (kind === "get" || kind === "set") {
    this.word(kind);
    this.space();
  }

  if (node.async) {
    this.word("async");
    this.space();
  }

  if (node.computed) {
    this.token("[");
    this.print(key, node);
    this.token("]");
  } else {
    this.print(key, node);
  }

  this._params(node);
  this.space();
  this.print(node.body, node);
}

function FunctionExpression(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }
  this.word("function");
  if (node.generator) this.token("*");

  if (node.id) {
    this.space();
    this.print(node.id, node);
  } else {
    this.space();
  }

  this._params(node);
  this.space();
  this.print(node.body, node);
}

exports.FunctionDeclaration = FunctionExpression;
function ArrowFunctionExpression(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }

  var firstParam = node.params[0];

  if (node.params.length === 1 && t.isIdentifier(firstParam) && !hasTypes(node, firstParam)) {
    this.print(firstParam, node);
  } else {
    this._params(node);
  }

  this.space();
  this.token("=>");
  this.space();

  this.print(node.body, node);
}

function hasTypes(node, param) {
  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
}

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ImportSpecifier = ImportSpecifier;
exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
exports.ExportSpecifier = ExportSpecifier;
exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
exports.ExportAllDeclaration = ExportAllDeclaration;
exports.ExportNamedDeclaration = ExportNamedDeclaration;
exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
exports.ImportDeclaration = ImportDeclaration;
exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function ImportSpecifier(node) {
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }

  this.print(node.imported, node);
  if (node.local && node.local.name !== node.imported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }
}

function ImportDefaultSpecifier(node) {
  this.print(node.local, node);
}

function ExportDefaultSpecifier(node) {
  this.print(node.exported, node);
}

function ExportSpecifier(node) {
  this.print(node.local, node);
  if (node.exported && node.local.name !== node.exported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
}

function ExportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.exported, node);
}

function ExportAllDeclaration(node) {
  this.word("export");
  this.space();
  this.token("*");
  this.space();
  this.word("from");
  this.space();
  this.print(node.source, node);
  this.semicolon();
}

function ExportNamedDeclaration() {
  this.word("export");
  this.space();
  ExportDeclaration.apply(this, arguments);
}

function ExportDefaultDeclaration() {
  this.word("export");
  this.space();
  this.word("default");
  this.space();
  ExportDeclaration.apply(this, arguments);
}

function ExportDeclaration(node) {
  if (node.declaration) {
    var declar = node.declaration;
    this.print(declar, node);
    if (!t.isStatement(declar)) this.semicolon();
  } else {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    var specifiers = node.specifiers.slice(0);

    var hasSpecial = false;
    while (true) {
      var first = specifiers[0];
      if (t.isExportDefaultSpecifier(first) || t.isExportNamespaceSpecifier(first)) {
        hasSpecial = true;
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length || !specifiers.length && !hasSpecial) {
      this.token("{");
      if (specifiers.length) {
        this.space();
        this.printList(specifiers, node);
        this.space();
      }
      this.token("}");
    }

    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }

    this.semicolon();
  }
}

function ImportDeclaration(node) {
  this.word("import");
  this.space();

  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }

  var specifiers = node.specifiers.slice(0);
  if (specifiers && specifiers.length) {
    while (true) {
      var first = specifiers[0];
      if (t.isImportDefaultSpecifier(first) || t.isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length) {
      this.token("{");
      this.space();
      this.printList(specifiers, node);
      this.space();
      this.token("}");
    }

    this.space();
    this.word("from");
    this.space();
  }

  this.print(node.source, node);
  this.semicolon();
}

function ImportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.local, node);
}

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/jsesc v1.3.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var forOwn = function(object, callback) {
		var key;
		for (key in object) {
			if (hasOwnProperty.call(object, key)) {
				callback(key, object[key]);
			}
		}
	};

	var extend = function(destination, source) {
		if (!source) {
			return destination;
		}
		forOwn(source, function(key, value) {
			destination[key] = value;
		});
		return destination;
	};

	var forEach = function(array, callback) {
		var length = array.length;
		var index = -1;
		while (++index < length) {
			callback(array[index]);
		}
	};

	var toString = object.toString;
	var isArray = function(value) {
		return toString.call(value) == '[object Array]';
	};
	var isObject = function(value) {
		// This is a very simple check, but its good enough for what we need.
		return toString.call(value) == '[object Object]';
	};
	var isString = function(value) {
		return typeof value == 'string' ||
			toString.call(value) == '[object String]';
	};
	var isNumber = function(value) {
		return typeof value == 'number' ||
			toString.call(value) == '[object Number]';
	};
	var isFunction = function(value) {
		// In a perfect world, the `typeof` check would be sufficient. However,
		// in Chrome 112, `typeof /x/ == 'object'`, and in IE 68
		// `typeof alert == 'object'` and similar for other host objects.
		return typeof value == 'function' ||
			toString.call(value) == '[object Function]';
	};
	var isMap = function(value) {
		return toString.call(value) == '[object Map]';
	};
	var isSet = function(value) {
		return toString.call(value) == '[object Set]';
	};

	/*--------------------------------------------------------------------------*/

	// https://mathiasbynens.be/notes/javascript-escapes#single
	var singleEscapes = {
		'"': '\\"',
		'\'': '\\\'',
		'\\': '\\\\',
		'\b': '\\b',
		'\f': '\\f',
		'\n': '\\n',
		'\r': '\\r',
		'\t': '\\t'
		// `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
		// '\v': '\\x0B'
	};
	var regexSingleEscape = /["'\\\b\f\n\r\t]/;

	var regexDigit = /[0-9]/;
	var regexWhitelist = /[ !#-&\(-\[\]-~]/;

	var jsesc = function(argument, options) {
		// Handle options
		var defaults = {
			'escapeEverything': false,
			'escapeEtago': false,
			'quotes': 'single',
			'wrap': false,
			'es6': false,
			'json': false,
			'compact': true,
			'lowercaseHex': false,
			'numbers': 'decimal',
			'indent': '\t',
			'__indent__': '',
			'__inline1__': false,
			'__inline2__': false
		};
		var json = options && options.json;
		if (json) {
			defaults.quotes = 'double';
			defaults.wrap = true;
		}
		options = extend(defaults, options);
		if (options.quotes != 'single' && options.quotes != 'double') {
			options.quotes = 'single';
		}
		var quote = options.quotes == 'double' ? '"' : '\'';
		var compact = options.compact;
		var indent = options.indent;
		var lowercaseHex = options.lowercaseHex;
		var oldIndent = '';
		var inline1 = options.__inline1__;
		var inline2 = options.__inline2__;
		var newLine = compact ? '' : '\n';
		var result;
		var isEmpty = true;
		var useBinNumbers = options.numbers == 'binary';
		var useOctNumbers = options.numbers == 'octal';
		var useDecNumbers = options.numbers == 'decimal';
		var useHexNumbers = options.numbers == 'hexadecimal';

		if (json && argument && isFunction(argument.toJSON)) {
			argument = argument.toJSON();
		}

		if (!isString(argument)) {
			if (isMap(argument)) {
				if (argument.size == 0) {
					return 'new Map()';
				}
				if (!compact) {
					options.__inline1__ = true;
				}
				return 'new Map(' + jsesc(Array.from(argument), options) + ')';
			}
			if (isSet(argument)) {
				if (argument.size == 0) {
					return 'new Set()';
				}
				return 'new Set(' + jsesc(Array.from(argument), options) + ')';
			}
			if (isArray(argument)) {
				result = [];
				options.wrap = true;
				if (inline1) {
					options.__inline1__ = false;
					options.__inline2__ = true;
				} else {
					oldIndent = options.__indent__;
					indent += oldIndent;
					options.__indent__ = indent;
				}
				forEach(argument, function(value) {
					isEmpty = false;
					if (inline2) {
						options.__inline2__ = false;
					}
					result.push(
						(compact || inline2 ? '' : indent) +
						jsesc(value, options)
					);
				});
				if (isEmpty) {
					return '[]';
				}
				if (inline2) {
					return '[' + result.join(', ') + ']';
				}
				return '[' + newLine + result.join(',' + newLine) + newLine +
					(compact ? '' : oldIndent) + ']';
			} else if (isNumber(argument)) {
				if (json) {
					// Some number values (e.g. `Infinity`) cannot be represented in JSON.
					return JSON.stringify(argument);
				}
				if (useDecNumbers) {
					return String(argument);
				}
				if (useHexNumbers) {
					var tmp = argument.toString(16);
					if (!lowercaseHex) {
						tmp = tmp.toUpperCase();
					}
					return '0x' + tmp;
				}
				if (useBinNumbers) {
					return '0b' + argument.toString(2);
				}
				if (useOctNumbers) {
					return '0o' + argument.toString(8);
				}
			} else if (!isObject(argument)) {
				if (json) {
					// For some values (e.g. `undefined`, `function` objects),
					// `JSON.stringify(value)` returns `undefined` (which isnt valid
					// JSON) instead of `'null'`.
					return JSON.stringify(argument) || 'null';
				}
				return String(argument);
			} else { // its an object
				result = [];
				options.wrap = true;
				oldIndent = options.__indent__;
				indent += oldIndent;
				options.__indent__ = indent;
				forOwn(argument, function(key, value) {
					isEmpty = false;
					result.push(
						(compact ? '' : indent) +
						jsesc(key, options) + ':' +
						(compact ? '' : ' ') +
						jsesc(value, options)
					);
				});
				if (isEmpty) {
					return '{}';
				}
				return '{' + newLine + result.join(',' + newLine) + newLine +
					(compact ? '' : oldIndent) + '}';
			}
		}

		var string = argument;
		// Loop over each code unit in the string and escape it
		var index = -1;
		var length = string.length;
		var first;
		var second;
		var codePoint;
		result = '';
		while (++index < length) {
			var character = string.charAt(index);
			if (options.es6) {
				first = string.charCodeAt(index);
				if ( // check if its the start of a surrogate pair
					first >= 0xD800 && first <= 0xDBFF && // high surrogate
					length > index + 1 // there is a next code unit
				) {
					second = string.charCodeAt(index + 1);
					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
						var hexadecimal = codePoint.toString(16);
						if (!lowercaseHex) {
							hexadecimal = hexadecimal.toUpperCase();
						}
						result += '\\u{' + hexadecimal + '}';
						index++;
						continue;
					}
				}
			}
			if (!options.escapeEverything) {
				if (regexWhitelist.test(character)) {
					// Its a printable ASCII character that is not `"`, `'` or `\`,
					// so dont escape it.
					result += character;
					continue;
				}
				if (character == '"') {
					result += quote == character ? '\\"' : character;
					continue;
				}
				if (character == '\'') {
					result += quote == character ? '\\\'' : character;
					continue;
				}
			}
			if (
				character == '\0' &&
				!json &&
				!regexDigit.test(string.charAt(index + 1))
			) {
				result += '\\0';
				continue;
			}
			if (regexSingleEscape.test(character)) {
				// no need for a `hasOwnProperty` check here
				result += singleEscapes[character];
				continue;
			}
			var charCode = character.charCodeAt(0);
			var hexadecimal = charCode.toString(16);
			if (!lowercaseHex) {
				hexadecimal = hexadecimal.toUpperCase();
			}
			var longhand = hexadecimal.length > 2 || json;
			var escaped = '\\' + (longhand ? 'u' : 'x') +
				('0000' + hexadecimal).slice(longhand ? -4 : -2);
			result += escaped;
			continue;
		}
		if (options.wrap) {
			result = quote + result + quote;
		}
		if (options.escapeEtago) {
			// https://mathiasbynens.be/notes/etago
			return result.replace(/<\/(script|style)/gi, '<\\/$1');
		}
		return result;
	};

	jsesc.version = '1.3.0';

	/*--------------------------------------------------------------------------*/

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return jsesc;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = jsesc;
		} else { // in Narwhal or RingoJS v0.7.0-
			freeExports.jsesc = jsesc;
		}
	} else { // in Rhino or a web browser
		root.jsesc = jsesc;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)(module)))

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.TypeParameterDeclaration = exports.StringLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = exports.GenericTypeAnnotation = exports.ClassImplements = undefined;
exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.DeclareClass = DeclareClass;
exports.DeclareFunction = DeclareFunction;
exports.DeclareInterface = DeclareInterface;
exports.DeclareModule = DeclareModule;
exports.DeclareModuleExports = DeclareModuleExports;
exports.DeclareTypeAlias = DeclareTypeAlias;
exports.DeclareOpaqueType = DeclareOpaqueType;
exports.DeclareVariable = DeclareVariable;
exports.DeclareExportDeclaration = DeclareExportDeclaration;
exports.ExistentialTypeParam = ExistentialTypeParam;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.FunctionTypeParam = FunctionTypeParam;
exports.InterfaceExtends = InterfaceExtends;
exports._interfaceish = _interfaceish;
exports._variance = _variance;
exports.InterfaceDeclaration = InterfaceDeclaration;
exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.NullableTypeAnnotation = NullableTypeAnnotation;

var _types = __webpack_require__(115);

Object.defineProperty(exports, "NumericLiteralTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _types.NumericLiteral;
  }
});
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _types.StringLiteral;
  }
});
exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.StringTypeAnnotation = StringTypeAnnotation;
exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.TypeAlias = TypeAlias;
exports.OpaqueType = OpaqueType;
exports.TypeAnnotation = TypeAnnotation;
exports.TypeParameter = TypeParameter;
exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.ObjectTypeProperty = ObjectTypeProperty;
exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.TypeCastExpression = TypeCastExpression;
exports.VoidTypeAnnotation = VoidTypeAnnotation;

var _babelTypes = __webpack_require__(0);

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function AnyTypeAnnotation() {
  this.word("any");
}

function ArrayTypeAnnotation(node) {
  this.print(node.elementType, node);
  this.token("[");
  this.token("]");
}

function BooleanTypeAnnotation() {
  this.word("boolean");
}

function BooleanLiteralTypeAnnotation(node) {
  this.word(node.value ? "true" : "false");
}

function NullLiteralTypeAnnotation() {
  this.word("null");
}

function DeclareClass(node, parent) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
  this.word("class");
  this.space();
  this._interfaceish(node);
}

function DeclareFunction(node, parent) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
  this.word("function");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation.typeAnnotation, node);
  this.semicolon();
}

function DeclareInterface(node) {
  this.word("declare");
  this.space();
  this.InterfaceDeclaration(node);
}

function DeclareModule(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.space();
  this.print(node.id, node);
  this.space();
  this.print(node.body, node);
}

function DeclareModuleExports(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.token(".");
  this.word("exports");
  this.print(node.typeAnnotation, node);
}

function DeclareTypeAlias(node) {
  this.word("declare");
  this.space();
  this.TypeAlias(node);
}

function DeclareOpaqueType(node, parent) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
  this.OpaqueType(node);
}

function DeclareVariable(node, parent) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
  this.word("var");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  this.semicolon();
}

function DeclareExportDeclaration(node) {
  this.word("declare");
  this.space();
  this.word("export");
  this.space();
  if (node.default) {
    this.word("default");
    this.space();
  }

  FlowExportDeclaration.apply(this, arguments);
}

function FlowExportDeclaration(node) {
  if (node.declaration) {
    var declar = node.declaration;
    this.print(declar, node);
    if (!t.isStatement(declar)) this.semicolon();
  } else {
    this.token("{");
    if (node.specifiers.length) {
      this.space();
      this.printList(node.specifiers, node);
      this.space();
    }
    this.token("}");

    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }

    this.semicolon();
  }
}

function ExistentialTypeParam() {
  this.token("*");
}

function FunctionTypeAnnotation(node, parent) {
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.params, node);

  if (node.rest) {
    if (node.params.length) {
      this.token(",");
      this.space();
    }
    this.token("...");
    this.print(node.rest, node);
  }

  this.token(")");

  if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction") {
    this.token(":");
  } else {
    this.space();
    this.token("=>");
  }

  this.space();
  this.print(node.returnType, node);
}

function FunctionTypeParam(node) {
  this.print(node.name, node);
  if (node.optional) this.token("?");
  this.token(":");
  this.space();
  this.print(node.typeAnnotation, node);
}

function InterfaceExtends(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);
}

exports.ClassImplements = InterfaceExtends;
exports.GenericTypeAnnotation = InterfaceExtends;
function _interfaceish(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  if (node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }
  if (node.mixins && node.mixins.length) {
    this.space();
    this.word("mixins");
    this.space();
    this.printList(node.mixins, node);
  }
  this.space();
  this.print(node.body, node);
}

function _variance(node) {
  if (node.variance === "plus") {
    this.token("+");
  } else if (node.variance === "minus") {
    this.token("-");
  }
}

function InterfaceDeclaration(node) {
  this.word("interface");
  this.space();
  this._interfaceish(node);
}

function andSeparator() {
  this.space();
  this.token("&");
  this.space();
}

function IntersectionTypeAnnotation(node) {
  this.printJoin(node.types, node, { separator: andSeparator });
}

function MixedTypeAnnotation() {
  this.word("mixed");
}

function EmptyTypeAnnotation() {
  this.word("empty");
}

function NullableTypeAnnotation(node) {
  this.token("?");
  this.print(node.typeAnnotation, node);
}

function NumberTypeAnnotation() {
  this.word("number");
}

function StringTypeAnnotation() {
  this.word("string");
}

function ThisTypeAnnotation() {
  this.word("this");
}

function TupleTypeAnnotation(node) {
  this.token("[");
  this.printList(node.types, node);
  this.token("]");
}

function TypeofTypeAnnotation(node) {
  this.word("typeof");
  this.space();
  this.print(node.argument, node);
}

function TypeAlias(node) {
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
  this.semicolon();
}
function OpaqueType(node) {
  this.word("opaque");
  this.space();
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  if (node.supertype) {
    this.token(":");
    this.space();
    this.print(node.supertype, node);
  }
  if (node.impltype) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.impltype, node);
  }
  this.semicolon();
}

function TypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}

function TypeParameter(node) {
  this._variance(node);

  this.word(node.name);

  if (node.bound) {
    this.print(node.bound, node);
  }

  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}

function TypeParameterInstantiation(node) {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}

exports.TypeParameterDeclaration = TypeParameterInstantiation;
function ObjectTypeAnnotation(node) {
  var _this = this;

  if (node.exact) {
    this.token("{|");
  } else {
    this.token("{");
  }

  var props = node.properties.concat(node.callProperties, node.indexers);

  if (props.length) {
    this.space();

    this.printJoin(props, node, {
      addNewlines: function addNewlines(leading) {
        if (leading && !props[0]) return 1;
      },

      indent: true,
      statement: true,
      iterator: function iterator() {
        if (props.length !== 1) {
          if (_this.format.flowCommaSeparator) {
            _this.token(",");
          } else {
            _this.semicolon();
          }
          _this.space();
        }
      }
    });

    this.space();
  }

  if (node.exact) {
    this.token("|}");
  } else {
    this.token("}");
  }
}

function ObjectTypeCallProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.print(node.value, node);
}

function ObjectTypeIndexer(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this._variance(node);
  this.token("[");
  this.print(node.id, node);
  this.token(":");
  this.space();
  this.print(node.key, node);
  this.token("]");
  this.token(":");
  this.space();
  this.print(node.value, node);
}

function ObjectTypeProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this._variance(node);
  this.print(node.key, node);
  if (node.optional) this.token("?");
  this.token(":");
  this.space();
  this.print(node.value, node);
}

function ObjectTypeSpreadProperty(node) {
  this.token("...");
  this.print(node.argument, node);
}

function QualifiedTypeIdentifier(node) {
  this.print(node.qualification, node);
  this.token(".");
  this.print(node.id, node);
}

function orSeparator() {
  this.space();
  this.token("|");
  this.space();
}

function UnionTypeAnnotation(node) {
  this.printJoin(node.types, node, { separator: orSeparator });
}

function TypeCastExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.print(node.typeAnnotation, node);
  this.token(")");
}

function VoidTypeAnnotation() {
  this.word("void");
}

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.File = File;
exports.Program = Program;
exports.BlockStatement = BlockStatement;
exports.Noop = Noop;
exports.Directive = Directive;

var _types = __webpack_require__(115);

Object.defineProperty(exports, "DirectiveLiteral", {
  enumerable: true,
  get: function get() {
    return _types.StringLiteral;
  }
});
function File(node) {
  this.print(node.program, node);
}

function Program(node) {
  this.printInnerComments(node, false);

  this.printSequence(node.directives, node);
  if (node.directives && node.directives.length) this.newline();

  this.printSequence(node.body, node);
}

function BlockStatement(node) {
  this.token("{");
  this.printInnerComments(node);

  var hasDirectives = node.directives && node.directives.length;

  if (node.body.length || hasDirectives) {
    this.newline();

    this.printSequence(node.directives, node, { indent: true });
    if (hasDirectives) this.newline();

    this.printSequence(node.body, node, { indent: true });
    this.removeTrailingNewline();

    this.source("end", node.loc);

    if (!this.endsWith("\n")) this.newline();

    this.rightBrace();
  } else {
    this.source("end", node.loc);
    this.token("}");
  }
}

function Noop() {}

function Directive(node) {
  this.print(node.value, node);
  this.semicolon();
}

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getIterator2 = __webpack_require__(1);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.JSXAttribute = JSXAttribute;
exports.JSXIdentifier = JSXIdentifier;
exports.JSXNamespacedName = JSXNamespacedName;
exports.JSXMemberExpression = JSXMemberExpression;
exports.JSXSpreadAttribute = JSXSpreadAttribute;
exports.JSXExpressionContainer = JSXExpressionContainer;
exports.JSXSpreadChild = JSXSpreadChild;
exports.JSXText = JSXText;
exports.JSXElement = JSXElement;
exports.JSXOpeningElement = JSXOpeningElement;
exports.JSXClosingElement = JSXClosingElement;
exports.JSXEmptyExpression = JSXEmptyExpression;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function JSXAttribute(node) {
  this.print(node.name, node);
  if (node.value) {
    this.token("=");
    this.print(node.value, node);
  }
}

function JSXIdentifier(node) {
  this.word(node.name);
}

function JSXNamespacedName(node) {
  this.print(node.namespace, node);
  this.token(":");
  this.print(node.name, node);
}

function JSXMemberExpression(node) {
  this.print(node.object, node);
  this.token(".");
  this.print(node.property, node);
}

function JSXSpreadAttribute(node) {
  this.token("{");
  this.token("...");
  this.print(node.argument, node);
  this.token("}");
}

function JSXExpressionContainer(node) {
  this.token("{");
  this.print(node.expression, node);
  this.token("}");
}

function JSXSpreadChild(node) {
  this.token("{");
  this.token("...");
  this.print(node.expression, node);
  this.token("}");
}

function JSXText(node) {
  this.token(node.value);
}

function JSXElement(node) {
  var open = node.openingElement;
  this.print(open, node);
  if (open.selfClosing) return;

  this.indent();
  for (var _iterator = node.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var child = _ref;

    this.print(child, node);
  }
  this.dedent();

  this.print(node.closingElement, node);
}

function spaceSeparator() {
  this.space();
}

function JSXOpeningElement(node) {
  this.token("<");
  this.print(node.name, node);
  if (node.attributes.length > 0) {
    this.space();
    this.printJoin(node.attributes, node, { separator: spaceSeparator });
  }
  if (node.selfClosing) {
    this.space();
    this.token("/>");
  } else {
    this.token(">");
  }
}

function JSXClosingElement(node) {
  this.token("</");
  this.print(node.name, node);
  this.token(">");
}

function JSXEmptyExpression() {}

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const fs = __webpack_require__(26);
const path = __webpack_require__(45);
class Folder {
    constructor(absolutePath) {
        // this.from = from;
        this.to = absolutePath;
    }
    operate() {
        if (fs.existsSync(this.to)) {
            this.deleteFolderRecursive(this.to);
        }
        fs.mkdirSync(this.to, 0o777);
    }
    deleteFolderRecursive(url) {
        var files = [];
        //
        if (fs.existsSync(url)) {
            //
            files = fs.readdirSync(url);
            files.forEach((file, index) => {
                // var curPath = url + "/" + file;
                var curPath = path.join(url, file);
                //fs.statSync
                if (fs.statSync(curPath).isDirectory()) {
                    this.deleteFolderRecursive(curPath);
                    // delete file
                } else {
                    fs.unlinkSync(curPath);
                }
            });
            //
            fs.rmdirSync(url);
        } else {
            console.log("");
        }
    }
}
exports.Folder = Folder;

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const Tools_1 = __webpack_require__(116);
const Page_1 = __webpack_require__(46);
const encrypt_1 = __webpack_require__(68);
class scriptPage extends Page_1.Page {
    constructor(from, to, compress = false) {
        super(from, to);
        this.compress = false;
        this.compress = compress;
    }
    operate() {
        //fs.writeFileSync(this.to, this.content);
        let txt = this.read(this.from);
        ;
        if (this.compress) {
            let p = encrypt_1.encryptCode(txt);
            p.then(data => {
                //console.log("---------------->",data.length)
                Tools_1.writeFile(data, this.to);
                //fs.writeFileSync(this.to,data);
            }).catch(e => {
                console.log("----->", e);
            });
        } else {
            // fs.writeFileSync(this.to,txt);
            Tools_1.writeFile(txt, this.to);
        }
    }
}
exports.scriptPage = scriptPage;

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
const Page_1 = __webpack_require__(46);
const conf_1 = __webpack_require__(44);
//import {read,writeFile} from "../common/Tools";
class manifestPage extends Page_1.Page {
    constructor(from, to, compress = false) {
        super(from, to);
    }
    read(IN) {
        return super.read(IN);
    }
    operate() {
        let txt = this.read(this.from);
        let json = JSON.parse(txt);
        json.version = conf_1.version;
        let out = JSON.stringify(json, null, '\t');
        this.writeFile(out, this.to);
    }
}
exports.manifestPage = manifestPage;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2svYm9vdHN0cmFwIGQ4ZThhOTA3YjAxY2U4MzA3ZTQxIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlc1xcbGliXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxjb3JlLWpzXFxnZXQtaXRlcmF0b3IuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfY29yZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxoZWxwZXJzXFxjbGFzc0NhbGxDaGVjay5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9leHBvcnQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfaXMtb2JqZWN0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX3drcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcaXNBcnJheS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9nbG9iYWwuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9yb290LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpc09iamVjdExpa2UuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfb2JqZWN0LWRwLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2FuLW9iamVjdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9kZXNjcmlwdG9ycy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9oaWRlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2ZhaWxzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2hhcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxoZWxwZXJzXFx0eXBlb2YuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlR2V0VGFnLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpc09iamVjdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxca2V5cy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcaXNBcnJheUxpa2UuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzXFxsaWJcXGRlZmluaXRpb25zXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9wb3N0aHRtbEAwLjExLjJAcG9zdGh0bWxcXGxpYlxcYXBpLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZVxcbGliXFxwYXRoXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2dldE5hdGl2ZS5qcyIsImV4dGVybmFsIFwiZnNcIiIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF90by1pb2JqZWN0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2N0eC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxjb3JlLWpzXFxvYmplY3RcXGtleXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcd2ViLmRvbS5pdGVyYWJsZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9pdGVyYXRvcnMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfb2JqZWN0LWtleXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfbWV0YS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxjb3JlLWpzXFxqc29uXFxzdHJpbmdpZnkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9TeW1ib2wuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fd2VicGFja0AzLjEwLjBAd2VicGFja1xcYnVpbGRpblxcbW9kdWxlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxlcS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2NvcHlPYmplY3QuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfZm9yLW9mLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXHRvSW50ZWdlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9zb3VyY2UtbWFwQDAuNS43QHNvdXJjZS1tYXBcXGxpYlxcdXRpbC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXHNyY1xcY29tbW9uXFxjb25mLnRzIiwiZXh0ZXJuYWwgXCJwYXRoXCIiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxzcmNcXHBvam9cXFBhZ2UudHMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfcHJvcGVydHktZGVzYy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9vYmplY3QtY3JlYXRlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX3VpZC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF90by1vYmplY3QuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfb2JqZWN0LXBpZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxjb3JlLWpzXFxvYmplY3RcXGNyZWF0ZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VVbmFyeS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX25vZGVVdGlsLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfTGlzdENhY2hlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYXNzb2NJbmRleE9mLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfbmF0aXZlQ3JlYXRlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfZ2V0TWFwRGF0YS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2lzUHJvdG90eXBlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfZ2V0VGFnLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpc1N5bWJvbC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1tZXNzYWdlc0A2LjIzLjBAYmFiZWwtbWVzc2FnZXNcXGxpYlxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXGNhY2hlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYmFzZUl0ZXJhdGVlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfdG9LZXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxzcmNcXGNvbW1vblxcZW5jcnlwdC50cyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9wb3N0aHRtbC1wYXJzZXJAMC40LjBAcG9zdGh0bWwtcGFyc2VyXFxpbmRleC5qcyIsImV4dGVybmFsIFwidXRpbFwiIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX3Bvc3RodG1sLXJlbmRlckAxLjEuMEBwb3N0aHRtbC1yZW5kZXJcXGxpYlxccG9zdGh0bWwtcmVuZGVyLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2lvYmplY3QuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfY29mLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2RlZmluZWQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfaXRlci1kZWZpbmUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfbGlicmFyeS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF90by1wcmltaXRpdmUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfcmVkZWZpbmUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfdG8tbGVuZ3RoLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX3RvLWludGVnZXIuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfc2hhcmVkLWtleS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9zaGFyZWQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfZW51bS1idWcta2V5cy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxlczYuc3ltYm9sLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX3drcy1leHQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfd2tzLWRlZmluZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9vYmplY3QtZ29wcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXNcXGxpYlxcY29uc3RhbnRzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfZ2V0UHJvdG90eXBlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfU3RhY2suanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9NYXAuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9NYXBDYWNoZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Fzc2lnblZhbHVlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpc0J1ZmZlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2lzSW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXGlzTGVuZ3RoLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxrZXlzSW4uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9nZXRTeW1ib2xzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY2xvbmVBcnJheUJ1ZmZlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VGaW5kSW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9zZXRUb0FycmF5LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpZGVudGl0eS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2lzSXRlcmF0ZWVDYWxsLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZVxcbGliXFxzY29wZVxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfcmVkZWZpbmUtYWxsLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2FuLWluc3RhbmNlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2NvbGxlY3Rpb24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfYXJyYXktbWV0aG9kcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9zZXQtY29sbGVjdGlvbi1vZi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpbmNsdWRlcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2FycmF5TWFwLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfaXNLZXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3JcXGxpYlxcZ2VuZXJhdG9yc1xcdHlwZXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxzcmNcXGNvbW1vblxcVG9vbHMudHMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5faHRtbHBhcnNlcjJAMy45LjJAaHRtbHBhcnNlcjJcXGxpYlxcUGFyc2VyLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2lzb2JqZWN0QDIuMS4wQGlzb2JqZWN0XFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9vYmplY3QtYXNzaWduQDQuMS4xQG9iamVjdC1hc3NpZ25cXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYnlsb25ANi4xOC4wQGJhYnlsb25cXGxpYlxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfaXRlci1zdGVwLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2EtZnVuY3Rpb24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfaWU4LWRvbS1kZWZpbmUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfZG9tLWNyZWF0ZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGNvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9jbGFzc29mLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZVxcbGliXFxwYXRoXFxsaWJcXHZpcnR1YWwtdHlwZXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfaXMtYXJyYXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfb2JqZWN0LWdvcG4uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfb2JqZWN0LWdvcGQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzXFxsaWJcXHJldHJpZXZlcnMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZXN1dGlsc0AyLjAuMkBlc3V0aWxzXFxsaWJcXHV0aWxzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2VzdXRpbHNAMi4wLjJAZXN1dGlsc1xcbGliXFxjb2RlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfZnJlZUdsb2JhbC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX292ZXJBcmcuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXGNsb25lLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpc0Z1bmN0aW9uLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfdG9Tb3VyY2UuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlQXNzaWduVmFsdWUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9kZWZpbmVQcm9wZXJ0eS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2FycmF5TGlrZUtleXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXGlzQXJndW1lbnRzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpc1R5cGVkQXJyYXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXHN0dWJBcnJheS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2dldFN5bWJvbHNJbi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2FycmF5UHVzaC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2dldEFsbEtleXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlR2V0QWxsS2V5cy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX1NldC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX1VpbnQ4QXJyYXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9TZXRDYWNoZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VJbmRleE9mLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY2FjaGVIYXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZGVidWdAMi42LjlAZGVidWdcXHNyY1xcZGVidWcuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlUmVzdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxjb3JlLWpzXFxtYXAuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXHJlcGVhdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcdG9TdHJpbmcuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHNjb3BlXFxiaW5kaW5nLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX29iamVjdC1hc3NpZ24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfY29sbGVjdGlvbi13ZWFrLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2Fuc2ktcmVnZXhAMi4xLjFAYW5zaS1yZWdleFxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXGh1Yi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9zb3VyY2UtbWFwQDAuNS43QHNvdXJjZS1tYXBcXGxpYlxcc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fc291cmNlLW1hcEAwLjUuN0Bzb3VyY2UtbWFwXFxsaWJcXGJhc2U2NC12bHEuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fc291cmNlLW1hcEAwLjUuN0Bzb3VyY2UtbWFwXFxsaWJcXGFycmF5LXNldC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2NyZWF0ZUZpbmQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlSXNFcXVhbC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2VxdWFsQXJyYXlzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfaXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlR2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY2FzdFBhdGguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3JcXGxpYlxcbm9kZVxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxzcmNcXDEudHMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxzcmNcXHBvam9cXFBhZ2VGYWN0b3J5LnRzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcc3JjXFxjb21tb25cXHJlcXVlc3QudHMiLCJleHRlcm5hbCBcImh0dHBzXCIiLCJleHRlcm5hbCBcInF1ZXJ5c3RyaW5nXCIiLCJleHRlcm5hbCBcInVybFwiIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2h0bWxwYXJzZXIyQDMuOS4yQGh0bWxwYXJzZXIyXFxsaWJcXFRva2VuaXplci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9lbnRpdGllc0AxLjEuMUBlbnRpdGllc1xcbGliXFxkZWNvZGVfY29kZXBvaW50LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2VudGl0aWVzQDEuMS4xQGVudGl0aWVzXFxtYXBzXFxkZWNvZGUuanNvbiIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9lbnRpdGllc0AxLjEuMUBlbnRpdGllc1xcbWFwc1xcZW50aXRpZXMuanNvbiIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9lbnRpdGllc0AxLjEuMUBlbnRpdGllc1xcbWFwc1xcbGVnYWN5Lmpzb24iLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZW50aXRpZXNAMS4xLjFAZW50aXRpZXNcXG1hcHNcXHhtbC5qc29uIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2luaGVyaXRzQDIuMC4zQGluaGVyaXRzXFxpbmhlcml0cy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9pbmhlcml0c0AyLjAuM0Bpbmhlcml0c1xcaW5oZXJpdHNfYnJvd3Nlci5qcyIsImV4dGVybmFsIFwiZXZlbnRzXCIiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5faXNhcnJheUAxLjAuMEBpc2FycmF5XFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9wb3N0aHRtbEAwLjExLjJAcG9zdGh0bWxcXGxpYlxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fcG9zdGh0bWxAMC4xMS4yQHBvc3RodG1sXFxwYWNrYWdlLmpzb24iLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fcG9zdGh0bWwtcGFyc2VyQDAuMy4zQHBvc3RodG1sLXBhcnNlclxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxzcmNcXHBvam9cXEh0bWxQYWdlLnRzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcc3JjXFxjb21tb25cXGFzdFF1ZXJ5LnRzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcZm5cXGdldC1pdGVyYXRvci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNi5hcnJheS5pdGVyYXRvci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfaXRlci1jcmVhdGUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfb2JqZWN0LWRwcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9hcnJheS1pbmNsdWRlcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF90by1hYnNvbHV0ZS1pbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9odG1sLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX29iamVjdC1ncG8uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfc3RyaW5nLWF0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcY29yZS5nZXQtaXRlcmF0b3IuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZVxcY29yZS1qc1xcb2JqZWN0XFxnZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxmblxcb2JqZWN0XFxnZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfZW51bS1rZXlzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX29iamVjdC1nb3BuLWV4dC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXGZuXFxvYmplY3RcXGtleXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxlczYub2JqZWN0LmtleXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfb2JqZWN0LXNhcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXGZuXFxqc29uXFxzdHJpbmdpZnkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZVxcY29yZS1qc1xcc3ltYm9sXFxmb3IuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxmblxcc3ltYm9sXFxmb3IuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxmblxcb2JqZWN0XFxjcmVhdGUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxlczYub2JqZWN0LmNyZWF0ZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXNcXGxpYlxcdmFsaWRhdG9ycy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxjb3JlLWpzXFxzeW1ib2xcXGl0ZXJhdG9yLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcZm5cXHN5bWJvbFxcaXRlcmF0b3IuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZVxcY29yZS1qc1xcc3ltYm9sLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcZm5cXHN5bWJvbFxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxlczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2VzdXRpbHNAMi4wLjJAZXN1dGlsc1xcbGliXFxhc3QuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZXN1dGlsc0AyLjAuMkBlc3V0aWxzXFxsaWJcXGtleXdvcmQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzXFxsaWJcXGNvbnZlcnRlcnMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZVxcY29yZS1qc1xcbnVtYmVyXFxtYXgtc2FmZS1pbnRlZ2VyLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcZm5cXG51bWJlclxcbWF4LXNhZmUtaW50ZWdlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcaXNQbGFpbk9iamVjdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2dldFJhd1RhZy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX29iamVjdFRvU3RyaW5nLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpc1JlZ0V4cC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VJc1JlZ0V4cC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXNcXGxpYlxcZmxvdy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl90by1mYXN0LXByb3BlcnRpZXNAMS4wLjNAdG8tZmFzdC1wcm9wZXJ0aWVzXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VDbG9uZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2xpc3RDYWNoZUNsZWFyLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfbGlzdENhY2hlRGVsZXRlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfbGlzdENhY2hlR2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfbGlzdENhY2hlSGFzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfbGlzdENhY2hlU2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfc3RhY2tDbGVhci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX3N0YWNrRGVsZXRlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfc3RhY2tHZXQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9zdGFja0hhcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX3N0YWNrU2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYmFzZUlzTmF0aXZlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfaXNNYXNrZWQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9jb3JlSnNEYXRhLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfZ2V0VmFsdWUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9tYXBDYWNoZUNsZWFyLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfSGFzaC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2hhc2hDbGVhci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2hhc2hEZWxldGUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9oYXNoR2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfaGFzaEhhcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2hhc2hTZXQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9tYXBDYWNoZURlbGV0ZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2lzS2V5YWJsZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX21hcENhY2hlR2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfbWFwQ2FjaGVIYXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9tYXBDYWNoZVNldC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2FycmF5RWFjaC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VBc3NpZ24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlVGltZXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlSXNBcmd1bWVudHMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXHN0dWJGYWxzZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlS2V5cy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX25hdGl2ZUtleXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlQXNzaWduSW4uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlS2V5c0luLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfbmF0aXZlS2V5c0luLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY2xvbmVCdWZmZXIuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9jb3B5QXJyYXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9jb3B5U3ltYm9scy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2FycmF5RmlsdGVyLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY29weVN5bWJvbHNJbi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2dldEFsbEtleXNJbi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX0RhdGFWaWV3LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfUHJvbWlzZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX1dlYWtNYXAuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9pbml0Q2xvbmVBcnJheS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2luaXRDbG9uZUJ5VGFnLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY2xvbmVEYXRhVmlldy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Nsb25lUmVnRXhwLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY2xvbmVTeW1ib2wuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9jbG9uZVR5cGVkQXJyYXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9pbml0Q2xvbmVPYmplY3QuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlQ3JlYXRlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxpc01hcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VJc01hcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcaXNTZXQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlSXNTZXQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXHVuaXEuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlVW5pcS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX3NldENhY2hlQWRkLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfc2V0Q2FjaGVIYXMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9hcnJheUluY2x1ZGVzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYmFzZUlzTmFOLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfc3RyaWN0SW5kZXhPZi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY3JlYXRlU2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxub29wLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlc1xcbGliXFxkZWZpbml0aW9uc1xcaW5pdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXNcXGxpYlxcZGVmaW5pdGlvbnNcXGNvcmUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzXFxsaWJcXGRlZmluaXRpb25zXFxlczIwMTUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzXFxsaWJcXGRlZmluaXRpb25zXFxmbG93LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlc1xcbGliXFxkZWZpbml0aW9uc1xcanN4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlc1xcbGliXFxkZWZpbml0aW9uc1xcbWlzYy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXNcXGxpYlxcZGVmaW5pdGlvbnNcXGV4cGVyaW1lbnRhbC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXNcXGxpYlxccmVhY3QuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZGVidWdAMi42LjlAZGVidWdcXHNyY1xcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZGVidWdAMi42LjlAZGVidWdcXHNyY1xcYnJvd3Nlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9tc0AyLjAuMEBtc1xcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZGVidWdAMi42LjlAZGVidWdcXHNyY1xcbm9kZS5qcyIsImV4dGVybmFsIFwidHR5XCIiLCJleHRlcm5hbCBcIm5ldFwiIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2ludmFyaWFudEAyLjIuMkBpbnZhcmlhbnRcXGludmFyaWFudC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcYXNzaWduLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY3JlYXRlQXNzaWduZXIuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9vdmVyUmVzdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2FwcGx5LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfc2V0VG9TdHJpbmcuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlU2V0VG9TdHJpbmcuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXGNvbnN0YW50LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfc2hvcnRPdXQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxmblxcbWFwLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcZXM2Lm1hcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9pdGVyLWNhbGwuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzXFxsaWJyYXJ5XFxtb2R1bGVzXFxfaXMtYXJyYXktaXRlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9zZXQtc3BlY2llcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcZXM3Lm1hcC50by1qc29uLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcZXM3Lm1hcC5vZi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNy5tYXAuZnJvbS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcaXNTdHJpbmcuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXHRvRmluaXRlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFx0b051bWJlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcdmFsdWVzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYmFzZVZhbHVlcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VSZXBlYXQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlVG9TdHJpbmcuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHNjb3BlXFxsaWJcXHJlbmFtZXIuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXGRlZmF1bHRzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2dsb2JhbHNAOS4xOC4wQGdsb2JhbHNcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2dsb2JhbHNAOS4xOC4wQGdsb2JhbHNcXGdsb2JhbHMuanNvbiIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxjb3JlLWpzXFx3ZWFrLW1hcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXGZuXFx3ZWFrLW1hcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNi53ZWFrLW1hcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNy53ZWFrLW1hcC5vZi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNy53ZWFrLW1hcC5mcm9tLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZVxcbGliXFxwYXRoXFxhbmNlc3RyeS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2VcXGxpYlxccGF0aFxcaW5mZXJlbmNlXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2VcXGxpYlxccGF0aFxcaW5mZXJlbmNlXFxpbmZlcmVycy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2VcXGxpYlxccGF0aFxcaW5mZXJlbmNlXFxpbmZlcmVyLXJlZmVyZW5jZS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2VcXGxpYlxccGF0aFxccmVwbGFjZW1lbnQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtY29kZS1mcmFtZUA2LjI2LjBAYmFiZWwtY29kZS1mcmFtZVxcbGliXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9qcy10b2tlbnNAMy4wLjJAanMtdG9rZW5zXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jaGFsa0AxLjEuM0BjaGFsa1xcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZXNjYXBlLXN0cmluZy1yZWdleHBAMS4wLjVAZXNjYXBlLXN0cmluZy1yZWdleHBcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2Fuc2ktc3R5bGVzQDIuMi4xQGFuc2ktc3R5bGVzXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9zdHJpcC1hbnNpQDMuMC4xQHN0cmlwLWFuc2lcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2hhcy1hbnNpQDIuMC4wQGhhcy1hbnNpXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9zdXBwb3J0cy1jb2xvckAyLjAuMEBzdXBwb3J0cy1jb2xvclxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHBhdGhcXGV2YWx1YXRpb24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHBhdGhcXGNvbnZlcnNpb24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHBhdGhcXGludHJvc3BlY3Rpb24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHBhdGhcXGNvbnRleHQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHBhdGhcXHJlbW92YWwuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHBhdGhcXGxpYlxccmVtb3ZhbC1ob29rcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2VcXGxpYlxccGF0aFxcbW9kaWZpY2F0aW9uLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZVxcbGliXFxwYXRoXFxsaWJcXGhvaXN0ZXIuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHBhdGhcXGZhbWlseS5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2VcXGxpYlxccGF0aFxcY29tbWVudHMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXGNvbnRleHQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlXFxsaWJcXHZpc2l0b3JzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yXFxsaWJcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWVcXGhlbHBlcnNcXHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZVxcaGVscGVyc1xcaW5oZXJpdHMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZVxcY29yZS1qc1xcb2JqZWN0XFxzZXQtcHJvdG90eXBlLW9mLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcZm5cXG9iamVjdFxcc2V0LXByb3RvdHlwZS1vZi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXF9zZXQtcHJvdG8uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fZGV0ZWN0LWluZGVudEA0LjAuMEBkZXRlY3QtaW5kZW50XFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9yZXBlYXRpbmdAMi4wLjFAcmVwZWF0aW5nXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9pcy1maW5pdGVAMS4wLjJAaXMtZmluaXRlXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9udW1iZXItaXMtbmFuQDEuMC4xQG51bWJlci1pcy1uYW5cXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yXFxsaWJcXHNvdXJjZS1tYXAuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fc291cmNlLW1hcEAwLjUuN0Bzb3VyY2UtbWFwXFxzb3VyY2UtbWFwLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX3NvdXJjZS1tYXBAMC41LjdAc291cmNlLW1hcFxcbGliXFxiYXNlNjQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fc291cmNlLW1hcEAwLjUuN0Bzb3VyY2UtbWFwXFxsaWJcXG1hcHBpbmctbGlzdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9zb3VyY2UtbWFwQDAuNS43QHNvdXJjZS1tYXBcXGxpYlxcc291cmNlLW1hcC1jb25zdW1lci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9zb3VyY2UtbWFwQDAuNS43QHNvdXJjZS1tYXBcXGxpYlxcYmluYXJ5LXNlYXJjaC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9zb3VyY2UtbWFwQDAuNS43QHNvdXJjZS1tYXBcXGxpYlxccXVpY2stc29ydC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9zb3VyY2UtbWFwQDAuNS43QHNvdXJjZS1tYXBcXGxpYlxcc291cmNlLW5vZGUuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3JcXGxpYlxccHJpbnRlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lXFxjb3JlLWpzXFxvYmplY3RcXGFzc2lnbi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXGZuXFxvYmplY3RcXGFzc2lnbi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9jb3JlLWpzQDIuNS4zQGNvcmUtanNcXGxpYnJhcnlcXG1vZHVsZXNcXGVzNi5vYmplY3QuYXNzaWduLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWVcXGNvcmUtanNcXHdlYWstc2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcZm5cXHdlYWstc2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcZXM2LndlYWstc2V0LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcZXM3LndlYWstc2V0Lm9mLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2NvcmUtanNAMi41LjNAY29yZS1qc1xcbGlicmFyeVxcbW9kdWxlc1xcZXM3LndlYWstc2V0LmZyb20uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXGZpbmQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlTWF0Y2hlcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VJc01hdGNoLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYmFzZUlzRXF1YWxEZWVwLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYXJyYXlTb21lLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfZXF1YWxCeVRhZy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX21hcFRvQXJyYXkuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9lcXVhbE9iamVjdHMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9nZXRNYXRjaERhdGEuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxnZXQuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9zdHJpbmdUb1BhdGguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9tZW1vaXplQ2FwcGVkLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxtZW1vaXplLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxoYXNJbi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VIYXNJbi5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2hhc1BhdGguanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXHByb3BlcnR5LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYmFzZVByb3BlcnR5LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfYmFzZVByb3BlcnR5RGVlcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcZmluZEluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxmaW5kTGFzdC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcZmluZExhc3RJbmRleC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcaXNJbnRlZ2VyLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yXFxsaWJcXGJ1ZmZlci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl90cmltLXJpZ2h0QDEuMC4xQHRyaW0tcmlnaHRcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yXFxsaWJcXG5vZGVcXHdoaXRlc3BhY2UuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXG1hcC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VNYXAuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlRWFjaC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2Jhc2VGb3JPd24uanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fbG9kYXNoQDQuMTcuNUBsb2Rhc2hcXF9iYXNlRm9yLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2xvZGFzaEA0LjE3LjVAbG9kYXNoXFxfY3JlYXRlQmFzZUZvci5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9sb2Rhc2hANC4xNy41QGxvZGFzaFxcX2NyZWF0ZUJhc2VFYWNoLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yXFxsaWJcXG5vZGVcXHBhcmVudGhlc2VzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yXFxsaWJcXHdoaXRlc3BhY2UuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3JcXGxpYlxcZ2VuZXJhdG9yc1xcdGVtcGxhdGUtbGl0ZXJhbHMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3JcXGxpYlxcZ2VuZXJhdG9yc1xcZXhwcmVzc2lvbnMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3JcXGxpYlxcZ2VuZXJhdG9yc1xcc3RhdGVtZW50cy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvclxcbGliXFxnZW5lcmF0b3JzXFxjbGFzc2VzLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yXFxsaWJcXGdlbmVyYXRvcnNcXG1ldGhvZHMuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3JcXGxpYlxcZ2VuZXJhdG9yc1xcbW9kdWxlcy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9qc2VzY0AxLjMuMEBqc2VzY1xcanNlc2MuanMiLCJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXGNvb2tpbmdcXHRzXFxub2RlX21vZHVsZXNcXC5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3JcXGxpYlxcZ2VuZXJhdG9yc1xcZmxvdy5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXG5vZGVfbW9kdWxlc1xcLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvclxcbGliXFxnZW5lcmF0b3JzXFxiYXNlLmpzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcbm9kZV9tb2R1bGVzXFwuX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yXFxsaWJcXGdlbmVyYXRvcnNcXGpzeC5qcyIsIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcY29va2luZ1xcdHNcXHNyY1xccG9qb1xcRm9sZGVyLnRzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcc3JjXFxwb2pvXFxzY3JpcHRQYWdlLnRzIiwiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxjb29raW5nXFx0c1xcc3JjXFxwb2pvXFxtYW5pZmVzdFBhZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzdEQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLE9BQU8saUJBQWlCLG1CQUFtQix1QkFBdUIsNEVBQTRFLEVBQUUsRUFBRSxzQkFBc0IsZUFBZSxFQUFFOztBQUUzUSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5SkFBeUo7QUFDeko7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw4SkFBOEo7QUFDOUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEpBQTRKO0FBQzVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0tBQXNLO0FBQ3RLOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtLQUErSztBQUMvSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRLQUE0SztBQUM1Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoYUEsaUNBQTRCO0FBQzVCLCtCQUF3QjtBQUd4QixJQUFRLE9BQVEsS0FBTSxNQUFHLEdBQWEsYUFBSyxLQUFLLEtBQVMsUUFB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QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLHdLQUF3SztBQUN4Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLHNLQUFzSztBQUN0Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1S0FBdUs7QUFDdks7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2S0FBNks7QUFDN0s7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLDZLQUE2SztBQUM3Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLGlMQUFpTDtBQUNqTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1MQUFtTDtBQUNuTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1MQUFtTDtBQUNuTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwS0FBMEs7QUFDMUs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtTEFBbUw7QUFDbkw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtMQUFrTDtBQUNsTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSwwTEFBMEw7QUFDMUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMktBQTJLO0FBQzNLOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7OztBQ3JrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUs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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBOzs7QUFHQTs7O0FBR0E7OztBQUdBLHNDQUFzQyxhQUFhO0FBQ25EOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBLHlCQUF5QixlQUFlLGtCQUFrQjs7O0FBRzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxLQUFLOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFLHdFQUF3RTtBQUN4RSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLE9BQU87QUFDUCw2QkFBNkI7QUFDN0IsT0FBTztBQUNQLHdCQUF3QjtBQUN4QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtSkFBbUo7QUFDbko7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsbUJBQW1COztBQUVuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3SkFBd0o7QUFDeEo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixnRUFBZ0U7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0tBQWtLO0FBQ2xLOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrTEFBa0w7QUFDbEw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0tBQWdLO0FBQ2hLOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhKQUE4SjtBQUM5Sjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxZQUFZO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEpBQTRKO0FBQzVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtLQUFrSztBQUNsSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnS0FBZ0s7QUFDaEs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxjQUFjLEVBQUU7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFLFdBQVcsb0NBQW9DLFdBQVc7QUFDNUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUpBQWlKO0FBQ2pKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxS0FBcUs7QUFDcks7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdDQUF3QztBQUN6RTtBQUNBO0FBQ0Esc0NBQXNDLGtDQUFrQztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SkFBNEo7QUFDNUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1Q0FBdUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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OztBQUVIO0FBQ0E7QUFDQSw0RkFBNEYsZUFBZTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvS0FBb0s7QUFDcEs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esd0VBQXdFLGVBQWU7QUFDdkY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3RUFBd0UsZUFBZTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Qsa0RBQWtELG1CQUFtQjtBQUNyRTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywyQ0FBMkM7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7O0FDdElBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFT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Q2xCQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL1pBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7Ozs7Ozs7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O0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw2REFBNkQ7QUFDcEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7QUN6NEJBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pCQSxrQkFBa0IseVM7Ozs7OztBQ0FsQixrQkFBa0Iscy9WQUFzL1YsZ0lBQWdJLHVxU0FBdXFTLGdJQUFnSSxvNERBQW80RCxxcE07Ozs7OztBQ0FuenNCLGtCQUFrQix3dUM7Ozs7OztBQ0FsQixrQkFBa0IsbUQ7Ozs7OztBQ0FsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkEsbUM7Ozs7OztBQ0FBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRLGlDQUFpQyxFQUFFO0FBQ3hELGFBQWEsU0FBUyxpQ0FBaUMsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVksU0FBUztBQUNyQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRSxxQkFBcUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE1BQU07QUFDbkIsYUFBYSxRQUFRLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdFBBLGtCQUFrQiw0T0FBNE8sa0JBQWtCLGlCQUFpQixzREFBc0Qsb0JBQW9CLDJQQUEyUCxZQUFZLHVWQUF1Vix1RUFBdUUscURBQXFELEVBQUUsMkRBQTJELEVBQUUsdURBQXVELDhSOzs7Ozs7O0FDQTNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QiwwQkFBMEIsdUNBQXVDOztBQUVqRTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNySUEsbUNBQTJCO0FBQzNCLHNDQUE4QztBQUM5Qyx1Q0FBMkM7QUFFM0MsbUNBQXlDO0FBQ3pDLG1DQUF5QztBQUN6QyxpQ0FBNEI7QUFFNUIsSUFBUSxPQUFVLG9CQUFvQixJQUFLO0FBQzNDLElBQVMsUUFBVSxvQkFBb0IsSUFBTTtBQUU3QyxtQ0FBcUM7QUFFOUIsUUFBSSxJQUFDLE9BQU87QUFDOEI7QUFFakQsTUFBc0IsaUJBQVMsT0FBSTtBQVMvQixnQkFBdUIsTUFBVSxJQUFpQjtBQUN6QyxjQUFLLE1BQUs7QUFFWCxhQUFRLFVBQU8sS0FBUSxRQUFPO0FBQzlCLGFBQVUsWUFDbEI7QUFBQztBQUdHLFNBQVc7QUFFWCxZQUFRLE9BQVEsTUFBSyxLQUFLO0FBQ3hCLFlBQUcsR0FBUyxTQUFjLGNBQUM7QUFDekIsZ0JBQVEsT0FBRyxXQUFPLFFBQU87QUFFckIsaUJBQUMsSUFBSyxLQUFVLE9BQUssS0FBQyxPQUFRLFNBQUU7QUFDaEMsb0JBQUssSUFBRyxPQUFNLE9BQUk7QUFDZCxxQkFBWSxZQUFFLEdBQ3RCO0FBQUM7QUFHRSxtQkFBTyxLQUFhO0FBSTNCO0FBQUM7QUFHSyxlQUNWO0FBQUM7QUFFUTtBQUtHLGFBQVEsVUFBTyxLQUFLLEtBQUssS0FBTztBQUNwQyxZQUFPLE1BQVUsT0FBSyxLQUFVO0FBRTdCLGNBQU0sS0FBZ0IsZ0JBQU87QUFHNUIsYUFBUSxVQUFXLE9BSy9CO0FBQUM7QUFFYyxvQkFBSTtBQUNtQjtBQUVsQyxZQUFTLFFBQUs7QUFDZCxZQUFRLGFBQWEsS0FBSSxLQUFFLENBQUMsRUFBSyxLQUFhLGFBQVcsSUFBUjtBQUM3QyxnQkFBUSxPQUFPLEtBQVM7QUFDdEIsZ0JBQUssUUFBTyxLQUFJLE9BQVksWUFBUSxLQUFNLFNBQVEsS0FBTSxNQUFLLEtBQUM7QUFDNUQsb0JBQUssSUFBTyxLQUFRLFFBQUssTUFBSyxLQUFNLE1BQUs7QUFDcEMsc0JBQUssS0FDZDtBQUFDO0FBQ0s7QUFDQyxxQkFBTTtBQUNGLHlCQUVmO0FBSlc7QUFJUixTQVZhO0FBV1osYUFBUSxVQUFTO0FBR3JCLFlBQU8sWUFBYSxLQUFLLE1BQUUsQ0FBQyxFQUFLLEtBQVcsV0FBVyxJQUFSO0FBQzNDLGdCQUFlLGNBQU8sS0FBUyxTQUFPLEtBQVEsUUFBSyxLQUFJLEtBQU0sS0FBWTtBQUN6RSxnQkFBZSxjQUFFLEVBQUssS0FBVSxVQUFPLE9BQUUsRUFBSyxLQUFrQjtBQUM5RCxnQkFBSyxRQUFRLEtBQUksT0FBVyxRQUFDO0FBQ3ZCLHFCQUFRLFFBQUssS0FDckI7QUFBQztBQUNLLG1CQUNWO0FBQUUsU0FQYTtBQVlULGVBQ1Y7QUFBQztBQUVVO0FBQ1AsWUFBUSxPQUFNO0FBRVYsYUFBUSxRQUFRLFFBQVMsSUFBUjtBQUNiLG9CQUFNLE1BQU0sS0FBSyxLQUN6QjtBQUFFO0FBRUksZUFDVjtBQUFDO0FBR007QUFJQyxhQUFhO0FBQ2IsYUFBVSxVQUFLLEtBQVEsU0FBSyxLQUFLO0FBQ3JDLFlBQU8sTUFBTSxLQUFlO0FBRTVCLFlBQUssSUFBZ0IsVUFBVyxZQUFNO0FBQ3JDLFVBQUssS0FBVSxJQUFSO0FBRUEsaUJBQVUsVUFBSyxNQUFLLEtBTTVCO0FBQUcsV0FBTSxNQUFNLENBQUw7QUFDQyxvQkFBSSxJQUFXLFlBQzFCO0FBRUo7QUFNSDs7QUFoSUQsbUJBZ0lDLFM7Ozs7Ozs7Ozs7QUNoSkQsb0NBQW1DO0FBQ25DLDZDQUFzQztBQUN0Qyw4Q0FBd0M7QUFDeEMsSUFBUyxRQUFVLG9CQUFnQjtBQU1uQyxpQkFBMEI7QUFDaEIsV0FBQyxJQUFZLFNBQ3ZCO0FBQUM7QUFGRCxrQkFFQztBQUdEO0FBS0ksZ0JBQWdCO0FBRlIsYUFBSSxPQUFVLElBQWE7QUFPM0IsYUFBUSxRQUNoQjtBQUFDO0FBRU0sWUFBSztBQUNKLGFBQUksTUFBVSxRQUFNLE1BQzVCO0FBQUM7QUFFVSxnQkFBRSxHQUFFO0FBQ1AsYUFBSyxLQUFHLEtBQ2hCO0FBQUM7QUFFTztBQUNKLFlBQVEsT0FBUTtBQUNoQix5QkFBUSxRQUFLLEtBQUk7QUFDUixrQkFBSztBQUNOLG9CQUFRLE9BQVEsS0FBYztBQUczQixvQkFBSyxLQUFZLFlBQUU7QUFFbEIsd0JBQWMsYUFBUSxLQUFXLFdBQWU7QUFDaEQsd0JBQU0sS0FBYyxXQUFJO0FBQ3hCLHdCQUFRLE9BQWMsV0FBTTtBQUV6Qix3QkFDSyxLQUFXLFdBQXFCLHFCQUFDLEVBQU0sTUFBUyxXQUM3QyxLQUFZLGVBQ04sY0FDTCxNQUFhLGFBQUksT0FDbEIsS0FBSyxLQUFHLEdBQ2xCLE9BQUU7QUFFQSw0QkFBSyxJQUFPLEtBQUssS0FBRyxHQUFPO0FBQ3ZCLDZCQUFPLFFBQ2Q7QUFFSjtBQUNKO0FBRVI7QUExQnVCO0FBMEJ0QjtBQUVRO0FBRUQsYUFBVztBQUVULGVBQUMsa0JBQVMsUUFBSyxLQUFLLEtBRTlCO0FBSUg7O0FBSTZCO0FBR1Isc0I7Ozs7OztBQ2xGdEI7QUFDQTtBQUNBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pDQSw4QkFBOEI7Ozs7Ozs7O0FDQTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RkFBa0YsYUFBYSxFQUFFOztBQUVqRztBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVksZUFBZTtBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBOzs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTkE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQSxrQkFBa0IseUQ7Ozs7OztBQ0FsQjtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsQkE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNSRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxREFBcUQsT0FBTyxFQUFFO0FBQzlEOzs7Ozs7O0FDVEE7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FLHlDQUF5QztBQUN6QztBQUNBOzs7Ozs7O0FDSkEsa0JBQWtCLHlEOzs7Ozs7QUNBbEI7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFzQzs7Ozs7Ozs7QUNGcEU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FBRTNRLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLO0FBQ2pLOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7O0FBRUE7QUFDQSw0R0FBNEcsa0JBQWtCO0FBQzlIOztBQUVBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4SkFBOEo7QUFDOUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7OztBQ3hRQSxrQkFBa0IseUQ7Ozs7OztBQ0FsQjtBQUNBO0FBQ0E7Ozs7Ozs7QUNGQSxrQkFBa0IseUQ7Ozs7OztBQ0FsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7OztBQy9JQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsY0FBYzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLGNBQWM7O0FBRTVDO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3BLQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FBRTNRLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFKQUFxSjtBQUNySjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQSw2S0FBNks7QUFDN0s7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrSkFBK0o7QUFDL0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7OztBQzdWQSxrQkFBa0IseUQ7Ozs7OztBQ0FsQjtBQUNBOzs7Ozs7O0FDREE7QUFDQTs7QUFFQSw4QkFBOEIscUNBQXFDOzs7Ozs7O0FDSG5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBO0FB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OztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUM1ckJEOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNqV0Q7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDNVJEOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDbEpEOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDcEJEOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUN0R0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FBRTNROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwwQkFBMEI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2SkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5Qjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLG1CQUFtQjtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FB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QUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEpBQTRKO0FBQzVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQSw0QkFBNEIsY0FBYztBQUMxQzs7QUFFQSxvS0FBb0s7QUFDcEs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUtBQW1LO0FBQ25LOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7OztBQzdPQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25IQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OzhDQ1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7QUNoRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7Ozs7Ozs7QUNIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNqREQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrSkFBK0o7QUFDL0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdFQUF3RSxlQUFlO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLO0FBQ2pLOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLO0FBQ2pLOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDN1lBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLE9BQU8saUJBQWlCLG1CQUFtQix1QkFBdUIsNEVBQTRFLEVBQUUsRUFBRSxzQkFBc0IsZUFBZSxFQUFFOztBQUUzUTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7QUM5Q0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLE9BQU8saUJBQWlCLG1CQUFtQix1QkFBdUIsNEVBQTRFLEVBQUUsRUFBRSxzQkFBc0IsZUFBZSxFQUFFOztBQUUzUSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4SkFBOEo7QUFDOUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNLQUFzSztBQUN0Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUVBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CLEVBQUU7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUIsK0NBQStDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6akNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOUdBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDakhBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVILFVBQVU7QUFDVjs7QUFFQTs7Ozs7Ozs7QUM1WkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FBRTNRLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LEVBQUUsRUFBRSxzQkFBc0IsZUFBZSxFQUFFOztBQUUzUTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsZUFBZTs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsdUJBQXVCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OzhDQ3RMQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYixvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQUE7QUFDSCxFQUFFO0FBQ0YsbUJBQW1CO0FBQ25CO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7O0FDeFZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FBRTNRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsMEJBQTBCO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLEdBQUc7QUFDSCxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLEdBQUc7QUFDSCxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7QUN2ZkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLGVBQWU7QUFDOUQ7O0FBRUEseUNBQXlDLGVBQWU7QUFDeEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDN0RBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkpBQTZKO0FBQzdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0QkFBNEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0M7Ozs7Ozs7Ozs7QUN6SEEsK0JBQXdCO0FBQ3hCLGlDQUE0QjtBQUU1QjtBQU1JLGdCQUErQjtBQUNSO0FBQ2YsYUFBRyxLQUNYO0FBQUM7QUFFYTtBQUVSLFlBQUcsR0FBVyxXQUFLLEtBQUssS0FBQztBQUNuQixpQkFBc0Isc0JBQUssS0FDbkM7QUFBQztBQUVDLFdBQVUsVUFBSyxLQUFHLElBRXhCO0FBQUM7QUFHMkIsMEJBQVk7QUFDcEMsWUFBUyxRQUFNO0FBQ0Y7QUFDVixZQUFHLEdBQVcsV0FBTSxNQUFFO0FBQ1I7QUFDUixvQkFBSyxHQUFZLFlBQU07QUFDdkIsa0JBQVEsUUFBRSxDQUFLLE1BQVU7QUFDUTtBQUNsQyxvQkFBVyxVQUFPLEtBQUssS0FBSSxLQUFRO0FBQ0U7QUFDbEMsb0JBQUcsR0FBUyxTQUFTLFNBQWUsZUFBRTtBQUNqQyx5QkFBc0Isc0JBQVU7QUFFeEM7QUFBTSx1QkFBRTtBQUNGLHVCQUFXLFdBQ2pCO0FBQ0o7QUFBRztBQUNJO0FBQ0wsZUFBVSxVQUNoQjtBQUFNLGVBQUU7QUFDRyxvQkFBSSxJQUNmO0FBQ0o7QUFJSDs7QUFoREQsaUJBZ0RDLE87Ozs7Ozs7Ozs7QUNyREQsb0NBQWlFO0FBR2pFLG1DQUEyQjtBQUUzQixzQ0FBOEM7QUFFOUMsTUFBd0IsbUJBQVMsT0FBSTtBQUlqQyxnQkFBdUIsTUFBVSxJQUFDLFdBQXdCO0FBQ2pELGNBQUssTUFBSztBQUhYLGFBQVEsV0FBUztBQUtqQixhQUFTLFdBQ2pCO0FBQUM7QUFFYTtBQUVnQztBQUUxQyxZQUFPLE1BQU0sS0FBSyxLQUFLLEtBQU87QUFBQztBQUU3QixZQUFLLEtBQVUsVUFBQztBQUNkLGdCQUFLLElBQWdCLFVBQVcsWUFBTTtBQUNyQyxjQUFLLEtBQVUsSUFBUjtBQUMwQztBQUM5Qyx3QkFBUyxVQUFLLE1BQUssS0FBSztBQUU1QjtBQUFHLGVBQU0sTUFBTSxDQUFMO0FBQ0Msd0JBQUksSUFBVyxZQUMxQjtBQUVKO0FBQUssZUFBQztBQUM4QjtBQUNqQyxvQkFBUyxVQUFJLEtBQUssS0FDckI7QUFDSjtBQU9IOztBQXJDRCxxQkFxQ0MsVzs7Ozs7Ozs7OztBQzVDRCxtQ0FBMkI7QUFFM0IsbUNBQXNDO0FBQ1c7QUFFakQsTUFBMEIscUJBQVMsT0FBSTtBQUVuQyxnQkFBdUIsTUFBVSxJQUFDLFdBQXdCO0FBQ2pELGNBQUssTUFDZDtBQUFDO0FBR1csU0FBVztBQUNiLGVBQU0sTUFBSyxLQUNyQjtBQUFDO0FBR2E7QUFFVixZQUFPLE1BQU0sS0FBSyxLQUFLLEtBQU87QUFDOUIsWUFBUSxPQUFPLEtBQU0sTUFBTTtBQUN2QixhQUFRLFVBQUcsT0FBUTtBQUN2QixZQUFPLE1BQU8sS0FBVSxVQUFLLE1BQU0sTUFBUTtBQUN2QyxhQUFVLFVBQUksS0FBSyxLQUszQjtBQUlIOztBQTNCRCx1QkEyQkMsYSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNzYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGQ4ZThhOTA3YjAxY2U4MzA3ZTQxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZiA9IGV4cG9ydHMucmVtb3ZlVHlwZUR1cGxpY2F0ZXMgPSBleHBvcnRzLmNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnZhbHVlVG9Ob2RlID0gZXhwb3J0cy50b0Jsb2NrID0gZXhwb3J0cy50b0V4cHJlc3Npb24gPSBleHBvcnRzLnRvU3RhdGVtZW50ID0gZXhwb3J0cy50b0JpbmRpbmdJZGVudGlmaWVyTmFtZSA9IGV4cG9ydHMudG9JZGVudGlmaWVyID0gZXhwb3J0cy50b0tleUFsaWFzID0gZXhwb3J0cy50b1NlcXVlbmNlRXhwcmVzc2lvbiA9IGV4cG9ydHMudG9Db21wdXRlZEtleSA9IGV4cG9ydHMuaXNOb2Rlc0VxdWl2YWxlbnQgPSBleHBvcnRzLmlzSW1tdXRhYmxlID0gZXhwb3J0cy5pc1Njb3BlID0gZXhwb3J0cy5pc1NwZWNpZmllckRlZmF1bHQgPSBleHBvcnRzLmlzVmFyID0gZXhwb3J0cy5pc0Jsb2NrU2NvcGVkID0gZXhwb3J0cy5pc0xldCA9IGV4cG9ydHMuaXNWYWxpZElkZW50aWZpZXIgPSBleHBvcnRzLmlzUmVmZXJlbmNlZCA9IGV4cG9ydHMuaXNCaW5kaW5nID0gZXhwb3J0cy5nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycyA9IGV4cG9ydHMuZ2V0QmluZGluZ0lkZW50aWZpZXJzID0gZXhwb3J0cy5UWVBFUyA9IGV4cG9ydHMucmVhY3QgPSBleHBvcnRzLkRFUFJFQ0FURURfS0VZUyA9IGV4cG9ydHMuQlVJTERFUl9LRVlTID0gZXhwb3J0cy5OT0RFX0ZJRUxEUyA9IGV4cG9ydHMuQUxJQVNfS0VZUyA9IGV4cG9ydHMuVklTSVRPUl9LRVlTID0gZXhwb3J0cy5OT1RfTE9DQUxfQklORElORyA9IGV4cG9ydHMuQkxPQ0tfU0NPUEVEX1NZTUJPTCA9IGV4cG9ydHMuSU5IRVJJVF9LRVlTID0gZXhwb3J0cy5VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlNUUklOR19VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5DT01QQVJJU09OX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlVQREFURV9PUEVSQVRPUlMgPSBleHBvcnRzLkxPR0lDQUxfT1BFUkFUT1JTID0gZXhwb3J0cy5DT01NRU5UX0tFWVMgPSBleHBvcnRzLkZPUl9JTklUX0tFWVMgPSBleHBvcnRzLkZMQVRURU5BQkxFX0tFWVMgPSBleHBvcnRzLlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gdW5kZWZpbmVkO1xuXG52YXIgX2dldE93blByb3BlcnR5U3ltYm9scyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktc3ltYm9sc1wiKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eVN5bWJvbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0T3duUHJvcGVydHlTeW1ib2xzKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG52YXIgX2tleXMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfc3RyaW5naWZ5ID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeVwiKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb25zdGFudHMuU1RBVEVNRU5UX09SX0JMT0NLX0tFWVM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRkxBVFRFTkFCTEVfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLkZMQVRURU5BQkxFX0tFWVM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRk9SX0lOSVRfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLkZPUl9JTklUX0tFWVM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ09NTUVOVF9LRVlTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb25zdGFudHMuQ09NTUVOVF9LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxPR0lDQUxfT1BFUkFUT1JTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb25zdGFudHMuTE9HSUNBTF9PUEVSQVRPUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVVBEQVRFX09QRVJBVE9SU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLlVQREFURV9PUEVSQVRPUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLkJPT0xFQU5fTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLkVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb25zdGFudHMuQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJPT0xFQU5fQklOQVJZX09QRVJBVE9SU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLkJPT0xFQU5fQklOQVJZX09QRVJBVE9SUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOVU1CRVJfQklOQVJZX09QRVJBVE9SU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJJTkFSWV9PUEVSQVRPUlNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvbnN0YW50cy5CSU5BUllfT1BFUkFUT1JTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb25zdGFudHMuQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTlVNQkVSX1VOQVJZX09QRVJBVE9SU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1RSSU5HX1VOQVJZX09QRVJBVE9SU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLlNUUklOR19VTkFSWV9PUEVSQVRPUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVU5BUllfT1BFUkFUT1JTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb25zdGFudHMuVU5BUllfT1BFUkFUT1JTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklOSEVSSVRfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLklOSEVSSVRfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCTE9DS19TQ09QRURfU1lNQk9MXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb25zdGFudHMuQkxPQ0tfU0NPUEVEX1NZTUJPTDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOT1RfTE9DQUxfQklORElOR1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uc3RhbnRzLk5PVF9MT0NBTF9CSU5ESU5HO1xuICB9XG59KTtcbmV4cG9ydHMuaXMgPSBpcztcbmV4cG9ydHMuaXNUeXBlID0gaXNUeXBlO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuZXhwb3J0cy5zaGFsbG93RXF1YWwgPSBzaGFsbG93RXF1YWw7XG5leHBvcnRzLmFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IGFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMucHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IHByZXBlbmRUb01lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmVuc3VyZUJsb2NrID0gZW5zdXJlQmxvY2s7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmNsb25lV2l0aG91dExvYyA9IGNsb25lV2l0aG91dExvYztcbmV4cG9ydHMuY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuZXhwb3J0cy5idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbiA9IGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5yZW1vdmVDb21tZW50cyA9IHJlbW92ZUNvbW1lbnRzO1xuZXhwb3J0cy5pbmhlcml0c0NvbW1lbnRzID0gaW5oZXJpdHNDb21tZW50cztcbmV4cG9ydHMuaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMgPSBpbmhlcml0VHJhaWxpbmdDb21tZW50cztcbmV4cG9ydHMuaW5oZXJpdExlYWRpbmdDb21tZW50cyA9IGluaGVyaXRMZWFkaW5nQ29tbWVudHM7XG5leHBvcnRzLmluaGVyaXRJbm5lckNvbW1lbnRzID0gaW5oZXJpdElubmVyQ29tbWVudHM7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLmFzc2VydE5vZGUgPSBhc3NlcnROb2RlO1xuZXhwb3J0cy5pc05vZGUgPSBpc05vZGU7XG5leHBvcnRzLnRyYXZlcnNlRmFzdCA9IHRyYXZlcnNlRmFzdDtcbmV4cG9ydHMucmVtb3ZlUHJvcGVydGllcyA9IHJlbW92ZVByb3BlcnRpZXM7XG5leHBvcnRzLnJlbW92ZVByb3BlcnRpZXNEZWVwID0gcmVtb3ZlUHJvcGVydGllc0RlZXA7XG5cbnZhciBfcmV0cmlldmVycyA9IHJlcXVpcmUoXCIuL3JldHJpZXZlcnNcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJpbmRpbmdJZGVudGlmaWVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmV0cmlldmVycy5nZXRCaW5kaW5nSWRlbnRpZmllcnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JldHJpZXZlcnMuZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnM7XG4gIH1cbn0pO1xuXG52YXIgX3ZhbGlkYXRvcnMgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0JpbmRpbmdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3ZhbGlkYXRvcnMuaXNCaW5kaW5nO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVmZXJlbmNlZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdmFsaWRhdG9ycy5pc1JlZmVyZW5jZWQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZElkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3ZhbGlkYXRvcnMuaXNWYWxpZElkZW50aWZpZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMZXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3ZhbGlkYXRvcnMuaXNMZXQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCbG9ja1Njb3BlZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdmFsaWRhdG9ycy5pc0Jsb2NrU2NvcGVkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0b3JzLmlzVmFyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3BlY2lmaWVyRGVmYXVsdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdmFsaWRhdG9ycy5pc1NwZWNpZmllckRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTY29wZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdmFsaWRhdG9ycy5pc1Njb3BlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSW1tdXRhYmxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0b3JzLmlzSW1tdXRhYmxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTm9kZXNFcXVpdmFsZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0b3JzLmlzTm9kZXNFcXVpdmFsZW50O1xuICB9XG59KTtcblxudmFyIF9jb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9Db21wdXRlZEtleVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29udmVydGVycy50b0NvbXB1dGVkS2V5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvU2VxdWVuY2VFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb252ZXJ0ZXJzLnRvU2VxdWVuY2VFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvS2V5QWxpYXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvbnZlcnRlcnMudG9LZXlBbGlhcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0lkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvbnZlcnRlcnMudG9JZGVudGlmaWVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmluZGluZ0lkZW50aWZpZXJOYW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb252ZXJ0ZXJzLnRvQmluZGluZ0lkZW50aWZpZXJOYW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb252ZXJ0ZXJzLnRvU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29udmVydGVycy50b0V4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CbG9ja1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29udmVydGVycy50b0Jsb2NrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbHVlVG9Ob2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb252ZXJ0ZXJzLnZhbHVlVG9Ob2RlO1xuICB9XG59KTtcblxudmFyIF9mbG93ID0gcmVxdWlyZShcIi4vZmxvd1wiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVW5pb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmxvdy5jcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZVR5cGVEdXBsaWNhdGVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mbG93LnJlbW92ZVR5cGVEdXBsaWNhdGVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmxvdy5jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2Y7XG4gIH1cbn0pO1xuXG52YXIgX3RvRmFzdFByb3BlcnRpZXMgPSByZXF1aXJlKFwidG8tZmFzdC1wcm9wZXJ0aWVzXCIpO1xuXG52YXIgX3RvRmFzdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9GYXN0UHJvcGVydGllcyk7XG5cbnZhciBfY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpO1xuXG52YXIgX2Nsb25lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lKTtcblxudmFyIF91bmlxID0gcmVxdWlyZShcImxvZGFzaC91bmlxXCIpO1xuXG52YXIgX3VuaXEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdW5pcSk7XG5cbnJlcXVpcmUoXCIuL2RlZmluaXRpb25zL2luaXRcIik7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi9kZWZpbml0aW9uc1wiKTtcblxudmFyIF9yZWFjdDIgPSByZXF1aXJlKFwiLi9yZWFjdFwiKTtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9yZWFjdDIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdCA9IGV4cG9ydHM7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyVHlwZSh0eXBlKSB7XG4gIHZhciBpcyA9IHRbXCJpc1wiICsgdHlwZV07XG4gIGlmICghaXMpIHtcbiAgICBpcyA9IHRbXCJpc1wiICsgdHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgb3B0cykge1xuICAgICAgcmV0dXJuIHQuaXModHlwZSwgbm9kZSwgb3B0cyk7XG4gICAgfTtcbiAgfVxuXG4gIHRbXCJhc3NlcnRcIiArIHR5cGVdID0gZnVuY3Rpb24gKG5vZGUsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBpZiAoIWlzKG5vZGUsIG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB0eXBlIFwiICsgKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKHR5cGUpICsgXCIgd2l0aCBvcHRpb24gXCIgKyAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkob3B0cykpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0cy5WSVNJVE9SX0tFWVMgPSBfZGVmaW5pdGlvbnMuVklTSVRPUl9LRVlTO1xuZXhwb3J0cy5BTElBU19LRVlTID0gX2RlZmluaXRpb25zLkFMSUFTX0tFWVM7XG5leHBvcnRzLk5PREVfRklFTERTID0gX2RlZmluaXRpb25zLk5PREVfRklFTERTO1xuZXhwb3J0cy5CVUlMREVSX0tFWVMgPSBfZGVmaW5pdGlvbnMuQlVJTERFUl9LRVlTO1xuZXhwb3J0cy5ERVBSRUNBVEVEX0tFWVMgPSBfZGVmaW5pdGlvbnMuREVQUkVDQVRFRF9LRVlTO1xuZXhwb3J0cy5yZWFjdCA9IF9yZWFjdDtcblxuXG5mb3IgKHZhciB0eXBlIGluIHQuVklTSVRPUl9LRVlTKSB7XG4gIHJlZ2lzdGVyVHlwZSh0eXBlKTtcbn1cblxudC5GTElQUEVEX0FMSUFTX0tFWVMgPSB7fTtcblxuKDAsIF9rZXlzMi5kZWZhdWx0KSh0LkFMSUFTX0tFWVMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgdC5BTElBU19LRVlTW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgdmFyIHR5cGVzID0gdC5GTElQUEVEX0FMSUFTX0tFWVNbYWxpYXNdID0gdC5GTElQUEVEX0FMSUFTX0tFWVNbYWxpYXNdIHx8IFtdO1xuICAgIHR5cGVzLnB1c2godHlwZSk7XG4gIH0pO1xufSk7XG5cbigwLCBfa2V5czIuZGVmYXVsdCkodC5GTElQUEVEX0FMSUFTX0tFWVMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgdFt0eXBlLnRvVXBwZXJDYXNlKCkgKyBcIl9UWVBFU1wiXSA9IHQuRkxJUFBFRF9BTElBU19LRVlTW3R5cGVdO1xuICByZWdpc3RlclR5cGUodHlwZSk7XG59KTtcblxudmFyIFRZUEVTID0gZXhwb3J0cy5UWVBFUyA9ICgwLCBfa2V5czIuZGVmYXVsdCkodC5WSVNJVE9SX0tFWVMpLmNvbmNhdCgoMCwgX2tleXMyLmRlZmF1bHQpKHQuRkxJUFBFRF9BTElBU19LRVlTKSkuY29uY2F0KCgwLCBfa2V5czIuZGVmYXVsdCkodC5ERVBSRUNBVEVEX0tFWVMpKTtcblxuZnVuY3Rpb24gaXModHlwZSwgbm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF0Y2hlcyA9IGlzVHlwZShub2RlLnR5cGUsIHR5cGUpO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdC5zaGFsbG93RXF1YWwobm9kZSwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUeXBlKG5vZGVUeXBlLCB0YXJnZXRUeXBlKSB7XG4gIGlmIChub2RlVHlwZSA9PT0gdGFyZ2V0VHlwZSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHQuQUxJQVNfS0VZU1t0YXJnZXRUeXBlXSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBhbGlhc2VzID0gdC5GTElQUEVEX0FMSUFTX0tFWVNbdGFyZ2V0VHlwZV07XG4gIGlmIChhbGlhc2VzKSB7XG4gICAgaWYgKGFsaWFzZXNbMF0gPT09IG5vZGVUeXBlKSByZXR1cm4gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFsaWFzZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGlhcyA9IF9yZWY7XG5cbiAgICAgIGlmIChub2RlVHlwZSA9PT0gYWxpYXMpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuKDAsIF9rZXlzMi5kZWZhdWx0KSh0LkJVSUxERVJfS0VZUykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICB2YXIga2V5cyA9IHQuQlVJTERFUl9LRVlTW3R5cGVdO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkZXIoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiBrZXlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidC5cIiArIHR5cGUgKyBcIjogVG9vIG1hbnkgYXJndW1lbnRzIHBhc3NlZC4gUmVjZWl2ZWQgXCIgKyBhcmd1bWVudHMubGVuZ3RoICsgXCIgYnV0IGNhbiByZWNlaXZlIFwiICsgKFwibm8gbW9yZSB0aGFuIFwiICsga2V5cy5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IHt9O1xuICAgIG5vZGUudHlwZSA9IHR5cGU7XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0ga2V5cywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IyKTs7KSB7XG4gICAgICB2YXIgX3JlZjI7XG5cbiAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfa2V5ID0gX3JlZjI7XG5cbiAgICAgIHZhciBmaWVsZCA9IHQuTk9ERV9GSUVMRFNbdHlwZV1bX2tleV07XG5cbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkgYXJnID0gKDAsIF9jbG9uZTIuZGVmYXVsdCkoZmllbGQuZGVmYXVsdCk7XG5cbiAgICAgIG5vZGVbX2tleV0gPSBhcmc7XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICAgIHZhbGlkYXRlKG5vZGUsIGtleSwgbm9kZVtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHRbdHlwZV0gPSBidWlsZGVyO1xuICB0W3R5cGVbMF0udG9Mb3dlckNhc2UoKSArIHR5cGUuc2xpY2UoMSldID0gYnVpbGRlcjtcbn0pO1xuXG52YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfdHlwZSkge1xuICB2YXIgbmV3VHlwZSA9IHQuREVQUkVDQVRFRF9LRVlTW190eXBlXTtcblxuICBmdW5jdGlvbiBwcm94eShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBcIiArIF90eXBlICsgXCIgaGFzIGJlZW4gcmVuYW1lZCB0byBcIiArIG5ld1R5cGUpO1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHRbX3R5cGVdID0gdFtfdHlwZVswXS50b0xvd2VyQ2FzZSgpICsgX3R5cGUuc2xpY2UoMSldID0gcHJveHkodFtuZXdUeXBlXSk7XG4gIHRbXCJpc1wiICsgX3R5cGVdID0gcHJveHkodFtcImlzXCIgKyBuZXdUeXBlXSk7XG4gIHRbXCJhc3NlcnRcIiArIF90eXBlXSA9IHByb3h5KHRbXCJhc3NlcnRcIiArIG5ld1R5cGVdKTtcbn07XG5cbmZvciAodmFyIF90eXBlIGluIHQuREVQUkVDQVRFRF9LRVlTKSB7XG4gIF9sb29wKF90eXBlKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgdmFyIGZpZWxkcyA9IHQuTk9ERV9GSUVMRFNbbm9kZS50eXBlXTtcbiAgaWYgKCFmaWVsZHMpIHJldHVybjtcblxuICB2YXIgZmllbGQgPSBmaWVsZHNba2V5XTtcbiAgaWYgKCFmaWVsZCB8fCAhZmllbGQudmFsaWRhdGUpIHJldHVybjtcbiAgaWYgKGZpZWxkLm9wdGlvbmFsICYmIHZhbCA9PSBudWxsKSByZXR1cm47XG5cbiAgZmllbGQudmFsaWRhdGUobm9kZSwga2V5LCB2YWwpO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICB2YXIga2V5cyA9ICgwLCBfa2V5czIuZGVmYXVsdCkoZXhwZWN0ZWQpO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvcjMgPSBrZXlzLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjMpOzspIHtcbiAgICB2YXIgX3JlZjM7XG5cbiAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYzID0gX2l0ZXJhdG9yM1tfaTMrK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpO1xuICAgICAgaWYgKF9pMy5kb25lKSBicmVhaztcbiAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBfcmVmMztcblxuICAgIGlmIChhY3R1YWxba2V5XSAhPT0gZXhwZWN0ZWRba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRUb01lbWJlckV4cHJlc3Npb24obWVtYmVyLCBhcHBlbmQsIGNvbXB1dGVkKSB7XG4gIG1lbWJlci5vYmplY3QgPSB0Lm1lbWJlckV4cHJlc3Npb24obWVtYmVyLm9iamVjdCwgbWVtYmVyLnByb3BlcnR5LCBtZW1iZXIuY29tcHV0ZWQpO1xuICBtZW1iZXIucHJvcGVydHkgPSBhcHBlbmQ7XG4gIG1lbWJlci5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gIHJldHVybiBtZW1iZXI7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRUb01lbWJlckV4cHJlc3Npb24obWVtYmVyLCBwcmVwZW5kKSB7XG4gIG1lbWJlci5vYmplY3QgPSB0Lm1lbWJlckV4cHJlc3Npb24ocHJlcGVuZCwgbWVtYmVyLm9iamVjdCk7XG4gIHJldHVybiBtZW1iZXI7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUJsb2NrKG5vZGUpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJib2R5XCI7XG5cbiAgcmV0dXJuIG5vZGVba2V5XSA9IHQudG9CbG9jayhub2RlW2tleV0sIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBjbG9uZShub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIG5vZGU7XG4gIHZhciBuZXdOb2RlID0ge307XG4gIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgaWYgKGtleVswXSA9PT0gXCJfXCIpIGNvbnRpbnVlO1xuICAgIG5ld05vZGVba2V5XSA9IG5vZGVba2V5XTtcbiAgfVxuICByZXR1cm4gbmV3Tm9kZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVXaXRob3V0TG9jKG5vZGUpIHtcbiAgdmFyIG5ld05vZGUgPSBjbG9uZShub2RlKTtcbiAgZGVsZXRlIG5ld05vZGUubG9jO1xuICByZXR1cm4gbmV3Tm9kZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVEZWVwKG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gbm9kZTtcbiAgdmFyIG5ld05vZGUgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuICAgIGlmIChrZXlbMF0gPT09IFwiX1wiKSBjb250aW51ZTtcblxuICAgIHZhciB2YWwgPSBub2RlW2tleV07XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICBpZiAodmFsLnR5cGUpIHtcbiAgICAgICAgdmFsID0gdC5jbG9uZURlZXAodmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHZhbC5tYXAodC5jbG9uZURlZXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld05vZGVba2V5XSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBuZXdOb2RlO1xufVxuXG5mdW5jdGlvbiBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihtYXRjaCwgYWxsb3dQYXJ0aWFsKSB7XG4gIHZhciBwYXJ0cyA9IG1hdGNoLnNwbGl0KFwiLlwiKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKG1lbWJlcikge1xuICAgIGlmICghdC5pc01lbWJlckV4cHJlc3Npb24obWVtYmVyKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHNlYXJjaCA9IFttZW1iZXJdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChzZWFyY2gubGVuZ3RoKSB7XG4gICAgICB2YXIgbm9kZSA9IHNlYXJjaC5zaGlmdCgpO1xuXG4gICAgICBpZiAoYWxsb3dQYXJ0aWFsICYmIGkgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgICAgIGlmIChwYXJ0c1tpXSAhPT0gbm9kZS5uYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHQuaXNTdHJpbmdMaXRlcmFsKG5vZGUpKSB7XG4gICAgICAgIGlmIChwYXJ0c1tpXSAhPT0gbm9kZS52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCAmJiAhdC5pc1N0cmluZ0xpdGVyYWwobm9kZS5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VhcmNoLnB1c2gobm9kZS5vYmplY3QpO1xuICAgICAgICAgIHNlYXJjaC5wdXNoKG5vZGUucHJvcGVydHkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgrK2kgPiBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDb21tZW50cyhub2RlKSB7XG4gIGZvciAodmFyIF9pdGVyYXRvcjQgPSB0LkNPTU1FTlRfS0VZUywgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I0KSwgX2k0ID0gMCwgX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/IF9pdGVyYXRvcjQgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3I0KTs7KSB7XG4gICAgdmFyIF9yZWY0O1xuXG4gICAgaWYgKF9pc0FycmF5NCkge1xuICAgICAgaWYgKF9pNCA+PSBfaXRlcmF0b3I0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmNCA9IF9pdGVyYXRvcjRbX2k0KytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcbiAgICAgIGlmIChfaTQuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmNCA9IF9pNC52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gX3JlZjQ7XG5cbiAgICBkZWxldGUgbm9kZVtrZXldO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpbmhlcml0c0NvbW1lbnRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMoY2hpbGQsIHBhcmVudCk7XG4gIGluaGVyaXRMZWFkaW5nQ29tbWVudHMoY2hpbGQsIHBhcmVudCk7XG4gIGluaGVyaXRJbm5lckNvbW1lbnRzKGNoaWxkLCBwYXJlbnQpO1xuICByZXR1cm4gY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRUcmFpbGluZ0NvbW1lbnRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgX2luaGVyaXRDb21tZW50cyhcInRyYWlsaW5nQ29tbWVudHNcIiwgY2hpbGQsIHBhcmVudCk7XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRMZWFkaW5nQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICBfaW5oZXJpdENvbW1lbnRzKFwibGVhZGluZ0NvbW1lbnRzXCIsIGNoaWxkLCBwYXJlbnQpO1xufVxuXG5mdW5jdGlvbiBpbmhlcml0SW5uZXJDb21tZW50cyhjaGlsZCwgcGFyZW50KSB7XG4gIF9pbmhlcml0Q29tbWVudHMoXCJpbm5lckNvbW1lbnRzXCIsIGNoaWxkLCBwYXJlbnQpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdENvbW1lbnRzKGtleSwgY2hpbGQsIHBhcmVudCkge1xuICBpZiAoY2hpbGQgJiYgcGFyZW50KSB7XG4gICAgY2hpbGRba2V5XSA9ICgwLCBfdW5pcTIuZGVmYXVsdCkoW10uY29uY2F0KGNoaWxkW2tleV0sIHBhcmVudFtrZXldKS5maWx0ZXIoQm9vbGVhbikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgaWYgKCFjaGlsZCB8fCAhcGFyZW50KSByZXR1cm4gY2hpbGQ7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IHQuSU5IRVJJVF9LRVlTLm9wdGlvbmFsLCBfaXNBcnJheTUgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjUpLCBfaTUgPSAwLCBfaXRlcmF0b3I1ID0gX2lzQXJyYXk1ID8gX2l0ZXJhdG9yNSA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjUpOzspIHtcbiAgICB2YXIgX3JlZjU7XG5cbiAgICBpZiAoX2lzQXJyYXk1KSB7XG4gICAgICBpZiAoX2k1ID49IF9pdGVyYXRvcjUubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWY1ID0gX2l0ZXJhdG9yNVtfaTUrK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pNSA9IF9pdGVyYXRvcjUubmV4dCgpO1xuICAgICAgaWYgKF9pNS5kb25lKSBicmVhaztcbiAgICAgIF9yZWY1ID0gX2k1LnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBfa2V5MiA9IF9yZWY1O1xuXG4gICAgaWYgKGNoaWxkW19rZXkyXSA9PSBudWxsKSB7XG4gICAgICBjaGlsZFtfa2V5Ml0gPSBwYXJlbnRbX2tleTJdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoa2V5WzBdID09PSBcIl9cIikgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuICB9XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IHQuSU5IRVJJVF9LRVlTLmZvcmNlLCBfaXNBcnJheTYgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjYpLCBfaTYgPSAwLCBfaXRlcmF0b3I2ID0gX2lzQXJyYXk2ID8gX2l0ZXJhdG9yNiA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjYpOzspIHtcbiAgICB2YXIgX3JlZjY7XG5cbiAgICBpZiAoX2lzQXJyYXk2KSB7XG4gICAgICBpZiAoX2k2ID49IF9pdGVyYXRvcjYubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWY2ID0gX2l0ZXJhdG9yNltfaTYrK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pNiA9IF9pdGVyYXRvcjYubmV4dCgpO1xuICAgICAgaWYgKF9pNi5kb25lKSBicmVhaztcbiAgICAgIF9yZWY2ID0gX2k2LnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBfa2V5MyA9IF9yZWY2O1xuXG4gICAgY2hpbGRbX2tleTNdID0gcGFyZW50W19rZXkzXTtcbiAgfVxuXG4gIHQuaW5oZXJpdHNDb21tZW50cyhjaGlsZCwgcGFyZW50KTtcblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSkge1xuICBpZiAoIWlzTm9kZShub2RlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgYSB2YWxpZCBub2RlIFwiICsgKG5vZGUgJiYgbm9kZS50eXBlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgX2RlZmluaXRpb25zLlZJU0lUT1JfS0VZU1tub2RlLnR5cGVdKTtcbn1cblxuKDAsIF90b0Zhc3RQcm9wZXJ0aWVzMi5kZWZhdWx0KSh0KTtcbigwLCBfdG9GYXN0UHJvcGVydGllczIuZGVmYXVsdCkodC5WSVNJVE9SX0tFWVMpO1xuXG5mdW5jdGlvbiB0cmF2ZXJzZUZhc3Qobm9kZSwgZW50ZXIsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgdmFyIGtleXMgPSB0LlZJU0lUT1JfS0VZU1tub2RlLnR5cGVdO1xuICBpZiAoIWtleXMpIHJldHVybjtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgZW50ZXIobm9kZSwgb3B0cyk7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IGtleXMsIF9pc0FycmF5NyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNyksIF9pNyA9IDAsIF9pdGVyYXRvcjcgPSBfaXNBcnJheTcgPyBfaXRlcmF0b3I3IDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yNyk7Oykge1xuICAgIHZhciBfcmVmNztcblxuICAgIGlmIChfaXNBcnJheTcpIHtcbiAgICAgIGlmIChfaTcgPj0gX2l0ZXJhdG9yNy5sZW5ndGgpIGJyZWFrO1xuICAgICAgX3JlZjcgPSBfaXRlcmF0b3I3W19pNysrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2k3ID0gX2l0ZXJhdG9yNy5uZXh0KCk7XG4gICAgICBpZiAoX2k3LmRvbmUpIGJyZWFrO1xuICAgICAgX3JlZjcgPSBfaTcudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IF9yZWY3O1xuXG4gICAgdmFyIHN1Yk5vZGUgPSBub2RlW2tleV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJOb2RlKSkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOCA9IHN1Yk5vZGUsIF9pc0FycmF5OCA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yOCksIF9pOCA9IDAsIF9pdGVyYXRvcjggPSBfaXNBcnJheTggPyBfaXRlcmF0b3I4IDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yOCk7Oykge1xuICAgICAgICB2YXIgX3JlZjg7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5OCkge1xuICAgICAgICAgIGlmIChfaTggPj0gX2l0ZXJhdG9yOC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWY4ID0gX2l0ZXJhdG9yOFtfaTgrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2k4ID0gX2l0ZXJhdG9yOC5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pOC5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmOCA9IF9pOC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZSA9IF9yZWY4O1xuXG4gICAgICAgIHRyYXZlcnNlRmFzdChfbm9kZSwgZW50ZXIsIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmF2ZXJzZUZhc3Qoc3ViTm9kZSwgZW50ZXIsIG9wdHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgQ0xFQVJfS0VZUyA9IFtcInRva2Vuc1wiLCBcInN0YXJ0XCIsIFwiZW5kXCIsIFwibG9jXCIsIFwicmF3XCIsIFwicmF3VmFsdWVcIl07XG5cbnZhciBDTEVBUl9LRVlTX1BMVVNfQ09NTUVOVFMgPSB0LkNPTU1FTlRfS0VZUy5jb25jYXQoW1wiY29tbWVudHNcIl0pLmNvbmNhdChDTEVBUl9LRVlTKTtcblxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhub2RlLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgbWFwID0gb3B0cy5wcmVzZXJ2ZUNvbW1lbnRzID8gQ0xFQVJfS0VZUyA6IENMRUFSX0tFWVNfUExVU19DT01NRU5UUztcbiAgZm9yICh2YXIgX2l0ZXJhdG9yOSA9IG1hcCwgX2lzQXJyYXk5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I5KSwgX2k5ID0gMCwgX2l0ZXJhdG9yOSA9IF9pc0FycmF5OSA/IF9pdGVyYXRvcjkgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3I5KTs7KSB7XG4gICAgdmFyIF9yZWY5O1xuXG4gICAgaWYgKF9pc0FycmF5OSkge1xuICAgICAgaWYgKF9pOSA+PSBfaXRlcmF0b3I5Lmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmOSA9IF9pdGVyYXRvcjlbX2k5KytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaTkgPSBfaXRlcmF0b3I5Lm5leHQoKTtcbiAgICAgIGlmIChfaTkuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmOSA9IF9pOS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgX2tleTQgPSBfcmVmOTtcblxuICAgIGlmIChub2RlW19rZXk0XSAhPSBudWxsKSBub2RlW19rZXk0XSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgaWYgKGtleVswXSA9PT0gXCJfXCIgJiYgbm9kZVtrZXldICE9IG51bGwpIG5vZGVba2V5XSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBzeW1zID0gKDAsIF9nZXRPd25Qcm9wZXJ0eVN5bWJvbHMyLmRlZmF1bHQpKG5vZGUpO1xuICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IHN5bXMsIF9pc0FycmF5MTAgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjEwKSwgX2kxMCA9IDAsIF9pdGVyYXRvcjEwID0gX2lzQXJyYXkxMCA/IF9pdGVyYXRvcjEwIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMTApOzspIHtcbiAgICB2YXIgX3JlZjEwO1xuXG4gICAgaWYgKF9pc0FycmF5MTApIHtcbiAgICAgIGlmIChfaTEwID49IF9pdGVyYXRvcjEwLmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmMTAgPSBfaXRlcmF0b3IxMFtfaTEwKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaTEwID0gX2l0ZXJhdG9yMTAubmV4dCgpO1xuICAgICAgaWYgKF9pMTAuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmMTAgPSBfaTEwLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBzeW0gPSBfcmVmMTA7XG5cbiAgICBub2RlW3N5bV0gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXNEZWVwKHRyZWUsIG9wdHMpIHtcbiAgdHJhdmVyc2VGYXN0KHRyZWUsIHJlbW92ZVByb3BlcnRpZXMsIG9wdHMpO1xuICByZXR1cm4gdHJlZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlcy9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjMnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYga2V5IGluIGV4cG9ydHMpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaXNBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19yb290LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaXNPYmplY3RMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlR2V0VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaXNPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2lzQXJyYXlMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuREVQUkVDQVRFRF9LRVlTID0gZXhwb3J0cy5CVUlMREVSX0tFWVMgPSBleHBvcnRzLk5PREVfRklFTERTID0gZXhwb3J0cy5BTElBU19LRVlTID0gZXhwb3J0cy5WSVNJVE9SX0tFWVMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5XCIpO1xuXG52YXIgX3N0cmluZ2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnkpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmV4cG9ydHMuYXNzZXJ0RWFjaCA9IGFzc2VydEVhY2g7XG5leHBvcnRzLmFzc2VydE9uZU9mID0gYXNzZXJ0T25lT2Y7XG5leHBvcnRzLmFzc2VydE5vZGVUeXBlID0gYXNzZXJ0Tm9kZVR5cGU7XG5leHBvcnRzLmFzc2VydE5vZGVPclZhbHVlVHlwZSA9IGFzc2VydE5vZGVPclZhbHVlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VmFsdWVUeXBlID0gYXNzZXJ0VmFsdWVUeXBlO1xuZXhwb3J0cy5jaGFpbiA9IGNoYWluO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmaW5lVHlwZTtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaW5kZXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgVklTSVRPUl9LRVlTID0gZXhwb3J0cy5WSVNJVE9SX0tFWVMgPSB7fTtcbnZhciBBTElBU19LRVlTID0gZXhwb3J0cy5BTElBU19LRVlTID0ge307XG52YXIgTk9ERV9GSUVMRFMgPSBleHBvcnRzLk5PREVfRklFTERTID0ge307XG52YXIgQlVJTERFUl9LRVlTID0gZXhwb3J0cy5CVUlMREVSX0tFWVMgPSB7fTtcbnZhciBERVBSRUNBVEVEX0tFWVMgPSBleHBvcnRzLkRFUFJFQ0FURURfS0VZUyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRUeXBlKHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH0gZWxzZSBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkodmFsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRFYWNoKGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2sobm9kZSwga2V5ICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbFtpXSk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRvci5lYWNoID0gY2FsbGJhY2s7XG4gIHJldHVybiB2YWxpZGF0b3I7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9uZU9mKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFscyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGlmICh2YWxzLmluZGV4T2YodmFsKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBcIiArIGtleSArIFwiIGV4cGVjdGVkIHZhbHVlIHRvIGJlIG9uZSBvZiBcIiArICgwLCBfc3RyaW5naWZ5Mi5kZWZhdWx0KSh2YWxzKSArIFwiIGJ1dCBnb3QgXCIgKyAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkodmFsKSk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUub25lT2YgPSB2YWxzO1xuXG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm9kZVR5cGUoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZXMgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIHR5cGVzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdHlwZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gX3JlZjtcblxuICAgICAgaWYgKHQuaXModHlwZSwgdmFsKSkge1xuICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBcIiArIGtleSArIFwiIG9mIFwiICsgbm9kZS50eXBlICsgXCIgZXhwZWN0ZWQgbm9kZSB0byBiZSBvZiBhIHR5cGUgXCIgKyAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkodHlwZXMpICsgXCIgXCIgKyAoXCJidXQgaW5zdGVhZCBnb3QgXCIgKyAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkodmFsICYmIHZhbC50eXBlKSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlLm9uZU9mTm9kZVR5cGVzID0gdHlwZXM7XG5cbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb2RlT3JWYWx1ZVR5cGUoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZXMgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHR5cGVzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHR5cGVzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjIpOzspIHtcbiAgICAgIHZhciBfcmVmMjtcblxuICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSBfcmVmMjtcblxuICAgICAgaWYgKGdldFR5cGUodmFsKSA9PT0gdHlwZSB8fCB0LmlzKHR5cGUsIHZhbCkpIHtcbiAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcGVydHkgXCIgKyBrZXkgKyBcIiBvZiBcIiArIG5vZGUudHlwZSArIFwiIGV4cGVjdGVkIG5vZGUgdG8gYmUgb2YgYSB0eXBlIFwiICsgKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKHR5cGVzKSArIFwiIFwiICsgKFwiYnV0IGluc3RlYWQgZ290IFwiICsgKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKHZhbCAmJiB2YWwudHlwZSkpKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZS5vbmVPZk5vZGVPclZhbHVlVHlwZXMgPSB0eXBlcztcblxuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhbHVlVHlwZSh0eXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgdmFyIHZhbGlkID0gZ2V0VHlwZSh2YWwpID09PSB0eXBlO1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3BlcnR5IFwiICsga2V5ICsgXCIgZXhwZWN0ZWQgdHlwZSBvZiBcIiArIHR5cGUgKyBcIiBidXQgZ290IFwiICsgZ2V0VHlwZSh2YWwpKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZS50eXBlID0gdHlwZTtcblxuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGNoYWluKCkge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGZucyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgZm5zW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gZm5zLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjMpOzspIHtcbiAgICAgIHZhciBfcmVmMztcblxuICAgICAgaWYgKF9pc0FycmF5Mykge1xuICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpO1xuICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZuID0gX3JlZjM7XG5cbiAgICAgIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUuY2hhaW5PZiA9IGZucztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVUeXBlKHR5cGUpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciBpbmhlcml0cyA9IG9wdHMuaW5oZXJpdHMgJiYgc3RvcmVbb3B0cy5pbmhlcml0c10gfHwge307XG5cbiAgb3B0cy5maWVsZHMgPSBvcHRzLmZpZWxkcyB8fCBpbmhlcml0cy5maWVsZHMgfHwge307XG4gIG9wdHMudmlzaXRvciA9IG9wdHMudmlzaXRvciB8fCBpbmhlcml0cy52aXNpdG9yIHx8IFtdO1xuICBvcHRzLmFsaWFzZXMgPSBvcHRzLmFsaWFzZXMgfHwgaW5oZXJpdHMuYWxpYXNlcyB8fCBbXTtcbiAgb3B0cy5idWlsZGVyID0gb3B0cy5idWlsZGVyIHx8IGluaGVyaXRzLmJ1aWxkZXIgfHwgb3B0cy52aXNpdG9yIHx8IFtdO1xuXG4gIGlmIChvcHRzLmRlcHJlY2F0ZWRBbGlhcykge1xuICAgIERFUFJFQ0FURURfS0VZU1tvcHRzLmRlcHJlY2F0ZWRBbGlhc10gPSB0eXBlO1xuICB9XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IG9wdHMudmlzaXRvci5jb25jYXQob3B0cy5idWlsZGVyKSwgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I0KSwgX2k0ID0gMCwgX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/IF9pdGVyYXRvcjQgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3I0KTs7KSB7XG4gICAgdmFyIF9yZWY0O1xuXG4gICAgaWYgKF9pc0FycmF5NCkge1xuICAgICAgaWYgKF9pNCA+PSBfaXRlcmF0b3I0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmNCA9IF9pdGVyYXRvcjRbX2k0KytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcbiAgICAgIGlmIChfaTQuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmNCA9IF9pNC52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgX2tleTUgPSBfcmVmNDtcblxuICAgIG9wdHMuZmllbGRzW19rZXk1XSA9IG9wdHMuZmllbGRzW19rZXk1XSB8fCB7fTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvcHRzLmZpZWxkcykge1xuICAgIHZhciBmaWVsZCA9IG9wdHMuZmllbGRzW2tleV07XG5cbiAgICBpZiAob3B0cy5idWlsZGVyLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIGZpZWxkLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGZpZWxkLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmllbGQuZGVmYXVsdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICghZmllbGQudmFsaWRhdGUpIHtcbiAgICAgIGZpZWxkLnZhbGlkYXRlID0gYXNzZXJ0VmFsdWVUeXBlKGdldFR5cGUoZmllbGQuZGVmYXVsdCkpO1xuICAgIH1cbiAgfVxuXG4gIFZJU0lUT1JfS0VZU1t0eXBlXSA9IG9wdHMudmlzaXRvcjtcbiAgQlVJTERFUl9LRVlTW3R5cGVdID0gb3B0cy5idWlsZGVyO1xuICBOT0RFX0ZJRUxEU1t0eXBlXSA9IG9wdHMuZmllbGRzO1xuICBBTElBU19LRVlTW3R5cGVdID0gb3B0cy5hbGlhc2VzO1xuXG4gIHN0b3JlW3R5cGVdID0gb3B0cztcbn1cblxudmFyIHN0b3JlID0ge307XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXMvbGliL2RlZmluaXRpb25zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiAjIEFQSVxuICpcbiAqIEBhdXRob3IgSXZhbiBWb2lzY2hldiAoQHZvaXNjaGV2KSxcbiAqICAgICAgICAgQW50b24gV2lub2dyYWRvdiAoQGF3aW5vZ3JhZG92KSxcbiAqICAgICAgICAgQWxleGVqIFlhcm9zaGV2aWNoIChAenhxZm94KSxcbiAqICAgICAgICAgVmFzaWxpeSAoQFlldGktb3IpXG4gKlxuICogQG5hbWVzcGFjZSB0cmVlXG4gKi9cbnZhciBhcGkgPSB7XG4gIC8qKlxuICAgKiBXYWxrcyB0aGUgdHJlZSBhbmQgcGFzc2VzIGFsbCBub2RlcyB2aWEgYSBjYWxsYmFja1xuICAgKlxuICAgKiBAbWVtYmVyb2YgdHJlZVxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgIENhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgQ2FsbGJhY2sobm9kZSlcbiAgICpcbiAgICpAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBleHBvcnQgY29uc3Qgd2FsayA9ICh0cmVlKSA9PiB7XG4gICAqICAgdHJlZS53YWxrKChub2RlKSA9PiB7XG4gICAqICAgICBsZXQgY2xhc3NlcyA9IG5vZGUuYXR0cnMgJiYgbm9kZS5hdHRycy5jbGFzcy5zcGxpdCgnICcpIHx8IFtdXG4gICAqXG4gICAqICAgICBpZiAoY2xhc3Nlcy5pbmNsdWRlcyhjbGFzc05hbWUpKSByZXR1cm4gY2Iobm9kZSlcbiAgICogICAgICAgcmV0dXJuIG5vZGVcbiAgICogICB9KVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgd2FsazogZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHRoaXMsIGNiKVxuICB9LFxuICAvKipcbiAgICogTWF0Y2hlcyBhbiBleHByZXNzaW9uIHRvIHNlYXJjaCBmb3Igbm9kZXMgaW4gdGhlIHRyZWVcbiAgICpcbiAgICogQG1lbWJlcm9mIHRyZWVcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfFJlZ0V4cHxPYmplY3R8QXJyYXl9IGV4cHJlc3Npb24gLSBNYXRjaGVyKHMpIHRvIHNlYXJjaFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IENhbGxiYWNrKG5vZGUpXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGV4cG9ydCBjb25zdCBtYXRjaCA9ICh0cmVlKSA9PiB7XG4gICAqICAgLy8gU2luZ2xlIG1hdGNoZXJcbiAgICogICB0cmVlLm1hdGNoKHsgdGFnOiAnY3VzdG9tLXRhZycgfSwgKG5vZGUpID0+IHtcbiAgICogICAgIGxldCB0YWcgPSBub2RlLnRhZ1xuICAgKlxuICAgKiAgICAgT2JqZWN0LmFzc2lnbihub2RlLCB7IHRhZzogJ2RpdicsIGF0dHJzOiB7Y2xhc3M6IHRhZ30gfSlcbiAgICpcbiAgICogICAgIHJldHVybiBub2RlXG4gICAqICAgfSlcbiAgICogICAvLyBNdWx0aXBsZSBtYXRjaGVyc1xuICAgKiAgIHRyZWUubWF0Y2goW3sgdGFnOiAnYicgfSwgeyB0YWc6ICdzdHJvbmcnIH1dLCAobm9kZSkgPT4ge1xuICAgKiAgICAgbGV0IHN0eWxlID0gJ2ZvbnQtd2VpZ2h0OiBib2xkOydcbiAgICpcbiAgICogICAgIG5vZGUudGFnID0gJ3NwYW4nXG4gICAqXG4gICAqICAgICBub2RlLmF0dHJzXG4gICAqICAgICAgID8gKCBub2RlLmF0dHJzLnN0eWxlXG4gICAqICAgICAgICAgPyAoIG5vZGUuYXR0cnMuc3R5bGUgKz0gc3R5bGUgKVxuICAgKiAgICAgICAgIDogbm9kZS5hdHRycy5zdHlsZSA9IHN0eWxlXG4gICAqICAgICAgIClcbiAgICogICAgICAgOiBub2RlLmF0dHJzID0geyBzdHlsZTogc3R5bGUgfVxuICAgKlxuICAgKiAgICAgcmV0dXJuIG5vZGVcbiAgICogICB9KVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgbWF0Y2g6IGZ1bmN0aW9uIChleHByZXNzaW9uLCBjYikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGV4cHJlc3Npb24pXG4gICAgICA/IHRyYXZlcnNlKHRoaXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjb21wYXJlKGV4cHJlc3Npb25baV0sIG5vZGUpKSByZXR1cm4gY2Iobm9kZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlXG4gICAgICB9KVxuICAgICAgOiB0cmF2ZXJzZSh0aGlzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoY29tcGFyZShleHByZXNzaW9uLCBub2RlKSkgcmV0dXJuIGNiKG5vZGUpXG5cbiAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgIH0pXG4gIH0sXG4gIC8qKlxuICAgKiBUcmVlIG1lc3NhZ2VzIHRvIHN0b3JlIGFuZCBwYXNzIG1ldGFkYXRhIGJldHdlZW4gcGx1Z2luc1xuICAgKlxuICAgKiBAbWVtYmVyb2YgdHJlZVxuICAgKiBAdHlwZSB7QXJyYXl9IG1lc3NhZ2VzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBsdWdpbiAob3B0aW9ucyA9IHt9KSB7XG4gICAqICAgcmV0dXJuIGZ1bmN0aW9uICh0cmVlKSB7XG4gICAqICAgICAgdHJlZS5tZXNzYWdlcy5wdXNoKHtcbiAgICogICAgICAgIHR5cGU6ICdkZXBlbmRlbmN5JyxcbiAgICogICAgICAgIGZpbGU6ICdwYXRoL3RvL2RlcGVuZGVuY3kuaHRtbCcsXG4gICAqICAgICAgICBmcm9tOiB0cmVlLm9wdGlvbnMuZnJvbVxuICAgKiAgICAgIH0pXG4gICAqXG4gICAqICAgICAgcmV0dXJuIHRyZWVcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBtZXNzYWdlczogW11cbn1cblxuLyoqXG4gKiBFeHRlbmRzIHRoZSB0cmVlIHdpdGggdGhlIGl0J3MgQVBJXG4gKlxuICogQG1vZHVsZSBBUElcbiAqXG4gKiBAcGFyYW0gICB7QXJyYXl9IHRyZWUgLSBQb3N0SFRNTCBUcmVlXG4gKlxuICogQHJldHVybnMge0FycmF5fSB0cmVlIC0gUG9zdEhUTUwgVHJlZSAoZXh0ZW5kZWQpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgdHJlZS53YWxrID0gYXBpLndhbGtcbiAgdHJlZS5tYXRjaCA9IGFwaS5tYXRjaFxuICB0cmVlLm1lc3NhZ2VzID0gYXBpLm1lc3NhZ2VzXG59XG5cbm1vZHVsZS5leHBvcnRzLndhbGsgPSBhcGkud2Fsa1xubW9kdWxlLmV4cG9ydHMubWF0Y2ggPSBhcGkubWF0Y2hcblxuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodHJlZSwgY2IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyZWVbaV0gPSB0cmF2ZXJzZShjYih0cmVlW2ldKSwgY2IpXG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgICAgdHJlZSAmJlxuICAgICAgdHlwZW9mIHRyZWUgPT09ICdvYmplY3QnICYmXG4gICAgICB0cmVlLmhhc093blByb3BlcnR5KCdjb250ZW50JylcbiAgKSB0cmF2ZXJzZSh0cmVlLmNvbnRlbnQsIGNiKVxuXG4gIHJldHVybiB0cmVlXG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gY29tcGFyZSAoZXhwZWN0ZWQsIGFjdHVhbCkge1xuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICBpZiAodHlwZW9mIGFjdHVhbCA9PT0gJ29iamVjdCcpIHJldHVybiBmYWxzZVxuICAgIGlmICh0eXBlb2YgYWN0dWFsID09PSAnc3RyaW5nJykgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gdHlwZW9mIGFjdHVhbCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnIHx8IGV4cGVjdGVkID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkID09PSBhY3R1YWxcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBleHBlY3RlZC5ldmVyeShmdW5jdGlvbiAoZXhwKSB7XG4gICAgICByZXR1cm4gW10uc29tZS5jYWxsKGFjdHVhbCwgZnVuY3Rpb24gKGFjdCkge1xuICAgICAgICByZXR1cm4gY29tcGFyZShleHAsIGFjdClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhleHBlY3RlZCkuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBhbyA9IGFjdHVhbFtrZXldXG4gICAgdmFyIGVvID0gZXhwZWN0ZWRba2V5XVxuXG4gICAgaWYgKHR5cGVvZiBlbyA9PT0gJ29iamVjdCcgJiYgZW8gIT09IG51bGwgJiYgYW8gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb21wYXJlKGVvLCBhbylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gZW8gIT09IChhbyA9PSBudWxsKVxuICAgIH1cblxuICAgIHJldHVybiBhbyA9PT0gZW9cbiAgfSlcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fcG9zdGh0bWxAMC4xMS4yQHBvc3RodG1sL2xpYi9hcGkuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX3ZpcnR1YWxUeXBlcyA9IHJlcXVpcmUoXCIuL2xpYi92aXJ0dWFsLXR5cGVzXCIpO1xuXG52YXIgdmlydHVhbFR5cGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3ZpcnR1YWxUeXBlcyk7XG5cbnZhciBfZGVidWcyID0gcmVxdWlyZShcImRlYnVnXCIpO1xuXG52YXIgX2RlYnVnMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlYnVnMik7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZShcImludmFyaWFudFwiKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZShcImxvZGFzaC9hc3NpZ25cIik7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbnZhciBfc2NvcGUgPSByZXF1aXJlKFwiLi4vc2NvcGVcIik7XG5cbnZhciBfc2NvcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2NvcGUpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX2RlYnVnID0gKDAsIF9kZWJ1ZzMuZGVmYXVsdCkoXCJiYWJlbFwiKTtcblxudmFyIE5vZGVQYXRoID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlUGF0aChodWIsIHBhcmVudCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE5vZGVQYXRoKTtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuaHViID0gaHViO1xuICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB0aGlzLnNob3VsZFNraXAgPSBmYWxzZTtcbiAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTtcbiAgICB0aGlzLnJlbW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB0aGlzLm9wdHMgPSBudWxsO1xuICAgIHRoaXMuc2tpcEtleXMgPSBudWxsO1xuICAgIHRoaXMucGFyZW50UGF0aCA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5saXN0S2V5ID0gbnVsbDtcbiAgICB0aGlzLmluTGlzdCA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50S2V5ID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICB0aGlzLnNjb3BlID0gbnVsbDtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIHRoaXMudHlwZUFubm90YXRpb24gPSBudWxsO1xuICB9XG5cbiAgTm9kZVBhdGguZ2V0ID0gZnVuY3Rpb24gZ2V0KF9yZWYpIHtcbiAgICB2YXIgaHViID0gX3JlZi5odWIsXG4gICAgICAgIHBhcmVudFBhdGggPSBfcmVmLnBhcmVudFBhdGgsXG4gICAgICAgIHBhcmVudCA9IF9yZWYucGFyZW50LFxuICAgICAgICBjb250YWluZXIgPSBfcmVmLmNvbnRhaW5lcixcbiAgICAgICAgbGlzdEtleSA9IF9yZWYubGlzdEtleSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXk7XG5cbiAgICBpZiAoIWh1YiAmJiBwYXJlbnRQYXRoKSB7XG4gICAgICBodWIgPSBwYXJlbnRQYXRoLmh1YjtcbiAgICB9XG5cbiAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkocGFyZW50LCBcIlRvIGdldCBhIG5vZGUgcGF0aCB0aGUgcGFyZW50IG5lZWRzIHRvIGV4aXN0XCIpO1xuXG4gICAgdmFyIHRhcmdldE5vZGUgPSBjb250YWluZXJba2V5XTtcblxuICAgIHZhciBwYXRocyA9IF9jYWNoZS5wYXRoLmdldChwYXJlbnQpIHx8IFtdO1xuICAgIGlmICghX2NhY2hlLnBhdGguaGFzKHBhcmVudCkpIHtcbiAgICAgIF9jYWNoZS5wYXRoLnNldChwYXJlbnQsIHBhdGhzKTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXRoQ2hlY2sgPSBwYXRoc1tpXTtcbiAgICAgIGlmIChwYXRoQ2hlY2subm9kZSA9PT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgICBwYXRoID0gcGF0aENoZWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHBhdGggPSBuZXcgTm9kZVBhdGgoaHViLCBwYXJlbnQpO1xuICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICB9XG5cbiAgICBwYXRoLnNldHVwKHBhcmVudFBhdGgsIGNvbnRhaW5lciwgbGlzdEtleSwga2V5KTtcblxuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIE5vZGVQYXRoLnByb3RvdHlwZS5nZXRTY29wZSA9IGZ1bmN0aW9uIGdldFNjb3BlKHNjb3BlKSB7XG4gICAgdmFyIG91clNjb3BlID0gc2NvcGU7XG5cbiAgICBpZiAodGhpcy5pc1Njb3BlKCkpIHtcbiAgICAgIG91clNjb3BlID0gbmV3IF9zY29wZTIuZGVmYXVsdCh0aGlzLCBzY29wZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91clNjb3BlO1xuICB9O1xuXG4gIE5vZGVQYXRoLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShrZXksIHZhbCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XSA9IHZhbDtcbiAgfTtcblxuICBOb2RlUGF0aC5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIGdldERhdGEoa2V5LCBkZWYpIHtcbiAgICB2YXIgdmFsID0gdGhpcy5kYXRhW2tleV07XG4gICAgaWYgKCF2YWwgJiYgZGVmKSB2YWwgPSB0aGlzLmRhdGFba2V5XSA9IGRlZjtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuXG4gIE5vZGVQYXRoLnByb3RvdHlwZS5idWlsZENvZGVGcmFtZUVycm9yID0gZnVuY3Rpb24gYnVpbGRDb2RlRnJhbWVFcnJvcihtc2cpIHtcbiAgICB2YXIgRXJyb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFN5bnRheEVycm9yO1xuXG4gICAgcmV0dXJuIHRoaXMuaHViLmZpbGUuYnVpbGRDb2RlRnJhbWVFcnJvcih0aGlzLm5vZGUsIG1zZywgRXJyb3IpO1xuICB9O1xuXG4gIE5vZGVQYXRoLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKHZpc2l0b3IsIHN0YXRlKSB7XG4gICAgKDAsIF9pbmRleDIuZGVmYXVsdCkodGhpcy5ub2RlLCB2aXNpdG9yLCB0aGlzLnNjb3BlLCBzdGF0ZSwgdGhpcyk7XG4gIH07XG5cbiAgTm9kZVBhdGgucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiBtYXJrKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLmh1Yi5maWxlLm1ldGFkYXRhLm1hcmtlZC5wdXNoKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgbG9jOiB0aGlzLm5vZGUubG9jXG4gICAgfSk7XG4gIH07XG5cbiAgTm9kZVBhdGgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChrZXksIG5vZGUpIHtcbiAgICB0LnZhbGlkYXRlKHRoaXMubm9kZSwga2V5LCBub2RlKTtcbiAgICB0aGlzLm5vZGVba2V5XSA9IG5vZGU7XG4gIH07XG5cbiAgTm9kZVBhdGgucHJvdG90eXBlLmdldFBhdGhMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldFBhdGhMb2NhdGlvbigpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgdmFyIGtleSA9IHBhdGgua2V5O1xuICAgICAgaWYgKHBhdGguaW5MaXN0KSBrZXkgPSBwYXRoLmxpc3RLZXkgKyBcIltcIiArIGtleSArIFwiXVwiO1xuICAgICAgcGFydHMudW5zaGlmdChrZXkpO1xuICAgIH0gd2hpbGUgKHBhdGggPSBwYXRoLnBhcmVudFBhdGgpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiLlwiKTtcbiAgfTtcblxuICBOb2RlUGF0aC5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZyhidWlsZE1lc3NhZ2UpIHtcbiAgICBpZiAoIV9kZWJ1Zy5lbmFibGVkKSByZXR1cm47XG4gICAgX2RlYnVnKHRoaXMuZ2V0UGF0aExvY2F0aW9uKCkgKyBcIiBcIiArIHRoaXMudHlwZSArIFwiOiBcIiArIGJ1aWxkTWVzc2FnZSgpKTtcbiAgfTtcblxuICByZXR1cm4gTm9kZVBhdGg7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE5vZGVQYXRoO1xuXG5cbigwLCBfYXNzaWduMi5kZWZhdWx0KShOb2RlUGF0aC5wcm90b3R5cGUsIHJlcXVpcmUoXCIuL2FuY2VzdHJ5XCIpKTtcbigwLCBfYXNzaWduMi5kZWZhdWx0KShOb2RlUGF0aC5wcm90b3R5cGUsIHJlcXVpcmUoXCIuL2luZmVyZW5jZVwiKSk7XG4oMCwgX2Fzc2lnbjIuZGVmYXVsdCkoTm9kZVBhdGgucHJvdG90eXBlLCByZXF1aXJlKFwiLi9yZXBsYWNlbWVudFwiKSk7XG4oMCwgX2Fzc2lnbjIuZGVmYXVsdCkoTm9kZVBhdGgucHJvdG90eXBlLCByZXF1aXJlKFwiLi9ldmFsdWF0aW9uXCIpKTtcbigwLCBfYXNzaWduMi5kZWZhdWx0KShOb2RlUGF0aC5wcm90b3R5cGUsIHJlcXVpcmUoXCIuL2NvbnZlcnNpb25cIikpO1xuKDAsIF9hc3NpZ24yLmRlZmF1bHQpKE5vZGVQYXRoLnByb3RvdHlwZSwgcmVxdWlyZShcIi4vaW50cm9zcGVjdGlvblwiKSk7XG4oMCwgX2Fzc2lnbjIuZGVmYXVsdCkoTm9kZVBhdGgucHJvdG90eXBlLCByZXF1aXJlKFwiLi9jb250ZXh0XCIpKTtcbigwLCBfYXNzaWduMi5kZWZhdWx0KShOb2RlUGF0aC5wcm90b3R5cGUsIHJlcXVpcmUoXCIuL3JlbW92YWxcIikpO1xuKDAsIF9hc3NpZ24yLmRlZmF1bHQpKE5vZGVQYXRoLnByb3RvdHlwZSwgcmVxdWlyZShcIi4vbW9kaWZpY2F0aW9uXCIpKTtcbigwLCBfYXNzaWduMi5kZWZhdWx0KShOb2RlUGF0aC5wcm90b3R5cGUsIHJlcXVpcmUoXCIuL2ZhbWlseVwiKSk7XG4oMCwgX2Fzc2lnbjIuZGVmYXVsdCkoTm9kZVBhdGgucHJvdG90eXBlLCByZXF1aXJlKFwiLi9jb21tZW50c1wiKSk7XG5cbnZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gIGlmIChfaXNBcnJheSkge1xuICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSByZXR1cm4gXCJicmVha1wiO1xuICAgIF9yZWYyID0gX2l0ZXJhdG9yW19pKytdO1xuICB9IGVsc2Uge1xuICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAoX2kuZG9uZSkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICBfcmVmMiA9IF9pLnZhbHVlO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfcmVmMjtcblxuICB2YXIgdHlwZUtleSA9IFwiaXNcIiArIHR5cGU7XG4gIE5vZGVQYXRoLnByb3RvdHlwZVt0eXBlS2V5XSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIHRbdHlwZUtleV0odGhpcy5ub2RlLCBvcHRzKTtcbiAgfTtcblxuICBOb2RlUGF0aC5wcm90b3R5cGVbXCJhc3NlcnRcIiArIHR5cGVdID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBpZiAoIXRoaXNbdHlwZUtleV0ob3B0cykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBub2RlIHBhdGggb2YgdHlwZSBcIiArIHR5cGUpO1xuICAgIH1cbiAgfTtcbn07XG5cbmZvciAodmFyIF9pdGVyYXRvciA9IHQuVFlQRVMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gIHZhciBfcmVmMjtcblxuICB2YXIgX3JldDIgPSBfbG9vcDIoKTtcblxuICBpZiAoX3JldDIgPT09IFwiYnJlYWtcIikgYnJlYWs7XG59XG5cbnZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHR5cGUpIHtcbiAgaWYgKHR5cGVbMF0gPT09IFwiX1wiKSByZXR1cm4gXCJjb250aW51ZVwiO1xuICBpZiAodC5UWVBFUy5pbmRleE9mKHR5cGUpIDwgMCkgdC5UWVBFUy5wdXNoKHR5cGUpO1xuXG4gIHZhciB2aXJ0dWFsVHlwZSA9IHZpcnR1YWxUeXBlc1t0eXBlXTtcblxuICBOb2RlUGF0aC5wcm90b3R5cGVbXCJpc1wiICsgdHlwZV0gPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiB2aXJ0dWFsVHlwZS5jaGVja1BhdGgodGhpcywgb3B0cyk7XG4gIH07XG59O1xuXG5mb3IgKHZhciB0eXBlIGluIHZpcnR1YWxUeXBlcykge1xuICB2YXIgX3JldCA9IF9sb29wKHR5cGUpO1xuXG4gIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvcGF0aC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19nZXROYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZnNcIlxuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudmlzaXRvcnMgPSBleHBvcnRzLkh1YiA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLk5vZGVQYXRoID0gdW5kZWZpbmVkO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbnZhciBfcGF0aCA9IHJlcXVpcmUoXCIuL3BhdGhcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vZGVQYXRoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhdGgpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3Njb3BlID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njb3BlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9odWIgPSByZXF1aXJlKFwiLi9odWJcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh1YlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9odWIpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdHJhdmVyc2U7XG5cbnZhciBfY29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHRcIik7XG5cbnZhciBfY29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0KTtcblxudmFyIF92aXNpdG9ycyA9IHJlcXVpcmUoXCIuL3Zpc2l0b3JzXCIpO1xuXG52YXIgdmlzaXRvcnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdmlzaXRvcnMpO1xuXG52YXIgX2JhYmVsTWVzc2FnZXMgPSByZXF1aXJlKFwiYmFiZWwtbWVzc2FnZXNcIik7XG5cbnZhciBtZXNzYWdlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9iYWJlbE1lc3NhZ2VzKTtcblxudmFyIF9pbmNsdWRlcyA9IHJlcXVpcmUoXCJsb2Rhc2gvaW5jbHVkZXNcIik7XG5cbnZhciBfaW5jbHVkZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5jbHVkZXMpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4vY2FjaGVcIik7XG5cbnZhciBjYWNoZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jYWNoZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMudmlzaXRvcnMgPSB2aXNpdG9ycztcbmZ1bmN0aW9uIHRyYXZlcnNlKHBhcmVudCwgb3B0cywgc2NvcGUsIHN0YXRlLCBwYXJlbnRQYXRoKSB7XG4gIGlmICghcGFyZW50KSByZXR1cm47XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG4gIGlmICghb3B0cy5ub1Njb3BlICYmICFzY29wZSkge1xuICAgIGlmIChwYXJlbnQudHlwZSAhPT0gXCJQcm9ncmFtXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiRmlsZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuZ2V0KFwidHJhdmVyc2VOZWVkc1BhcmVudFwiLCBwYXJlbnQudHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIHZpc2l0b3JzLmV4cGxvZGUob3B0cyk7XG5cbiAgdHJhdmVyc2Uubm9kZShwYXJlbnQsIG9wdHMsIHNjb3BlLCBzdGF0ZSwgcGFyZW50UGF0aCk7XG59XG5cbnRyYXZlcnNlLnZpc2l0b3JzID0gdmlzaXRvcnM7XG50cmF2ZXJzZS52ZXJpZnkgPSB2aXNpdG9ycy52ZXJpZnk7XG50cmF2ZXJzZS5leHBsb2RlID0gdmlzaXRvcnMuZXhwbG9kZTtcblxudHJhdmVyc2UuTm9kZVBhdGggPSByZXF1aXJlKFwiLi9wYXRoXCIpO1xudHJhdmVyc2UuU2NvcGUgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbnRyYXZlcnNlLkh1YiA9IHJlcXVpcmUoXCIuL2h1YlwiKTtcblxudHJhdmVyc2UuY2hlYXAgPSBmdW5jdGlvbiAobm9kZSwgZW50ZXIpIHtcbiAgcmV0dXJuIHQudHJhdmVyc2VGYXN0KG5vZGUsIGVudGVyKTtcbn07XG5cbnRyYXZlcnNlLm5vZGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0cywgc2NvcGUsIHN0YXRlLCBwYXJlbnRQYXRoLCBza2lwS2V5cykge1xuICB2YXIga2V5cyA9IHQuVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGlmICgha2V5cykgcmV0dXJuO1xuXG4gIHZhciBjb250ZXh0ID0gbmV3IF9jb250ZXh0Mi5kZWZhdWx0KHNjb3BlLCBvcHRzLCBzdGF0ZSwgcGFyZW50UGF0aCk7XG4gIGZvciAodmFyIF9pdGVyYXRvciA9IGtleXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gX3JlZjtcblxuICAgIGlmIChza2lwS2V5cyAmJiBza2lwS2V5c1trZXldKSBjb250aW51ZTtcbiAgICBpZiAoY29udGV4dC52aXNpdChub2RlLCBrZXkpKSByZXR1cm47XG4gIH1cbn07XG5cbnRyYXZlcnNlLmNsZWFyTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRzKSB7XG4gIHQucmVtb3ZlUHJvcGVydGllcyhub2RlLCBvcHRzKTtcblxuICBjYWNoZS5wYXRoLmRlbGV0ZShub2RlKTtcbn07XG5cbnRyYXZlcnNlLnJlbW92ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHJlZSwgb3B0cykge1xuICB0LnRyYXZlcnNlRmFzdCh0cmVlLCB0cmF2ZXJzZS5jbGVhck5vZGUsIG9wdHMpO1xuICByZXR1cm4gdHJlZTtcbn07XG5cbmZ1bmN0aW9uIGhhc0JsYWNrbGlzdGVkVHlwZShwYXRoLCBzdGF0ZSkge1xuICBpZiAocGF0aC5ub2RlLnR5cGUgPT09IHN0YXRlLnR5cGUpIHtcbiAgICBzdGF0ZS5oYXMgPSB0cnVlO1xuICAgIHBhdGguc3RvcCgpO1xuICB9XG59XG5cbnRyYXZlcnNlLmhhc1R5cGUgPSBmdW5jdGlvbiAodHJlZSwgc2NvcGUsIHR5cGUsIGJsYWNrbGlzdFR5cGVzKSB7XG4gIGlmICgoMCwgX2luY2x1ZGVzMi5kZWZhdWx0KShibGFja2xpc3RUeXBlcywgdHJlZS50eXBlKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0cmVlLnR5cGUgPT09IHR5cGUpIHJldHVybiB0cnVlO1xuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBoYXM6IGZhbHNlLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcblxuICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgYmxhY2tsaXN0OiBibGFja2xpc3RUeXBlcyxcbiAgICBlbnRlcjogaGFzQmxhY2tsaXN0ZWRUeXBlXG4gIH0sIHNjb3BlLCBzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLmhhcztcbn07XG5cbnRyYXZlcnNlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGNhY2hlLmNsZWFyKCk7XG59O1xuXG50cmF2ZXJzZS5jbGVhckNhY2hlLmNsZWFyUGF0aCA9IGNhY2hlLmNsZWFyUGF0aDtcbnRyYXZlcnNlLmNsZWFyQ2FjaGUuY2xlYXJTY29wZSA9IGNhY2hlLmNsZWFyU2NvcGU7XG5cbnRyYXZlcnNlLmNvcHlDYWNoZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGlmIChjYWNoZS5wYXRoLmhhcyhzb3VyY2UpKSB7XG4gICAgY2FjaGUucGF0aC5zZXQoZGVzdGluYXRpb24sIGNhY2hlLnBhdGguZ2V0KHNvdXJjZSkpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9lcS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2NvcHlPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvdG9JbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuXSopKD86OihcXGQrKSk/KFxcUyopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gIHZhciBwYXRoID0gYVBhdGg7XG4gIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGlmICh1cmwpIHtcbiAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuICAgIHBhdGggPSB1cmwucGF0aDtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gKlxuICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICogICBmaXJzdC5cbiAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gKiAgIGlzIHJldHVybmVkLlxuICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cbiAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgYVBhdGggPSBcIi5cIjtcbiAgfVxuICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgfVxuXG4gIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgfVxuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gIH1cblxuICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICByZXR1cm4gYVBhdGg7XG4gIH1cblxuICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cblxuICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICA/IGFQYXRoXG4gICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoYVBhdGgpIHtcbiAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8ICEhYVBhdGgubWF0Y2godXJsUmVnZXhwKTtcbn07XG5cbi8qKlxuICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cblxuICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgICsrbGV2ZWw7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xufVxuZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG52YXIgc3VwcG9ydHNOdWxsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICEoJ19fcHJvdG9fXycgaW4gb2JqKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlkZW50aXR5IChzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLnRvU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IHRvU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gYVN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IGZyb21TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzUHJvdG9TdHJpbmcocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDkgLyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocy5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMikgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAzKSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDQpICE9PSAxMTYgLyogJ3QnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNSkgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA2KSAhPT0gMTE0IC8qICdyJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDcpICE9PSAxMTIgLyogJ3AnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOCkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA5KSAhPT0gOTUgIC8qICdfJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAxMDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KGkpICE9PSAzNiAvKiAnJCcgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICB2YXIgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3NvdXJjZS1tYXBAMC41LjdAc291cmNlLW1hcC9saWIvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJ1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcydcclxuXHJcblxyXG5sZXQgaW5mbyA9ICBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4oIHByb2Nlc3MuY3dkKCkgICxcIi4vZGlzdC9jYW0uanNvblwiKSxcInV0Zi04XCIpKSA7XHJcbi8vbGV0IHR0PWZzLnJlYWRkaXJTeW5jKFwiLi9jYW0uanNvblwiKTtcclxuXHJcbi8vY29uc29sZS5sb2coaW5mbylcclxuXHJcblxyXG5cclxuLy9sZXQgaW5wdXRSb290LG91dHB1dFJvb3QsdmVyc2lvbixIdG1sMkpzT2JqLHVucGFja2FnZWRGaWxlLGpzU2NyaXB0c1gsanNTY3JpcHRzLHVucGFja2FnZWRGb2xkZXIsbWFuaWZlc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgY29uZmlnID0gaW5mby5jb25maWc7XHJcbmV4cG9ydCBjb25zdCBpbnB1dFJvb3QgPSBpbmZvLmlucHV0Um9vdDtcclxuZXhwb3J0IGNvbnN0IG91dHB1dFJvb3Q6IHN0cmluZyA9aW5mby5vdXRwdXRSb290OyBcclxuXHJcblxyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IGluZm8udmVyc2lvbjtcclxuXHJcblxyXG5jb25zdCByZXNvbHZlSW5wdXRSb290ID0gZnVuY3Rpb24gKGRpcikge1xyXG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShpbmZvLmlucHV0Um9vdCwgZGlyKVxyXG59XHJcblxyXG5jb25zdCByZXNvbHZlT3V0cHV0Um9vdCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgIHJldHVybiBwYXRoLnJlc29sdmUoaW5mby5vdXRwdXRSb290LCBkaXIpXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IHVucGFja2FnZWRGaWxlID0gaW5mby51bnBhY2thZ2VkRmlsZS5tYXAoKGZpbGUpID0+IHsgcmV0dXJuIHJlc29sdmVJbnB1dFJvb3QoZmlsZSkgfSk7XHJcblxyXG5leHBvcnQgY29uc3QganNTY3JpcHRzWCA9IGluZm8uanNTY3JpcHRzWC5tYXAoKGZpbGUpID0+IHsgcmV0dXJuIHJlc29sdmVJbnB1dFJvb3QoZmlsZSkgfSk7XHJcbmV4cG9ydCBjb25zdCBqc1NjcmlwdHMgPSBpbmZvLmpzU2NyaXB0cy5tYXAoKGZpbGUpID0+IHsgcmV0dXJuIHJlc29sdmVJbnB1dFJvb3QoZmlsZSkgfSk7XHJcblxyXG5leHBvcnQgY29uc3QgdW5wYWNrYWdlZEZvbGRlciA9IGluZm8udW5wYWNrYWdlZEZvbGRlci5tYXAoKGZpbGUpID0+IHsgcmV0dXJuIHJlc29sdmVJbnB1dFJvb3QoZmlsZSkgfSk7XHJcblxyXG5leHBvcnQgY29uc3QgbWFuaWZlc3QgPWluZm8ubWFuaWZlc3QubWFwKChmaWxlKSA9PiB7IHJldHVybiByZXNvbHZlSW5wdXRSb290KGZpbGUpIH0pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBIdG1sMkpzTWFwID0gbmV3IE1hcCgpO1xyXG5mb3IgKGxldCBrIG9mIE9iamVjdC5rZXlzKGluZm8uSHRtbDJKc09iaikpIHtcclxuICAgIGxldCB2ID0gIGluZm8uSHRtbDJKc09ialtrXTtcclxuICAgIEh0bWwySnNNYXAuc2V0KHJlc29sdmVJbnB1dFJvb3QoaykscmVzb2x2ZU91dHB1dFJvb3QodikpXHJcbiAgICBcclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qXHJcbmV4cG9ydCBsZXQgaW5wdXRSb290OiBzdHJpbmcgPSBcIkM6XFxcXFVzZXJzXFxcXEFkbWluaXN0cmF0b3JcXFxcRG9jdW1lbnRzXFxcXEhidWlsZGVyMlxcXFx2M1VzYlwiO1xyXG5leHBvcnQgbGV0IG91dHB1dFJvb3Q6IHN0cmluZyA9IFwiQzpcXFxcVXNlcnNcXFxcQWRtaW5pc3RyYXRvclxcXFxEZXNrdG9wXFxcXGNhbVwiO1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCIyMC4xLjY2XCI7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IHJlc29sdmVJbnB1dFJvb3QgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKGlucHV0Um9vdCwgZGlyKVxyXG59XHJcblxyXG5jb25zdCByZXNvbHZlT3V0cHV0Um9vdCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgIHJldHVybiBwYXRoLnJlc29sdmUob3V0cHV0Um9vdCwgZGlyKVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBIdG1sMkpzTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+ID0gbmV3IE1hcChbXHJcbiAgICBbcmVzb2x2ZUlucHV0Um9vdChcIi4vYmFja2dyb3VuZC9iYWNrZ3JvdW5kLmh0bWxcIiksIHJlc29sdmVPdXRwdXRSb290KFwiLi9tYWluX2JhY2tncm91bmQuanNcIildLFxyXG4gICAgW3Jlc29sdmVJbnB1dFJvb3QoXCIuL3NldHRpbmcvc2V0dGluZy5odG1sXCIpLCByZXNvbHZlT3V0cHV0Um9vdChcIi4vbWFpbl9zZXR0aW5nLmpzXCIpXSxcclxuICAgIFtyZXNvbHZlSW5wdXRSb290KFwiLi9zZXR0aW5nL3NldHVwLmh0bWxcIiksIHJlc29sdmVPdXRwdXRSb290KFwiLi9tYWluX3NldHVwLmpzXCIpXSxcclxuICAgIFtyZXNvbHZlSW5wdXRSb290KFwiLi9wb3B1cC9wb3B1cC5odG1sXCIpLCByZXNvbHZlT3V0cHV0Um9vdChcIi4vbWFpbl9wb3AuanNcIildXHJcbl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVucGFja2FnZWRGaWxlID0gaW5mby5tYXAoKGZpbGUpID0+IHsgcmV0dXJuIHJlc29sdmVJbnB1dFJvb3QoZmlsZSkgfSk7XHJcblxyXG5leHBvcnQgY29uc3QganNTY3JpcHRzWCA9IFtcIi4vZm9yZWdyb3VuZC9teWpzLmpzXCJdLm1hcCgoZmlsZSkgPT4geyByZXR1cm4gcmVzb2x2ZUlucHV0Um9vdChmaWxlKSB9KTtcclxuZXhwb3J0IGNvbnN0IGpzU2NyaXB0cyA9IFtcIi4vY29tbW9uL2pxdWVyeS5qc1wiLCBcIi4vc2V0dGluZy9qcy93ZWJfYmx1ZXRvb3RoLmpzXCJdLm1hcCgoZmlsZSkgPT4geyByZXR1cm4gcmVzb2x2ZUlucHV0Um9vdChmaWxlKSB9KTtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgdW5wYWNrYWdlZEZvbGRlciA9IFtcIi5zdm5cIiwgXCJ1bnBhY2thZ2VcIl0ubWFwKChmaWxlKSA9PiB7IHJldHVybiByZXNvbHZlSW5wdXRSb290KGZpbGUpIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1hbmlmZXN0ID0gW1wiLi9tYW5pZmVzdC5qc29uXCJdLm1hcCgoZmlsZSkgPT4geyByZXR1cm4gcmVzb2x2ZUlucHV0Um9vdChmaWxlKSB9KTtcclxuKi9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL2NvbmYudHMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicGF0aFwiXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL2ltcG9ydCB7IGNvcHlGaWxlLHJlYWQsIHdyaXRlIH0gZnJvbSAnLi4vY29tbW9uL1Rvb2xzJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJ1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcydcclxuaW1wb3J0IHtGaWxlSW50ZXJmYWNlfSBmcm9tICcuL0ZpbGVJbnRlcmZhY2UnXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFBhZ2UgaW1wbGVtZW50cyBGaWxlSW50ZXJmYWNle1xyXG5cclxuICAgIHByb3RlY3RlZCBmcm9tOnN0cmluZzsgICAvLyBhYnNvbHV0ZSBQYXRoXHJcbiAgICBwcm90ZWN0ZWQgdG86c3RyaW5nOyAgLy8gYWJzb2x1dGUgcGF0aFxyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihmcm9tOnN0cmluZyx0bzpzdHJpbmcpeyAgIFxyXG5cclxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICAgIHRoaXMudG8gPSB0bzsgXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvcGVyYXRlKCl7XHJcblxyXG4gICAgICAgIHRoaXMuY29weUZpbGUodGhpcy5mcm9tLHRoaXMudG8pXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgIHJlYWQoIElOOnN0cmluZyk6c3RyaW5ne1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IFR4dCA9IGZzLnJlYWRGaWxlU3luYyhJTixcInV0Zi04XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gVHh0O1xyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHdyaXRlKHRleHQ6c3RyaW5nICwgT1VUOnN0cmluZyk6Ym9vbGVhbntcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoT1VULHRleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgd3JpdGVGaWxlKHRleHQ6c3RyaW5nICwgT1VUOnN0cmluZyl7XHJcblxyXG4gICAgICAgIGZzLndyaXRlRmlsZShPVVQsdGV4dCwoKT0+e1xyXG5cclxuICAgICAgICB9KVxyXG4gICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBjb3B5RmlsZShJTjpzdHJpbmcgLCBPVVQ6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgdmFyIHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShJTik7XHJcbiAgICAgICAgdmFyIHdzID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oT1VUKTtcclxuICAgICAgICBycy5waXBlKHdzKTtcclxuICAgICAgICBcclxuICAgIFxyXG4gICAgXHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9qby9QYWdlLnRzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlVW5hcnkuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19ub2RlVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX0xpc3RDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Fzc29jSW5kZXhPZi5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2dldE1hcERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2lzUHJvdG90eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19nZXRUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaXNTeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5NRVNTQUdFUyA9IHVuZGVmaW5lZDtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5XCIpO1xuXG52YXIgX3N0cmluZ2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnkpO1xuXG5leHBvcnRzLmdldCA9IGdldDtcbmV4cG9ydHMucGFyc2VBcmdzID0gcGFyc2VBcmdzO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcblxudmFyIHV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBNRVNTQUdFUyA9IGV4cG9ydHMuTUVTU0FHRVMgPSB7XG4gIHRhaWxDYWxsUmVhc3NpZ25tZW50RGVvcHQ6IFwiRnVuY3Rpb24gcmVmZXJlbmNlIGhhcyBiZWVuIHJlYXNzaWduZWQsIHNvIGl0IHdpbGwgcHJvYmFibHkgYmUgZGVyZWZlcmVuY2VkLCB0aGVyZWZvcmUgd2UgY2FuJ3Qgb3B0aW1pc2UgdGhpcyB3aXRoIGNvbmZpZGVuY2VcIixcbiAgY2xhc3Nlc0lsbGVnYWxCYXJlU3VwZXI6IFwiSWxsZWdhbCB1c2Ugb2YgYmFyZSBzdXBlclwiLFxuICBjbGFzc2VzSWxsZWdhbFN1cGVyQ2FsbDogXCJEaXJlY3Qgc3VwZXIgY2FsbCBpcyBpbGxlZ2FsIGluIG5vbi1jb25zdHJ1Y3RvciwgdXNlIHN1cGVyLiQxKCkgaW5zdGVhZFwiLFxuICBzY29wZUR1cGxpY2F0ZURlY2xhcmF0aW9uOiBcIkR1cGxpY2F0ZSBkZWNsYXJhdGlvbiAkMVwiLFxuICBzZXR0ZXJzTm9SZXN0OiBcIlNldHRlcnMgYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBhIHJlc3RcIixcbiAgbm9Bc3NpZ25tZW50c0luRm9ySGVhZDogXCJObyBhc3NpZ25tZW50cyBhbGxvd2VkIGluIGZvci1pbi9vZiBoZWFkXCIsXG4gIGV4cGVjdGVkTWVtYmVyRXhwcmVzc2lvbk9ySWRlbnRpZmllcjogXCJFeHBlY3RlZCB0eXBlIE1lbWJlckV4cHJlc3Npb24gb3IgSWRlbnRpZmllclwiLFxuICBpbnZhbGlkUGFyZW50Rm9yVGhpc05vZGU6IFwiV2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlIHRoaXMgbm9kZSB3aXRoaW4gdGhlIGN1cnJlbnQgcGFyZW50IC0gcGxlYXNlIG9wZW4gYW4gaXNzdWVcIixcbiAgcmVhZE9ubHk6IFwiJDEgaXMgcmVhZC1vbmx5XCIsXG4gIHVua25vd25Gb3JIZWFkOiBcIlVua25vd24gbm9kZSB0eXBlICQxIGluIEZvclN0YXRlbWVudFwiLFxuICBkaWRZb3VNZWFuOiBcIkRpZCB5b3UgbWVhbiAkMT9cIixcbiAgY29kZUdlbmVyYXRvckRlb3B0OiBcIk5vdGU6IFRoZSBjb2RlIGdlbmVyYXRvciBoYXMgZGVvcHRpbWlzZWQgdGhlIHN0eWxpbmcgb2YgJDEgYXMgaXQgZXhjZWVkcyB0aGUgbWF4IG9mICQyLlwiLFxuICBtaXNzaW5nVGVtcGxhdGVzRGlyZWN0b3J5OiBcIm5vIHRlbXBsYXRlcyBkaXJlY3RvcnkgLSB0aGlzIGlzIG1vc3QgbGlrZWx5IHRoZSByZXN1bHQgb2YgYSBicm9rZW4gYG5wbSBwdWJsaXNoYC4gUGxlYXNlIHJlcG9ydCB0byBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzXCIsXG4gIHVuc3VwcG9ydGVkT3V0cHV0VHlwZTogXCJVbnN1cHBvcnRlZCBvdXRwdXQgdHlwZSAkMVwiLFxuICBpbGxlZ2FsTWV0aG9kTmFtZTogXCJJbGxlZ2FsIG1ldGhvZCBuYW1lICQxXCIsXG4gIGxvc3RUcmFja05vZGVQYXRoOiBcIldlIGxvc3QgdHJhY2sgb2YgdGhpcyBub2RlJ3MgcG9zaXRpb24sIGxpa2VseSBiZWNhdXNlIHRoZSBBU1Qgd2FzIGRpcmVjdGx5IG1hbmlwdWxhdGVkXCIsXG5cbiAgbW9kdWxlc0lsbGVnYWxFeHBvcnROYW1lOiBcIklsbGVnYWwgZXhwb3J0ICQxXCIsXG4gIG1vZHVsZXNEdXBsaWNhdGVEZWNsYXJhdGlvbnM6IFwiRHVwbGljYXRlIG1vZHVsZSBkZWNsYXJhdGlvbnMgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYnV0IGluIGRpZmZlcmVudCBzY29wZXNcIixcblxuICB1bmRlY2xhcmVkVmFyaWFibGU6IFwiUmVmZXJlbmNlIHRvIHVuZGVjbGFyZWQgdmFyaWFibGUgJDFcIixcbiAgdW5kZWNsYXJlZFZhcmlhYmxlVHlwZTogXCJSZWZlcmVuY2luZyBhIHR5cGUgYWxpYXMgb3V0c2lkZSBvZiBhIHR5cGUgYW5ub3RhdGlvblwiLFxuICB1bmRlY2xhcmVkVmFyaWFibGVTdWdnZXN0aW9uOiBcIlJlZmVyZW5jZSB0byB1bmRlY2xhcmVkIHZhcmlhYmxlICQxIC0gZGlkIHlvdSBtZWFuICQyP1wiLFxuXG4gIHRyYXZlcnNlTmVlZHNQYXJlbnQ6IFwiWW91IG11c3QgcGFzcyBhIHNjb3BlIGFuZCBwYXJlbnRQYXRoIHVubGVzcyB0cmF2ZXJzaW5nIGEgUHJvZ3JhbS9GaWxlLiBJbnN0ZWFkIG9mIHRoYXQgeW91IHRyaWVkIHRvIHRyYXZlcnNlIGEgJDEgbm9kZSB3aXRob3V0IHBhc3Npbmcgc2NvcGUgYW5kIHBhcmVudFBhdGguXCIsXG4gIHRyYXZlcnNlVmVyaWZ5Um9vdEZ1bmN0aW9uOiBcIllvdSBwYXNzZWQgYHRyYXZlcnNlKClgIGEgZnVuY3Rpb24gd2hlbiBpdCBleHBlY3RlZCBhIHZpc2l0b3Igb2JqZWN0LCBhcmUgeW91IHN1cmUgeW91IGRpZG4ndCBtZWFuIGB7IGVudGVyOiBGdW5jdGlvbiB9YD9cIixcbiAgdHJhdmVyc2VWZXJpZnlWaXNpdG9yUHJvcGVydHk6IFwiWW91IHBhc3NlZCBgdHJhdmVyc2UoKWAgYSB2aXNpdG9yIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0eSAkMSB0aGF0IGhhcyB0aGUgaW52YWxpZCBwcm9wZXJ0eSAkMlwiLFxuICB0cmF2ZXJzZVZlcmlmeU5vZGVUeXBlOiBcIllvdSBnYXZlIHVzIGEgdmlzaXRvciBmb3IgdGhlIG5vZGUgdHlwZSAkMSBidXQgaXQncyBub3QgYSB2YWxpZCB0eXBlXCIsXG5cbiAgcGx1Z2luTm90T2JqZWN0OiBcIlBsdWdpbiAkMiBzcGVjaWZpZWQgaW4gJDEgd2FzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3Qgd2hlbiBpbnZva2VkIGJ1dCByZXR1cm5lZCAkM1wiLFxuICBwbHVnaW5Ob3RGdW5jdGlvbjogXCJQbHVnaW4gJDIgc3BlY2lmaWVkIGluICQxIHdhcyBleHBlY3RlZCB0byByZXR1cm4gYSBmdW5jdGlvbiBidXQgcmV0dXJuZWQgJDNcIixcbiAgcGx1Z2luVW5rbm93bjogXCJVbmtub3duIHBsdWdpbiAkMSBzcGVjaWZpZWQgaW4gJDIgYXQgJDMsIGF0dGVtcHRlZCB0byByZXNvbHZlIHJlbGF0aXZlIHRvICQ0XCIsXG4gIHBsdWdpbkludmFsaWRQcm9wZXJ0eTogXCJQbHVnaW4gJDIgc3BlY2lmaWVkIGluICQxIHByb3ZpZGVkIGFuIGludmFsaWQgcHJvcGVydHkgb2YgJDNcIlxufTtcblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBtc2cgPSBNRVNTQUdFU1trZXldO1xuICBpZiAoIW1zZykgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiVW5rbm93biBtZXNzYWdlIFwiICsgKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKGtleSkpO1xuXG4gIGFyZ3MgPSBwYXJzZUFyZ3MoYXJncyk7XG5cbiAgcmV0dXJuIG1zZy5yZXBsYWNlKC9cXCQoXFxkKykvZywgZnVuY3Rpb24gKHN0ciwgaSkge1xuICAgIHJldHVybiBhcmdzW2kgLSAxXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXJncyhhcmdzKSB7XG4gIHJldHVybiBhcmdzLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC5pbnNwZWN0KSB7XG4gICAgICByZXR1cm4gdmFsLmluc3BlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBfc3RyaW5naWZ5Mi5kZWZhdWx0KSh2YWwpIHx8IHZhbCArIFwiXCI7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmluc3BlY3QodmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtbWVzc2FnZXNANi4yMy4wQGJhYmVsLW1lc3NhZ2VzL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNjb3BlID0gZXhwb3J0cy5wYXRoID0gdW5kZWZpbmVkO1xuXG52YXIgX3dlYWtNYXAgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3dlYWstbWFwXCIpO1xuXG52YXIgX3dlYWtNYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2Vha01hcCk7XG5cbmV4cG9ydHMuY2xlYXIgPSBjbGVhcjtcbmV4cG9ydHMuY2xlYXJQYXRoID0gY2xlYXJQYXRoO1xuZXhwb3J0cy5jbGVhclNjb3BlID0gY2xlYXJTY29wZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHBhdGggPSBleHBvcnRzLnBhdGggPSBuZXcgX3dlYWtNYXAyLmRlZmF1bHQoKTtcbnZhciBzY29wZSA9IGV4cG9ydHMuc2NvcGUgPSBuZXcgX3dlYWtNYXAyLmRlZmF1bHQoKTtcblxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGNsZWFyUGF0aCgpO1xuICBjbGVhclNjb3BlKCk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyUGF0aCgpIHtcbiAgZXhwb3J0cy5wYXRoID0gcGF0aCA9IG5ldyBfd2Vha01hcDIuZGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBjbGVhclNjb3BlKCkge1xuICBleHBvcnRzLnNjb3BlID0gc2NvcGUgPSBuZXcgX3dlYWtNYXAyLmRlZmF1bHQoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvY2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fdG9LZXkuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IHBvc3RNZXNzYWdlIH0gZnJvbSAnLi9yZXF1ZXN0JztcbmltcG9ydCAqIGFzIHBvc3RodG1sIGZyb20gJ3Bvc3RodG1sJ1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnXG5pbXBvcnQgKiBhcyBwYXJzZXIgZnJvbSAncG9zdGh0bWwtcGFyc2VyJ1xuXG52YXIgd2FsayA9IHJlcXVpcmUoJ3Bvc3RodG1sL2xpYi9hcGknKS53YWxrXG52YXIgbWF0Y2ggPSByZXF1aXJlKCdwb3N0aHRtbC9saWIvYXBpJykubWF0Y2hcblxudmFyIHVybCA9IFwiaHR0cHM6Ly93d3cuamF2YXNjcmlwdG9iZnVzY2F0b3IuY29tL0phdmFzY3JpcHQtT2JmdXNjYXRvci5hc3B4XCI7XG5cblxudmFyIGhlYWRlciA9IHtcbiAgICBcIk9yaWdpblwiOiBcImh0dHBzOi8vd3d3LmphdmFzY3JpcHRvYmZ1c2NhdG9yLmNvbVwiLFxuICAgIFwiVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0c1wiOiBcIjFcIixcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgIFwiVXNlci1BZ2VudFwiOiBcIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDYuMTsgV09XNjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS82My4wLjMyMzkuODQgU2FmYXJpLzUzNy4zNlwiLFxuICAgIFwiWC1EZXZUb29scy1FbXVsYXRlLU5ldHdvcmstQ29uZGl0aW9ucy1DbGllbnQtSWRcIjogXCIoMzhDQzhGNjlBNzZFQTYzNDJFNEIzMUIxQThBQkQ5RDgpXCIsXG4gICAgXCJBY2NlcHRcIjogXCJ0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmdcIixcbiAgICBcIlJlZmVyZXJcIjogXCJodHRwczovL3d3dy5qYXZhc2NyaXB0b2JmdXNjYXRvci5jb20vSmF2YXNjcmlwdC1PYmZ1c2NhdG9yLmFzcHhcIixcbiAgICAvL1wiQWNjZXB0LUVuY29kaW5nXCI6IFwiZ3ppcCwgZGVmbGF0ZSwgYnJcIixcbiAgICBcIkFjY2VwdC1MYW5ndWFnZVwiOiBcInpoLUNOLHpoO3E9MC45XCIsXG4gICAgXCJDb29raWVcIjpcIl9fY2ZkdWlkPWRjZjU2ZDk3MzQ3NzY5NTA5NzhkZDc5ZjIyMGY5YTRiNTE1MTQwMzQ5MDlcIlxufVxuXG5sZXQgcG9zdERhdGEgPSB7XG4gICAgXCJVcGxvYWRMaWJfVXBsb2FkZXJfanNcIjogXCIxXCIsXG4gICAgXCJfX0VWRU5UQVJHVU1FTlRcIjogXCJcIixcbiAgICBcIl9fRVZFTlRUQVJHRVRcIjogXCJjdGwwMCRNYWluQ29udGVudCRCdXR0b24xXCIsXG4gICAgXCJfX0VWRU5UVkFMSURBVElPTlwiOiBcIi93RWRBQXhSVi9RZ1JLSmE2akdXTnBOZGVKOE5DSjh4RUx0WUdIZkhKaWc4Qk5SMUEvbmQzd2N0eXd3ODlKYkRiZUx2Z3JqVy9RWTVjeitwdTNxVWpxTSs0bjVqSVdseUVLRnhMTzVjaytGNk0wT0RpSjFpdFpwKzJoQVRZVldqL2IrK255UjhmMmRQaFFRcmU0YUkwSWVhNGRLWW1qSTVTU3JQOC9kaTlGUEtBc0NSaVNEU29OdnBlMnFwOTB3blAySEFXek5zOW1kSmFlOVRBcEFKRlJSYjU0ZjczV2JBNFhjRVNmb2VJOEVJbkV6QStkeFJKSy9rVnhsVUxnMEFzVzMzNy9JaHlQbEx6TnhCL0lHNEZFVU0wOUVMUzU5RTYyMktsMlEydFZrSGpLT3JLZz09XCIsXG4gICAgXCJfX1ZJRVdTVEFURVwiOiBcIi93RVBEd1VLTVRNNE1qVTNORGd4Tnc5a0ZnSm1EMlFXQWdJREQyUVdCQUlCRHhZQ0hnUlVaWGgwQmZvQ1BHeHBJR05zWVhOelBTZHNhWE4wTFdsdWJHbHVaUzFwZEdWdElHY3RiWGd0TkNCbkxXMTBMVEV3Sno0OFlTQmpiR0Z6Y3owblp5MWpiMnh2Y2kxM2FHbDBaU0JuTFdOdmJHOXlMWEJ5YVcxaGNua3RMV2h2ZG1WeUlHY3RkR1Y0ZEMxMWJtUmxjbXhwYm1VdExXNXZibVV0TFdodmRtVnlKeUJvY21WbVBTY3ZjMmxuYm1sdUxtRnpjSGduUGtGalkyOTFiblFnVEc5bmFXNDhMMkUrUEM5c2FUNEtQR3hwSUdOc1lYTnpQU2RzYVhOMExXbHViR2x1WlMxcGRHVnRJR2N0YlhndE5DQm5MVzEwTFRFd0p6NThQQzlzYVQ0S1BHeHBJR05zWVhOelBTZHNhWE4wTFdsdWJHbHVaUzFwZEdWdElHY3RiWGd0TkNCbkxXMTBMVEV3Sno0OFlTQmpiR0Z6Y3owblp5MWpiMnh2Y2kxM2FHbDBaU0JuTFdOdmJHOXlMWEJ5YVcxaGNua3RMV2h2ZG1WeUlHY3RkR1Y0ZEMxMWJtUmxjbXhwYm1VdExXNXZibVV0TFdodmRtVnlKeUJvY21WbVBTY3ZjbVZuYVhOMFpYSXVZWE53ZUNjK1VtVm5hWE4wWlhJOEwyRStQQzlzYVQ0Z1pBSUhEMlFXQWdJWkR3OFdBaDRIVm1semFXSnNaV2RrWkJnQkJSNWZYME52Ym5SeWIyeHpVbVZ4ZFdseVpWQnZjM1JDWVdOclMyVjVYMThXQlFVYVkzUnNNREFrVFdGcGJrTnZiblJsYm5Ra1kySk1hVzVsUWxJRkdtTjBiREF3SkUxaGFXNURiMjUwWlc1MEpHTmlTVzVrWlc1MEJSMWpkR3d3TUNSTllXbHVRMjl1ZEdWdWRDUmpZa1Z1WTI5a1pWTjBjZ1ViWTNSc01EQWtUV0ZwYmtOdmJuUmxiblFrWTJKTmIzWmxVM1J5QlNCamRHd3dNQ1JOWVdsdVEyOXVkR1Z1ZENSallsSmxjR3hoWTJWT1lXMWxjMnl2L3FYbjc2MTJTcUlXUnBIRWt1VzZ5QjUyQzVzRExrZkhOSEk1Vi80R1wiLFxuICAgIFwiX19WSUVXU1RBVEVHRU5FUkFUT1JcIjogXCI2RDE5OEJFMVwiLFxuICAgIFwiY3RsMDAkTWFpbkNvbnRlbnQkVGV4dEJveDFcIjogXCJ2YXIgaSA9IDA7XFxuXFxuXFxudmFyIHkgPSAwO1wiLFxuICAgIFwiY3RsMDAkTWFpbkNvbnRlbnQkVGV4dEJveDJcIjogXCJcIixcbiAgICBcImN0bDAwJE1haW5Db250ZW50JFRleHRCb3gzXCI6IFwiXCIsXG4gICAgXCJjdGwwMCRNYWluQ29udGVudCRjYkVuY29kZVN0clwiOiBcIm9uXCIsXG4gICAgXCJjdGwwMCRNYWluQ29udGVudCRjYk1vdmVTdHJcIjogXCJvblwiLFxuICAgIFwiY3RsMDAkTWFpbkNvbnRlbnQkY2JSZXBsYWNlTmFtZXNcIjogXCJvblwiLFxuICAgIFwiY3RsMDAkTWFpbkNvbnRlbnQkdXBsb2FkZXIxXCI6IFwiXCJcbn1cblxuXG52YXIgcGFyc2VIdG1sID0gZnVuY3Rpb24gcGx1Z2luTmFtZSh0cmVlKSB7XG4gICAgLy8gZG8gc29tZXRoaW5nIGZvciB0cmVlXG4gICAgdHJlZS5tYXRjaCh7IHRhZzogJ3RleHRhcmVhJyB9LCBmdW5jdGlvbihub2RlKSB7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhub2RlLmF0dHJzLmlkKVxuICAgICAgICBpZihub2RlLmF0dHJzICYmIG5vZGUuYXR0cnMmJiBub2RlLmF0dHJzLmlkPT1cImN0bDAwX01haW5Db250ZW50X1RleHRCb3gyXCIpe1xuXG4gICAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICB9XG5cbiAgICB9KVxuXG4gICAvLyByZXR1cm4gdHJlZTtcbn1cblxuZnVuY3Rpb24geG1sZXNjYXBlICh0ZXh0KSB7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvJmFtcDsvZywgXCImXCIpO1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyZsdDsvZywgXCI8XCIpO1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyZndDsvZywgXCI+XCIpO1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyZhcG9zOy9nLCBcIidcIik7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpO1xuICAgIHJldHVybiB0ZXh0O1xufTtcblxuXG5cblxuXG5leHBvcnQgIGZ1bmN0aW9uIGVuY3J5cHRDb2RlKGlucHV0Q29kZTpzdHJpbmcpOlByb21pc2U8YW55PntcblxuICAgIHBvc3REYXRhW1wiY3RsMDAkTWFpbkNvbnRlbnQkVGV4dEJveDFcIl0gPSBpbnB1dENvZGU7XG4gICAgbGV0IHByb21pc2UgPSAgIHBvc3RNZXNzYWdlKHVybCxwb3N0RGF0YSxoZWFkZXIpO1xuICAgIGxldCBvdXRwdXQgID0gXCJcIjsgXG5cbiAgICAvL2NvbnNvbGUubG9nKFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIilcblxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCkgPT4ge1xuICAgICAgICBwcm9taXNlLnRoZW4oKHYpPT57XG5cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBsZXQgYXN0ID0gcGFyc2VyKHYpO1xuICAgICAgICAgICAgbWF0Y2guY2FsbChhc3QsIHsgdGFnOiAndGV4dGFyZWEnIH0sICAobm9kZSk9PiB7XG4gICAgICAgICAgICAgICAgaWYobm9kZS5hdHRycyAmJiBub2RlLmF0dHJzJiYgbm9kZS5hdHRycy5pZD09XCJjdGwwMF9NYWluQ29udGVudF9UZXh0Qm94MlwiKXtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Kz1ub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgXG5cblxuICAgICAgICAgICAgcmVzb2x2ZSggIHhtbGVzY2FwZShvdXRwdXQpIClcbiAgICAgICAgfSkuY2F0Y2goKGUpPT57XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yXCIsZSlcbiAgICAgICAgICAgIHJlamVjdChlKVxuICAgICAgICB9KVxuXG5cbiAgICB9KVxuICAgIFxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vZW5jcnlwdC50cyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBhcnNlciA9IHJlcXVpcmUoJ2h0bWxwYXJzZXIyL2xpYi9QYXJzZXInKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZiNTUvaHRtbHBhcnNlcjIvd2lraS9QYXJzZXItb3B0aW9uc1xuICovXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7bG93ZXJDYXNlVGFnczogZmFsc2UsIGxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiBmYWxzZX07XG5cbnZhciBkZWZhdWx0RGlyZWN0aXZlcyA9IFt7bmFtZTogJyFkb2N0eXBlJywgc3RhcnQ6ICc8JywgZW5kOiAnPid9XTtcblxuLyoqXG4gKiBQYXJzZSBodG1sIHRvIFBvc3RIVE1MVHJlZVxuICogQHBhcmFtICB7U3RyaW5nfSBodG1sXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPWRlZmF1bHRPcHRpb25zXVxuICogQHJldHVybiB7UG9zdEhUTUxUcmVlfVxuICovXG5mdW5jdGlvbiBwb3N0SFRNTFBhcnNlcihodG1sLCBvcHRpb25zKSB7XG4gICAgdmFyIGJ1ZkFycmF5ID0gW10sXG4gICAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgIGJ1ZkFycmF5Lmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNEaXJlY3RpdmUoZGlyZWN0aXZlLCB0YWcpIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZS5uYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXggPSBSZWdFeHAoZGlyZWN0aXZlLm5hbWUuc291cmNlLCAnaScpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdCh0YWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhZyAhPT0gZGlyZWN0aXZlLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlckRpcmVjdGl2ZShuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gW10uY29uY2F0KGRlZmF1bHREaXJlY3RpdmVzLCBvcHRpb25zLmRpcmVjdGl2ZXMgfHwgW10pO1xuICAgICAgICB2YXIgbGFzdCA9IGJ1ZkFycmF5Lmxhc3QoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSBkaXJlY3RpdmVzW2ldO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZVRleHQgPSBkaXJlY3RpdmUuc3RhcnQgKyBkYXRhICsgZGlyZWN0aXZlLmVuZDtcblxuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChpc0RpcmVjdGl2ZShkaXJlY3RpdmUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkaXJlY3RpdmVUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxhc3QuY29udGVudCB8fCAobGFzdC5jb250ZW50ID0gW10pO1xuICAgICAgICAgICAgICAgIGxhc3QuY29udGVudC5wdXNoKGRpcmVjdGl2ZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQXJyaWJ1dGVzKGF0dHJzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBhdHRyc1trZXldLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKTtcbiAgICAgICAgICAgIG9iamVjdEFzc2lnbihyZXN1bHQsIG9iaik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoe1xuICAgICAgICBvbnByb2Nlc3NpbmdpbnN0cnVjdGlvbjogcGFyc2VyRGlyZWN0aXZlLFxuICAgICAgICBvbmNvbW1lbnQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gJzwhLS0nICsgZGF0YSArICctLT4nLFxuICAgICAgICAgICAgICAgIGxhc3QgPSBidWZBcnJheS5sYXN0KCk7XG5cbiAgICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3QuY29udGVudCB8fCAobGFzdC5jb250ZW50ID0gW10pO1xuICAgICAgICAgICAgbGFzdC5jb250ZW50LnB1c2goY29tbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ub3BlbnRhZzogZnVuY3Rpb24odGFnLCBhdHRycykge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IHsgdGFnOiB0YWcgfTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWYuYXR0cnMgPSBub3JtYWxpemVBcnJpYnV0ZXMoYXR0cnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZBcnJheS5wdXNoKGJ1Zik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2xvc2V0YWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IGJ1ZkFycmF5LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoIWJ1ZkFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChidWYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxhc3QgPSBidWZBcnJheS5sYXN0KCk7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGFzdC5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgIGxhc3QuY29udGVudCA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0LmNvbnRlbnQucHVzaChidWYpO1xuICAgICAgICB9LFxuICAgICAgICBvbnRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gYnVmQXJyYXkubGFzdCgpO1xuICAgICAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdC5jb250ZW50IHx8IChsYXN0LmNvbnRlbnQgPSBbXSk7XG4gICAgICAgICAgICBsYXN0LmNvbnRlbnQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH0sIG9wdGlvbnMgfHwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgcGFyc2VyLndyaXRlKGh0bWwpO1xuICAgIHBhcnNlci5lbmQoKTtcblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBwYXJzZXJXcmFwcGVyKCkge1xuICAgIHZhciBvcHRpb247XG5cbiAgICBmdW5jdGlvbiBwYXJzZXIoaHRtbCkge1xuICAgICAgICB2YXIgb3B0ID0gb2JqZWN0QXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb24pO1xuICAgICAgICByZXR1cm4gcG9zdEhUTUxQYXJzZXIoaHRtbCwgb3B0KTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc09iamVjdChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9wdGlvbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9XG5cbiAgICBvcHRpb24gPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIHBhcnNlcihhcmd1bWVudHNbMF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcldyYXBwZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdERpcmVjdGl2ZXMgPSBkZWZhdWx0RGlyZWN0aXZlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fcG9zdGh0bWwtcGFyc2VyQDAuNC4wQHBvc3RodG1sLXBhcnNlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInV0aWxcIlxuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uKGdsb2JhbCkge1xuLyoqXG4gKiBSZW5kZXIgUG9zdEhUTUxUcmVlIHRvIGh0bWxcbiAqIEBwYXJhbSAge09iamVjdH0gdHJlZSAgICBQb3N0SFRNTFRyZWVcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBSZW5kZXIgb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIGh0bWwgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHBvc3RIVE1MUmVuZGVyKHRyZWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIG9wdGlvbnMgcmVuZGVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIHNpbmdsZVRhZ3MgICAgICAgICAgIHNpbmdsZSB0YWdzIGFycmF5IGZvciBleHRlbmQgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbG9zaW5nU2luZ2xlVGFnICAgICBvcHRpb24gZm9yIGNsb3Npbmcgc2luZ2xlIHRhZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb246XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBgPGJyPmBcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXNoOiBgPGJyIC8+YFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBgPGJyPjwvYnI+YFxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgb3B0U2luZ2xlVGFncyA9IG9wdGlvbnMuc2luZ2xlVGFncyxcbiAgICAgICAgY2xvc2luZ1NpbmdsZVRhZyA9IG9wdGlvbnMuY2xvc2luZ1NpbmdsZVRhZztcblxuICAgIHZhciBTSU5HTEVfVEFHUyA9IFsnYXJlYScsICdiYXNlJywgJ2JyJywgJ2NvbCcsICdjb21tYW5kJywgJ2VtYmVkJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdrZXlnZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmsnLCAnbWVudWl0ZW0nLCAnbWV0YScsICdwYXJhbScsICdzb3VyY2UnLCAndHJhY2snLCAnd2JyJ107XG4gICAgdmFyIHNpbmdsZVRhZ3MgPSB7fTtcbiAgICB2YXIgcmVnZXhwU2luZ2xlVGFncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmkgPSBTSU5HTEVfVEFHUy5sZW5ndGg7IGkgPCBsZW5pOyBpKyspIHtcbiAgICAgICAgc2luZ2xlVGFnc1tTSU5HTEVfVEFHU1tpXV0gPSAxO1xuICAgIH1cblxuICAgIGlmIChvcHRTaW5nbGVUYWdzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW5qID0gb3B0U2luZ2xlVGFncy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChvcHRTaW5nbGVUYWdzW2pdIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgcmVnZXhwU2luZ2xlVGFncy5wdXNoKG9wdFNpbmdsZVRhZ3Nbal0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaW5nbGVUYWdzW29wdFNpbmdsZVRhZ3Nbal1dID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBodG1sKHRyZWUpO1xuXG4gICAgZnVuY3Rpb24gaHRtbCh0cmVlKSB7XG5cbiAgICAgICAgdmFyIGJ1ZiA9ICcnO1xuXG4gICAgICAgIHRyYXZlcnNlKFtdLmNvbmNhdCh0cmVlKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGJ1ZiArPSBub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS50YWcgPT09ICdib29sZWFuJyAmJiAhbm9kZS50YWcpIHtcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5jb250ZW50ICE9PSAnb2JqZWN0JyAmJiAgKGJ1ZiArPSBub2RlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyZWF0IGFzIG5ldyByb290IHRyZWUgaWYgbm9kZSBpcyBhbiBhcnJheVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBidWYgKz0gaHRtbChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0YWcgPSBub2RlLnRhZyB8fCAnZGl2JztcbiAgICAgICAgICAgIGlmIChpc1NpbmdsZVRhZyh0YWcsIHNpbmdsZVRhZ3MsIHJlZ2V4cFNpbmdsZVRhZ3MpKSB7XG4gICAgICAgICAgICAgICAgYnVmICs9ICc8JysgdGFnICsgYXR0cnMobm9kZS5hdHRycyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbG9zaW5nU2luZ2xlVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NsYXNoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiArPSAnIC8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmICs9ICc+PC8nICsgdGFnICsgJz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBidWYgKz0gJz4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmICs9ICc8JyArIHRhZyArIChub2RlLmF0dHJzPyBhdHRycyhub2RlLmF0dHJzKTogJycpICsgJz4nICtcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUuY29udGVudD8gaHRtbChub2RlLmNvbnRlbnQpOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnPC8nICsgdGFnICsgJz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYnVmO1xuXG4gICAgICAgIGZ1bmN0aW9uIGF0dHJzKG9iaikge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldXG4gICAgICAgICAgICAgICAgKSBhdHRyICs9ICcgJyArIGtleTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9ialtrZXldID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb2JqW2tleV0gPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgKSBhdHRyICs9ICcgJyArIGtleSArICc9XCInICsgb2JqW2tleV0gKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlKHRyZWUsIGNiKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRyZWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRyYXZlcnNlKGNiKHRyZWVbaV0pLCBjYik7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmVlID09PSAnb2JqZWN0JyAmJiB0cmVlLmhhc093blByb3BlcnR5KCdjb250ZW50JykpIHRyYXZlcnNlKHRyZWUuY29udGVudCwgY2IpO1xuICAgIHJldHVybiB0cmVlO1xufVxuXG5mdW5jdGlvbiBpc1NpbmdsZVRhZyh0YWcsIHN0cmluZ3MsIHJlZ2V4cHMpIHtcbiAgICBpZiAoc3RyaW5nc1t0YWddKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2V4cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRhZy5tYXRjaChyZWdleHBzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgZGVmaW5lQXNHbG9iYWwgPSB0cnVlO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBvc3RIVE1MUmVuZGVyO1xuICAgIGRlZmluZUFzR2xvYmFsID0gZmFsc2U7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAodHlwZW9mIG1vZHVsZXMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGVzLmRlZmluZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1vZHVsZXMuZGVmaW5lKCdwb3N0SFRNTFJlbmRlcicsIGZ1bmN0aW9uKHByb3ZpZGUpIHtcbiAgICAgICAgcHJvdmlkZShwb3N0SFRNTFJlbmRlcik7XG4gICAgfSk7XG4gICAgZGVmaW5lQXNHbG9iYWwgPSBmYWxzZTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHBvc3RIVE1MUmVuZGVyO1xuICAgIH0pO1xuICAgIGRlZmluZUFzR2xvYmFsID0gZmFsc2U7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZGVmaW5lQXNHbG9iYWwgJiYgKGdsb2JhbC5wb3N0SFRNTFJlbmRlciA9IHBvc3RIVE1MUmVuZGVyKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbn0pKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnPyB3aW5kb3c6IGdsb2JhbCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3Bvc3RodG1sLXJlbmRlckAxLjEuMEBwb3N0aHRtbC1yZW5kZXIvbGliL3Bvc3RodG1sLXJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gKCFCVUdHWSAmJiAkbmF0aXZlKSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLk5PVF9MT0NBTF9CSU5ESU5HID0gZXhwb3J0cy5CTE9DS19TQ09QRURfU1lNQk9MID0gZXhwb3J0cy5JTkhFUklUX0tFWVMgPSBleHBvcnRzLlVOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuTlVNQkVSX1VOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkNPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuVVBEQVRFX09QRVJBVE9SUyA9IGV4cG9ydHMuTE9HSUNBTF9PUEVSQVRPUlMgPSBleHBvcnRzLkNPTU1FTlRfS0VZUyA9IGV4cG9ydHMuRk9SX0lOSVRfS0VZUyA9IGV4cG9ydHMuRkxBVFRFTkFCTEVfS0VZUyA9IGV4cG9ydHMuU1RBVEVNRU5UX09SX0JMT0NLX0tFWVMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZm9yID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvZm9yXCIpO1xuXG52YXIgX2ZvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgU1RBVEVNRU5UX09SX0JMT0NLX0tFWVMgPSBleHBvcnRzLlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gW1wiY29uc2VxdWVudFwiLCBcImJvZHlcIiwgXCJhbHRlcm5hdGVcIl07XG52YXIgRkxBVFRFTkFCTEVfS0VZUyA9IGV4cG9ydHMuRkxBVFRFTkFCTEVfS0VZUyA9IFtcImJvZHlcIiwgXCJleHByZXNzaW9uc1wiXTtcbnZhciBGT1JfSU5JVF9LRVlTID0gZXhwb3J0cy5GT1JfSU5JVF9LRVlTID0gW1wibGVmdFwiLCBcImluaXRcIl07XG52YXIgQ09NTUVOVF9LRVlTID0gZXhwb3J0cy5DT01NRU5UX0tFWVMgPSBbXCJsZWFkaW5nQ29tbWVudHNcIiwgXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIFwiaW5uZXJDb21tZW50c1wiXTtcblxudmFyIExPR0lDQUxfT1BFUkFUT1JTID0gZXhwb3J0cy5MT0dJQ0FMX09QRVJBVE9SUyA9IFtcInx8XCIsIFwiJiZcIl07XG52YXIgVVBEQVRFX09QRVJBVE9SUyA9IGV4cG9ydHMuVVBEQVRFX09QRVJBVE9SUyA9IFtcIisrXCIsIFwiLS1cIl07XG5cbnZhciBCT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gW1wiPlwiLCBcIjxcIiwgXCI+PVwiLCBcIjw9XCJdO1xudmFyIEVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMgPSBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdO1xudmFyIENPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTID0gW10uY29uY2F0KEVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMsIFtcImluXCIsIFwiaW5zdGFuY2VvZlwiXSk7XG52YXIgQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMgPSBbXS5jb25jYXQoQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTLCBCT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTKTtcbnZhciBOVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBbXCItXCIsIFwiL1wiLCBcIiVcIiwgXCIqXCIsIFwiKipcIiwgXCImXCIsIFwifFwiLCBcIj4+XCIsIFwiPj4+XCIsIFwiPDxcIiwgXCJeXCJdO1xudmFyIEJJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJJTkFSWV9PUEVSQVRPUlMgPSBbXCIrXCJdLmNvbmNhdChOVU1CRVJfQklOQVJZX09QRVJBVE9SUywgQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTKTtcblxudmFyIEJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX1VOQVJZX09QRVJBVE9SUyA9IFtcImRlbGV0ZVwiLCBcIiFcIl07XG52YXIgTlVNQkVSX1VOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuTlVNQkVSX1VOQVJZX09QRVJBVE9SUyA9IFtcIitcIiwgXCItXCIsIFwiKytcIiwgXCItLVwiLCBcIn5cIl07XG52YXIgU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IFtcInR5cGVvZlwiXTtcbnZhciBVTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlVOQVJZX09QRVJBVE9SUyA9IFtcInZvaWRcIl0uY29uY2F0KEJPT0xFQU5fVU5BUllfT1BFUkFUT1JTLCBOVU1CRVJfVU5BUllfT1BFUkFUT1JTLCBTVFJJTkdfVU5BUllfT1BFUkFUT1JTKTtcblxudmFyIElOSEVSSVRfS0VZUyA9IGV4cG9ydHMuSU5IRVJJVF9LRVlTID0ge1xuICBvcHRpb25hbDogW1widHlwZUFubm90YXRpb25cIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInJldHVyblR5cGVcIl0sXG4gIGZvcmNlOiBbXCJzdGFydFwiLCBcImxvY1wiLCBcImVuZFwiXVxufTtcblxudmFyIEJMT0NLX1NDT1BFRF9TWU1CT0wgPSBleHBvcnRzLkJMT0NLX1NDT1BFRF9TWU1CT0wgPSAoMCwgX2ZvcjIuZGVmYXVsdCkoXCJ2YXIgdXNlZCB0byBiZSBibG9jayBzY29wZWRcIik7XG52YXIgTk9UX0xPQ0FMX0JJTkRJTkcgPSBleHBvcnRzLk5PVF9MT0NBTF9CSU5ESU5HID0gKDAsIF9mb3IyLmRlZmF1bHQpKFwic2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGEgbG9jYWwgYmluZGluZ1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlcy9saWIvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX1N0YWNrLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fTWFwQ2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Fzc2lnblZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2lzQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2lzSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaXNMZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gva2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fZ2V0U3ltYm9scy5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlRmluZEluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fc2V0VG9BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2lkZW50aXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfa2V5cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIik7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfbWFwID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXBcIik7XG5cbnZhciBfbWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hcCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbnZhciBfaW5jbHVkZXMgPSByZXF1aXJlKFwibG9kYXNoL2luY2x1ZGVzXCIpO1xuXG52YXIgX2luY2x1ZGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luY2x1ZGVzKTtcblxudmFyIF9yZXBlYXQgPSByZXF1aXJlKFwibG9kYXNoL3JlcGVhdFwiKTtcblxudmFyIF9yZXBlYXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVwZWF0KTtcblxudmFyIF9yZW5hbWVyID0gcmVxdWlyZShcIi4vbGliL3JlbmFtZXJcIik7XG5cbnZhciBfcmVuYW1lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5hbWVyKTtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbnZhciBfZGVmYXVsdHMgPSByZXF1aXJlKFwibG9kYXNoL2RlZmF1bHRzXCIpO1xuXG52YXIgX2RlZmF1bHRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRzKTtcblxudmFyIF9iYWJlbE1lc3NhZ2VzID0gcmVxdWlyZShcImJhYmVsLW1lc3NhZ2VzXCIpO1xuXG52YXIgbWVzc2FnZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYmFiZWxNZXNzYWdlcyk7XG5cbnZhciBfYmluZGluZzIgPSByZXF1aXJlKFwiLi9iaW5kaW5nXCIpO1xuXG52YXIgX2JpbmRpbmczID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmluZGluZzIpO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiZ2xvYmFsc1wiKTtcblxudmFyIF9nbG9iYWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbHMpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX2NyYXdsQ2FsbHNDb3VudCA9IDA7XG5cbmZ1bmN0aW9uIGdldENhY2hlKHBhdGgsIHBhcmVudFNjb3BlLCBzZWxmKSB7XG4gIHZhciBzY29wZXMgPSBfY2FjaGUuc2NvcGUuZ2V0KHBhdGgubm9kZSkgfHwgW107XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gc2NvcGVzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcik7Oykge1xuICAgIHZhciBfcmVmO1xuXG4gICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0gX3JlZjtcblxuICAgIGlmIChzY29wZS5wYXJlbnQgPT09IHBhcmVudFNjb3BlICYmIHNjb3BlLnBhdGggPT09IHBhdGgpIHJldHVybiBzY29wZTtcbiAgfVxuXG4gIHNjb3Blcy5wdXNoKHNlbGYpO1xuXG4gIGlmICghX2NhY2hlLnNjb3BlLmhhcyhwYXRoLm5vZGUpKSB7XG4gICAgX2NhY2hlLnNjb3BlLnNldChwYXRoLm5vZGUsIHNjb3Blcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2F0aGVyTm9kZVBhcnRzKG5vZGUsIHBhcnRzKSB7XG4gIGlmICh0LmlzTW9kdWxlRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICBpZiAobm9kZS5zb3VyY2UpIHtcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLnNvdXJjZSwgcGFydHMpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5zcGVjaWZpZXJzICYmIG5vZGUuc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBub2RlLnNwZWNpZmllcnMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMik7Oykge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcGVjaWZpZXIgPSBfcmVmMjtcblxuICAgICAgICBnYXRoZXJOb2RlUGFydHMoc3BlY2lmaWVyLCBwYXJ0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5kZWNsYXJhdGlvbiwgcGFydHMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0LmlzTW9kdWxlU3BlY2lmaWVyKG5vZGUpKSB7XG4gICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUubG9jYWwsIHBhcnRzKTtcbiAgfSBlbHNlIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihub2RlKSkge1xuICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLm9iamVjdCwgcGFydHMpO1xuICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLnByb3BlcnR5LCBwYXJ0cyk7XG4gIH0gZWxzZSBpZiAodC5pc0lkZW50aWZpZXIobm9kZSkpIHtcbiAgICBwYXJ0cy5wdXNoKG5vZGUubmFtZSk7XG4gIH0gZWxzZSBpZiAodC5pc0xpdGVyYWwobm9kZSkpIHtcbiAgICBwYXJ0cy5wdXNoKG5vZGUudmFsdWUpO1xuICB9IGVsc2UgaWYgKHQuaXNDYWxsRXhwcmVzc2lvbihub2RlKSkge1xuICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLmNhbGxlZSwgcGFydHMpO1xuICB9IGVsc2UgaWYgKHQuaXNPYmplY3RFeHByZXNzaW9uKG5vZGUpIHx8IHQuaXNPYmplY3RQYXR0ZXJuKG5vZGUpKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IG5vZGUucHJvcGVydGllcywgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IzKTs7KSB7XG4gICAgICB2YXIgX3JlZjM7XG5cbiAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yM1tfaTMrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTMgPSBfaXRlcmF0b3IzLm5leHQoKTtcbiAgICAgICAgaWYgKF9pMy5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gX3JlZjM7XG5cbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhwcm9wLmtleSB8fCBwcm9wLmFyZ3VtZW50LCBwYXJ0cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBjb2xsZWN0b3JWaXNpdG9yID0ge1xuICBGb3I6IGZ1bmN0aW9uIEZvcihwYXRoKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IHQuRk9SX0lOSVRfS0VZUywgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I0KSwgX2k0ID0gMCwgX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/IF9pdGVyYXRvcjQgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3I0KTs7KSB7XG4gICAgICB2YXIgX3JlZjQ7XG5cbiAgICAgIGlmIChfaXNBcnJheTQpIHtcbiAgICAgICAgaWYgKF9pNCA+PSBfaXRlcmF0b3I0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWY0ID0gX2l0ZXJhdG9yNFtfaTQrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcbiAgICAgICAgaWYgKF9pNC5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjQgPSBfaTQudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXkgPSBfcmVmNDtcblxuICAgICAgdmFyIGRlY2xhciA9IHBhdGguZ2V0KGtleSk7XG4gICAgICBpZiAoZGVjbGFyLmlzVmFyKCkpIHBhdGguc2NvcGUuZ2V0RnVuY3Rpb25QYXJlbnQoKS5yZWdpc3RlckJpbmRpbmcoXCJ2YXJcIiwgZGVjbGFyKTtcbiAgICB9XG4gIH0sXG4gIERlY2xhcmF0aW9uOiBmdW5jdGlvbiBEZWNsYXJhdGlvbihwYXRoKSB7XG4gICAgaWYgKHBhdGguaXNCbG9ja1Njb3BlZCgpKSByZXR1cm47XG5cbiAgICBpZiAocGF0aC5pc0V4cG9ydERlY2xhcmF0aW9uKCkgJiYgcGF0aC5nZXQoXCJkZWNsYXJhdGlvblwiKS5pc0RlY2xhcmF0aW9uKCkpIHJldHVybjtcblxuICAgIHBhdGguc2NvcGUuZ2V0RnVuY3Rpb25QYXJlbnQoKS5yZWdpc3RlckRlY2xhcmF0aW9uKHBhdGgpO1xuICB9LFxuICBSZWZlcmVuY2VkSWRlbnRpZmllcjogZnVuY3Rpb24gUmVmZXJlbmNlZElkZW50aWZpZXIocGF0aCwgc3RhdGUpIHtcbiAgICBzdGF0ZS5yZWZlcmVuY2VzLnB1c2gocGF0aCk7XG4gIH0sXG4gIEZvclhTdGF0ZW1lbnQ6IGZ1bmN0aW9uIEZvclhTdGF0ZW1lbnQocGF0aCwgc3RhdGUpIHtcbiAgICB2YXIgbGVmdCA9IHBhdGguZ2V0KFwibGVmdFwiKTtcbiAgICBpZiAobGVmdC5pc1BhdHRlcm4oKSB8fCBsZWZ0LmlzSWRlbnRpZmllcigpKSB7XG4gICAgICBzdGF0ZS5jb25zdGFudFZpb2xhdGlvbnMucHVzaChsZWZ0KTtcbiAgICB9XG4gIH0sXG5cblxuICBFeHBvcnREZWNsYXJhdGlvbjoge1xuICAgIGV4aXQ6IGZ1bmN0aW9uIGV4aXQocGF0aCkge1xuICAgICAgdmFyIG5vZGUgPSBwYXRoLm5vZGUsXG4gICAgICAgICAgc2NvcGUgPSBwYXRoLnNjb3BlO1xuXG4gICAgICB2YXIgZGVjbGFyID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgIGlmICh0LmlzQ2xhc3NEZWNsYXJhdGlvbihkZWNsYXIpIHx8IHQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2xhcikpIHtcbiAgICAgICAgdmFyIF9pZCA9IGRlY2xhci5pZDtcbiAgICAgICAgaWYgKCFfaWQpIHJldHVybjtcblxuICAgICAgICB2YXIgYmluZGluZyA9IHNjb3BlLmdldEJpbmRpbmcoX2lkLm5hbWUpO1xuICAgICAgICBpZiAoYmluZGluZykgYmluZGluZy5yZWZlcmVuY2UocGF0aCk7XG4gICAgICB9IGVsc2UgaWYgKHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcikpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGRlY2xhci5kZWNsYXJhdGlvbnMsIF9pc0FycmF5NSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNSksIF9pNSA9IDAsIF9pdGVyYXRvcjUgPSBfaXNBcnJheTUgPyBfaXRlcmF0b3I1IDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yNSk7Oykge1xuICAgICAgICAgIHZhciBfcmVmNTtcblxuICAgICAgICAgIGlmIChfaXNBcnJheTUpIHtcbiAgICAgICAgICAgIGlmIChfaTUgPj0gX2l0ZXJhdG9yNS5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjUgPSBfaXRlcmF0b3I1W19pNSsrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2k1ID0gX2l0ZXJhdG9yNS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoX2k1LmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjUgPSBfaTUudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlY2wgPSBfcmVmNTtcblxuICAgICAgICAgIHZhciBpZHMgPSB0LmdldEJpbmRpbmdJZGVudGlmaWVycyhkZWNsKTtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGlkcykge1xuICAgICAgICAgICAgdmFyIF9iaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZyhuYW1lKTtcbiAgICAgICAgICAgIGlmIChfYmluZGluZykgX2JpbmRpbmcucmVmZXJlbmNlKHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBMYWJlbGVkU3RhdGVtZW50OiBmdW5jdGlvbiBMYWJlbGVkU3RhdGVtZW50KHBhdGgpIHtcbiAgICBwYXRoLnNjb3BlLmdldFByb2dyYW1QYXJlbnQoKS5hZGRHbG9iYWwocGF0aC5ub2RlKTtcbiAgICBwYXRoLnNjb3BlLmdldEJsb2NrUGFyZW50KCkucmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKTtcbiAgfSxcbiAgQXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKHBhdGgsIHN0YXRlKSB7XG4gICAgc3RhdGUuYXNzaWdubWVudHMucHVzaChwYXRoKTtcbiAgfSxcbiAgVXBkYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihwYXRoLCBzdGF0ZSkge1xuICAgIHN0YXRlLmNvbnN0YW50VmlvbGF0aW9ucy5wdXNoKHBhdGguZ2V0KFwiYXJndW1lbnRcIikpO1xuICB9LFxuICBVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIFVuYXJ5RXhwcmVzc2lvbihwYXRoLCBzdGF0ZSkge1xuICAgIGlmIChwYXRoLm5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgIHN0YXRlLmNvbnN0YW50VmlvbGF0aW9ucy5wdXNoKHBhdGguZ2V0KFwiYXJndW1lbnRcIikpO1xuICAgIH1cbiAgfSxcbiAgQmxvY2tTY29wZWQ6IGZ1bmN0aW9uIEJsb2NrU2NvcGVkKHBhdGgpIHtcbiAgICB2YXIgc2NvcGUgPSBwYXRoLnNjb3BlO1xuICAgIGlmIChzY29wZS5wYXRoID09PSBwYXRoKSBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICBzY29wZS5nZXRCbG9ja1BhcmVudCgpLnJlZ2lzdGVyRGVjbGFyYXRpb24ocGF0aCk7XG4gIH0sXG4gIENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIENsYXNzRGVjbGFyYXRpb24ocGF0aCkge1xuICAgIHZhciBpZCA9IHBhdGgubm9kZS5pZDtcbiAgICBpZiAoIWlkKSByZXR1cm47XG5cbiAgICB2YXIgbmFtZSA9IGlkLm5hbWU7XG4gICAgcGF0aC5zY29wZS5iaW5kaW5nc1tuYW1lXSA9IHBhdGguc2NvcGUuZ2V0QmluZGluZyhuYW1lKTtcbiAgfSxcbiAgQmxvY2s6IGZ1bmN0aW9uIEJsb2NrKHBhdGgpIHtcbiAgICB2YXIgcGF0aHMgPSBwYXRoLmdldChcImJvZHlcIik7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IHBhdGhzLCBfaXNBcnJheTYgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjYpLCBfaTYgPSAwLCBfaXRlcmF0b3I2ID0gX2lzQXJyYXk2ID8gX2l0ZXJhdG9yNiA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjYpOzspIHtcbiAgICAgIHZhciBfcmVmNjtcblxuICAgICAgaWYgKF9pc0FycmF5Nikge1xuICAgICAgICBpZiAoX2k2ID49IF9pdGVyYXRvcjYubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjYgPSBfaXRlcmF0b3I2W19pNisrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pNiA9IF9pdGVyYXRvcjYubmV4dCgpO1xuICAgICAgICBpZiAoX2k2LmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmNiA9IF9pNi52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvZHlQYXRoID0gX3JlZjY7XG5cbiAgICAgIGlmIChib2R5UGF0aC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBwYXRoLnNjb3BlLmdldEJsb2NrUGFyZW50KCkucmVnaXN0ZXJEZWNsYXJhdGlvbihib2R5UGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgdWlkID0gMDtcblxudmFyIFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY29wZShwYXRoLCBwYXJlbnRTY29wZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFNjb3BlKTtcblxuICAgIGlmIChwYXJlbnRTY29wZSAmJiBwYXJlbnRTY29wZS5ibG9jayA9PT0gcGF0aC5ub2RlKSB7XG4gICAgICByZXR1cm4gcGFyZW50U2NvcGU7XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlZCA9IGdldENhY2hlKHBhdGgsIHBhcmVudFNjb3BlLCB0aGlzKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuXG4gICAgdGhpcy51aWQgPSB1aWQrKztcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFNjb3BlO1xuICAgIHRoaXMuaHViID0gcGF0aC5odWI7XG5cbiAgICB0aGlzLnBhcmVudEJsb2NrID0gcGF0aC5wYXJlbnQ7XG4gICAgdGhpcy5ibG9jayA9IHBhdGgubm9kZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuXG4gICAgdGhpcy5sYWJlbHMgPSBuZXcgX21hcDIuZGVmYXVsdCgpO1xuICB9XG5cbiAgU2NvcGUucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSwgb3B0cywgc3RhdGUpIHtcbiAgICAoMCwgX2luZGV4Mi5kZWZhdWx0KShub2RlLCBvcHRzLCB0aGlzLCBzdGF0ZSwgdGhpcy5wYXRoKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuZ2VuZXJhdGVEZWNsYXJlZFVpZElkZW50aWZpZXIgPSBmdW5jdGlvbiBnZW5lcmF0ZURlY2xhcmVkVWlkSWRlbnRpZmllcigpIHtcbiAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJ0ZW1wXCI7XG5cbiAgICB2YXIgaWQgPSB0aGlzLmdlbmVyYXRlVWlkSWRlbnRpZmllcihuYW1lKTtcbiAgICB0aGlzLnB1c2goeyBpZDogaWQgfSk7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIgPSBmdW5jdGlvbiBnZW5lcmF0ZVVpZElkZW50aWZpZXIoKSB7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwidGVtcFwiO1xuXG4gICAgcmV0dXJuIHQuaWRlbnRpZmllcih0aGlzLmdlbmVyYXRlVWlkKG5hbWUpKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuZ2VuZXJhdGVVaWQgPSBmdW5jdGlvbiBnZW5lcmF0ZVVpZCgpIHtcbiAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJ0ZW1wXCI7XG5cbiAgICBuYW1lID0gdC50b0lkZW50aWZpZXIobmFtZSkucmVwbGFjZSgvXl8rLywgXCJcIikucmVwbGFjZSgvWzAtOV0rJC9nLCBcIlwiKTtcblxuICAgIHZhciB1aWQgPSB2b2lkIDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIHVpZCA9IHRoaXMuX2dlbmVyYXRlVWlkKG5hbWUsIGkpO1xuICAgICAgaSsrO1xuICAgIH0gd2hpbGUgKHRoaXMuaGFzTGFiZWwodWlkKSB8fCB0aGlzLmhhc0JpbmRpbmcodWlkKSB8fCB0aGlzLmhhc0dsb2JhbCh1aWQpIHx8IHRoaXMuaGFzUmVmZXJlbmNlKHVpZCkpO1xuXG4gICAgdmFyIHByb2dyYW0gPSB0aGlzLmdldFByb2dyYW1QYXJlbnQoKTtcbiAgICBwcm9ncmFtLnJlZmVyZW5jZXNbdWlkXSA9IHRydWU7XG4gICAgcHJvZ3JhbS51aWRzW3VpZF0gPSB0cnVlO1xuXG4gICAgcmV0dXJuIHVpZDtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuX2dlbmVyYXRlVWlkID0gZnVuY3Rpb24gX2dlbmVyYXRlVWlkKG5hbWUsIGkpIHtcbiAgICB2YXIgaWQgPSBuYW1lO1xuICAgIGlmIChpID4gMSkgaWQgKz0gaTtcbiAgICByZXR1cm4gXCJfXCIgKyBpZDtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyQmFzZWRPbk5vZGUgPSBmdW5jdGlvbiBnZW5lcmF0ZVVpZElkZW50aWZpZXJCYXNlZE9uTm9kZShwYXJlbnQsIGRlZmF1bHROYW1lKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQ7XG5cbiAgICBpZiAodC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKHBhcmVudCkpIHtcbiAgICAgIG5vZGUgPSBwYXJlbnQubGVmdDtcbiAgICB9IGVsc2UgaWYgKHQuaXNWYXJpYWJsZURlY2xhcmF0b3IocGFyZW50KSkge1xuICAgICAgbm9kZSA9IHBhcmVudC5pZDtcbiAgICB9IGVsc2UgaWYgKHQuaXNPYmplY3RQcm9wZXJ0eShub2RlKSB8fCB0LmlzT2JqZWN0TWV0aG9kKG5vZGUpKSB7XG4gICAgICBub2RlID0gbm9kZS5rZXk7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUsIHBhcnRzKTtcblxuICAgIHZhciBpZCA9IHBhcnRzLmpvaW4oXCIkXCIpO1xuICAgIGlkID0gaWQucmVwbGFjZSgvXl8vLCBcIlwiKSB8fCBkZWZhdWx0TmFtZSB8fCBcInJlZlwiO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKGlkLnNsaWNlKDAsIDIwKSk7XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLmlzU3RhdGljID0gZnVuY3Rpb24gaXNTdGF0aWMobm9kZSkge1xuICAgIGlmICh0LmlzVGhpc0V4cHJlc3Npb24obm9kZSkgfHwgdC5pc1N1cGVyKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodC5pc0lkZW50aWZpZXIobm9kZSkpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKG5vZGUubmFtZSk7XG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICByZXR1cm4gYmluZGluZy5jb25zdGFudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0JpbmRpbmcobm9kZS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLm1heWJlR2VuZXJhdGVNZW1vaXNlZCA9IGZ1bmN0aW9uIG1heWJlR2VuZXJhdGVNZW1vaXNlZChub2RlLCBkb250UHVzaCkge1xuICAgIGlmICh0aGlzLmlzU3RhdGljKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9pZDIgPSB0aGlzLmdlbmVyYXRlVWlkSWRlbnRpZmllckJhc2VkT25Ob2RlKG5vZGUpO1xuICAgICAgaWYgKCFkb250UHVzaCkgdGhpcy5wdXNoKHsgaWQ6IF9pZDIgfSk7XG4gICAgICByZXR1cm4gX2lkMjtcbiAgICB9XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLmNoZWNrQmxvY2tTY29wZWRDb2xsaXNpb25zID0gZnVuY3Rpb24gY2hlY2tCbG9ja1Njb3BlZENvbGxpc2lvbnMobG9jYWwsIGtpbmQsIG5hbWUsIGlkKSB7XG4gICAgaWYgKGtpbmQgPT09IFwicGFyYW1cIikgcmV0dXJuO1xuXG4gICAgaWYgKGtpbmQgPT09IFwiaG9pc3RlZFwiICYmIGxvY2FsLmtpbmQgPT09IFwibGV0XCIpIHJldHVybjtcblxuICAgIHZhciBkdXBsaWNhdGUgPSBraW5kID09PSBcImxldFwiIHx8IGxvY2FsLmtpbmQgPT09IFwibGV0XCIgfHwgbG9jYWwua2luZCA9PT0gXCJjb25zdFwiIHx8IGxvY2FsLmtpbmQgPT09IFwibW9kdWxlXCIgfHwgbG9jYWwua2luZCA9PT0gXCJwYXJhbVwiICYmIChraW5kID09PSBcImxldFwiIHx8IGtpbmQgPT09IFwiY29uc3RcIik7XG5cbiAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICB0aHJvdyB0aGlzLmh1Yi5maWxlLmJ1aWxkQ29kZUZyYW1lRXJyb3IoaWQsIG1lc3NhZ2VzLmdldChcInNjb3BlRHVwbGljYXRlRGVjbGFyYXRpb25cIiwgbmFtZSksIFR5cGVFcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiByZW5hbWUob2xkTmFtZSwgbmV3TmFtZSwgYmxvY2spIHtcbiAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyhvbGROYW1lKTtcbiAgICBpZiAoYmluZGluZykge1xuICAgICAgbmV3TmFtZSA9IG5ld05hbWUgfHwgdGhpcy5nZW5lcmF0ZVVpZElkZW50aWZpZXIob2xkTmFtZSkubmFtZTtcbiAgICAgIHJldHVybiBuZXcgX3JlbmFtZXIyLmRlZmF1bHQoYmluZGluZywgb2xkTmFtZSwgbmV3TmFtZSkucmVuYW1lKGJsb2NrKTtcbiAgICB9XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLl9yZW5hbWVGcm9tTWFwID0gZnVuY3Rpb24gX3JlbmFtZUZyb21NYXAobWFwLCBvbGROYW1lLCBuZXdOYW1lLCB2YWx1ZSkge1xuICAgIGlmIChtYXBbb2xkTmFtZV0pIHtcbiAgICAgIG1hcFtuZXdOYW1lXSA9IHZhbHVlO1xuICAgICAgbWFwW29sZE5hbWVdID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiBkdW1wKCkge1xuICAgIHZhciBzZXAgPSAoMCwgX3JlcGVhdDIuZGVmYXVsdCkoXCItXCIsIDYwKTtcbiAgICBjb25zb2xlLmxvZyhzZXApO1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgY29uc29sZS5sb2coXCIjXCIsIHNjb3BlLmJsb2NrLnR5cGUpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzY29wZS5iaW5kaW5ncykge1xuICAgICAgICB2YXIgYmluZGluZyA9IHNjb3BlLmJpbmRpbmdzW25hbWVdO1xuICAgICAgICBjb25zb2xlLmxvZyhcIiAtXCIsIG5hbWUsIHtcbiAgICAgICAgICBjb25zdGFudDogYmluZGluZy5jb25zdGFudCxcbiAgICAgICAgICByZWZlcmVuY2VzOiBiaW5kaW5nLnJlZmVyZW5jZXMsXG4gICAgICAgICAgdmlvbGF0aW9uczogYmluZGluZy5jb25zdGFudFZpb2xhdGlvbnMubGVuZ3RoLFxuICAgICAgICAgIGtpbmQ6IGJpbmRpbmcua2luZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gICAgY29uc29sZS5sb2coc2VwKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkobm9kZSwgaSkge1xuICAgIHZhciBmaWxlID0gdGhpcy5odWIuZmlsZTtcblxuICAgIGlmICh0LmlzSWRlbnRpZmllcihub2RlKSkge1xuICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcobm9kZS5uYW1lKTtcbiAgICAgIGlmIChiaW5kaW5nICYmIGJpbmRpbmcuY29uc3RhbnQgJiYgYmluZGluZy5wYXRoLmlzR2VuZXJpY1R5cGUoXCJBcnJheVwiKSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNBcnJheUV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGlmICh0LmlzSWRlbnRpZmllcihub2RlLCB7IG5hbWU6IFwiYXJndW1lbnRzXCIgfSkpIHtcbiAgICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKHQubWVtYmVyRXhwcmVzc2lvbih0Lm1lbWJlckV4cHJlc3Npb24odC5tZW1iZXJFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcIkFycmF5XCIpLCB0LmlkZW50aWZpZXIoXCJwcm90b3R5cGVcIikpLCB0LmlkZW50aWZpZXIoXCJzbGljZVwiKSksIHQuaWRlbnRpZmllcihcImNhbGxcIikpLCBbbm9kZV0pO1xuICAgIH1cblxuICAgIHZhciBoZWxwZXJOYW1lID0gXCJ0b0FycmF5XCI7XG4gICAgdmFyIGFyZ3MgPSBbbm9kZV07XG4gICAgaWYgKGkgPT09IHRydWUpIHtcbiAgICAgIGhlbHBlck5hbWUgPSBcInRvQ29uc3VtYWJsZUFycmF5XCI7XG4gICAgfSBlbHNlIGlmIChpKSB7XG4gICAgICBhcmdzLnB1c2godC5udW1lcmljTGl0ZXJhbChpKSk7XG4gICAgICBoZWxwZXJOYW1lID0gXCJzbGljZWRUb0FycmF5XCI7XG4gICAgfVxuICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKGZpbGUuYWRkSGVscGVyKGhlbHBlck5hbWUpLCBhcmdzKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuaGFzTGFiZWwgPSBmdW5jdGlvbiBoYXNMYWJlbChuYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRMYWJlbChuYW1lKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiBnZXRMYWJlbChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubGFiZWxzLmdldChuYW1lKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUucmVnaXN0ZXJMYWJlbCA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGFiZWwocGF0aCkge1xuICAgIHRoaXMubGFiZWxzLnNldChwYXRoLm5vZGUubGFiZWwubmFtZSwgcGF0aCk7XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLnJlZ2lzdGVyRGVjbGFyYXRpb24gPSBmdW5jdGlvbiByZWdpc3RlckRlY2xhcmF0aW9uKHBhdGgpIHtcbiAgICBpZiAocGF0aC5pc0xhYmVsZWRTdGF0ZW1lbnQoKSkge1xuICAgICAgdGhpcy5yZWdpc3RlckxhYmVsKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSkge1xuICAgICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoXCJob2lzdGVkXCIsIHBhdGguZ2V0KFwiaWRcIiksIHBhdGgpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24oKSkge1xuICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHBhdGguZ2V0KFwiZGVjbGFyYXRpb25zXCIpO1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IGRlY2xhcmF0aW9ucywgX2lzQXJyYXk3ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I3KSwgX2k3ID0gMCwgX2l0ZXJhdG9yNyA9IF9pc0FycmF5NyA/IF9pdGVyYXRvcjcgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3I3KTs7KSB7XG4gICAgICAgIHZhciBfcmVmNztcblxuICAgICAgICBpZiAoX2lzQXJyYXk3KSB7XG4gICAgICAgICAgaWYgKF9pNyA+PSBfaXRlcmF0b3I3Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjcgPSBfaXRlcmF0b3I3W19pNysrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTcgPSBfaXRlcmF0b3I3Lm5leHQoKTtcbiAgICAgICAgICBpZiAoX2k3LmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWY3ID0gX2k3LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlY2xhciA9IF9yZWY3O1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKHBhdGgubm9kZS5raW5kLCBkZWNsYXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aC5pc0NsYXNzRGVjbGFyYXRpb24oKSkge1xuICAgICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoXCJsZXRcIiwgcGF0aCk7XG4gICAgfSBlbHNlIGlmIChwYXRoLmlzSW1wb3J0RGVjbGFyYXRpb24oKSkge1xuICAgICAgdmFyIHNwZWNpZmllcnMgPSBwYXRoLmdldChcInNwZWNpZmllcnNcIik7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3I4ID0gc3BlY2lmaWVycywgX2lzQXJyYXk4ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I4KSwgX2k4ID0gMCwgX2l0ZXJhdG9yOCA9IF9pc0FycmF5OCA/IF9pdGVyYXRvcjggOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3I4KTs7KSB7XG4gICAgICAgIHZhciBfcmVmODtcblxuICAgICAgICBpZiAoX2lzQXJyYXk4KSB7XG4gICAgICAgICAgaWYgKF9pOCA+PSBfaXRlcmF0b3I4Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjggPSBfaXRlcmF0b3I4W19pOCsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTggPSBfaXRlcmF0b3I4Lm5leHQoKTtcbiAgICAgICAgICBpZiAoX2k4LmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWY4ID0gX2k4LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwZWNpZmllciA9IF9yZWY4O1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwibW9kdWxlXCIsIHNwZWNpZmllcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXRoLmlzRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgICAgdmFyIF9kZWNsYXIgPSBwYXRoLmdldChcImRlY2xhcmF0aW9uXCIpO1xuICAgICAgaWYgKF9kZWNsYXIuaXNDbGFzc0RlY2xhcmF0aW9uKCkgfHwgX2RlY2xhci5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSB8fCBfZGVjbGFyLmlzVmFyaWFibGVEZWNsYXJhdGlvbigpKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJEZWNsYXJhdGlvbihfZGVjbGFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoXCJ1bmtub3duXCIsIHBhdGgpO1xuICAgIH1cbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuYnVpbGRVbmRlZmluZWROb2RlID0gZnVuY3Rpb24gYnVpbGRVbmRlZmluZWROb2RlKCkge1xuICAgIGlmICh0aGlzLmhhc0JpbmRpbmcoXCJ1bmRlZmluZWRcIikpIHtcbiAgICAgIHJldHVybiB0LnVuYXJ5RXhwcmVzc2lvbihcInZvaWRcIiwgdC5udW1lcmljTGl0ZXJhbCgwKSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0LmlkZW50aWZpZXIoXCJ1bmRlZmluZWRcIik7XG4gICAgfVxuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5yZWdpc3RlckNvbnN0YW50VmlvbGF0aW9uID0gZnVuY3Rpb24gcmVnaXN0ZXJDb25zdGFudFZpb2xhdGlvbihwYXRoKSB7XG4gICAgdmFyIGlkcyA9IHBhdGguZ2V0QmluZGluZ0lkZW50aWZpZXJzKCk7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBpZHMpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKG5hbWUpO1xuICAgICAgaWYgKGJpbmRpbmcpIGJpbmRpbmcucmVhc3NpZ24ocGF0aCk7XG4gICAgfVxuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5yZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbiByZWdpc3RlckJpbmRpbmcoa2luZCwgcGF0aCkge1xuICAgIHZhciBiaW5kaW5nUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogcGF0aDtcblxuICAgIGlmICgha2luZCkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwibm8gYGtpbmRgXCIpO1xuXG4gICAgaWYgKHBhdGguaXNWYXJpYWJsZURlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHZhciBkZWNsYXJhdG9ycyA9IHBhdGguZ2V0KFwiZGVjbGFyYXRpb25zXCIpO1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOSA9IGRlY2xhcmF0b3JzLCBfaXNBcnJheTkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjkpLCBfaTkgPSAwLCBfaXRlcmF0b3I5ID0gX2lzQXJyYXk5ID8gX2l0ZXJhdG9yOSA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjkpOzspIHtcbiAgICAgICAgdmFyIF9yZWY5O1xuXG4gICAgICAgIGlmIChfaXNBcnJheTkpIHtcbiAgICAgICAgICBpZiAoX2k5ID49IF9pdGVyYXRvcjkubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmOSA9IF9pdGVyYXRvcjlbX2k5KytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pOSA9IF9pdGVyYXRvcjkubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjkgPSBfaTkudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVjbGFyID0gX3JlZjk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoa2luZCwgZGVjbGFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQcm9ncmFtUGFyZW50KCk7XG4gICAgdmFyIGlkcyA9IHBhdGguZ2V0QmluZGluZ0lkZW50aWZpZXJzKHRydWUpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBpZHMpIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEwID0gaWRzW25hbWVdLCBfaXNBcnJheTEwID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IxMCksIF9pMTAgPSAwLCBfaXRlcmF0b3IxMCA9IF9pc0FycmF5MTAgPyBfaXRlcmF0b3IxMCA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjEwKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMTA7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5MTApIHtcbiAgICAgICAgICBpZiAoX2kxMCA+PSBfaXRlcmF0b3IxMC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYxMCA9IF9pdGVyYXRvcjEwW19pMTArK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kxMCA9IF9pdGVyYXRvcjEwLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kxMC5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMTAgPSBfaTEwLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9pZDMgPSBfcmVmMTA7XG5cbiAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5nZXRPd25CaW5kaW5nKG5hbWUpO1xuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICBpZiAobG9jYWwuaWRlbnRpZmllciA9PT0gX2lkMykgY29udGludWU7XG5cbiAgICAgICAgICB0aGlzLmNoZWNrQmxvY2tTY29wZWRDb2xsaXNpb25zKGxvY2FsLCBraW5kLCBuYW1lLCBfaWQzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2NhbCAmJiBsb2NhbC5wYXRoLmlzRmxvdygpKSBsb2NhbCA9IG51bGw7XG5cbiAgICAgICAgcGFyZW50LnJlZmVyZW5jZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuYmluZGluZ3NbbmFtZV0gPSBuZXcgX2JpbmRpbmczLmRlZmF1bHQoe1xuICAgICAgICAgIGlkZW50aWZpZXI6IF9pZDMsXG4gICAgICAgICAgZXhpc3Rpbmc6IGxvY2FsLFxuICAgICAgICAgIHNjb3BlOiB0aGlzLFxuICAgICAgICAgIHBhdGg6IGJpbmRpbmdQYXRoLFxuICAgICAgICAgIGtpbmQ6IGtpbmRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5hZGRHbG9iYWwgPSBmdW5jdGlvbiBhZGRHbG9iYWwobm9kZSkge1xuICAgIHRoaXMuZ2xvYmFsc1tub2RlLm5hbWVdID0gbm9kZTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuaGFzVWlkID0gZnVuY3Rpb24gaGFzVWlkKG5hbWUpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnVpZHNbbmFtZV0pIHJldHVybiB0cnVlO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuaGFzR2xvYmFsID0gZnVuY3Rpb24gaGFzR2xvYmFsKG5hbWUpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLmdsb2JhbHNbbmFtZV0pIHJldHVybiB0cnVlO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuaGFzUmVmZXJlbmNlID0gZnVuY3Rpb24gaGFzUmVmZXJlbmNlKG5hbWUpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnJlZmVyZW5jZXNbbmFtZV0pIHJldHVybiB0cnVlO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuaXNQdXJlID0gZnVuY3Rpb24gaXNQdXJlKG5vZGUsIGNvbnN0YW50c09ubHkpIHtcbiAgICBpZiAodC5pc0lkZW50aWZpZXIobm9kZSkpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKG5vZGUubmFtZSk7XG4gICAgICBpZiAoIWJpbmRpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChjb25zdGFudHNPbmx5KSByZXR1cm4gYmluZGluZy5jb25zdGFudDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodC5pc0NsYXNzKG5vZGUpKSB7XG4gICAgICBpZiAobm9kZS5zdXBlckNsYXNzICYmICF0aGlzLmlzUHVyZShub2RlLnN1cGVyQ2xhc3MsIGNvbnN0YW50c09ubHkpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5pc1B1cmUobm9kZS5ib2R5LCBjb25zdGFudHNPbmx5KTtcbiAgICB9IGVsc2UgaWYgKHQuaXNDbGFzc0JvZHkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjExID0gbm9kZS5ib2R5LCBfaXNBcnJheTExID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IxMSksIF9pMTEgPSAwLCBfaXRlcmF0b3IxMSA9IF9pc0FycmF5MTEgPyBfaXRlcmF0b3IxMSA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjExKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMTE7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5MTEpIHtcbiAgICAgICAgICBpZiAoX2kxMSA+PSBfaXRlcmF0b3IxMS5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYxMSA9IF9pdGVyYXRvcjExW19pMTErK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kxMSA9IF9pdGVyYXRvcjExLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kxMS5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMTEgPSBfaTExLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ldGhvZCA9IF9yZWYxMTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNQdXJlKG1ldGhvZCwgY29uc3RhbnRzT25seSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodC5pc0JpbmFyeShub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNQdXJlKG5vZGUubGVmdCwgY29uc3RhbnRzT25seSkgJiYgdGhpcy5pc1B1cmUobm9kZS5yaWdodCwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmICh0LmlzQXJyYXlFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMiA9IG5vZGUuZWxlbWVudHMsIF9pc0FycmF5MTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjEyKSwgX2kxMiA9IDAsIF9pdGVyYXRvcjEyID0gX2lzQXJyYXkxMiA/IF9pdGVyYXRvcjEyIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMTIpOzspIHtcbiAgICAgICAgdmFyIF9yZWYxMjtcblxuICAgICAgICBpZiAoX2lzQXJyYXkxMikge1xuICAgICAgICAgIGlmIChfaTEyID49IF9pdGVyYXRvcjEyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjEyID0gX2l0ZXJhdG9yMTJbX2kxMisrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTEyID0gX2l0ZXJhdG9yMTIubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTEyLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYxMiA9IF9pMTIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbSA9IF9yZWYxMjtcblxuICAgICAgICBpZiAoIXRoaXMuaXNQdXJlKGVsZW0sIGNvbnN0YW50c09ubHkpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHQuaXNPYmplY3RFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMyA9IG5vZGUucHJvcGVydGllcywgX2lzQXJyYXkxMyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMTMpLCBfaTEzID0gMCwgX2l0ZXJhdG9yMTMgPSBfaXNBcnJheTEzID8gX2l0ZXJhdG9yMTMgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IxMyk7Oykge1xuICAgICAgICB2YXIgX3JlZjEzO1xuXG4gICAgICAgIGlmIChfaXNBcnJheTEzKSB7XG4gICAgICAgICAgaWYgKF9pMTMgPj0gX2l0ZXJhdG9yMTMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmMTMgPSBfaXRlcmF0b3IxM1tfaTEzKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMTMgPSBfaXRlcmF0b3IxMy5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMTMuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjEzID0gX2kxMy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wID0gX3JlZjEzO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1B1cmUocHJvcCwgY29uc3RhbnRzT25seSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodC5pc0NsYXNzTWV0aG9kKG5vZGUpKSB7XG4gICAgICBpZiAobm9kZS5jb21wdXRlZCAmJiAhdGhpcy5pc1B1cmUobm9kZS5rZXksIGNvbnN0YW50c09ubHkpKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAobm9kZS5raW5kID09PSBcImdldFwiIHx8IG5vZGUua2luZCA9PT0gXCJzZXRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0LmlzQ2xhc3NQcm9wZXJ0eShub2RlKSB8fCB0LmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIGlmIChub2RlLmNvbXB1dGVkICYmICF0aGlzLmlzUHVyZShub2RlLmtleSwgY29uc3RhbnRzT25seSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLmlzUHVyZShub2RlLnZhbHVlLCBjb25zdGFudHNPbmx5KTtcbiAgICB9IGVsc2UgaWYgKHQuaXNVbmFyeUV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzUHVyZShub2RlLmFyZ3VtZW50LCBjb25zdGFudHNPbmx5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHQuaXNQdXJlaXNoKG5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEoa2V5LCB2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV0gPSB2YWw7XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhKGtleSkge1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgdmFyIGRhdGEgPSBzY29wZS5kYXRhW2tleV07XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSByZXR1cm4gZGF0YTtcbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLnJlbW92ZURhdGEgPSBmdW5jdGlvbiByZW1vdmVEYXRhKGtleSkge1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgdmFyIGRhdGEgPSBzY29wZS5kYXRhW2tleV07XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSBzY29wZS5kYXRhW2tleV0gPSBudWxsO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLnJlZmVyZW5jZXMpIHRoaXMuY3Jhd2woKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuY3Jhd2wgPSBmdW5jdGlvbiBjcmF3bCgpIHtcbiAgICBfY3Jhd2xDYWxsc0NvdW50Kys7XG4gICAgdGhpcy5fY3Jhd2woKTtcbiAgICBfY3Jhd2xDYWxsc0NvdW50LS07XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLl9jcmF3bCA9IGZ1bmN0aW9uIF9jcmF3bCgpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgIHRoaXMucmVmZXJlbmNlcyA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShudWxsKTtcbiAgICB0aGlzLmJpbmRpbmdzID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKG51bGwpO1xuICAgIHRoaXMuZ2xvYmFscyA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShudWxsKTtcbiAgICB0aGlzLnVpZHMgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkobnVsbCk7XG4gICAgdGhpcy5kYXRhID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKG51bGwpO1xuXG4gICAgaWYgKHBhdGguaXNMb29wKCkpIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjE0ID0gdC5GT1JfSU5JVF9LRVlTLCBfaXNBcnJheTE0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IxNCksIF9pMTQgPSAwLCBfaXRlcmF0b3IxNCA9IF9pc0FycmF5MTQgPyBfaXRlcmF0b3IxNCA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjE0KTs7KSB7XG4gICAgICAgIHZhciBfcmVmMTQ7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5MTQpIHtcbiAgICAgICAgICBpZiAoX2kxNCA+PSBfaXRlcmF0b3IxNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYxNCA9IF9pdGVyYXRvcjE0W19pMTQrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kxNCA9IF9pdGVyYXRvcjE0Lm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kxNC5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMTQgPSBfaTE0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IF9yZWYxNDtcblxuICAgICAgICB2YXIgbm9kZSA9IHBhdGguZ2V0KGtleSk7XG4gICAgICAgIGlmIChub2RlLmlzQmxvY2tTY29wZWQoKSkgdGhpcy5yZWdpc3RlckJpbmRpbmcobm9kZS5ub2RlLmtpbmQsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXRoLmlzRnVuY3Rpb25FeHByZXNzaW9uKCkgJiYgcGF0aC5oYXMoXCJpZFwiKSkge1xuICAgICAgaWYgKCFwYXRoLmdldChcImlkXCIpLm5vZGVbdC5OT1RfTE9DQUxfQklORElOR10pIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoXCJsb2NhbFwiLCBwYXRoLmdldChcImlkXCIpLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc0NsYXNzRXhwcmVzc2lvbigpICYmIHBhdGguaGFzKFwiaWRcIikpIHtcbiAgICAgIGlmICghcGF0aC5nZXQoXCJpZFwiKS5ub2RlW3QuTk9UX0xPQ0FMX0JJTkRJTkddKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwibG9jYWxcIiwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGguaXNGdW5jdGlvbigpKSB7XG4gICAgICB2YXIgcGFyYW1zID0gcGF0aC5nZXQoXCJwYXJhbXNcIik7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxNSA9IHBhcmFtcywgX2lzQXJyYXkxNSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMTUpLCBfaTE1ID0gMCwgX2l0ZXJhdG9yMTUgPSBfaXNBcnJheTE1ID8gX2l0ZXJhdG9yMTUgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IxNSk7Oykge1xuICAgICAgICB2YXIgX3JlZjE1O1xuXG4gICAgICAgIGlmIChfaXNBcnJheTE1KSB7XG4gICAgICAgICAgaWYgKF9pMTUgPj0gX2l0ZXJhdG9yMTUubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmMTUgPSBfaXRlcmF0b3IxNVtfaTE1KytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMTUgPSBfaXRlcmF0b3IxNS5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMTUuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjE1ID0gX2kxNS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJhbSA9IF9yZWYxNTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyQmluZGluZyhcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc0NhdGNoQ2xhdXNlKCkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwibGV0XCIsIHBhdGgpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFByb2dyYW1QYXJlbnQoKTtcbiAgICBpZiAocGFyZW50LmNyYXdsaW5nKSByZXR1cm47XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgIGNvbnN0YW50VmlvbGF0aW9uczogW10sXG4gICAgICBhc3NpZ25tZW50czogW11cbiAgICB9O1xuXG4gICAgdGhpcy5jcmF3bGluZyA9IHRydWU7XG4gICAgcGF0aC50cmF2ZXJzZShjb2xsZWN0b3JWaXNpdG9yLCBzdGF0ZSk7XG4gICAgdGhpcy5jcmF3bGluZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMTYgPSBzdGF0ZS5hc3NpZ25tZW50cywgX2lzQXJyYXkxNiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMTYpLCBfaTE2ID0gMCwgX2l0ZXJhdG9yMTYgPSBfaXNBcnJheTE2ID8gX2l0ZXJhdG9yMTYgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IxNik7Oykge1xuICAgICAgdmFyIF9yZWYxNjtcblxuICAgICAgaWYgKF9pc0FycmF5MTYpIHtcbiAgICAgICAgaWYgKF9pMTYgPj0gX2l0ZXJhdG9yMTYubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjE2ID0gX2l0ZXJhdG9yMTZbX2kxNisrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pMTYgPSBfaXRlcmF0b3IxNi5uZXh0KCk7XG4gICAgICAgIGlmIChfaTE2LmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmMTYgPSBfaTE2LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3BhdGggPSBfcmVmMTY7XG5cbiAgICAgIHZhciBpZHMgPSBfcGF0aC5nZXRCaW5kaW5nSWRlbnRpZmllcnMoKTtcbiAgICAgIHZhciBwcm9ncmFtUGFyZW50ID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBpZHMpIHtcbiAgICAgICAgaWYgKF9wYXRoLnNjb3BlLmdldEJpbmRpbmcobmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHByb2dyYW1QYXJlbnQgPSBwcm9ncmFtUGFyZW50IHx8IF9wYXRoLnNjb3BlLmdldFByb2dyYW1QYXJlbnQoKTtcbiAgICAgICAgcHJvZ3JhbVBhcmVudC5hZGRHbG9iYWwoaWRzW25hbWVdKTtcbiAgICAgIH1cblxuICAgICAgX3BhdGguc2NvcGUucmVnaXN0ZXJDb25zdGFudFZpb2xhdGlvbihfcGF0aCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMTcgPSBzdGF0ZS5yZWZlcmVuY2VzLCBfaXNBcnJheTE3ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IxNyksIF9pMTcgPSAwLCBfaXRlcmF0b3IxNyA9IF9pc0FycmF5MTcgPyBfaXRlcmF0b3IxNyA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjE3KTs7KSB7XG4gICAgICB2YXIgX3JlZjE3O1xuXG4gICAgICBpZiAoX2lzQXJyYXkxNykge1xuICAgICAgICBpZiAoX2kxNyA+PSBfaXRlcmF0b3IxNy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmMTcgPSBfaXRlcmF0b3IxN1tfaTE3KytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kxNyA9IF9pdGVyYXRvcjE3Lm5leHQoKTtcbiAgICAgICAgaWYgKF9pMTcuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYxNyA9IF9pMTcudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBfcmVmMTc7XG5cbiAgICAgIHZhciBiaW5kaW5nID0gcmVmLnNjb3BlLmdldEJpbmRpbmcocmVmLm5vZGUubmFtZSk7XG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICBiaW5kaW5nLnJlZmVyZW5jZShyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmLnNjb3BlLmdldFByb2dyYW1QYXJlbnQoKS5hZGRHbG9iYWwocmVmLm5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pdGVyYXRvcjE4ID0gc3RhdGUuY29uc3RhbnRWaW9sYXRpb25zLCBfaXNBcnJheTE4ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IxOCksIF9pMTggPSAwLCBfaXRlcmF0b3IxOCA9IF9pc0FycmF5MTggPyBfaXRlcmF0b3IxOCA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjE4KTs7KSB7XG4gICAgICB2YXIgX3JlZjE4O1xuXG4gICAgICBpZiAoX2lzQXJyYXkxOCkge1xuICAgICAgICBpZiAoX2kxOCA+PSBfaXRlcmF0b3IxOC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmMTggPSBfaXRlcmF0b3IxOFtfaTE4KytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kxOCA9IF9pdGVyYXRvcjE4Lm5leHQoKTtcbiAgICAgICAgaWYgKF9pMTguZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYxOCA9IF9pMTgudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcGF0aDIgPSBfcmVmMTg7XG5cbiAgICAgIF9wYXRoMi5zY29wZS5yZWdpc3RlckNvbnN0YW50VmlvbGF0aW9uKF9wYXRoMik7XG4gICAgfVxuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaChvcHRzKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICBpZiAoIXBhdGguaXNCbG9ja1N0YXRlbWVudCgpICYmICFwYXRoLmlzUHJvZ3JhbSgpKSB7XG4gICAgICBwYXRoID0gdGhpcy5nZXRCbG9ja1BhcmVudCgpLnBhdGg7XG4gICAgfVxuXG4gICAgaWYgKHBhdGguaXNTd2l0Y2hTdGF0ZW1lbnQoKSkge1xuICAgICAgcGF0aCA9IHRoaXMuZ2V0RnVuY3Rpb25QYXJlbnQoKS5wYXRoO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmlzTG9vcCgpIHx8IHBhdGguaXNDYXRjaENsYXVzZSgpIHx8IHBhdGguaXNGdW5jdGlvbigpKSB7XG4gICAgICB0LmVuc3VyZUJsb2NrKHBhdGgubm9kZSk7XG4gICAgICBwYXRoID0gcGF0aC5nZXQoXCJib2R5XCIpO1xuICAgIH1cblxuICAgIHZhciB1bmlxdWUgPSBvcHRzLnVuaXF1ZTtcbiAgICB2YXIga2luZCA9IG9wdHMua2luZCB8fCBcInZhclwiO1xuICAgIHZhciBibG9ja0hvaXN0ID0gb3B0cy5fYmxvY2tIb2lzdCA9PSBudWxsID8gMiA6IG9wdHMuX2Jsb2NrSG9pc3Q7XG5cbiAgICB2YXIgZGF0YUtleSA9IFwiZGVjbGFyYXRpb246XCIgKyBraW5kICsgXCI6XCIgKyBibG9ja0hvaXN0O1xuICAgIHZhciBkZWNsYXJQYXRoID0gIXVuaXF1ZSAmJiBwYXRoLmdldERhdGEoZGF0YUtleSk7XG5cbiAgICBpZiAoIWRlY2xhclBhdGgpIHtcbiAgICAgIHZhciBkZWNsYXIgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oa2luZCwgW10pO1xuICAgICAgZGVjbGFyLl9nZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgZGVjbGFyLl9ibG9ja0hvaXN0ID0gYmxvY2tIb2lzdDtcblxuICAgICAgdmFyIF9wYXRoJHVuc2hpZnRDb250YWluZSA9IHBhdGgudW5zaGlmdENvbnRhaW5lcihcImJvZHlcIiwgW2RlY2xhcl0pO1xuXG4gICAgICBkZWNsYXJQYXRoID0gX3BhdGgkdW5zaGlmdENvbnRhaW5lWzBdO1xuXG4gICAgICBpZiAoIXVuaXF1ZSkgcGF0aC5zZXREYXRhKGRhdGFLZXksIGRlY2xhclBhdGgpO1xuICAgIH1cblxuICAgIHZhciBkZWNsYXJhdG9yID0gdC52YXJpYWJsZURlY2xhcmF0b3Iob3B0cy5pZCwgb3B0cy5pbml0KTtcbiAgICBkZWNsYXJQYXRoLm5vZGUuZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRvcik7XG4gICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoa2luZCwgZGVjbGFyUGF0aC5nZXQoXCJkZWNsYXJhdGlvbnNcIikucG9wKCkpO1xuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5nZXRQcm9ncmFtUGFyZW50ID0gZnVuY3Rpb24gZ2V0UHJvZ3JhbVBhcmVudCgpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGlmIChzY29wZS5wYXRoLmlzUHJvZ3JhbSgpKSB7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2UgY291bGRuJ3QgZmluZCBhIEZ1bmN0aW9uIG9yIFByb2dyYW0uLi5cIik7XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLmdldEZ1bmN0aW9uUGFyZW50ID0gZnVuY3Rpb24gZ2V0RnVuY3Rpb25QYXJlbnQoKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAoc2NvcGUucGF0aC5pc0Z1bmN0aW9uUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBjb3VsZG4ndCBmaW5kIGEgRnVuY3Rpb24gb3IgUHJvZ3JhbS4uLlwiKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuZ2V0QmxvY2tQYXJlbnQgPSBmdW5jdGlvbiBnZXRCbG9ja1BhcmVudCgpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGlmIChzY29wZS5wYXRoLmlzQmxvY2tQYXJlbnQoKSkge1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoc2NvcGUgPSBzY29wZS5wYXJlbnQpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIldlIGNvdWxkbid0IGZpbmQgYSBCbG9ja1N0YXRlbWVudCwgRm9yLCBTd2l0Y2gsIEZ1bmN0aW9uLCBMb29wIG9yIFByb2dyYW0uLi5cIik7XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLmdldEFsbEJpbmRpbmdzID0gZnVuY3Rpb24gZ2V0QWxsQmluZGluZ3MoKSB7XG4gICAgdmFyIGlkcyA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShudWxsKTtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgKDAsIF9kZWZhdWx0czIuZGVmYXVsdCkoaWRzLCBzY29wZS5iaW5kaW5ncyk7XG4gICAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICB9IHdoaWxlIChzY29wZSk7XG5cbiAgICByZXR1cm4gaWRzO1xuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5nZXRBbGxCaW5kaW5nc09mS2luZCA9IGZ1bmN0aW9uIGdldEFsbEJpbmRpbmdzT2ZLaW5kKCkge1xuICAgIHZhciBpZHMgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkobnVsbCk7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IxOSA9IGFyZ3VtZW50cywgX2lzQXJyYXkxOSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMTkpLCBfaTE5ID0gMCwgX2l0ZXJhdG9yMTkgPSBfaXNBcnJheTE5ID8gX2l0ZXJhdG9yMTkgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IxOSk7Oykge1xuICAgICAgdmFyIF9yZWYxOTtcblxuICAgICAgaWYgKF9pc0FycmF5MTkpIHtcbiAgICAgICAgaWYgKF9pMTkgPj0gX2l0ZXJhdG9yMTkubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjE5ID0gX2l0ZXJhdG9yMTlbX2kxOSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pMTkgPSBfaXRlcmF0b3IxOS5uZXh0KCk7XG4gICAgICAgIGlmIChfaTE5LmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmMTkgPSBfaTE5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIga2luZCA9IF9yZWYxOTtcblxuICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzY29wZS5iaW5kaW5ncykge1xuICAgICAgICAgIHZhciBiaW5kaW5nID0gc2NvcGUuYmluZGluZ3NbbmFtZV07XG4gICAgICAgICAgaWYgKGJpbmRpbmcua2luZCA9PT0ga2luZCkgaWRzW25hbWVdID0gYmluZGluZztcbiAgICAgICAgfVxuICAgICAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICAgIH0gd2hpbGUgKHNjb3BlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRzO1xuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5iaW5kaW5nSWRlbnRpZmllckVxdWFscyA9IGZ1bmN0aW9uIGJpbmRpbmdJZGVudGlmaWVyRXF1YWxzKG5hbWUsIG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCaW5kaW5nSWRlbnRpZmllcihuYW1lKSA9PT0gbm9kZTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUud2Fybk9uRmxvd0JpbmRpbmcgPSBmdW5jdGlvbiB3YXJuT25GbG93QmluZGluZyhiaW5kaW5nKSB7XG4gICAgaWYgKF9jcmF3bENhbGxzQ291bnQgPT09IDAgJiYgYmluZGluZyAmJiBiaW5kaW5nLnBhdGguaXNGbG93KCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlxcbiAgICAgICAgWW91IG9yIG9uZSBvZiB0aGUgQmFiZWwgcGx1Z2lucyB5b3UgYXJlIHVzaW5nIGFyZSB1c2luZyBGbG93IGRlY2xhcmF0aW9ucyBhcyBiaW5kaW5ncy5cXG4gICAgICAgIFN1cHBvcnQgZm9yIHRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gNy4gVG8gZmluZCBvdXQgdGhlIGNhbGxlciwgZ3JlcCBmb3IgdGhpc1xcbiAgICAgICAgbWVzc2FnZSBhbmQgY2hhbmdlIGl0IHRvIGEgYGNvbnNvbGUudHJhY2UoKWAuXFxuICAgICAgXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmluZGluZztcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuZ2V0QmluZGluZyA9IGZ1bmN0aW9uIGdldEJpbmRpbmcobmFtZSkge1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgYmluZGluZyA9IHNjb3BlLmdldE93bkJpbmRpbmcobmFtZSk7XG4gICAgICBpZiAoYmluZGluZykgcmV0dXJuIHRoaXMud2Fybk9uRmxvd0JpbmRpbmcoYmluZGluZyk7XG4gICAgfSB3aGlsZSAoc2NvcGUgPSBzY29wZS5wYXJlbnQpO1xuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5nZXRPd25CaW5kaW5nID0gZnVuY3Rpb24gZ2V0T3duQmluZGluZyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMud2Fybk9uRmxvd0JpbmRpbmcodGhpcy5iaW5kaW5nc1tuYW1lXSk7XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLmdldEJpbmRpbmdJZGVudGlmaWVyID0gZnVuY3Rpb24gZ2V0QmluZGluZ0lkZW50aWZpZXIobmFtZSkge1xuICAgIHZhciBpbmZvID0gdGhpcy5nZXRCaW5kaW5nKG5hbWUpO1xuICAgIHJldHVybiBpbmZvICYmIGluZm8uaWRlbnRpZmllcjtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuZ2V0T3duQmluZGluZ0lkZW50aWZpZXIgPSBmdW5jdGlvbiBnZXRPd25CaW5kaW5nSWRlbnRpZmllcihuYW1lKSB7XG4gICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgIHJldHVybiBiaW5kaW5nICYmIGJpbmRpbmcuaWRlbnRpZmllcjtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuaGFzT3duQmluZGluZyA9IGZ1bmN0aW9uIGhhc093bkJpbmRpbmcobmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0T3duQmluZGluZyhuYW1lKTtcbiAgfTtcblxuICBTY29wZS5wcm90b3R5cGUuaGFzQmluZGluZyA9IGZ1bmN0aW9uIGhhc0JpbmRpbmcobmFtZSwgbm9HbG9iYWxzKSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaGFzT3duQmluZGluZyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMucGFyZW50SGFzQmluZGluZyhuYW1lLCBub0dsb2JhbHMpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5oYXNVaWQobmFtZSkpIHJldHVybiB0cnVlO1xuICAgIGlmICghbm9HbG9iYWxzICYmICgwLCBfaW5jbHVkZXMyLmRlZmF1bHQpKFNjb3BlLmdsb2JhbHMsIG5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIW5vR2xvYmFscyAmJiAoMCwgX2luY2x1ZGVzMi5kZWZhdWx0KShTY29wZS5jb250ZXh0VmFyaWFibGVzLCBuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5wYXJlbnRIYXNCaW5kaW5nID0gZnVuY3Rpb24gcGFyZW50SGFzQmluZGluZyhuYW1lLCBub0dsb2JhbHMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaGFzQmluZGluZyhuYW1lLCBub0dsb2JhbHMpO1xuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5tb3ZlQmluZGluZ1RvID0gZnVuY3Rpb24gbW92ZUJpbmRpbmdUbyhuYW1lLCBzY29wZSkge1xuICAgIHZhciBpbmZvID0gdGhpcy5nZXRCaW5kaW5nKG5hbWUpO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLnNjb3BlLnJlbW92ZU93bkJpbmRpbmcobmFtZSk7XG4gICAgICBpbmZvLnNjb3BlID0gc2NvcGU7XG4gICAgICBzY29wZS5iaW5kaW5nc1tuYW1lXSA9IGluZm87XG4gICAgfVxuICB9O1xuXG4gIFNjb3BlLnByb3RvdHlwZS5yZW1vdmVPd25CaW5kaW5nID0gZnVuY3Rpb24gcmVtb3ZlT3duQmluZGluZyhuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbbmFtZV07XG4gIH07XG5cbiAgU2NvcGUucHJvdG90eXBlLnJlbW92ZUJpbmRpbmcgPSBmdW5jdGlvbiByZW1vdmVCaW5kaW5nKG5hbWUpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0QmluZGluZyhuYW1lKTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5zY29wZS5yZW1vdmVPd25CaW5kaW5nKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnVpZHNbbmFtZV0pIHtcbiAgICAgICAgc2NvcGUudWlkc1tuYW1lXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgfTtcblxuICByZXR1cm4gU2NvcGU7XG59KCk7XG5cblNjb3BlLmdsb2JhbHMgPSAoMCwgX2tleXMyLmRlZmF1bHQpKF9nbG9iYWxzMi5kZWZhdWx0LmJ1aWx0aW4pO1xuU2NvcGUuY29udGV4dFZhcmlhYmxlcyA9IFtcImFyZ3VtZW50c1wiLCBcInVuZGVmaW5lZFwiLCBcIkluZmluaXR5XCIsIFwiTmFOXCJdO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2NvcGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9zY29wZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgaWYgKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FLCAnX2MnKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlKCk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIGVhY2goJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTicuc3BsaXQoJywnKSwgZnVuY3Rpb24gKEtFWSkge1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmIChLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSkgaGlkZShDLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmICghSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkpIHJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgSVNfV0VBSyB8fCBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Muc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgQSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgQSA9IFtdO1xuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKSxcbiAgICB2YWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5jbHVkZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2luY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2FycmF5TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9faXNLZXkuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQXJyYXlQYXR0ZXJuID0gZXhwb3J0cy5PYmplY3RQYXR0ZXJuID0gZXhwb3J0cy5SZXN0UHJvcGVydHkgPSBleHBvcnRzLlNwcmVhZFByb3BlcnR5ID0gZXhwb3J0cy5TcHJlYWRFbGVtZW50ID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5JZGVudGlmaWVyID0gSWRlbnRpZmllcjtcbmV4cG9ydHMuUmVzdEVsZW1lbnQgPSBSZXN0RWxlbWVudDtcbmV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IE9iamVjdEV4cHJlc3Npb247XG5leHBvcnRzLk9iamVjdE1ldGhvZCA9IE9iamVjdE1ldGhvZDtcbmV4cG9ydHMuT2JqZWN0UHJvcGVydHkgPSBPYmplY3RQcm9wZXJ0eTtcbmV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gQXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5SZWdFeHBMaXRlcmFsID0gUmVnRXhwTGl0ZXJhbDtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWwgPSBCb29sZWFuTGl0ZXJhbDtcbmV4cG9ydHMuTnVsbExpdGVyYWwgPSBOdWxsTGl0ZXJhbDtcbmV4cG9ydHMuTnVtZXJpY0xpdGVyYWwgPSBOdW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuU3RyaW5nTGl0ZXJhbCA9IFN0cmluZ0xpdGVyYWw7XG5cbnZhciBfYmFiZWxUeXBlcyA9IHJlcXVpcmUoXCJiYWJlbC10eXBlc1wiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYmFiZWxUeXBlcyk7XG5cbnZhciBfanNlc2MgPSByZXF1aXJlKFwianNlc2NcIik7XG5cbnZhciBfanNlc2MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNlc2MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBJZGVudGlmaWVyKG5vZGUpIHtcbiAgaWYgKG5vZGUudmFyaWFuY2UpIHtcbiAgICBpZiAobm9kZS52YXJpYW5jZSA9PT0gXCJwbHVzXCIpIHtcbiAgICAgIHRoaXMudG9rZW4oXCIrXCIpO1xuICAgIH0gZWxzZSBpZiAobm9kZS52YXJpYW5jZSA9PT0gXCJtaW51c1wiKSB7XG4gICAgICB0aGlzLnRva2VuKFwiLVwiKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLndvcmQobm9kZS5uYW1lKTtcbn1cblxuZnVuY3Rpb24gUmVzdEVsZW1lbnQobm9kZSkge1xuICB0aGlzLnRva2VuKFwiLi4uXCIpO1xuICB0aGlzLnByaW50KG5vZGUuYXJndW1lbnQsIG5vZGUpO1xufVxuXG5leHBvcnRzLlNwcmVhZEVsZW1lbnQgPSBSZXN0RWxlbWVudDtcbmV4cG9ydHMuU3ByZWFkUHJvcGVydHkgPSBSZXN0RWxlbWVudDtcbmV4cG9ydHMuUmVzdFByb3BlcnR5ID0gUmVzdEVsZW1lbnQ7XG5mdW5jdGlvbiBPYmplY3RFeHByZXNzaW9uKG5vZGUpIHtcbiAgdmFyIHByb3BzID0gbm9kZS5wcm9wZXJ0aWVzO1xuXG4gIHRoaXMudG9rZW4oXCJ7XCIpO1xuICB0aGlzLnByaW50SW5uZXJDb21tZW50cyhub2RlKTtcblxuICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRMaXN0KHByb3BzLCBub2RlLCB7IGluZGVudDogdHJ1ZSwgc3RhdGVtZW50OiB0cnVlIH0pO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuXG4gIHRoaXMudG9rZW4oXCJ9XCIpO1xufVxuXG5leHBvcnRzLk9iamVjdFBhdHRlcm4gPSBPYmplY3RFeHByZXNzaW9uO1xuZnVuY3Rpb24gT2JqZWN0TWV0aG9kKG5vZGUpIHtcbiAgdGhpcy5wcmludEpvaW4obm9kZS5kZWNvcmF0b3JzLCBub2RlKTtcbiAgdGhpcy5fbWV0aG9kKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBPYmplY3RQcm9wZXJ0eShub2RlKSB7XG4gIHRoaXMucHJpbnRKb2luKG5vZGUuZGVjb3JhdG9ycywgbm9kZSk7XG5cbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICB0aGlzLnRva2VuKFwiW1wiKTtcbiAgICB0aGlzLnByaW50KG5vZGUua2V5LCBub2RlKTtcbiAgICB0aGlzLnRva2VuKFwiXVwiKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodC5pc0Fzc2lnbm1lbnRQYXR0ZXJuKG5vZGUudmFsdWUpICYmIHQuaXNJZGVudGlmaWVyKG5vZGUua2V5KSAmJiBub2RlLmtleS5uYW1lID09PSBub2RlLnZhbHVlLmxlZnQubmFtZSkge1xuICAgICAgdGhpcy5wcmludChub2RlLnZhbHVlLCBub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByaW50KG5vZGUua2V5LCBub2RlKTtcblxuICAgIGlmIChub2RlLnNob3J0aGFuZCAmJiB0LmlzSWRlbnRpZmllcihub2RlLmtleSkgJiYgdC5pc0lkZW50aWZpZXIobm9kZS52YWx1ZSkgJiYgbm9kZS5rZXkubmFtZSA9PT0gbm9kZS52YWx1ZS5uYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgdGhpcy50b2tlbihcIjpcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLnZhbHVlLCBub2RlKTtcbn1cblxuZnVuY3Rpb24gQXJyYXlFeHByZXNzaW9uKG5vZGUpIHtcbiAgdmFyIGVsZW1zID0gbm9kZS5lbGVtZW50cztcbiAgdmFyIGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuICB0aGlzLnRva2VuKFwiW1wiKTtcbiAgdGhpcy5wcmludElubmVyQ29tbWVudHMobm9kZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGVtID0gZWxlbXNbaV07XG4gICAgaWYgKGVsZW0pIHtcbiAgICAgIGlmIChpID4gMCkgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy5wcmludChlbGVtLCBub2RlKTtcbiAgICAgIGlmIChpIDwgbGVuIC0gMSkgdGhpcy50b2tlbihcIixcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9rZW4oXCIsXCIpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudG9rZW4oXCJdXCIpO1xufVxuXG5leHBvcnRzLkFycmF5UGF0dGVybiA9IEFycmF5RXhwcmVzc2lvbjtcbmZ1bmN0aW9uIFJlZ0V4cExpdGVyYWwobm9kZSkge1xuICB0aGlzLndvcmQoXCIvXCIgKyBub2RlLnBhdHRlcm4gKyBcIi9cIiArIG5vZGUuZmxhZ3MpO1xufVxuXG5mdW5jdGlvbiBCb29sZWFuTGl0ZXJhbChub2RlKSB7XG4gIHRoaXMud29yZChub2RlLnZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xufVxuXG5mdW5jdGlvbiBOdWxsTGl0ZXJhbCgpIHtcbiAgdGhpcy53b3JkKFwibnVsbFwiKTtcbn1cblxuZnVuY3Rpb24gTnVtZXJpY0xpdGVyYWwobm9kZSkge1xuICB2YXIgcmF3ID0gdGhpcy5nZXRQb3NzaWJsZVJhdyhub2RlKTtcbiAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSArIFwiXCI7XG4gIGlmIChyYXcgPT0gbnVsbCkge1xuICAgIHRoaXMubnVtYmVyKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0aGlzLmZvcm1hdC5taW5pZmllZCkge1xuICAgIHRoaXMubnVtYmVyKHJhdy5sZW5ndGggPCB2YWx1ZS5sZW5ndGggPyByYXcgOiB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5udW1iZXIocmF3KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBTdHJpbmdMaXRlcmFsKG5vZGUsIHBhcmVudCkge1xuICB2YXIgcmF3ID0gdGhpcy5nZXRQb3NzaWJsZVJhdyhub2RlKTtcbiAgaWYgKCF0aGlzLmZvcm1hdC5taW5pZmllZCAmJiByYXcgIT0gbnVsbCkge1xuICAgIHRoaXMudG9rZW4ocmF3KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3B0cyA9IHtcbiAgICBxdW90ZXM6IHQuaXNKU1gocGFyZW50KSA/IFwiZG91YmxlXCIgOiB0aGlzLmZvcm1hdC5xdW90ZXMsXG4gICAgd3JhcDogdHJ1ZVxuICB9O1xuICBpZiAodGhpcy5mb3JtYXQuanNvbkNvbXBhdGlibGVTdHJpbmdzKSB7XG4gICAgb3B0cy5qc29uID0gdHJ1ZTtcbiAgfVxuICB2YXIgdmFsID0gKDAsIF9qc2VzYzIuZGVmYXVsdCkobm9kZS52YWx1ZSwgb3B0cyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4odmFsKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL3R5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgZW5jcnlwdENvZGUgIH0gZnJvbSAnLi9lbmNyeXB0JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnXHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCdcclxuaW1wb3J0ICogYXMgcG9zdGh0bWwgZnJvbSAncG9zdGh0bWwnXHJcbmltcG9ydCAqIGFzIHBhcnNlciBmcm9tICdwb3N0aHRtbC1wYXJzZXInXHJcbmltcG9ydCAqIGFzIHJlbmRlciBmcm9tICdwb3N0aHRtbC1yZW5kZXInXHJcbmxldCB3YWxrID0gcmVxdWlyZSgncG9zdGh0bWwvbGliL2FwaScpLndhbGtcclxubGV0IG1hdGNoID0gcmVxdWlyZSgncG9zdGh0bWwvbGliL2FwaScpLm1hdGNoXHJcblxyXG5cclxuZXhwb3J0e2VuY3J5cHRDb2RlLHBvc3RodG1sLHBhcnNlcixyZW5kZXIsd2FsayxtYXRjaH1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5RmlsZShJTjpzdHJpbmcgLCBPVVQ6c3RyaW5nKXtcclxuXHJcbiAgICB2YXIgcnMgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKElOKTtcclxuICAgIHZhciB3cyA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKE9VVCk7XHJcbiAgICBycy5waXBlKHdzKTtcclxuICAgIFxyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUZpbGUodGV4dDpzdHJpbmcgLCBPVVQ6c3RyaW5nKXtcclxuXHJcbiAgICAvL2ZzLndyaXRlRmlsZVN5bmMoT1VULHRleHQpO1xyXG4gICAgZnMud3JpdGVGaWxlKE9VVCx0ZXh0LCgpPT57XHJcbiAgICAgICAvLyBjb25zb2xlLmxvZyhwcm9jZXNzLnVwdGltZSgpKVxyXG4gICAgfSlcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB3cml0ZSh0ZXh0OnN0cmluZyAsIE9VVDpzdHJpbmcpOmJvb2xlYW57XHJcbiAgICB0cnl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhPVVQsdGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVhZCggSU46c3RyaW5nKTpzdHJpbmd7XHJcbiAgICB0cnl7XHJcbiAgICAgICAgbGV0IFR4dCA9IGZzLnJlYWRGaWxlU3luYyhJTixcInV0Zi04XCIpO1xyXG4gICAgICAgIHJldHVybiBUeHQ7XHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRmlsZU5hbWUoIG5hbWU6c3RyaW5nICk6Ym9vbGVhbntcclxuICAgIHJldHVybiAhbmV3IFJlZ0V4cChcIltcXFxcdTRlMDAtXFxcXHU5ZmE1XVwiKS50ZXN0KG5hbWUpO1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnRyaWVzIChvYmopIHtcclxuICAgIGxldCBhcnIgPSBbXTtcclxuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XHJcbiAgICAgIGFyci5wdXNoKFtrZXksIG9ialtrZXldXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9Ub29scy50cyIsInZhciBUb2tlbml6ZXIgPSByZXF1aXJlKFwiLi9Ub2tlbml6ZXIuanNcIik7XG5cbi8qXG5cdE9wdGlvbnM6XG5cblx0eG1sTW9kZTogRGlzYWJsZXMgdGhlIHNwZWNpYWwgYmVoYXZpb3IgZm9yIHNjcmlwdC9zdHlsZSB0YWdzIChmYWxzZSBieSBkZWZhdWx0KVxuXHRsb3dlckNhc2VBdHRyaWJ1dGVOYW1lczogY2FsbCAudG9Mb3dlckNhc2UgZm9yIGVhY2ggYXR0cmlidXRlIG5hbWUgKHRydWUgaWYgeG1sTW9kZSBpcyBgZmFsc2VgKVxuXHRsb3dlckNhc2VUYWdzOiBjYWxsIC50b0xvd2VyQ2FzZSBmb3IgZWFjaCB0YWcgbmFtZSAodHJ1ZSBpZiB4bWxNb2RlIGlzIGBmYWxzZWApXG4qL1xuXG4vKlxuXHRDYWxsYmFja3M6XG5cblx0b25jZGF0YWVuZCxcblx0b25jZGF0YXN0YXJ0LFxuXHRvbmNsb3NldGFnLFxuXHRvbmNvbW1lbnQsXG5cdG9uY29tbWVudGVuZCxcblx0b25lcnJvcixcblx0b25vcGVudGFnLFxuXHRvbnByb2Nlc3NpbmdpbnN0cnVjdGlvbixcblx0b25yZXNldCxcblx0b250ZXh0XG4qL1xuXG52YXIgZm9ybVRhZ3MgPSB7XG5cdGlucHV0OiB0cnVlLFxuXHRvcHRpb246IHRydWUsXG5cdG9wdGdyb3VwOiB0cnVlLFxuXHRzZWxlY3Q6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0ZGF0YWxpc3Q6IHRydWUsXG5cdHRleHRhcmVhOiB0cnVlXG59O1xuXG52YXIgb3BlbkltcGxpZXNDbG9zZSA9IHtcblx0dHIgICAgICA6IHsgdHI6dHJ1ZSwgdGg6dHJ1ZSwgdGQ6dHJ1ZSB9LFxuXHR0aCAgICAgIDogeyB0aDp0cnVlIH0sXG5cdHRkICAgICAgOiB7IHRoZWFkOnRydWUsIHRoOnRydWUsIHRkOnRydWUgfSxcblx0Ym9keSAgICA6IHsgaGVhZDp0cnVlLCBsaW5rOnRydWUsIHNjcmlwdDp0cnVlIH0sXG5cdGxpICAgICAgOiB7IGxpOnRydWUgfSxcblx0cCAgICAgICA6IHsgcDp0cnVlIH0sXG5cdGgxICAgICAgOiB7IHA6dHJ1ZSB9LFxuXHRoMiAgICAgIDogeyBwOnRydWUgfSxcblx0aDMgICAgICA6IHsgcDp0cnVlIH0sXG5cdGg0ICAgICAgOiB7IHA6dHJ1ZSB9LFxuXHRoNSAgICAgIDogeyBwOnRydWUgfSxcblx0aDYgICAgICA6IHsgcDp0cnVlIH0sXG5cdHNlbGVjdCAgOiBmb3JtVGFncyxcblx0aW5wdXQgICA6IGZvcm1UYWdzLFxuXHRvdXRwdXQgIDogZm9ybVRhZ3MsXG5cdGJ1dHRvbiAgOiBmb3JtVGFncyxcblx0ZGF0YWxpc3Q6IGZvcm1UYWdzLFxuXHR0ZXh0YXJlYTogZm9ybVRhZ3MsXG5cdG9wdGlvbiAgOiB7IG9wdGlvbjp0cnVlIH0sXG5cdG9wdGdyb3VwOiB7IG9wdGdyb3VwOnRydWUgfVxufTtcblxudmFyIHZvaWRFbGVtZW50cyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHRhcmVhOiB0cnVlLFxuXHRiYXNlOiB0cnVlLFxuXHRiYXNlZm9udDogdHJ1ZSxcblx0YnI6IHRydWUsXG5cdGNvbDogdHJ1ZSxcblx0Y29tbWFuZDogdHJ1ZSxcblx0ZW1iZWQ6IHRydWUsXG5cdGZyYW1lOiB0cnVlLFxuXHRocjogdHJ1ZSxcblx0aW1nOiB0cnVlLFxuXHRpbnB1dDogdHJ1ZSxcblx0aXNpbmRleDogdHJ1ZSxcblx0a2V5Z2VuOiB0cnVlLFxuXHRsaW5rOiB0cnVlLFxuXHRtZXRhOiB0cnVlLFxuXHRwYXJhbTogdHJ1ZSxcblx0c291cmNlOiB0cnVlLFxuXHR0cmFjazogdHJ1ZSxcblx0d2JyOiB0cnVlLFxuXG5cdC8vY29tbW9uIHNlbGYgY2xvc2luZyBzdmcgZWxlbWVudHNcblx0cGF0aDogdHJ1ZSxcblx0Y2lyY2xlOiB0cnVlLFxuXHRlbGxpcHNlOiB0cnVlLFxuXHRsaW5lOiB0cnVlLFxuXHRyZWN0OiB0cnVlLFxuXHR1c2U6IHRydWUsXG5cdHN0b3A6IHRydWUsXG5cdHBvbHlsaW5lOiB0cnVlLFxuXHRwb2x5Z29uOiB0cnVlXG59O1xuXG52YXIgcmVfbmFtZUVuZCA9IC9cXHN8XFwvLztcblxuZnVuY3Rpb24gUGFyc2VyKGNicywgb3B0aW9ucyl7XG5cdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR0aGlzLl9jYnMgPSBjYnMgfHwge307XG5cblx0dGhpcy5fdGFnbmFtZSA9IFwiXCI7XG5cdHRoaXMuX2F0dHJpYm5hbWUgPSBcIlwiO1xuXHR0aGlzLl9hdHRyaWJ2YWx1ZSA9IFwiXCI7XG5cdHRoaXMuX2F0dHJpYnMgPSBudWxsO1xuXHR0aGlzLl9zdGFjayA9IFtdO1xuXG5cdHRoaXMuc3RhcnRJbmRleCA9IDA7XG5cdHRoaXMuZW5kSW5kZXggPSBudWxsO1xuXG5cdHRoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzID0gXCJsb3dlckNhc2VUYWdzXCIgaW4gdGhpcy5fb3B0aW9ucyA/XG5cdFx0XHRcdFx0XHRcdFx0XHQhIXRoaXMuX29wdGlvbnMubG93ZXJDYXNlVGFncyA6XG5cdFx0XHRcdFx0XHRcdFx0XHQhdGhpcy5fb3B0aW9ucy54bWxNb2RlO1xuXHR0aGlzLl9sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyA9IFwibG93ZXJDYXNlQXR0cmlidXRlTmFtZXNcIiBpbiB0aGlzLl9vcHRpb25zID9cblx0XHRcdFx0XHRcdFx0XHRcdCEhdGhpcy5fb3B0aW9ucy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHQhdGhpcy5fb3B0aW9ucy54bWxNb2RlO1xuXG5cdGlmKHRoaXMuX29wdGlvbnMuVG9rZW5pemVyKSB7XG5cdFx0VG9rZW5pemVyID0gdGhpcy5fb3B0aW9ucy5Ub2tlbml6ZXI7XG5cdH1cblx0dGhpcy5fdG9rZW5pemVyID0gbmV3IFRva2VuaXplcih0aGlzLl9vcHRpb25zLCB0aGlzKTtcblxuXHRpZih0aGlzLl9jYnMub25wYXJzZXJpbml0KSB0aGlzLl9jYnMub25wYXJzZXJpbml0KHRoaXMpO1xufVxuXG5yZXF1aXJlKFwiaW5oZXJpdHNcIikoUGFyc2VyLCByZXF1aXJlKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcik7XG5cblBhcnNlci5wcm90b3R5cGUuX3VwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24oaW5pdGlhbE9mZnNldCl7XG5cdGlmKHRoaXMuZW5kSW5kZXggPT09IG51bGwpe1xuXHRcdGlmKHRoaXMuX3Rva2VuaXplci5fc2VjdGlvblN0YXJ0IDw9IGluaXRpYWxPZmZzZXQpe1xuXHRcdFx0dGhpcy5zdGFydEluZGV4ID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zdGFydEluZGV4ID0gdGhpcy5fdG9rZW5pemVyLl9zZWN0aW9uU3RhcnQgLSBpbml0aWFsT2Zmc2V0O1xuXHRcdH1cblx0fVxuXHRlbHNlIHRoaXMuc3RhcnRJbmRleCA9IHRoaXMuZW5kSW5kZXggKyAxO1xuXHR0aGlzLmVuZEluZGV4ID0gdGhpcy5fdG9rZW5pemVyLmdldEFic29sdXRlSW5kZXgoKTtcbn07XG5cbi8vVG9rZW5pemVyIGV2ZW50IGhhbmRsZXJzXG5QYXJzZXIucHJvdG90eXBlLm9udGV4dCA9IGZ1bmN0aW9uKGRhdGEpe1xuXHR0aGlzLl91cGRhdGVQb3NpdGlvbigxKTtcblx0dGhpcy5lbmRJbmRleC0tO1xuXG5cdGlmKHRoaXMuX2Nicy5vbnRleHQpIHRoaXMuX2Nicy5vbnRleHQoZGF0YSk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9ub3BlbnRhZ25hbWUgPSBmdW5jdGlvbihuYW1lKXtcblx0aWYodGhpcy5fbG93ZXJDYXNlVGFnTmFtZXMpe1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH1cblxuXHR0aGlzLl90YWduYW1lID0gbmFtZTtcblxuXHRpZighdGhpcy5fb3B0aW9ucy54bWxNb2RlICYmIG5hbWUgaW4gb3BlbkltcGxpZXNDbG9zZSkge1xuXHRcdGZvcihcblx0XHRcdHZhciBlbDtcblx0XHRcdChlbCA9IHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aCAtIDFdKSBpbiBvcGVuSW1wbGllc0Nsb3NlW25hbWVdO1xuXHRcdFx0dGhpcy5vbmNsb3NldGFnKGVsKVxuXHRcdCk7XG5cdH1cblxuXHRpZih0aGlzLl9vcHRpb25zLnhtbE1vZGUgfHwgIShuYW1lIGluIHZvaWRFbGVtZW50cykpe1xuXHRcdHRoaXMuX3N0YWNrLnB1c2gobmFtZSk7XG5cdH1cblxuXHRpZih0aGlzLl9jYnMub25vcGVudGFnbmFtZSkgdGhpcy5fY2JzLm9ub3BlbnRhZ25hbWUobmFtZSk7XG5cdGlmKHRoaXMuX2Nicy5vbm9wZW50YWcpIHRoaXMuX2F0dHJpYnMgPSB7fTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUub25vcGVudGFnZW5kID0gZnVuY3Rpb24oKXtcblx0dGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7XG5cblx0aWYodGhpcy5fYXR0cmlicyl7XG5cdFx0aWYodGhpcy5fY2JzLm9ub3BlbnRhZykgdGhpcy5fY2JzLm9ub3BlbnRhZyh0aGlzLl90YWduYW1lLCB0aGlzLl9hdHRyaWJzKTtcblx0XHR0aGlzLl9hdHRyaWJzID0gbnVsbDtcblx0fVxuXG5cdGlmKCF0aGlzLl9vcHRpb25zLnhtbE1vZGUgJiYgdGhpcy5fY2JzLm9uY2xvc2V0YWcgJiYgdGhpcy5fdGFnbmFtZSBpbiB2b2lkRWxlbWVudHMpe1xuXHRcdHRoaXMuX2Nicy5vbmNsb3NldGFnKHRoaXMuX3RhZ25hbWUpO1xuXHR9XG5cblx0dGhpcy5fdGFnbmFtZSA9IFwiXCI7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uY2xvc2V0YWcgPSBmdW5jdGlvbihuYW1lKXtcblx0dGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7XG5cblx0aWYodGhpcy5fbG93ZXJDYXNlVGFnTmFtZXMpe1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH1cblxuXHRpZih0aGlzLl9zdGFjay5sZW5ndGggJiYgKCEobmFtZSBpbiB2b2lkRWxlbWVudHMpIHx8IHRoaXMuX29wdGlvbnMueG1sTW9kZSkpe1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFjay5sYXN0SW5kZXhPZihuYW1lKTtcblx0XHRpZihwb3MgIT09IC0xKXtcblx0XHRcdGlmKHRoaXMuX2Nicy5vbmNsb3NldGFnKXtcblx0XHRcdFx0cG9zID0gdGhpcy5fc3RhY2subGVuZ3RoIC0gcG9zO1xuXHRcdFx0XHR3aGlsZShwb3MtLSkgdGhpcy5fY2JzLm9uY2xvc2V0YWcodGhpcy5fc3RhY2sucG9wKCkpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB0aGlzLl9zdGFjay5sZW5ndGggPSBwb3M7XG5cdFx0fSBlbHNlIGlmKG5hbWUgPT09IFwicFwiICYmICF0aGlzLl9vcHRpb25zLnhtbE1vZGUpe1xuXHRcdFx0dGhpcy5vbm9wZW50YWduYW1lKG5hbWUpO1xuXHRcdFx0dGhpcy5fY2xvc2VDdXJyZW50VGFnKCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYoIXRoaXMuX29wdGlvbnMueG1sTW9kZSAmJiAobmFtZSA9PT0gXCJiclwiIHx8IG5hbWUgPT09IFwicFwiKSl7XG5cdFx0dGhpcy5vbm9wZW50YWduYW1lKG5hbWUpO1xuXHRcdHRoaXMuX2Nsb3NlQ3VycmVudFRhZygpO1xuXHR9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uc2VsZmNsb3Npbmd0YWcgPSBmdW5jdGlvbigpe1xuXHRpZih0aGlzLl9vcHRpb25zLnhtbE1vZGUgfHwgdGhpcy5fb3B0aW9ucy5yZWNvZ25pemVTZWxmQ2xvc2luZyl7XG5cdFx0dGhpcy5fY2xvc2VDdXJyZW50VGFnKCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5vbm9wZW50YWdlbmQoKTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fY2xvc2VDdXJyZW50VGFnID0gZnVuY3Rpb24oKXtcblx0dmFyIG5hbWUgPSB0aGlzLl90YWduYW1lO1xuXG5cdHRoaXMub25vcGVudGFnZW5kKCk7XG5cblx0Ly9zZWxmLWNsb3NpbmcgdGFncyB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG5cdC8vKGNoZWFwZXIgY2hlY2sgdGhhbiBpbiBvbmNsb3NldGFnKVxuXHRpZih0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGggLSAxXSA9PT0gbmFtZSl7XG5cdFx0aWYodGhpcy5fY2JzLm9uY2xvc2V0YWcpe1xuXHRcdFx0dGhpcy5fY2JzLm9uY2xvc2V0YWcobmFtZSk7XG5cdFx0fVxuXHRcdHRoaXMuX3N0YWNrLnBvcCgpO1xuXHR9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uYXR0cmlibmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xuXHRpZih0aGlzLl9sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyl7XG5cdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fVxuXHR0aGlzLl9hdHRyaWJuYW1lID0gbmFtZTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUub25hdHRyaWJkYXRhID0gZnVuY3Rpb24odmFsdWUpe1xuXHR0aGlzLl9hdHRyaWJ2YWx1ZSArPSB2YWx1ZTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUub25hdHRyaWJlbmQgPSBmdW5jdGlvbigpe1xuXHRpZih0aGlzLl9jYnMub25hdHRyaWJ1dGUpIHRoaXMuX2Nicy5vbmF0dHJpYnV0ZSh0aGlzLl9hdHRyaWJuYW1lLCB0aGlzLl9hdHRyaWJ2YWx1ZSk7XG5cdGlmKFxuXHRcdHRoaXMuX2F0dHJpYnMgJiZcblx0XHQhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2F0dHJpYnMsIHRoaXMuX2F0dHJpYm5hbWUpXG5cdCl7XG5cdFx0dGhpcy5fYXR0cmlic1t0aGlzLl9hdHRyaWJuYW1lXSA9IHRoaXMuX2F0dHJpYnZhbHVlO1xuXHR9XG5cdHRoaXMuX2F0dHJpYm5hbWUgPSBcIlwiO1xuXHR0aGlzLl9hdHRyaWJ2YWx1ZSA9IFwiXCI7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9nZXRJbnN0cnVjdGlvbk5hbWUgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdHZhciBpZHggPSB2YWx1ZS5zZWFyY2gocmVfbmFtZUVuZCksXG5cdCAgICBuYW1lID0gaWR4IDwgMCA/IHZhbHVlIDogdmFsdWUuc3Vic3RyKDAsIGlkeCk7XG5cblx0aWYodGhpcy5fbG93ZXJDYXNlVGFnTmFtZXMpe1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH1cblxuXHRyZXR1cm4gbmFtZTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUub25kZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0aWYodGhpcy5fY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKXtcblx0XHR2YXIgbmFtZSA9IHRoaXMuX2dldEluc3RydWN0aW9uTmFtZSh2YWx1ZSk7XG5cdFx0dGhpcy5fY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKFwiIVwiICsgbmFtZSwgXCIhXCIgKyB2YWx1ZSk7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbih2YWx1ZSl7XG5cdGlmKHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbil7XG5cdFx0dmFyIG5hbWUgPSB0aGlzLl9nZXRJbnN0cnVjdGlvbk5hbWUodmFsdWUpO1xuXHRcdHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihcIj9cIiArIG5hbWUsIFwiP1wiICsgdmFsdWUpO1xuXHR9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uY29tbWVudCA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0dGhpcy5fdXBkYXRlUG9zaXRpb24oNCk7XG5cblx0aWYodGhpcy5fY2JzLm9uY29tbWVudCkgdGhpcy5fY2JzLm9uY29tbWVudCh2YWx1ZSk7XG5cdGlmKHRoaXMuX2Nicy5vbmNvbW1lbnRlbmQpIHRoaXMuX2Nicy5vbmNvbW1lbnRlbmQoKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUub25jZGF0YSA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0dGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7XG5cblx0aWYodGhpcy5fb3B0aW9ucy54bWxNb2RlIHx8IHRoaXMuX29wdGlvbnMucmVjb2duaXplQ0RBVEEpe1xuXHRcdGlmKHRoaXMuX2Nicy5vbmNkYXRhc3RhcnQpIHRoaXMuX2Nicy5vbmNkYXRhc3RhcnQoKTtcblx0XHRpZih0aGlzLl9jYnMub250ZXh0KSB0aGlzLl9jYnMub250ZXh0KHZhbHVlKTtcblx0XHRpZih0aGlzLl9jYnMub25jZGF0YWVuZCkgdGhpcy5fY2JzLm9uY2RhdGFlbmQoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLm9uY29tbWVudChcIltDREFUQVtcIiArIHZhbHVlICsgXCJdXVwiKTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcblx0aWYodGhpcy5fY2JzLm9uZXJyb3IpIHRoaXMuX2Nicy5vbmVycm9yKGVycik7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uZW5kID0gZnVuY3Rpb24oKXtcblx0aWYodGhpcy5fY2JzLm9uY2xvc2V0YWcpe1xuXHRcdGZvcihcblx0XHRcdHZhciBpID0gdGhpcy5fc3RhY2subGVuZ3RoO1xuXHRcdFx0aSA+IDA7XG5cdFx0XHR0aGlzLl9jYnMub25jbG9zZXRhZyh0aGlzLl9zdGFja1stLWldKVxuXHRcdCk7XG5cdH1cblx0aWYodGhpcy5fY2JzLm9uZW5kKSB0aGlzLl9jYnMub25lbmQoKTtcbn07XG5cblxuLy9SZXNldHMgdGhlIHBhcnNlciB0byBhIGJsYW5rIHN0YXRlLCByZWFkeSB0byBwYXJzZSBhIG5ldyBIVE1MIGRvY3VtZW50XG5QYXJzZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcblx0aWYodGhpcy5fY2JzLm9ucmVzZXQpIHRoaXMuX2Nicy5vbnJlc2V0KCk7XG5cdHRoaXMuX3Rva2VuaXplci5yZXNldCgpO1xuXG5cdHRoaXMuX3RhZ25hbWUgPSBcIlwiO1xuXHR0aGlzLl9hdHRyaWJuYW1lID0gXCJcIjtcblx0dGhpcy5fYXR0cmlicyA9IG51bGw7XG5cdHRoaXMuX3N0YWNrID0gW107XG5cblx0aWYodGhpcy5fY2JzLm9ucGFyc2VyaW5pdCkgdGhpcy5fY2JzLm9ucGFyc2VyaW5pdCh0aGlzKTtcbn07XG5cbi8vUGFyc2VzIGEgY29tcGxldGUgSFRNTCBkb2N1bWVudCBhbmQgcHVzaGVzIGl0IHRvIHRoZSBoYW5kbGVyXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxldGUgPSBmdW5jdGlvbihkYXRhKXtcblx0dGhpcy5yZXNldCgpO1xuXHR0aGlzLmVuZChkYXRhKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuayl7XG5cdHRoaXMuX3Rva2VuaXplci53cml0ZShjaHVuayk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rKXtcblx0dGhpcy5fdG9rZW5pemVyLmVuZChjaHVuayk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKXtcblx0dGhpcy5fdG9rZW5pemVyLnBhdXNlKCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3Rva2VuaXplci5yZXN1bWUoKTtcbn07XG5cbi8vYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRcblBhcnNlci5wcm90b3R5cGUucGFyc2VDaHVuayA9IFBhcnNlci5wcm90b3R5cGUud3JpdGU7XG5QYXJzZXIucHJvdG90eXBlLmRvbmUgPSBQYXJzZXIucHJvdG90eXBlLmVuZDtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2h0bWxwYXJzZXIyQDMuOS4yQGh0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGlzb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pc29iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIGlzQXJyYXkodmFsKSA9PT0gZmFsc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9pc29iamVjdEAyLjEuMEBpc29iamVjdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX29iamVjdC1hc3NpZ25ANC4xLjFAb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyogZXNsaW50IG1heC1sZW46IDAgKi9cblxuLy8gVGhpcyBpcyBhIHRyaWNrIHRha2VuIGZyb20gRXNwcmltYS4gSXQgdHVybnMgb3V0IHRoYXQsIG9uXG4vLyBub24tQ2hyb21lIGJyb3dzZXJzLCB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nIGlzIGluIGEgc2V0LCBhXG4vLyBwcmVkaWNhdGUgY29udGFpbmluZyBhIGJpZyB1Z2x5IGBzd2l0Y2hgIHN0YXRlbWVudCBpcyBmYXN0ZXIgdGhhblxuLy8gYSByZWd1bGFyIGV4cHJlc3Npb24sIGFuZCBvbiBDaHJvbWUgdGhlIHR3byBhcmUgYWJvdXQgb24gcGFyLlxuLy8gVGhpcyBmdW5jdGlvbiB1c2VzIGBldmFsYCAobm9uLWxleGljYWwpIHRvIHByb2R1Y2Ugc3VjaCBhXG4vLyBwcmVkaWNhdGUgZnJvbSBhIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgb2Ygd29yZHMuXG4vL1xuLy8gSXQgc3RhcnRzIGJ5IHNvcnRpbmcgdGhlIHdvcmRzIGJ5IGxlbmd0aC5cblxuZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuICB3b3JkcyA9IHdvcmRzLnNwbGl0KFwiIFwiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gd29yZHMuaW5kZXhPZihzdHIpID49IDA7XG4gIH07XG59XG5cbi8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbnZhciByZXNlcnZlZFdvcmRzID0ge1xuICA2OiBtYWtlUHJlZGljYXRlKFwiZW51bSBhd2FpdFwiKSxcbiAgc3RyaWN0OiBtYWtlUHJlZGljYXRlKFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiKSxcbiAgc3RyaWN0QmluZDogbWFrZVByZWRpY2F0ZShcImV2YWwgYXJndW1lbnRzXCIpXG59O1xuXG4vLyBBbmQgdGhlIGtleXdvcmRzXG5cbnZhciBpc0tleXdvcmQgPSBtYWtlUHJlZGljYXRlKFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzIGxldCBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgeWllbGQgc3VwZXJcIik7XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuLy8gR2VuZXJhdGVkIGJ5IGBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwQ1xcdTIwMERcXHhCN1xcdTAzMDAtXFx1MDM2RlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NjlcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNkYwLVxcdTA2RjlcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdDMC1cXHUwN0M5XFx1MDdFQi1cXHUwN0YzXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhENC1cXHUwOEUxXFx1MDhFMy1cXHUwOTAzXFx1MDkzQS1cXHUwOTNDXFx1MDkzRS1cXHUwOTRGXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTgxLVxcdTA5ODNcXHUwOUJDXFx1MDlCRS1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUU2LVxcdTA5RUZcXHUwQTAxLVxcdTBBMDNcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE2Ni1cXHUwQTcxXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBQkNcXHUwQUJFLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCM0NcXHUwQjNFLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjgyXFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDM0UtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQ0JDXFx1MENCRS1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBEMDEtXFx1MEQwM1xcdTBEM0UtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEODJcXHUwRDgzXFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQlxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0VcXHUwRjNGXFx1MEY3MS1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyQi1cXHUxMDNFXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4Ri1cXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjQtXFx1MTdEM1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxOEE5XFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOURBXFx1MUExNy1cXHUxQTFCXFx1MUE1NS1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjA0XFx1MUIzNC1cXHUxQjQ0XFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQjgyXFx1MUJBMS1cXHUxQkFEXFx1MUJCMC1cXHUxQkI5XFx1MUJFNi1cXHUxQkYzXFx1MUMyNC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0U4XFx1MUNFRFxcdTFDRjItXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY1XFx1MURGQi1cXHUxREZGXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2MjAtXFx1QTYyOVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyMy1cXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzVcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjFcXHVBOTAwLVxcdUE5MDlcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTNcXHVBOTgwLVxcdUE5ODNcXHVBOUIzLVxcdUE5QzBcXHVBOUQwLVxcdUE5RDlcXHVBOUU1XFx1QTlGMC1cXHVBOUY5XFx1QUEyOS1cXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE3Qi1cXHVBQTdEXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQi1cXHVBQUVGXFx1QUFGNVxcdUFBRjZcXHVBQkUzLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZGMTAtXFx1RkYxOVxcdUZGM0ZcIjtcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4vLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4vLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4vLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuLy8gZ2VuZXJhdGVkIGJ5IGBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNywgMjYsIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDE1NywgMzEwLCAxMCwgMjEsIDExLCA3LCAxNTMsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyNiwgNDUsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCA3ODUsIDUyLCA3NiwgNDQsIDMzLCAyNCwgMjcsIDM1LCA0MiwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCA4NSwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMTU5LCA1MiwgMTksIDMsIDU0LCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDg2LCAyNSwgMzkxLCA2MywgMzIsIDAsIDQ0OSwgNTYsIDI2NCwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDg4MSwgOTIxLCAxMDMsIDExMCwgMTgsIDE5NSwgMjc0OSwgMTA3MCwgNDA1MCwgNTgyLCA4NjM0LCA1NjgsIDgsIDMwLCAxMTQsIDI5LCAxOSwgNDcsIDE3LCAzLCAzMiwgMjAsIDYsIDE4LCA4ODEsIDY4LCAxMiwgMCwgNjcsIDEyLCA2NSwgMCwgMzIsIDYxMjQsIDIwLCA3NTQsIDk0ODYsIDEsIDMwNzEsIDEwNiwgNiwgMTIsIDQsIDgsIDgsIDksIDU5OTEsIDg0LCAyLCA3MCwgMiwgMSwgMywgMCwgMywgMSwgMywgMywgMiwgMTEsIDIsIDAsIDIsIDYsIDIsIDY0LCAyLCAzLCAzLCA3LCAyLCA2LCAyLCAyNywgMiwgMywgMiwgNCwgMiwgMCwgNCwgNiwgMiwgMzM5LCAzLCAyNCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgNywgNDE0OSwgMTk2LCA2MCwgNjcsIDEyMTMsIDMsIDIsIDI2LCAyLCAxLCAyLCAwLCAzLCAwLCAyLCA5LCAyLCAzLCAyLCAwLCAyLCAwLCA3LCAwLCA1LCAwLCAyLCAwLCAyLCAwLCAyLCAyLCAyLCAxLCAyLCAwLCAzLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAxLCAyLCAwLCAzLCAzLCAyLCA2LCAyLCAzLCAyLCAzLCAyLCAwLCAyLCA5LCAyLCAxNiwgNiwgMiwgMiwgNCwgMiwgMTYsIDQ0MjEsIDQyNzEwLCA0MiwgNDE0OCwgMTIsIDIyMSwgMywgNTc2MSwgMTA1OTEsIDU0MV07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksIDAsIDIyNywgMCwgMTUwLCA0LCAyOTQsIDksIDEzNjgsIDIsIDIsIDEsIDYsIDMsIDQxLCAyLCA1LCAwLCAxNjYsIDEsIDEzMDYsIDIsIDU0LCAxNCwgMzIsIDksIDE2LCAzLCA0NiwgMTAsIDU0LCA5LCA3LCAyLCAzNywgMTMsIDIsIDksIDUyLCAwLCAxMywgMiwgNDksIDEzLCAxMCwgMiwgNCwgOSwgODMsIDExLCA3LCAwLCAxNjEsIDExLCA2LCA5LCA3LCAzLCA1NywgMCwgMiwgNiwgMywgMSwgMywgMiwgMTAsIDAsIDExLCAxLCAzLCA2LCA0LCA0LCAxOTMsIDE3LCAxMCwgOSwgODcsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA4NCwgMTQsIDUsIDksIDQyMywgOSwgODM4LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTk4ODIsIDksIDEzNSwgNCwgNjAsIDYsIDI2LCA5LCAxMDE2LCA0NSwgMTcsIDMsIDE5NzIzLCAxLCA1MzE5LCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAyMjE0LCA2LCAxMTAsIDYsIDYsIDksIDc5MjQ4NywgMjM5XTtcblxuLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuLy8gcmFyZS5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIHZhciBwb3MgPSAweDEwMDAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHJldHVybiBmYWxzZTtcblxuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcyk7XG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSkge1xuICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpO1xufVxuXG4vLyBBIHNlY29uZCBvcHRpb25hbCBhcmd1bWVudCBjYW4gYmUgZ2l2ZW4gdG8gZnVydGhlciBjb25maWd1cmVcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gU291cmNlIHR5cGUgKFwic2NyaXB0XCIgb3IgXCJtb2R1bGVcIikgZm9yIGRpZmZlcmVudCBzZW1hbnRpY3NcbiAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgLy8gU291cmNlIGZpbGVuYW1lLlxuICBzb3VyY2VGaWxlbmFtZTogdW5kZWZpbmVkLFxuICAvLyBMaW5lIGZyb20gd2hpY2ggdG8gc3RhcnQgY291bnRpbmcgc291cmNlLiBVc2VmdWwgZm9yXG4gIC8vIGludGVncmF0aW9uIHdpdGggb3RoZXIgdG9vbHMuXG4gIHN0YXJ0TGluZTogMSxcbiAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gIC8vIGVycm9yLlxuICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgaW1wb3J0L2V4cG9ydCBzdGF0ZW1lbnRzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0uXG4gIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gIC8vIFRPRE9cbiAgYWxsb3dTdXBlck91dHNpZGVNZXRob2Q6IGZhbHNlLFxuICAvLyBBbiBhcnJheSBvZiBwbHVnaW5zIHRvIGVuYWJsZVxuICBwbHVnaW5zOiBbXSxcbiAgLy8gVE9ET1xuICBzdHJpY3RNb2RlOiBudWxsXG59O1xuXG4vLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gIHZhciBvcHRpb25zID0ge307XG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0T3B0aW9ucykge1xuICAgIG9wdGlvbnNba2V5XSA9IG9wdHMgJiYga2V5IGluIG9wdHMgPyBvcHRzW2tleV0gOiBkZWZhdWx0T3B0aW9uc1trZXldO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG4vLyAjIyBUb2tlbiB0eXBlc1xuXG4vLyBUaGUgYXNzaWdubWVudCBvZiBmaW5lLWdyYWluZWQsIGluZm9ybWF0aW9uLWNhcnJ5aW5nIHR5cGUgb2JqZWN0c1xuLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4vLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuLy8gQWxsIHRva2VuIHR5cGUgdmFyaWFibGVzIHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZSwgdG8gbWFrZSB0aGVtXG4vLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb25zIGFuZCBkaXZpc2lvbnMuIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBjYW5cbi8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBiZWZvcmVFeHByID0gdHJ1ZTtcbnZhciBzdGFydHNFeHByID0gdHJ1ZTtcbnZhciBpc0xvb3AgPSB0cnVlO1xudmFyIGlzQXNzaWduID0gdHJ1ZTtcbnZhciBwcmVmaXggPSB0cnVlO1xudmFyIHBvc3RmaXggPSB0cnVlO1xuXG52YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsKSB7XG4gIHZhciBjb25mID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9rZW5UeXBlKTtcblxuICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICB0aGlzLnJpZ2h0QXNzb2NpYXRpdmUgPSAhIWNvbmYucmlnaHRBc3NvY2lhdGl2ZTtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxudmFyIEtleXdvcmRUb2tlblR5cGUgPSBmdW5jdGlvbiAoX1Rva2VuVHlwZSkge1xuICBpbmhlcml0cyhLZXl3b3JkVG9rZW5UeXBlLCBfVG9rZW5UeXBlKTtcblxuICBmdW5jdGlvbiBLZXl3b3JkVG9rZW5UeXBlKG5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5d29yZFRva2VuVHlwZSk7XG5cbiAgICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1Rva2VuVHlwZS5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBLZXl3b3JkVG9rZW5UeXBlO1xufShUb2tlblR5cGUpO1xuXG52YXIgQmlub3BUb2tlblR5cGUgPSBmdW5jdGlvbiAoX1Rva2VuVHlwZTIpIHtcbiAgaW5oZXJpdHMoQmlub3BUb2tlblR5cGUsIF9Ub2tlblR5cGUyKTtcblxuICBmdW5jdGlvbiBCaW5vcFRva2VuVHlwZShuYW1lLCBwcmVjKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmlub3BUb2tlblR5cGUpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Ub2tlblR5cGUyLmNhbGwodGhpcywgbmFtZSwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBiaW5vcDogcHJlYyB9KSk7XG4gIH1cblxuICByZXR1cm4gQmlub3BUb2tlblR5cGU7XG59KFRva2VuVHlwZSk7XG5cbnZhciB0eXBlcyA9IHtcbiAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgeyBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIGJyYWNlQmFyTDogbmV3IFRva2VuVHlwZShcInt8XCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgYnJhY2VCYXJSOiBuZXcgVG9rZW5UeXBlKFwifH1cIiksXG4gIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIgfSksXG4gIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIgfSksXG4gIGRvdWJsZUNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOjpcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciB9KSxcbiAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBhdDogbmV3IFRva2VuVHlwZShcIkBcIiksXG5cbiAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgLy8gcGFyc2VyIHVzZSB0aGVtIHByb3Blcmx5ICh0aGUgcHJlc2VuY2Ugb2YgdGhlc2UgcHJvcGVydGllcyBpc1xuICAvLyB3aGF0IGNhdGVnb3JpemVzIHRoZW0gYXMgb3BlcmF0b3JzKS5cbiAgLy9cbiAgLy8gYGJpbm9wYCwgd2hlbiBwcmVzZW50LCBzcGVjaWZpZXMgdGhhdCB0aGlzIG9wZXJhdG9yIGlzIGEgYmluYXJ5XG4gIC8vIG9wZXJhdG9yLCBhbmQgd2lsbCByZWZlciB0byBpdHMgcHJlY2VkZW5jZS5cbiAgLy9cbiAgLy8gYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBtYXJrIHRoZSBvcGVyYXRvciBhcyBhIHByZWZpeCBvciBwb3N0Zml4XG4gIC8vIHVuYXJ5IG9wZXJhdG9yLlxuICAvL1xuICAvLyBgaXNBc3NpZ25gIG1hcmtzIGFsbCBvZiBgPWAsIGArPWAsIGAtPWAgZXRjZXRlcmEsIHdoaWNoIGFjdCBhc1xuICAvLyBiaW5hcnkgb3BlcmF0b3JzIHdpdGggYSB2ZXJ5IGxvdyBwcmVjZWRlbmNlLCB0aGF0IHNob3VsZCByZXN1bHRcbiAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgaXNBc3NpZ246IGlzQXNzaWduIH0pLFxuICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIGlzQXNzaWduOiBpc0Fzc2lnbiB9KSxcbiAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwgeyBwcmVmaXg6IHByZWZpeCwgcG9zdGZpeDogcG9zdGZpeCwgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwicHJlZml4XCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgcHJlZml4OiBwcmVmaXgsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIGxvZ2ljYWxPUjogbmV3IEJpbm9wVG9rZW5UeXBlKFwifHxcIiwgMSksXG4gIGxvZ2ljYWxBTkQ6IG5ldyBCaW5vcFRva2VuVHlwZShcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IG5ldyBCaW5vcFRva2VuVHlwZShcInxcIiwgMyksXG4gIGJpdHdpc2VYT1I6IG5ldyBCaW5vcFRva2VuVHlwZShcIl5cIiwgNCksXG4gIGJpdHdpc2VBTkQ6IG5ldyBCaW5vcFRva2VuVHlwZShcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBuZXcgQmlub3BUb2tlblR5cGUoXCI9PS8hPVwiLCA2KSxcbiAgcmVsYXRpb25hbDogbmV3IEJpbm9wVG9rZW5UeXBlKFwiPC8+XCIsIDcpLFxuICBiaXRTaGlmdDogbmV3IEJpbm9wVG9rZW5UeXBlKFwiPDwvPj5cIiwgOCksXG4gIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBiaW5vcDogOSwgcHJlZml4OiBwcmVmaXgsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIG1vZHVsbzogbmV3IEJpbm9wVG9rZW5UeXBlKFwiJVwiLCAxMCksXG4gIHN0YXI6IG5ldyBCaW5vcFRva2VuVHlwZShcIipcIiwgMTApLFxuICBzbGFzaDogbmV3IEJpbm9wVG9rZW5UeXBlKFwiL1wiLCAxMCksXG4gIGV4cG9uZW50OiBuZXcgVG9rZW5UeXBlKFwiKipcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBiaW5vcDogMTEsIHJpZ2h0QXNzb2NpYXRpdmU6IHRydWUgfSlcbn07XG5cbnZhciBrZXl3b3JkcyA9IHtcbiAgXCJicmVha1wiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImJyZWFrXCIpLFxuICBcImNhc2VcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJjYXNlXCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciB9KSxcbiAgXCJjYXRjaFwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImNhdGNoXCIpLFxuICBcImNvbnRpbnVlXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiY29udGludWVcIiksXG4gIFwiZGVidWdnZXJcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJkZWJ1Z2dlclwiKSxcbiAgXCJkZWZhdWx0XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiZGVmYXVsdFwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIgfSksXG4gIFwiZG9cIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJkb1wiLCB7IGlzTG9vcDogaXNMb29wLCBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBcImVsc2VcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJlbHNlXCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciB9KSxcbiAgXCJmaW5hbGx5XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiZmluYWxseVwiKSxcbiAgXCJmb3JcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJmb3JcIiwgeyBpc0xvb3A6IGlzTG9vcCB9KSxcbiAgXCJmdW5jdGlvblwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImZ1bmN0aW9uXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgXCJpZlwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImlmXCIpLFxuICBcInJldHVyblwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcInJldHVyblwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIgfSksXG4gIFwic3dpdGNoXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwic3dpdGNoXCIpLFxuICBcInRocm93XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwidGhyb3dcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBcInRyeVwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcInRyeVwiKSxcbiAgXCJ2YXJcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJ2YXJcIiksXG4gIFwibGV0XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwibGV0XCIpLFxuICBcImNvbnN0XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiY29uc3RcIiksXG4gIFwid2hpbGVcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJ3aGlsZVwiLCB7IGlzTG9vcDogaXNMb29wIH0pLFxuICBcIndpdGhcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJ3aXRoXCIpLFxuICBcIm5ld1wiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcIm5ld1wiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIFwidGhpc1wiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcInRoaXNcIiwgeyBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBcInN1cGVyXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwic3VwZXJcIiwgeyBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBcImNsYXNzXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiY2xhc3NcIiksXG4gIFwiZXh0ZW5kc1wiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImV4dGVuZHNcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBcImV4cG9ydFwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImV4cG9ydFwiKSxcbiAgXCJpbXBvcnRcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJpbXBvcnRcIiwgeyBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBcInlpZWxkXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwieWllbGRcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBcIm51bGxcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJudWxsXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgXCJ0cnVlXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwidHJ1ZVwiLCB7IHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIFwiZmFsc2VcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJmYWxzZVwiLCB7IHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIFwiaW5cIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJpblwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIGJpbm9wOiA3IH0pLFxuICBcImluc3RhbmNlb2ZcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJpbnN0YW5jZW9mXCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgYmlub3A6IDcgfSksXG4gIFwidHlwZW9mXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwidHlwZW9mXCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgcHJlZml4OiBwcmVmaXgsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIFwidm9pZFwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcInZvaWRcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBwcmVmaXg6IHByZWZpeCwgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgXCJkZWxldGVcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJkZWxldGVcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBwcmVmaXg6IHByZWZpeCwgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KVxufTtcblxuLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5PYmplY3Qua2V5cyhrZXl3b3JkcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICB0eXBlc1tcIl9cIiArIG5hbWVdID0ga2V5d29yZHNbbmFtZV07XG59KTtcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbnZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIGlzTmV3TGluZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCBjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5O1xufVxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcblxuLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuLy8gZ2l2ZW4gcG9pbnQgaW4gdGhlIHByb2dyYW0gaXMgbG9vc2VseSBiYXNlZCBvbiBzd2VldC5qcycgYXBwcm9hY2guXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cblxudmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlKSB7XG4gIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRva0NvbnRleHQpO1xuXG4gIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG59O1xuXG52YXIgdHlwZXMkMSA9IHtcbiAgYnJhY2VTdGF0ZW1lbnQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJyYWNlRXhwcmVzc2lvbjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICB0ZW1wbGF0ZVF1YXNpOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIHRydWUpLFxuICBwYXJlblN0YXRlbWVudDogbmV3IFRva0NvbnRleHQoXCIoXCIsIGZhbHNlKSxcbiAgcGFyZW5FeHByZXNzaW9uOiBuZXcgVG9rQ29udGV4dChcIihcIiwgdHJ1ZSksXG4gIHRlbXBsYXRlOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5yZWFkVG1wbFRva2VuKCk7XG4gIH0pLFxuICBmdW5jdGlvbkV4cHJlc3Npb246IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSlcbn07XG5cbi8vIFRva2VuLXNwZWNpZmljIGNvbnRleHQgdXBkYXRlIGNvZGVcblxudHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3V0ID0gdGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpO1xuICBpZiAob3V0ID09PSB0eXBlcyQxLmJyYWNlU3RhdGVtZW50ICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLmZ1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgIHRoaXMuc3RhdGUuY29udGV4dC5wb3AoKTtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ID09PSB0eXBlcyQxLnRlbXBsYXRlUXVhc2kpIHtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG4gIH1cbn07XG5cbnR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG5cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fbGV0IHx8IHByZXZUeXBlID09PSB0eXBlcy5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzLl92YXIpIHtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLmVuZCkpKSB7XG4gICAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbnR5cGVzLmJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSB7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYnJhY2VTdGF0ZW1lbnQgOiB0eXBlcyQxLmJyYWNlRXhwcmVzc2lvbik7XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEudGVtcGxhdGVRdWFzaSk7XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcy5faWYgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2hpbGU7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzJDEucGFyZW5TdGF0ZW1lbnQgOiB0eXBlcyQxLnBhcmVuRXhwcmVzc2lvbik7XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHRva0V4cHJBbGxvd2VkIHN0YXlzIHVuY2hhbmdlZFxufTtcblxudHlwZXMuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdHlwZXMkMS5icmFjZVN0YXRlbWVudCkge1xuICAgIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEuZnVuY3Rpb25FeHByZXNzaW9uKTtcbiAgfVxuXG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEudGVtcGxhdGUpIHtcbiAgICB0aGlzLnN0YXRlLmNvbnRleHQucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2godHlwZXMkMS50ZW1wbGF0ZSk7XG4gIH1cbiAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxuLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4vLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zaXRpb24pO1xuXG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sO1xufTtcblxudmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24oc3RhcnQsIGVuZCkge1xuICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTb3VyY2VMb2NhdGlvbik7XG5cbiAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICB0aGlzLmVuZCA9IGVuZDtcbn07XG5cbi8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbi8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4vLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuLy8gaW50by5cblxuZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdGUoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGUpO1xuICB9XG5cbiAgU3RhdGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMsIGlucHV0KSB7XG4gICAgdGhpcy5zdHJpY3QgPSBvcHRpb25zLnN0cmljdE1vZGUgPT09IGZhbHNlID8gZmFsc2UgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG5cbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAgIHRoaXMuaW5NZXRob2QgPSB0aGlzLmluRnVuY3Rpb24gPSB0aGlzLmluR2VuZXJhdG9yID0gdGhpcy5pbkFzeW5jID0gdGhpcy5pblByb3BlcnR5TmFtZSA9IHRoaXMuaW5UeXBlID0gdGhpcy5pbkNsYXNzUHJvcGVydHkgPSB0aGlzLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcblxuICAgIHRoaXMuZGVjb3JhdG9ycyA9IFtdO1xuXG4gICAgdGhpcy50b2tlbnMgPSBbXTtcblxuICAgIHRoaXMuY29tbWVudHMgPSBbXTtcblxuICAgIHRoaXMudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgIHRoaXMubGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgdGhpcy5jb21tZW50U3RhY2sgPSBbXTtcblxuICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMuY3VyTGluZSA9IG9wdGlvbnMuc3RhcnRMaW5lO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gW3R5cGVzJDEuYnJhY2VTdGF0ZW1lbnRdO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNPY3RhbCA9IGZhbHNlO1xuICAgIHRoaXMub2N0YWxQb3NpdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLmludmFsaWRUZW1wbGF0ZUVzY2FwZVBvc2l0aW9uID0gbnVsbDtcblxuICAgIHRoaXMuZXhwb3J0ZWRJZGVudGlmaWVycyA9IFtdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVE9ET1xuXG5cbiAgLy8gVE9ET1xuXG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuXG5cbiAgLy8gRmxhZ3MgdG8gdHJhY2sgd2hldGhlciB3ZSBhcmUgaW4gYSBmdW5jdGlvbiwgYSBnZW5lcmF0b3IuXG5cblxuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG5cblxuICAvLyBMZWFkaW5nIGRlY29yYXRvcnMuXG5cblxuICAvLyBUb2tlbiBzdG9yZS5cblxuXG4gIC8vIENvbW1lbnQgc3RvcmUuXG5cblxuICAvLyBDb21tZW50IGF0dGFjaG1lbnQgc3RvcmVcblxuXG4gIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuXG5cbiAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgLy8gSXRzIHR5cGVcblxuXG4gIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcblxuXG4gIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuXG5cbiAgLy8gQW5kLCBpZiBsb2NhdGlvbnMgYXJlIHVzZWQsIHRoZSB7bGluZSwgY29sdW1ufSBvYmplY3RcbiAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG5cblxuICAvLyBQb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHByZXZpb3VzIHRva2VuXG5cblxuICAvLyBUaGUgY29udGV4dCBzdGFjayBpcyB1c2VkIHRvIHN1cGVyZmljaWFsbHkgdHJhY2sgc3ludGFjdGljXG4gIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAvLyBnaXZlbiBwb3NpdGlvbi5cblxuXG4gIC8vIFVzZWQgdG8gc2lnbmFsIHRvIGNhbGxlcnMgb2YgYHJlYWRXb3JkMWAgd2hldGhlciB0aGUgd29yZFxuICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAvLyBlc2NhcGUgc2VxdWVuY2VzIG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGtleXdvcmRzLlxuXG5cbiAgLy8gVE9ET1xuXG5cbiAgLy8gTmFtZXMgb2YgZXhwb3J0cyBzdG9yZS4gYGRlZmF1bHRgIGlzIHN0b3JlZCBhcyBhIG5hbWUgZm9yIGJvdGhcbiAgLy8gYGV4cG9ydCBkZWZhdWx0IGZvbztgIGFuZCBgZXhwb3J0IHsgZm9vIGFzIGRlZmF1bHQgfTtgLlxuXG5cbiAgU3RhdGUucHJvdG90eXBlLmN1clBvc2l0aW9uID0gZnVuY3Rpb24gY3VyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpO1xuICB9O1xuXG4gIFN0YXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKHNraXBBcnJheXMpIHtcbiAgICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgdmFyIHZhbCA9IHRoaXNba2V5XTtcblxuICAgICAgaWYgKCghc2tpcEFycmF5cyB8fCBrZXkgPT09IFwiY29udGV4dFwiKSAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsID0gdmFsLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGU7XG59KCk7XG5cbi8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbi8vIHNpbXBseSBleGlzdCBhcyBwcm9wZXJ0aWVzIG9uIHRoZSBwYXJzZXIgb2JqZWN0LiBUaGlzIGlzIG9ubHlcbi8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG52YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihzdGF0ZSkge1xuICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUb2tlbik7XG5cbiAgdGhpcy50eXBlID0gc3RhdGUudHlwZTtcbiAgdGhpcy52YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB0aGlzLnN0YXJ0ID0gc3RhdGUuc3RhcnQ7XG4gIHRoaXMuZW5kID0gc3RhdGUuZW5kO1xuICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihzdGF0ZS5zdGFydExvYywgc3RhdGUuZW5kTG9jKTtcbn07XG5cbi8vICMjIFRva2VuaXplclxuXG5mdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjb2RlKSB7XG4gIC8vIFVURi0xNiBEZWNvZGluZ1xuICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSAtIDB4MTAwMDAgPj4gMTApICsgMHhEODAwLCAoY29kZSAtIDB4MTAwMDAgJiAxMDIzKSArIDB4REMwMCk7XG4gIH1cbn1cblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9rZW5pemVyKG9wdGlvbnMsIGlucHV0KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9rZW5pemVyKTtcblxuICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB0aGlzLnN0YXRlLmluaXQob3B0aW9ucywgaW5wdXQpO1xuICB9XG5cbiAgLy8gTW92ZSB0byB0aGUgbmV4dCB0b2tlblxuXG4gIFRva2VuaXplci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB7XG4gICAgICB0aGlzLnN0YXRlLnRva2Vucy5wdXNoKG5ldyBUb2tlbih0aGlzLnN0YXRlKSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kID0gdGhpcy5zdGF0ZS5lbmQ7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyA9IHRoaXMuc3RhdGUuZW5kTG9jO1xuICAgIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9O1xuXG4gIC8vIFRPRE9cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCh0eXBlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZSkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVE9ET1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwZSA9PT0gdHlwZTtcbiAgfTtcblxuICAvLyBUT0RPXG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiBpc0tleXdvcmQkJDEod29yZCkge1xuICAgIHJldHVybiBpc0tleXdvcmQod29yZCk7XG4gIH07XG5cbiAgLy8gVE9ET1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkKCkge1xuICAgIHZhciBvbGQgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUgPSBvbGQuY2xvbmUodHJ1ZSk7XG5cbiAgICB0aGlzLmlzTG9va2FoZWFkID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmlzTG9va2FoZWFkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VyciA9IHRoaXMuc3RhdGUuY2xvbmUodHJ1ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IG9sZDtcbiAgICByZXR1cm4gY3VycjtcbiAgfTtcblxuICAvLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4gIC8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnNldFN0cmljdCA9IGZ1bmN0aW9uIHNldFN0cmljdChzdHJpY3QpIHtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IHN0cmljdDtcbiAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMubnVtKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5zdHJpbmcpKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMuc3RhdGUubGluZVN0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgdGhpcy5zdGF0ZS5saW5lU3RhcnQgLSAyKSArIDE7XG4gICAgICAtLXRoaXMuc3RhdGUuY3VyTGluZTtcbiAgICB9XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmN1ckNvbnRleHQgPSBmdW5jdGlvbiBjdXJDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnRleHRbdGhpcy5zdGF0ZS5jb250ZXh0Lmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIC8vIFJlYWQgYSBzaW5nbGUgdG9rZW4sIHVwZGF0aW5nIHRoZSBwYXJzZXIgb2JqZWN0J3MgdG9rZW4tcmVsYXRlZFxuICAvLyBwcm9wZXJ0aWVzLlxuXG4gIFRva2VuaXplci5wcm90b3R5cGUubmV4dFRva2VuID0gZnVuY3Rpb24gbmV4dFRva2VuKCkge1xuICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHRoaXMuc2tpcFNwYWNlKCk7XG5cbiAgICB0aGlzLnN0YXRlLmNvbnRhaW5zT2N0YWwgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLm9jdGFsUG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuc3RhdGUuc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLnN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZW9mKTtcblxuICAgIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7XG4gICAgICByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7XG4gICAgfVxuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZFRva2VuID0gZnVuY3Rpb24gcmVhZFRva2VuKGNvZGUpIHtcbiAgICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkV29yZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbiBmdWxsQ2hhckNvZGVBdFBvcygpIHtcbiAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKGNvZGUgPD0gMHhkN2ZmIHx8IGNvZGUgPj0gMHhlMDAwKSByZXR1cm4gY29kZTtcblxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDA7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5wdXNoQ29tbWVudCA9IGZ1bmN0aW9uIHB1c2hDb21tZW50KGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBibG9jayA/IFwiQ29tbWVudEJsb2NrXCIgOiBcIkNvbW1lbnRMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIGVuZExvYylcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB7XG4gICAgICB0aGlzLnN0YXRlLnRva2Vucy5wdXNoKGNvbW1lbnQpO1xuICAgICAgdGhpcy5zdGF0ZS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgdGhpcy5hZGRDb21tZW50KGNvbW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbiBza2lwQmxvY2tDb21tZW50KCkge1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB2YXIgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5zdGF0ZS5wb3MgKz0gMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpO1xuXG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBlbmQgKyAyO1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgdmFyIG1hdGNoID0gdm9pZCAwO1xuICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWModGhpcy5pbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdGhpcy5zdGF0ZS5wb3MpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2hDb21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5zdGF0ZS5wb3MsIHN0YXJ0TG9jLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24gc2tpcExpbmVDb21tZW50KHN0YXJ0U2tpcCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiBjaCAhPT0gMTAgJiYgY2ggIT09IDEzICYmIGNoICE9PSA4MjMyICYmIGNoICE9PSA4MjMzKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgIH1cblxuICAgIHRoaXMucHVzaENvbW1lbnQoZmFsc2UsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIHRoaXMuc3RhdGUucG9zKSwgc3RhcnQsIHRoaXMuc3RhdGUucG9zLCBzdGFydExvYywgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgfTtcblxuICAvLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4gIC8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5za2lwU3BhY2UgPSBmdW5jdGlvbiBza2lwU3BhY2UoKSB7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgMzI6Y2FzZSAxNjA6XG4gICAgICAgICAgLy8gJyAnXG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMTA6Y2FzZSA4MjMyOmNhc2UgODIzMzpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAvLyAnLydcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpKSB7XG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICAvLyAnKidcbiAgICAgICAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbiAgLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuICAvLyB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHN0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZVxuICAvLyByaWdodCBwb3NpdGlvbi5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmZpbmlzaFRva2VuID0gZnVuY3Rpb24gZmluaXNoVG9rZW4odHlwZSwgdmFsKSB7XG4gICAgdGhpcy5zdGF0ZS5lbmQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLmVuZExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgdGhpcy5zdGF0ZS50eXBlID0gdHlwZTtcbiAgICB0aGlzLnN0YXRlLnZhbHVlID0gdmFsO1xuXG4gICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgfTtcblxuICAvLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuICAvLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbiAgLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbiAgLy8gaW50byBpdC5cbiAgLy9cbiAgLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuICAvL1xuXG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24gcmVhZFRva2VuX2RvdCgpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmIG5leHQyID09PSA0Nikge1xuICAgICAgLy8gNDYgPSBkb3QgJy4nXG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAzO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZWxsaXBzaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KTtcbiAgICB9XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbiByZWFkVG9rZW5fc2xhc2goKSB7XG4gICAgLy8gJy8nXG4gICAgaWYgKHRoaXMuc3RhdGUuZXhwckFsbG93ZWQpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnNsYXNoLCAxKTtcbiAgICB9XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fbXVsdF9tb2R1bG8gPSBmdW5jdGlvbiByZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSkge1xuICAgIC8vICclKidcbiAgICB2YXIgdHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMuc3RhciA6IHR5cGVzLm1vZHVsbztcbiAgICB2YXIgd2lkdGggPSAxO1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICBpZiAobmV4dCA9PT0gNDIpIHtcbiAgICAgIC8vICcqJ1xuICAgICAgd2lkdGgrKztcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKTtcbiAgICAgIHR5cGUgPSB0eXBlcy5leHBvbmVudDtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICB0eXBlID0gdHlwZXMuYXNzaWduO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGUsIHdpZHRoKTtcbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKSB7XG4gICAgLy8gJ3wmJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKTtcbiAgICBpZiAoY29kZSA9PT0gMTI0ICYmIG5leHQgPT09IDEyNSAmJiB0aGlzLmhhc1BsdWdpbihcImZsb3dcIikpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJyYWNlQmFyUiwgMik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSk7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbiByZWFkVG9rZW5fY2FyZXQoKSB7XG4gICAgLy8gJ14nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpO1xuICAgIH1cbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKSB7XG4gICAgLy8gJystJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKG5leHQgPT09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhdGUubGFzdFRva0VuZCwgdGhpcy5zdGF0ZS5wb3MpKSkge1xuICAgICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5pbmNEZWMsIDIpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucGx1c01pbiwgMSk7XG4gICAgfVxuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24gcmVhZFRva2VuX2x0X2d0KGNvZGUpIHtcbiAgICAvLyAnPD4nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG5cbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIHNpemUpID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXRTaGlmdCwgc2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDMzICYmIGNvZGUgPT09IDYwICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA0NSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgLy8gPD0gfCA+PVxuICAgICAgc2l6ZSA9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSk7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpIHtcbiAgICAvLyAnPSEnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMik7XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyKSB7XG4gICAgICAvLyAnPT4nXG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYXJyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMucHJlZml4LCAxKTtcbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbiBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIC8vIFRoZSBpbnRlcnByZXRhdGlvbiBvZiBhIGRvdCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaXMgZm9sbG93ZWRcbiAgICAgIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgICAgIGNhc2UgNDY6XG4gICAgICAgIC8vICcuJ1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZG90KCk7XG5cbiAgICAgIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgICAgIGNhc2UgNDA6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5MKTtcbiAgICAgIGNhc2UgNDE6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKTtcbiAgICAgIGNhc2UgNTk6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc2VtaSk7XG4gICAgICBjYXNlIDQ0OlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbW1hKTtcbiAgICAgIGNhc2UgOTE6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldEwpO1xuICAgICAgY2FzZSA5MzpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztyZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0Uik7XG5cbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93XCIpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMjQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5icmFjZUJhckwsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VMKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDEyNTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztyZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpO1xuXG4gICAgICBjYXNlIDU4OlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmdW5jdGlvbkJpbmRcIikgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDU4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZG91YmxlQ29sb24sIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgNjM6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucXVlc3Rpb24pO1xuICAgICAgY2FzZSA2NDpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztyZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hdCk7XG5cbiAgICAgIGNhc2UgOTY6XG4gICAgICAgIC8vICdgJ1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpO1xuXG4gICAgICBjYXNlIDQ4OlxuICAgICAgICAvLyAnMCdcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KTsgLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpOyAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpOyAvLyAnMGInLCAnMEInIC0gYmluYXJ5IG51bWJlclxuICAgICAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gICAgICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICAgICAgY2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6XG4gICAgICAgIC8vIDEtOVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKTtcblxuICAgICAgLy8gUXVvdGVzIHByb2R1Y2Ugc3RyaW5ncy5cbiAgICAgIGNhc2UgMzQ6Y2FzZSAzOTpcbiAgICAgICAgLy8gJ1wiJywgXCInXCJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKTtcblxuICAgICAgLy8gT3BlcmF0b3JzIGFyZSBwYXJzZWQgaW5saW5lIGluIHRpbnkgc3RhdGUgbWFjaGluZXMuICc9JyAoNjEpIGlzXG4gICAgICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAgICAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgICAgIC8vIG9mIHRoZSB0eXBlIGdpdmVuIGJ5IGl0cyBmaXJzdCBhcmd1bWVudC5cblxuICAgICAgY2FzZSA0NzpcbiAgICAgICAgLy8gJy8nXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpO1xuXG4gICAgICBjYXNlIDM3OmNhc2UgNDI6XG4gICAgICAgIC8vICclKidcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpO1xuXG4gICAgICBjYXNlIDEyNDpjYXNlIDM4OlxuICAgICAgICAvLyAnfCYnXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKTtcblxuICAgICAgY2FzZSA5NDpcbiAgICAgICAgLy8gJ14nXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpO1xuXG4gICAgICBjYXNlIDQzOmNhc2UgNDU6XG4gICAgICAgIC8vICcrLSdcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpO1xuXG4gICAgICBjYXNlIDYwOmNhc2UgNjI6XG4gICAgICAgIC8vICc8PidcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpO1xuXG4gICAgICBjYXNlIDYxOmNhc2UgMzM6XG4gICAgICAgIC8vICc9ISdcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSk7XG5cbiAgICAgIGNhc2UgMTI2OlxuICAgICAgICAvLyAnfidcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucHJlZml4LCAxKTtcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUuZmluaXNoT3AgPSBmdW5jdGlvbiBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5wb3MsIHRoaXMuc3RhdGUucG9zICsgc2l6ZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uIHJlYWRSZWdleHAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgdmFyIGVzY2FwZWQgPSB2b2lkIDAsXG4gICAgICAgIGluQ2xhc3MgPSB2b2lkIDA7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHtcbiAgICAgICAgICBpbkNsYXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykge1xuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICB9XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAvLyBOZWVkIHRvIHVzZSBgcmVhZFdvcmQxYCBiZWNhdXNlICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWRcbiAgICAvLyBoZXJlIChkb24ndCBhc2spLlxuICAgIHZhciBtb2RzID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICBpZiAobW9kcykge1xuICAgICAgdmFyIHZhbGlkRmxhZ3MgPSAvXltnbXNpeXVdKiQvO1xuICAgICAgaWYgKCF2YWxpZEZsYWdzLnRlc3QobW9kcykpIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucmVnZXhwLCB7XG4gICAgICBwYXR0ZXJuOiBjb250ZW50LFxuICAgICAgZmxhZ3M6IG1vZHNcbiAgICB9KTtcbiAgfTtcblxuICAvLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuICAvLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuICAvLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRJbnQgPSBmdW5jdGlvbiByZWFkSW50KHJhZGl4LCBsZW4pIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB2YXIgdmFsID0gdm9pZCAwO1xuICAgICAgaWYgKGNvZGUgPj0gOTcpIHtcbiAgICAgICAgdmFsID0gY29kZSAtIDk3ICsgMTA7IC8vIGFcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA+PSA2NSkge1xuICAgICAgICB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgLy8gQVxuICAgICAgfSBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcbiAgICAgICAgdmFsID0gY29kZSAtIDQ4OyAvLyAwLTlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgYnJlYWs7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMuc3RhdGUucG9zIC0gc3RhcnQgIT09IGxlbikgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkUmFkaXhOdW1iZXIgPSBmdW5jdGlvbiByZWFkUmFkaXhOdW1iZXIocmFkaXgpIHtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSAyOyAvLyAweFxuICAgIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpO1xuICB9O1xuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciwgb2N0YWwgaW50ZWdlciwgb3IgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZE51bWJlciA9IGZ1bmN0aW9uIHJlYWROdW1iZXIoc3RhcnRzV2l0aERvdCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHZhciBvY3RhbCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4OyAvLyAnMCdcbiAgICB2YXIgaXNGbG9hdCA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgaWYgKG9jdGFsICYmIHRoaXMuc3RhdGUucG9zID09IHN0YXJ0ICsgMSkgb2N0YWwgPSBmYWxzZTsgLy8gbnVtYmVyID09PSAwXG5cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkge1xuICAgICAgLy8gJy4nXG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuXG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkge1xuICAgICAgLy8gJ2VFJ1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgKyt0aGlzLnN0YXRlLnBvczsgLy8gJystJ1xuICAgICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcblxuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgdmFyIHZhbCA9IHZvaWQgMDtcbiAgICBpZiAoaXNGbG9hdCkge1xuICAgICAgdmFsID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIH0gZWxzZSBpZiAoIW9jdGFsIHx8IHN0ci5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhbCA9IHBhcnNlSW50KHN0ciwgMTApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmICgvWzg5XS8udGVzdChzdHIpKSB7XG4gICAgICB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gcGFyc2VJbnQoc3RyLCA4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpO1xuICB9O1xuXG4gIC8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbiByZWFkQ29kZVBvaW50KHRocm93T25JbnZhbGlkKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB2YXIgY29kZSA9IHZvaWQgMDtcblxuICAgIGlmIChjaCA9PT0gMTIzKSB7XG4gICAgICAvLyAneydcbiAgICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5zdGF0ZS5wb3MpIC0gdGhpcy5zdGF0ZS5wb3MsIHRocm93T25JbnZhbGlkKTtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAtLXRoaXMuc3RhdGUuaW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zaXRpb247IC8vIHRvIHBvaW50IHRvIHRoZSAnXFwnJyBpbnN0ZWFkIG9mIHRoZSAndSdcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA+IDB4MTBGRkZGKSB7XG4gICAgICAgIGlmICh0aHJvd09uSW52YWxpZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3NpdGlvbiA9IGNvZGVQb3MgLSAyO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQsIHRocm93T25JbnZhbGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGU7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24gcmVhZFN0cmluZyhxdW90ZSkge1xuICAgIHZhciBvdXQgPSBcIlwiLFxuICAgICAgICBjaHVua1N0YXJ0ID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIGJyZWFrO1xuICAgICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAvLyAnXFwnXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcysrKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dCk7XG4gIH07XG5cbiAgLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbiByZWFkVG1wbFRva2VuKCkge1xuICAgIHZhciBvdXQgPSBcIlwiLFxuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3MsXG4gICAgICAgIGNvbnRhaW5zSW52YWxpZCA9IGZhbHNlO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTIzKSB7XG4gICAgICAgIC8vICdgJywgJyR7J1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUuc3RhcnQgJiYgdGhpcy5tYXRjaCh0eXBlcy50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIGNvbnRhaW5zSW52YWxpZCA/IG51bGwgOiBvdXQpO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAvLyAnXFwnXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgdmFyIGVzY2FwZWQgPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgICAgaWYgKGVzY2FwZWQgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250YWluc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBlc2NhcGVkO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgPT09IDEwKSArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24gcmVhZEVzY2FwZWRDaGFyKGluVGVtcGxhdGUpIHtcbiAgICB2YXIgdGhyb3dPbkludmFsaWQgPSAhaW5UZW1wbGF0ZTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG4gICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDExMDpcbiAgICAgICAgcmV0dXJuIFwiXFxuXCI7IC8vICduJyAtPiAnXFxuJ1xuICAgICAgY2FzZSAxMTQ6XG4gICAgICAgIHJldHVybiBcIlxcclwiOyAvLyAncicgLT4gJ1xccidcbiAgICAgIGNhc2UgMTIwOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gJ3gnXG4gICAgICAgICAgdmFyIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDIsIHRocm93T25JbnZhbGlkKTtcbiAgICAgICAgICByZXR1cm4gY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDExNzpcbiAgICAgICAge1xuICAgICAgICAgIC8vICd1J1xuICAgICAgICAgIHZhciBfY29kZSA9IHRoaXMucmVhZENvZGVQb2ludCh0aHJvd09uSW52YWxpZCk7XG4gICAgICAgICAgcmV0dXJuIF9jb2RlID09PSBudWxsID8gbnVsbCA6IGNvZGVQb2ludFRvU3RyaW5nKF9jb2RlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMTY6XG4gICAgICAgIHJldHVybiBcIlxcdFwiOyAvLyAndCcgLT4gJ1xcdCdcbiAgICAgIGNhc2UgOTg6XG4gICAgICAgIHJldHVybiBcIlxcYlwiOyAvLyAnYicgLT4gJ1xcYidcbiAgICAgIGNhc2UgMTE4OlxuICAgICAgICByZXR1cm4gXCJcXHgwQlwiOyAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgICBjYXNlIDEwMjpcbiAgICAgICAgcmV0dXJuIFwiXFxmXCI7IC8vICdmJyAtPiAnXFxmJ1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgPT09IDEwKSArK3RoaXMuc3RhdGUucG9zOyAvLyAnXFxyXFxuJ1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgLy8gJyBcXG4nXG4gICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICAgIHZhciBjb2RlUG9zID0gdGhpcy5zdGF0ZS5wb3MgLSAxO1xuICAgICAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMuc3RhdGUucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2N0YWwgPiAwKSB7XG4gICAgICAgICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmludmFsaWRUZW1wbGF0ZUVzY2FwZVBvc2l0aW9uID0gY29kZVBvcztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuc3RyaWN0KSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UoY29kZVBvcywgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5zdGF0ZS5jb250YWluc09jdGFsKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYXJlIG9ubHkgdXNlZCB0byB0aHJvdyBhbiBlcnJvciBmb3IgYW4gb2N0YWwgd2hpY2ggb2NjdXJzXG4gICAgICAgICAgICAgIC8vIGluIGEgZGlyZWN0aXZlIHdoaWNoIG9jY3VycyBwcmlvciB0byBhIFwidXNlIHN0cmljdFwiIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jb250YWluc09jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5vY3RhbFBvc2l0aW9uID0gY29kZVBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JykuXG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uIHJlYWRIZXhDaGFyKGxlbiwgdGhyb3dPbkludmFsaWQpIHtcbiAgICB2YXIgY29kZVBvcyA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICAgIGlmIChuID09PSBudWxsKSB7XG4gICAgICBpZiAodGhyb3dPbkludmFsaWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgPSBjb2RlUG9zIC0gMTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3NpdGlvbiA9IGNvZGVQb3MgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfTtcblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYHRoaXMuc3RhdGUuY29udGFpbnNFc2NgXG4gIC8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuICAvL1xuICAvLyBJbmNyZW1lbnRhbGx5IGFkZHMgb25seSBlc2NhcGVkIGNoYXJzLCBhZGRpbmcgb3RoZXIgY2h1bmtzIGFzLWlzXG4gIC8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZFdvcmQxID0gZnVuY3Rpb24gcmVhZFdvcmQxKCkge1xuICAgIHRoaXMuc3RhdGUuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICB2YXIgd29yZCA9IFwiXCIsXG4gICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAvLyBcIlxcXCJcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250YWluc0VzYyA9IHRydWU7XG5cbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKSAhPT0gMTE3KSB7XG4gICAgICAgICAgLy8gXCJ1XCJcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7XG4gICAgICAgIH1cblxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KHRydWUpO1xuICAgICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmcoZXNjKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICB9O1xuXG4gIC8vIFJlYWQgYW4gaWRlbnRpZmllciBvciBrZXl3b3JkIHRva2VuLiBXaWxsIGNoZWNrIGZvciByZXNlcnZlZFxuICAvLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRXb3JkID0gZnVuY3Rpb24gcmVhZFdvcmQoKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIHZhciB0eXBlID0gdHlwZXMubmFtZTtcbiAgICBpZiAoIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgJiYgdGhpcy5pc0tleXdvcmQod29yZCkpIHtcbiAgICAgIHR5cGUgPSBrZXl3b3Jkc1t3b3JkXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZCk7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbiBicmFjZUlzQmxvY2socHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgICBpZiAocGFyZW50ID09PSB0eXBlcyQxLmJyYWNlU3RhdGVtZW50IHx8IHBhcmVudCA9PT0gdHlwZXMkMS5icmFjZUV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuICFwYXJlbnQuaXNFeHByO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybikge1xuICAgICAgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCB0aGlzLnN0YXRlLnN0YXJ0KSk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZWxzZSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuZW9mIHx8IHByZXZUeXBlID09PSB0eXBlcy5wYXJlblIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEuYnJhY2VTdGF0ZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLnN0YXRlLmV4cHJBbGxvd2VkO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQocHJldlR5cGUpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICB2YXIgdXBkYXRlID0gdm9pZCAwO1xuXG4gICAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMuZG90KSB7XG4gICAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpIHtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRva2VuaXplcjtcbn0oKTtcblxudmFyIHBsdWdpbnMgPSB7fTtcbnZhciBmcm96ZW5EZXByZWNhdGVkV2lsZGNhcmRQbHVnaW5MaXN0ID0gW1wianN4XCIsIFwiZG9FeHByZXNzaW9uc1wiLCBcIm9iamVjdFJlc3RTcHJlYWRcIiwgXCJkZWNvcmF0b3JzXCIsIFwiY2xhc3NQcm9wZXJ0aWVzXCIsIFwiZXhwb3J0RXh0ZW5zaW9uc1wiLCBcImFzeW5jR2VuZXJhdG9yc1wiLCBcImZ1bmN0aW9uQmluZFwiLCBcImZ1bmN0aW9uU2VudFwiLCBcImR5bmFtaWNJbXBvcnRcIiwgXCJmbG93XCJdO1xuXG52YXIgUGFyc2VyID0gZnVuY3Rpb24gKF9Ub2tlbml6ZXIpIHtcbiAgaW5oZXJpdHMoUGFyc2VyLCBfVG9rZW5pemVyKTtcblxuICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJzZXIpO1xuXG4gICAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Ub2tlbml6ZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBpbnB1dCkpO1xuXG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgX3RoaXMuaW5Nb2R1bGUgPSBfdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgX3RoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICBfdGhpcy5wbHVnaW5zID0gX3RoaXMubG9hZFBsdWdpbnMoX3RoaXMub3B0aW9ucy5wbHVnaW5zKTtcbiAgICBfdGhpcy5maWxlbmFtZSA9IG9wdGlvbnMuc291cmNlRmlsZW5hbWU7XG5cbiAgICAvLyBJZiBlbmFibGVkLCBza2lwIGxlYWRpbmcgaGFzaGJhbmcgbGluZS5cbiAgICBpZiAoX3RoaXMuc3RhdGUucG9zID09PSAwICYmIF90aGlzLmlucHV0WzBdID09PSBcIiNcIiAmJiBfdGhpcy5pbnB1dFsxXSA9PT0gXCIhXCIpIHtcbiAgICAgIF90aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5pc1Jlc2VydmVkV29yZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkKHdvcmQpIHtcbiAgICBpZiAod29yZCA9PT0gXCJhd2FpdFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbk1vZHVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc2VydmVkV29yZHNbNl0od29yZCk7XG4gICAgfVxuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuaGFzUGx1Z2luID0gZnVuY3Rpb24gaGFzUGx1Z2luKG5hbWUpIHtcbiAgICBpZiAodGhpcy5wbHVnaW5zW1wiKlwiXSAmJiBmcm96ZW5EZXByZWNhdGVkV2lsZGNhcmRQbHVnaW5MaXN0LmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhdGhpcy5wbHVnaW5zW25hbWVdO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIGYpIHtcbiAgICB0aGlzW25hbWVdID0gZih0aGlzW25hbWVdKTtcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmxvYWRBbGxQbHVnaW5zID0gZnVuY3Rpb24gbG9hZEFsbFBsdWdpbnMoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBlbnN1cmUgZmxvdyBwbHVnaW4gbG9hZHMgbGFzdCwgYWxzbyBlbnN1cmUgZXN0cmVlIGlzIG5vdCBsb2FkZWQgd2l0aCAqXG4gICAgdmFyIHBsdWdpbk5hbWVzID0gT2JqZWN0LmtleXMocGx1Z2lucykuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAhPT0gXCJmbG93XCIgJiYgbmFtZSAhPT0gXCJlc3RyZWVcIjtcbiAgICB9KTtcbiAgICBwbHVnaW5OYW1lcy5wdXNoKFwiZmxvd1wiKTtcblxuICAgIHBsdWdpbk5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW25hbWVdO1xuICAgICAgaWYgKHBsdWdpbikgcGx1Z2luKF90aGlzMik7XG4gICAgfSk7XG4gIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5sb2FkUGx1Z2lucyA9IGZ1bmN0aW9uIGxvYWRQbHVnaW5zKHBsdWdpbkxpc3QpIHtcbiAgICAvLyBUT0RPOiBEZXByZWNhdGUgXCIqXCIgb3B0aW9uIGluIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBCYWJ5bG9uXG4gICAgaWYgKHBsdWdpbkxpc3QuaW5kZXhPZihcIipcIikgPj0gMCkge1xuICAgICAgdGhpcy5sb2FkQWxsUGx1Z2lucygpO1xuXG4gICAgICByZXR1cm4geyBcIipcIjogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5NYXAgPSB7fTtcblxuICAgIGlmIChwbHVnaW5MaXN0LmluZGV4T2YoXCJmbG93XCIpID49IDApIHtcbiAgICAgIC8vIGVuc3VyZSBmbG93IHBsdWdpbiBsb2FkcyBsYXN0XG4gICAgICBwbHVnaW5MaXN0ID0gcGx1Z2luTGlzdC5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luICE9PSBcImZsb3dcIjtcbiAgICAgIH0pO1xuICAgICAgcGx1Z2luTGlzdC5wdXNoKFwiZmxvd1wiKTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luTGlzdC5pbmRleE9mKFwiZXN0cmVlXCIpID49IDApIHtcbiAgICAgIC8vIGVuc3VyZSBlc3RyZWUgcGx1Z2luIGxvYWRzIGZpcnN0XG4gICAgICBwbHVnaW5MaXN0ID0gcGx1Z2luTGlzdC5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luICE9PSBcImVzdHJlZVwiO1xuICAgICAgfSk7XG4gICAgICBwbHVnaW5MaXN0LnVuc2hpZnQoXCJlc3RyZWVcIik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcGx1Z2luTGlzdCwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBfcmVmO1xuXG4gICAgICBpZiAoIXBsdWdpbk1hcFtuYW1lXSkge1xuICAgICAgICBwbHVnaW5NYXBbbmFtZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW25hbWVdO1xuICAgICAgICBpZiAocGx1Z2luKSBwbHVnaW4odGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbk1hcDtcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgdmFyIGZpbGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBwcm9ncmFtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn0oVG9rZW5pemVyKTtcblxudmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG4vLyBUT0RPXG5cbnBwLmFkZEV4dHJhID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gIHZhciBleHRyYSA9IG5vZGUuZXh0cmEgPSBub2RlLmV4dHJhIHx8IHt9O1xuICBleHRyYVtrZXldID0gdmFsO1xufTtcblxuLy8gVE9ET1xuXG5wcC5pc1JlbGF0aW9uYWwgPSBmdW5jdGlvbiAob3ApIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMucmVsYXRpb25hbCkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gb3A7XG59O1xuXG4vLyBUT0RPXG5cbnBwLmV4cGVjdFJlbGF0aW9uYWwgPSBmdW5jdGlvbiAob3ApIHtcbiAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKG9wKSkge1xuICAgIHRoaXMubmV4dCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudW5leHBlY3RlZChudWxsLCB0eXBlcy5yZWxhdGlvbmFsKTtcbiAgfVxufTtcblxuLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IG5hbWU7XG59O1xuXG4vLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbnBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5zdGF0ZS52YWx1ZSA9PT0gbmFtZSAmJiB0aGlzLmVhdCh0eXBlcy5uYW1lKTtcbn07XG5cbi8vIEFzc2VydHMgdGhhdCBmb2xsb3dpbmcgdG9rZW4gaXMgZ2l2ZW4gY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24gKG5hbWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHRoaXMudW5leHBlY3RlZChudWxsLCBtZXNzYWdlKTtcbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIHNlbWljb2xvbiBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbnBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMuZW9mKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmJyYWNlUikgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsIHRoaXMuc3RhdGUuc3RhcnQpKTtcbn07XG5cbi8vIFRPRE9cblxucHAuaXNMaW5lVGVybWluYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG59O1xuXG4vLyBDb25zdW1lIGEgc2VtaWNvbG9uLCBvciwgZmFpbGluZyB0aGF0LCBzZWUgaWYgd2UgYXJlIGFsbG93ZWQgdG9cbi8vIHByZXRlbmQgdGhhdCB0aGVyZSBpcyBhIHNlbWljb2xvbiBhdCB0aGlzIHBvc2l0aW9uLlxuXG5wcC5zZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHRoaXMudW5leHBlY3RlZChudWxsLCB0eXBlcy5zZW1pKTtcbn07XG5cbi8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbi8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IgYXQgZ2l2ZW4gcG9zLlxuXG5wcC5leHBlY3QgPSBmdW5jdGlvbiAodHlwZSwgcG9zKSB7XG4gIHJldHVybiB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQocG9zLCB0eXBlKTtcbn07XG5cbi8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuIENhbiB0YWtlIHRoZSBleHBlY3RlZCB0b2tlbiB0eXBlXG4vLyBpbnN0ZWFkIG9mIGEgbWVzc2FnZSBzdHJpbmcuXG5cbnBwLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbiAocG9zKSB7XG4gIHZhciBtZXNzYWdlT3JUeXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlVuZXhwZWN0ZWQgdG9rZW5cIjtcblxuICBpZiAobWVzc2FnZU9yVHlwZSAmJiAodHlwZW9mIG1lc3NhZ2VPclR5cGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihtZXNzYWdlT3JUeXBlKSkgPT09IFwib2JqZWN0XCIgJiYgbWVzc2FnZU9yVHlwZS5sYWJlbCkge1xuICAgIG1lc3NhZ2VPclR5cGUgPSBcIlVuZXhwZWN0ZWQgdG9rZW4sIGV4cGVjdGVkIFwiICsgbWVzc2FnZU9yVHlwZS5sYWJlbDtcbiAgfVxuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGF0ZS5zdGFydCwgbWVzc2FnZU9yVHlwZSk7XG59O1xuXG4vKiBlc2xpbnQgbWF4LWxlbjogMCAqL1xuXG52YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vICMjIyBTdGF0ZW1lbnQgcGFyc2luZ1xuXG4vLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2Zcbi8vIHN0YXRlbWVudHMsIGFuZCB3cmFwcyB0aGVtIGluIGEgUHJvZ3JhbSBub2RlLiAgT3B0aW9uYWxseSB0YWtlcyBhXG4vLyBgcHJvZ3JhbWAgYXJndW1lbnQuICBJZiBwcmVzZW50LCB0aGUgc3RhdGVtZW50cyB3aWxsIGJlIGFwcGVuZGVkXG4vLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbnBwJDEucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChmaWxlLCBwcm9ncmFtKSB7XG4gIHByb2dyYW0uc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuXG4gIHRoaXMucGFyc2VCbG9ja0JvZHkocHJvZ3JhbSwgdHJ1ZSwgdHJ1ZSwgdHlwZXMuZW9mKTtcblxuICBmaWxlLnByb2dyYW0gPSB0aGlzLmZpbmlzaE5vZGUocHJvZ3JhbSwgXCJQcm9ncmFtXCIpO1xuICBmaWxlLmNvbW1lbnRzID0gdGhpcy5zdGF0ZS5jb21tZW50cztcbiAgZmlsZS50b2tlbnMgPSB0aGlzLnN0YXRlLnRva2VucztcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGZpbGUsIFwiRmlsZVwiKTtcbn07XG5cbnZhciBsb29wTGFiZWwgPSB7IGtpbmQ6IFwibG9vcFwiIH07XG52YXIgc3dpdGNoTGFiZWwgPSB7IGtpbmQ6IFwic3dpdGNoXCIgfTtcblxuLy8gVE9ET1xuXG5wcCQxLnN0bXRUb0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChzdG10KSB7XG4gIHZhciBleHByID0gc3RtdC5leHByZXNzaW9uO1xuXG4gIHZhciBkaXJlY3RpdmVMaXRlcmFsID0gdGhpcy5zdGFydE5vZGVBdChleHByLnN0YXJ0LCBleHByLmxvYy5zdGFydCk7XG4gIHZhciBkaXJlY3RpdmUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0bXQuc3RhcnQsIHN0bXQubG9jLnN0YXJ0KTtcblxuICB2YXIgcmF3ID0gdGhpcy5pbnB1dC5zbGljZShleHByLnN0YXJ0LCBleHByLmVuZCk7XG4gIHZhciB2YWwgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlID0gcmF3LnNsaWNlKDEsIC0xKTsgLy8gcmVtb3ZlIHF1b3Rlc1xuXG4gIHRoaXMuYWRkRXh0cmEoZGlyZWN0aXZlTGl0ZXJhbCwgXCJyYXdcIiwgcmF3KTtcbiAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcInJhd1ZhbHVlXCIsIHZhbCk7XG5cbiAgZGlyZWN0aXZlLnZhbHVlID0gdGhpcy5maW5pc2hOb2RlQXQoZGlyZWN0aXZlTGl0ZXJhbCwgXCJEaXJlY3RpdmVMaXRlcmFsXCIsIGV4cHIuZW5kLCBleHByLmxvYy5lbmQpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChkaXJlY3RpdmUsIFwiRGlyZWN0aXZlXCIsIHN0bXQuZW5kLCBzdG10LmxvYy5lbmQpO1xufTtcblxuLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuLy9cbi8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbylgLCB3aGVyZSBsb29raW5nIGF0IHRoZSBwcmV2aW91cyB0b2tlblxuLy8gZG9lcyBub3QgaGVscC5cblxucHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbiwgdG9wTGV2ZWwpIHtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuYXQpKSB7XG4gICAgdGhpcy5wYXJzZURlY29yYXRvcnModHJ1ZSk7XG4gIH1cblxuICB2YXIgc3RhcnR0eXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgLy8gTW9zdCB0eXBlcyBvZiBzdGF0ZW1lbnRzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSBrZXl3b3JkIHRoZXlcbiAgLy8gc3RhcnQgd2l0aC4gTWFueSBhcmUgdHJpdmlhbCB0byBwYXJzZSwgc29tZSByZXF1aXJlIGEgYml0IG9mXG4gIC8vIGNvbXBsZXhpdHkuXG5cbiAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl9icmVhazpjYXNlIHR5cGVzLl9jb250aW51ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZCk7XG4gICAgY2FzZSB0eXBlcy5fZGVidWdnZXI6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX2RvOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIHR5cGVzLl9mb3I6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAgIGlmICghZGVjbGFyYXRpb24pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlKTtcblxuICAgIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgICAgaWYgKCFkZWNsYXJhdGlvbikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpO1xuXG4gICAgY2FzZSB0eXBlcy5faWY6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX3JldHVybjpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX3N3aXRjaDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX3Rocm93OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIHR5cGVzLl90cnk6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKTtcblxuICAgIGNhc2UgdHlwZXMuX2xldDpcbiAgICBjYXNlIHR5cGVzLl9jb25zdDpcbiAgICAgIGlmICghZGVjbGFyYXRpb24pIHRoaXMudW5leHBlY3RlZCgpOyAvLyBOT1RFOiBmYWxscyB0aHJvdWdoIHRvIF92YXJcblxuICAgIGNhc2UgdHlwZXMuX3ZhcjpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZSk7XG5cbiAgICBjYXNlIHR5cGVzLl93aGlsZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSB0eXBlcy5fd2l0aDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICBjYXNlIHR5cGVzLnNlbWk6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX2V4cG9ydDpcbiAgICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkeW5hbWljSW1wb3J0XCIpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMucGFyZW5MKSBicmVhaztcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICAgIGlmICghdG9wTGV2ZWwpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogXFxcIm1vZHVsZVxcXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSk7XG5cbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJhc3luY1wiKSB7XG4gICAgICAgIC8vIHBlZWsgYWhlYWQgYW5kIHNlZSBpZiBuZXh0IHRva2VuIGlzIGEgZnVuY3Rpb25cbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2Z1bmN0aW9uKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLl9mdW5jdGlvbik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdGF0ZW1lbnQga2V5d29yZCBvciBhXG4gIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAvLyBuZXh0IHRva2VuIGlzIGEgY29sb24gYW5kIHRoZSBleHByZXNzaW9uIHdhcyBhIHNpbXBsZVxuICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgdmFyIG1heWJlTmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcy5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpO1xuICB9XG59O1xuXG5wcCQxLnRha2VEZWNvcmF0b3JzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICBub2RlLmRlY29yYXRvcnMgPSB0aGlzLnN0YXRlLmRlY29yYXRvcnM7XG4gICAgdGhpcy5zdGF0ZS5kZWNvcmF0b3JzID0gW107XG4gIH1cbn07XG5cbnBwJDEucGFyc2VEZWNvcmF0b3JzID0gZnVuY3Rpb24gKGFsbG93RXhwb3J0KSB7XG4gIHdoaWxlICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgIHZhciBkZWNvcmF0b3IgPSB0aGlzLnBhcnNlRGVjb3JhdG9yKCk7XG4gICAgdGhpcy5zdGF0ZS5kZWNvcmF0b3JzLnB1c2goZGVjb3JhdG9yKTtcbiAgfVxuXG4gIGlmIChhbGxvd0V4cG9ydCAmJiB0aGlzLm1hdGNoKHR5cGVzLl9leHBvcnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLl9jbGFzcykpIHtcbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiTGVhZGluZyBkZWNvcmF0b3JzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBjbGFzcyBkZWNsYXJhdGlvblwiKTtcbiAgfVxufTtcblxucHAkMS5wYXJzZURlY29yYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY29yYXRvclwiKTtcbn07XG5cbnBwJDEucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIGtleXdvcmQpIHtcbiAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gIHRoaXMubmV4dCgpO1xuXG4gIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgIG5vZGUubGFiZWwgPSBudWxsO1xuICB9IGVsc2UgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGFuIGFjdHVhbCBkZXN0aW5hdGlvbiB0byBicmVhayBvclxuICAvLyBjb250aW51ZSB0by5cbiAgdmFyIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsYWIgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcbiAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIGJyZWFrO1xuICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpID09PSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGgpIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpO1xufTtcblxucHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB0aGlzLmVhdCh0eXBlcy5zZW1pKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIik7XG59O1xuXG4vLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4vLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbi8vIHN0YXRlbWVudCBvciBleHByZXNzaW9uLCBkaXNhbGxvd2luZyB0aGUgYGluYCBvcGVyYXRvciAoc2VlXG4vLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4vLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4vLyBwYXJ0IChzZW1pY29sb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMpLCBpdFxuLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbnBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuXG4gIHZhciBmb3JBd2FpdCA9IGZhbHNlO1xuICBpZiAodGhpcy5oYXNQbHVnaW4oXCJhc3luY0dlbmVyYXRvcnNcIikgJiYgdGhpcy5zdGF0ZS5pbkFzeW5jICYmIHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikpIHtcbiAgICBmb3JBd2FpdCA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5zZW1pKSkge1xuICAgIGlmIChmb3JBd2FpdCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpO1xuICB9XG5cbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuX3ZhcikgfHwgdGhpcy5tYXRjaCh0eXBlcy5fbGV0KSB8fCB0aGlzLm1hdGNoKHR5cGVzLl9jb25zdCkpIHtcbiAgICB2YXIgX2luaXQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciB2YXJLaW5kID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoX2luaXQsIHRydWUsIHZhcktpbmQpO1xuICAgIHRoaXMuZmluaXNoTm9kZShfaW5pdCwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2luKSB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSB7XG4gICAgICBpZiAoX2luaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiAhX2luaXQuZGVjbGFyYXRpb25zWzBdLmluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBfaW5pdCwgZm9yQXdhaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9yQXdhaXQpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBfaW5pdCk7XG4gIH1cblxuICB2YXIgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcyA9IHsgc3RhcnQ6IDAgfTtcbiAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2luKSB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSA/IFwiZm9yLW9mIHN0YXRlbWVudFwiIDogXCJmb3ItaW4gc3RhdGVtZW50XCI7XG4gICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgdW5kZWZpbmVkLCBkZXNjcmlwdGlvbik7XG4gICAgdGhpcy5jaGVja0xWYWwoaW5pdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQsIGZvckF3YWl0KTtcbiAgfSBlbHNlIGlmIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpO1xuICB9XG4gIGlmIChmb3JBd2FpdCkge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpO1xufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgdHJ1ZSk7XG59O1xuXG5wcCQxLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKTtcbiAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIXRoaXMuc3RhdGUuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSB7XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7XG4gIH1cblxuICB0aGlzLm5leHQoKTtcblxuICAvLyBJbiBgcmV0dXJuYCAoYW5kIGBicmVha2AvYGNvbnRpbnVlYCksIHRoZSBrZXl3b3JkcyB3aXRoXG4gIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuY2FzZXMgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG5cbiAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gIHZhciBjdXIgPSB2b2lkIDA7XG4gIGZvciAodmFyIHNhd0RlZmF1bHQ7ICF0aGlzLm1hdGNoKHR5cGVzLmJyYWNlUik7KSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2Nhc2UpIHx8IHRoaXMubWF0Y2godHlwZXMuX2RlZmF1bHQpKSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcy5tYXRjaCh0eXBlcy5fY2FzZSk7XG4gICAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzYXdEZWZhdWx0KSB0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTtcbiAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cikge1xuICAgICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQodHJ1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjdXIpIHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTtcbiAgdGhpcy5uZXh0KCk7IC8vIENsb3NpbmcgYnJhY2VcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIik7XG59O1xuXG5wcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCB0aGlzLnN0YXRlLnN0YXJ0KSkpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcbn07XG5cbi8vIFJldXNlZCBlbXB0eSBhcnJheSBhZGRlZCBmb3Igbm9kZSBmaWVsZHMgdGhhdCBhcmUgYWx3YXlzIGVtcHR5LlxuXG52YXIgZW1wdHkgPSBbXTtcblxucHAkMS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgbm9kZS5oYW5kbGVyID0gbnVsbDtcblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fY2F0Y2gpKSB7XG4gICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgdHJ1ZSwgT2JqZWN0LmNyZWF0ZShudWxsKSwgXCJjYXRjaCBjbGF1c2VcIik7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgfVxuXG4gIG5vZGUuZ3VhcmRlZEhhbmRsZXJzID0gZW1wdHk7XG4gIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuXG4gIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikge1xuICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwga2luZCkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xufTtcblxucHAkMS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKTtcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0KSB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG59O1xuXG5wcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBtYXliZU5hbWUsIGV4cHIpIHtcbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5zdGF0ZS5sYWJlbHMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgX2xhYmVsID0gX3JlZjtcblxuICAgIGlmIChfbGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKSB7XG4gICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGtpbmQgPSB0aGlzLnN0YXRlLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLm1hdGNoKHR5cGVzLl9zd2l0Y2gpID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gIGZvciAodmFyIGkgPSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWxzW2ldO1xuICAgIGlmIChsYWJlbC5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgbGFiZWwuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgbGFiZWwua2luZCA9IGtpbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuc3RhdGUubGFiZWxzLnB1c2goeyBuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXRlLnN0YXJ0IH0pO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUpO1xuICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xufTtcblxucHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgZXhwcikge1xuICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbn07XG5cbi8vIFBhcnNlIGEgc2VtaWNvbG9uLWVuY2xvc2VkIGJsb2NrIG9mIHN0YXRlbWVudHMsIGhhbmRsaW5nIGBcInVzZVxuLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3Jcbi8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbnBwJDEucGFyc2VCbG9jayA9IGZ1bmN0aW9uIChhbGxvd0RpcmVjdGl2ZXMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB0aGlzLnBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgZmFsc2UsIHR5cGVzLmJyYWNlUik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEuaXNWYWxpZERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChzdG10KSB7XG4gIHJldHVybiBzdG10LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiAmJiAhc3RtdC5leHByZXNzaW9uLmV4dHJhLnBhcmVudGhlc2l6ZWQ7XG59O1xuXG5wcCQxLnBhcnNlQmxvY2tCb2R5ID0gZnVuY3Rpb24gKG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCkge1xuICBub2RlLmJvZHkgPSBbXTtcbiAgbm9kZS5kaXJlY3RpdmVzID0gW107XG5cbiAgdmFyIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IGZhbHNlO1xuICB2YXIgb2xkU3RyaWN0ID0gdm9pZCAwO1xuICB2YXIgb2N0YWxQb3NpdGlvbiA9IHZvaWQgMDtcblxuICB3aGlsZSAoIXRoaXMuZWF0KGVuZCkpIHtcbiAgICBpZiAoIXBhcnNlZE5vbkRpcmVjdGl2ZSAmJiB0aGlzLnN0YXRlLmNvbnRhaW5zT2N0YWwgJiYgIW9jdGFsUG9zaXRpb24pIHtcbiAgICAgIG9jdGFsUG9zaXRpb24gPSB0aGlzLnN0YXRlLm9jdGFsUG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUsIHRvcExldmVsKTtcblxuICAgIGlmIChhbGxvd0RpcmVjdGl2ZXMgJiYgIXBhcnNlZE5vbkRpcmVjdGl2ZSAmJiB0aGlzLmlzVmFsaWREaXJlY3RpdmUoc3RtdCkpIHtcbiAgICAgIHZhciBkaXJlY3RpdmUgPSB0aGlzLnN0bXRUb0RpcmVjdGl2ZShzdG10KTtcbiAgICAgIG5vZGUuZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XG5cbiAgICAgIGlmIChvbGRTdHJpY3QgPT09IHVuZGVmaW5lZCAmJiBkaXJlY3RpdmUudmFsdWUudmFsdWUgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgICAgIG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgICAgICB0aGlzLnNldFN0cmljdCh0cnVlKTtcblxuICAgICAgICBpZiAob2N0YWxQb3NpdGlvbikge1xuICAgICAgICAgIHRoaXMucmFpc2Uob2N0YWxQb3NpdGlvbiwgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IHRydWU7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cblxuICBpZiAob2xkU3RyaWN0ID09PSBmYWxzZSkge1xuICAgIHRoaXMuc2V0U3RyaWN0KGZhbHNlKTtcbiAgfVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbiAobm9kZSwgaW5pdCkge1xuICBub2RlLmluaXQgPSBpbml0O1xuICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5tYXRjaCh0eXBlcy5zZW1pKSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgbm9kZS51cGRhdGUgPSB0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpO1xufTtcblxuLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3Rcbi8vIHNhbWUgZnJvbSBwYXJzZXIncyBwZXJzcGVjdGl2ZS5cblxucHAkMS5wYXJzZUZvckluID0gZnVuY3Rpb24gKG5vZGUsIGluaXQsIGZvckF3YWl0KSB7XG4gIHZhciB0eXBlID0gdm9pZCAwO1xuICBpZiAoZm9yQXdhaXQpIHtcbiAgICB0aGlzLmVhdENvbnRleHR1YWwoXCJvZlwiKTtcbiAgICB0eXBlID0gXCJGb3JBd2FpdFN0YXRlbWVudFwiO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSB0aGlzLm1hdGNoKHR5cGVzLl9pbikgPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCI7XG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbnBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbiAobm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgbm9kZS5raW5kID0ga2luZC5rZXl3b3JkO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMucGFyc2VWYXJIZWFkKGRlY2wpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lcSkpIHtcbiAgICAgIGRlY2wuaW5pdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihpc0Zvcik7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSB0eXBlcy5fY29uc3QgJiYgISh0aGlzLm1hdGNoKHR5cGVzLl9pbikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLm1hdGNoKHR5cGVzLl9pbikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSBicmVhaztcbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5cbnBwJDEucGFyc2VWYXJIZWFkID0gZnVuY3Rpb24gKGRlY2wpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCB0cnVlLCB1bmRlZmluZWQsIFwidmFyaWFibGUgZGVjbGFyYXRpb25cIik7XG59O1xuXG4vLyBQYXJzZSBhIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cblxucHAkMS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc0FzeW5jLCBvcHRpb25hbElkKSB7XG4gIHZhciBvbGRJbk1ldGhvZCA9IHRoaXMuc3RhdGUuaW5NZXRob2Q7XG4gIHRoaXMuc3RhdGUuaW5NZXRob2QgPSBmYWxzZTtcblxuICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5zdGFyKSkge1xuICAgIGlmIChub2RlLmFzeW5jICYmICF0aGlzLmhhc1BsdWdpbihcImFzeW5jR2VuZXJhdG9yc1wiKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1N0YXRlbWVudCAmJiAhb3B0aW9uYWxJZCAmJiAhdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5feWllbGQpKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCB0aGlzLm1hdGNoKHR5cGVzLl95aWVsZCkpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUJpbmRpbmdJZGVudGlmaWVyKCk7XG4gIH1cblxuICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSk7XG5cbiAgdGhpcy5zdGF0ZS5pbk1ldGhvZCA9IG9sZEluTWV0aG9kO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SKTtcbn07XG5cbi8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG5wcCQxLnBhcnNlQ2xhc3MgPSBmdW5jdGlvbiAobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMudGFrZURlY29yYXRvcnMobm9kZSk7XG4gIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKTtcbiAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gIHRoaXMucGFyc2VDbGFzc0JvZHkobm9kZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpO1xufTtcblxucHAkMS5pc0NsYXNzUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmVxKSB8fCB0aGlzLm1hdGNoKHR5cGVzLnNlbWkpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2VSKTtcbn07XG5cbnBwJDEuaXNDbGFzc01ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMucGFyZW5MKTtcbn07XG5cbnBwJDEuaXNOb25zdGF0aWNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgcmV0dXJuICFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKG1ldGhvZC5rZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IC8vIElkZW50aWZpZXJcbiAgbWV0aG9kLmtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiIC8vIExpdGVyYWxcbiAgKTtcbn07XG5cbnBwJDEucGFyc2VDbGFzc0JvZHkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAvLyBjbGFzcyBib2RpZXMgYXJlIGltcGxpY2l0bHkgc3RyaWN0XG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgdGhpcy5zdGF0ZS5zdHJpY3QgPSB0cnVlO1xuXG4gIHZhciBoYWRDb25zdHJ1Y3RvckNhbGwgPSBmYWxzZTtcbiAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gIHZhciBkZWNvcmF0b3JzID0gW107XG4gIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gIGNsYXNzQm9keS5ib2R5ID0gW107XG5cbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcblxuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsIFwiRGVjb3JhdG9ycyBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBhIHNlbWljb2xvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIC8vIHN0ZWFsIHRoZSBkZWNvcmF0b3JzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIG1ldGhvZC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBtZXRob2Quc3RhdGljID0gZmFsc2U7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpOyAvLyBlYXRzICdzdGF0aWMnXG4gICAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgICAgLy8gYSBtZXRob2QgbmFtZWQgJ3N0YXRpYydcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgbWV0aG9kLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgICAvLyBhIHByb3BlcnR5IG5hbWVkICdzdGF0aWMnXG4gICAgICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICBtZXRob2Qua2V5ID0ga2V5O1xuICAgICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5KG1ldGhvZCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSBzb21ldGhpbmcgc3RhdGljXG4gICAgICBtZXRob2Quc3RhdGljID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc3RhcikpIHtcbiAgICAgIC8vIGEgZ2VuZXJhdG9yXG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICBpZiAodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShtZXRob2Qua2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgbWV0aG9kLnN0YXRpYyAmJiAobWV0aG9kLmtleS5uYW1lID09PSBcInByb3RvdHlwZVwiIHx8IG1ldGhvZC5rZXkudmFsdWUgPT09IFwicHJvdG90eXBlXCIpKSB7XG4gICAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1NpbXBsZSA9IHRoaXMubWF0Y2godHlwZXMubmFtZSk7XG4gICAgICB2YXIgX2tleSA9IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICAgIGlmICghbWV0aG9kLmNvbXB1dGVkICYmIG1ldGhvZC5zdGF0aWMgJiYgKG1ldGhvZC5rZXkubmFtZSA9PT0gXCJwcm90b3R5cGVcIiB8fCBtZXRob2Qua2V5LnZhbHVlID09PSBcInByb3RvdHlwZVwiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKG1ldGhvZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ2xhc3NNZXRob2QoKSkge1xuICAgICAgICAvLyBhIG5vcm1hbCBtZXRob2RcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpKSB7XG4gICAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKF9rZXkuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UobWV0aG9kLnN0YXJ0LCBcIllvdSBjYW4ndCBhdHRhY2ggZGVjb3JhdG9ycyB0byBhIGNsYXNzIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgICAvLyBhIG5vcm1hbCBwcm9wZXJ0eVxuICAgICAgICBpZiAodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKG1ldGhvZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBub24tc3RhdGljIGZpZWxkIG5hbWVkICdjb25zdHJ1Y3RvcidcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eShtZXRob2QpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTaW1wbGUgJiYgX2tleS5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgIC8vIGFuIGFzeW5jIG1ldGhvZFxuICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzLmhhc1BsdWdpbihcImFzeW5jR2VuZXJhdG9yc1wiKSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhbiBhc3luYyBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTaW1wbGUgJiYgKF9rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBfa2V5Lm5hbWUgPT09IFwic2V0XCIpICYmICEodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkgJiYgdGhpcy5tYXRjaCh0eXBlcy5zdGFyKSkpIHtcbiAgICAgICAgLy8gYGdldFxcbipgIGlzIGFuIHVuaW5pdGlhbGl6ZWQgcHJvcGVydHkgbmFtZWQgJ2dldCcgZm9sbG93ZWQgYnkgYSBnZW5lcmF0b3IuXG4gICAgICAgIC8vIGEgZ2V0dGVyIG9yIHNldHRlclxuICAgICAgICBtZXRob2Qua2luZCA9IF9rZXkubmFtZTtcbiAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgICAgICBpZiAodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKG1ldGhvZC5rZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtQ291bnQobWV0aG9kKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNQbHVnaW4oXCJjbGFzc0NvbnN0cnVjdG9yQ2FsbFwiKSAmJiBpc1NpbXBsZSAmJiBfa2V5Lm5hbWUgPT09IFwiY2FsbFwiICYmIHRoaXMubWF0Y2godHlwZXMubmFtZSkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIC8vIGEgKGRlcHJlY2F0ZWQpIGNhbGwgY29uc3RydWN0b3JcbiAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yQ2FsbCkge1xuICAgICAgICAgIHRoaXMucmFpc2UobWV0aG9kLnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBjYWxsIGluIHRoZSBzYW1lIGNsYXNzXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5kZWNvcmF0b3JzKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShtZXRob2Quc3RhcnQsIFwiWW91IGNhbid0IGF0dGFjaCBkZWNvcmF0b3JzIHRvIGEgY2xhc3MgY29uc3RydWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaGFkQ29uc3RydWN0b3JDYWxsID0gdHJ1ZTtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yQ2FsbFwiO1xuICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7IC8vIGNvbnN1bWUgXCJjb25zdHJ1Y3RvclwiIGFuZCBtYWtlIGl0IHRoZSBtZXRob2QncyBuYW1lXG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgLy8gYW4gdW5pbml0aWFsaXplZCBjbGFzcyBwcm9wZXJ0eSAoZHVlIHRvIEFTSSwgc2luY2Ugd2UgZG9uJ3Qgb3RoZXJ3aXNlIHJlY29nbml6ZSB0aGUgbmV4dCB0b2tlbilcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShtZXRob2Qua2V5LnN0YXJ0LCBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgbm9uLXN0YXRpYyBmaWVsZCBuYW1lZCAnY29uc3RydWN0b3InXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzUHJvcGVydHkobWV0aG9kKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiWW91IGhhdmUgdHJhaWxpbmcgZGVjb3JhdG9ycyB3aXRoIG5vIG1ldGhvZFwiKTtcbiAgfVxuXG4gIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuXG4gIHRoaXMuc3RhdGUuc3RyaWN0ID0gb2xkU3RyaWN0O1xufTtcblxucHAkMS5wYXJzZUNsYXNzUHJvcGVydHkgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLnN0YXRlLmluQ2xhc3NQcm9wZXJ0eSA9IHRydWU7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLmVxKSkge1xuICAgIGlmICghdGhpcy5oYXNQbHVnaW4oXCJjbGFzc1Byb3BlcnRpZXNcIikpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICB0aGlzLnN0YXRlLmluQ2xhc3NQcm9wZXJ0eSA9IGZhbHNlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NQcm9wZXJ0eVwiKTtcbn07XG5cbnBwJDEucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgdGhpcy5wYXJzZU1ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIkNsYXNzTWV0aG9kXCIpKTtcbn07XG5cbnBwJDEucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKSB7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbmFsSWQgfHwgIWlzU3RhdGVtZW50KSB7XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbDtcbn07XG5cbi8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlRXhwb3J0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGV4cG9ydCAqIGZyb20gJy4uLidcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RhcikpIHtcbiAgICB2YXIgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJleHBvcnRFeHRlbnNpb25zXCIpICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBzcGVjaWZpZXIuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW3RoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpXTtcbiAgICAgIHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzTWF5YmUobm9kZSk7XG4gICAgICB0aGlzLnBhcnNlRXhwb3J0RnJvbShub2RlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZXhwb3J0RXh0ZW5zaW9uc1wiKSAmJiB0aGlzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpKSB7XG4gICAgdmFyIF9zcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIF9zcGVjaWZpZXIuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbdGhpcy5maW5pc2hOb2RlKF9zcGVjaWZpZXIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKV07XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29tbWEpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgdmFyIF9zcGVjaWZpZXIyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnN0YXIpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiYXNcIik7XG4gICAgICBfc3BlY2lmaWVyMi5leHBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoX3NwZWNpZmllcjIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnNNYXliZShub2RlKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5lYXQodHlwZXMuX2RlZmF1bHQpKSB7XG4gICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgdmFyIGV4cHIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBuZWVkc1NlbWkgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuX2Z1bmN0aW9uKSkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VGdW5jdGlvbihleHByLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5fY2xhc3MpKSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUNsYXNzKGV4cHIsIHRydWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZWVkc1NlbWkgPSB0cnVlO1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIH1cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gZXhwcjtcbiAgICBpZiAobmVlZHNTZW1pKSB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKCk7XG4gICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSk7XG4gIH1cbiAgdGhpcy5jaGVja0V4cG9ydChub2RlLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIik7XG59O1xuXG5wcCQxLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUpO1xufTtcblxucHAkMS5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudmFsdWUgIT09IFwiYXN5bmNcIjtcbiAgfVxuXG4gIGlmICghdGhpcy5tYXRjaCh0eXBlcy5fZGVmYXVsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSB0eXBlcy5jb21tYSB8fCBsb29rYWhlYWQudHlwZSA9PT0gdHlwZXMubmFtZSAmJiBsb29rYWhlYWQudmFsdWUgPT09IFwiZnJvbVwiO1xufTtcblxucHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnNNYXliZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKCkpO1xuICB9XG59O1xuXG5wcCQxLnBhcnNlRXhwb3J0RnJvbSA9IGZ1bmN0aW9uIChub2RlLCBleHBlY3QpIHtcbiAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgdGhpcy5jaGVja0V4cG9ydChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZXhwZWN0KSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59O1xuXG5wcCQxLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fCB0aGlzLnN0YXRlLnR5cGUua2V5d29yZCA9PT0gXCJjb25zdFwiIHx8IHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkID09PSBcImxldFwiIHx8IHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHwgdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fCB0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpO1xufTtcblxucHAkMS5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uIChub2RlLCBjaGVja05hbWVzLCBpc0RlZmF1bHQpIHtcbiAgaWYgKGNoZWNrTmFtZXMpIHtcbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGV4cG9ydHNcbiAgICBpZiAoaXNEZWZhdWx0KSB7XG4gICAgICAvLyBEZWZhdWx0IGV4cG9ydHNcbiAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIFwiZGVmYXVsdFwiKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuc3BlY2lmaWVycyAmJiBub2RlLnNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAvLyBOYW1lZCBleHBvcnRzXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gbm9kZS5zcGVjaWZpZXJzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTIuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BlY2lmaWVyID0gX3JlZjI7XG5cbiAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMoc3BlY2lmaWVyLCBzcGVjaWZpZXIuZXhwb3J0ZWQubmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICAvLyBFeHBvcnRlZCBkZWNsYXJhdGlvbnNcbiAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgbm9kZS5kZWNsYXJhdGlvbi5pZC5uYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMsIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gX3JlZjM7XG5cbiAgICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24oZGVjbGFyYXRpb24uaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuc3RhdGUuZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICB2YXIgaXNDbGFzcyA9IG5vZGUuZGVjbGFyYXRpb24gJiYgKG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgfHwgbm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIkNsYXNzRXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIW5vZGUuZGVjbGFyYXRpb24gfHwgIWlzQ2xhc3MpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJZb3UgY2FuIG9ubHkgdXNlIGRlY29yYXRvcnMgb24gYW4gZXhwb3J0IHdoZW4gZXhwb3J0aW5nIGEgY2xhc3NcIik7XG4gICAgfVxuICAgIHRoaXMudGFrZURlY29yYXRvcnMobm9kZS5kZWNsYXJhdGlvbik7XG4gIH1cbn07XG5cbnBwJDEuY2hlY2tEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IG5vZGUucHJvcGVydGllcywgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I0KSwgX2k0ID0gMCwgX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/IF9pdGVyYXRvcjQgOiBfaXRlcmF0b3I0W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICB2YXIgX3JlZjQ7XG5cbiAgICAgIGlmIChfaXNBcnJheTQpIHtcbiAgICAgICAgaWYgKF9pNCA+PSBfaXRlcmF0b3I0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWY0ID0gX2l0ZXJhdG9yNFtfaTQrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcbiAgICAgICAgaWYgKF9pNC5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjQgPSBfaTQudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gX3JlZjQ7XG5cbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihwcm9wKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkFycmF5UGF0dGVyblwiKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IG5vZGUuZWxlbWVudHMsIF9pc0FycmF5NSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNSksIF9pNSA9IDAsIF9pdGVyYXRvcjUgPSBfaXNBcnJheTUgPyBfaXRlcmF0b3I1IDogX2l0ZXJhdG9yNVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWY1O1xuXG4gICAgICBpZiAoX2lzQXJyYXk1KSB7XG4gICAgICAgIGlmIChfaTUgPj0gX2l0ZXJhdG9yNS5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcjVbX2k1KytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2k1ID0gX2l0ZXJhdG9yNS5uZXh0KCk7XG4gICAgICAgIGlmIChfaTUuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWY1ID0gX2k1LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbSA9IF9yZWY1O1xuXG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24oZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSB7XG4gICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJSZXN0UHJvcGVydHlcIikge1xuICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmFyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgbm9kZS5uYW1lKTtcbiAgfVxufTtcblxucHAkMS5jaGVja0R1cGxpY2F0ZUV4cG9ydHMgPSBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICBpZiAodGhpcy5zdGF0ZS5leHBvcnRlZElkZW50aWZpZXJzLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgIHRoaXMucmFpc2VEdXBsaWNhdGVFeHBvcnRFcnJvcihub2RlLCBuYW1lKTtcbiAgfVxuICB0aGlzLnN0YXRlLmV4cG9ydGVkSWRlbnRpZmllcnMucHVzaChuYW1lKTtcbn07XG5cbnBwJDEucmFpc2VEdXBsaWNhdGVFeHBvcnRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgbmFtZSA9PT0gXCJkZWZhdWx0XCIgPyBcIk9ubHkgb25lIGRlZmF1bHQgZXhwb3J0IGFsbG93ZWQgcGVyIG1vZHVsZS5cIiA6IFwiYFwiICsgbmFtZSArIFwiYCBoYXMgYWxyZWFkeSBiZWVuIGV4cG9ydGVkLiBFeHBvcnRlZCBpZGVudGlmaWVycyBtdXN0IGJlIHVuaXF1ZS5cIik7XG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgZXhwb3J0cy5cblxucHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgbmVlZHNGcm9tID0gdm9pZCAwO1xuXG4gIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuXG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBpc0RlZmF1bHQgPSB0aGlzLm1hdGNoKHR5cGVzLl9kZWZhdWx0KTtcbiAgICBpZiAoaXNEZWZhdWx0ICYmICFuZWVkc0Zyb20pIG5lZWRzRnJvbSA9IHRydWU7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKGlzRGVmYXVsdCk7XG4gICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSkgOiBub2RlLmxvY2FsLl9fY2xvbmUoKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW1iZXItY2xpL2VtYmVyLWNsaS9wdWxsLzM3MzlcbiAgaWYgKG5lZWRzRnJvbSAmJiAhdGhpcy5pc0NvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cblxuICByZXR1cm4gbm9kZXM7XG59O1xuXG4vLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5lYXQodHlwZXMuX2ltcG9ydCk7XG5cbiAgLy8gaW1wb3J0ICcuLi4nXG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKG5vZGUpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBmaXJzdCA9IHRydWU7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyRGVmYXVsdCh0aGlzLnBhcnNlSWRlbnRpZmllcigpLCBzdGFydFBvcywgc3RhcnRMb2MpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RhcikpIHtcbiAgICB2YXIgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tMVmFsKHNwZWNpZmllci5sb2NhbCwgdHJ1ZSwgdW5kZWZpbmVkLCBcImltcG9ydCBuYW1lc3BhY2Ugc3BlY2lmaWVyXCIpO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERldGVjdCBhbiBhdHRlbXB0IHRvIGRlZXAgZGVzdHJ1Y3R1cmVcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5jb2xvbikpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIFwiRVMyMDE1IG5hbWVkIGltcG9ydHMgZG8gbm90IGRlc3RydWN0dXJlLiBVc2UgYW5vdGhlciBzdGF0ZW1lbnQgZm9yIGRlc3RydWN0dXJpbmcgYWZ0ZXIgdGhlIGltcG9ydC5cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKG5vZGUpO1xuICB9XG59O1xuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQoc3BlY2lmaWVyLmltcG9ydGVkLm5hbWUsIHNwZWNpZmllci5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gc3BlY2lmaWVyLmltcG9ydGVkLl9fY2xvbmUoKTtcbiAgfVxuICB0aGlzLmNoZWNrTFZhbChzcGVjaWZpZXIubG9jYWwsIHRydWUsIHVuZGVmaW5lZCwgXCJpbXBvcnQgc3BlY2lmaWVyXCIpO1xuICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG59O1xuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVyRGVmYXVsdCA9IGZ1bmN0aW9uIChpZCwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxvY2FsID0gaWQ7XG4gIHRoaXMuY2hlY2tMVmFsKG5vZGUubG9jYWwsIHRydWUsIHVuZGVmaW5lZCwgXCJkZWZhdWx0IGltcG9ydCBzcGVjaWZpZXJcIik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpO1xufTtcblxudmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDb252ZXJ0IGV4aXN0aW5nIGV4cHJlc3Npb24gYXRvbSB0byBhc3NpZ25hYmxlIHBhdHRlcm5cbi8vIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBpc0JpbmRpbmcsIGNvbnRleHREZXNjcmlwdGlvbikge1xuICBpZiAobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG5vZGUucHJvcGVydGllcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcm9wID0gX3JlZjtcblxuICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIgfHwgcHJvcC5raW5kID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIG1ldGhvZHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AsIGlzQmluZGluZywgXCJvYmplY3QgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RQcm9wZXJ0eVwiO1xuICAgICAgICB2YXIgYXJnID0gbm9kZS5hcmd1bWVudDtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUoYXJnLCBpc0JpbmRpbmcsIGNvbnRleHREZXNjcmlwdGlvbik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcsIGNvbnRleHREZXNjcmlwdGlvbik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgbGVmdC1oYW5kIHNpZGVcIiArIChjb250ZXh0RGVzY3JpcHRpb24gPyBcIiBpbiBcIiArIGNvbnRleHREZXNjcmlwdGlvbiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXCJleHByZXNzaW9uXCIpO1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vLyBDb252ZXJ0IGxpc3Qgb2YgZXhwcmVzc2lvbiBhdG9tcyB0byBiaW5kaW5nIGxpc3QuXG5cbnBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uIChleHByTGlzdCwgaXNCaW5kaW5nLCBjb250ZXh0RGVzY3JpcHRpb24pIHtcbiAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIC0tZW5kO1xuICAgIH0gZWxzZSBpZiAobGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICBsYXN0LnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICB2YXIgYXJnID0gbGFzdC5hcmd1bWVudDtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZywgaXNCaW5kaW5nLCBjb250ZXh0RGVzY3JpcHRpb24pO1xuICAgICAgaWYgKGFyZy50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBhcmcudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgYXJnLnR5cGUgIT09IFwiQXJyYXlQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGFyZy5zdGFydCk7XG4gICAgICB9XG4gICAgICAtLWVuZDtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBlbHQgPSBleHByTGlzdFtpXTtcbiAgICBpZiAoZWx0KSB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgfVxuICByZXR1cm4gZXhwckxpc3Q7XG59O1xuXG4vLyBDb252ZXJ0IGxpc3Qgb2YgZXhwcmVzc2lvbiBhdG9tcyB0byBhIGxpc3Qgb2ZcblxucHAkMi50b1JlZmVyZW5jZWRMaXN0ID0gZnVuY3Rpb24gKGV4cHJMaXN0KSB7XG4gIHJldHVybiBleHByTGlzdDtcbn07XG5cbi8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxucHAkMi5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKTtcbn07XG5cbnBwJDIucGFyc2VSZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdJZGVudGlmaWVyKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKTtcbn07XG5cbnBwJDIuc2hvdWxkQWxsb3dZaWVsZElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLl95aWVsZCkgJiYgIXRoaXMuc3RhdGUuc3RyaWN0ICYmICF0aGlzLnN0YXRlLmluR2VuZXJhdG9yO1xufTtcblxucHAkMi5wYXJzZUJpbmRpbmdJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodGhpcy5zaG91bGRBbGxvd1lpZWxkSWRlbnRpZmllcigpKTtcbn07XG5cbi8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbnBwJDIucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl95aWVsZDpcbiAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCB8fCB0aGlzLnN0YXRlLmluR2VuZXJhdG9yKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAvLyBmYWxsLXRocm91Z2hcbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG5cbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIik7XG5cbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbiAoY2xvc2UsIGFsbG93RW1wdHkpIHtcbiAgdmFyIGVsdHMgPSBbXTtcbiAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICB9XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy5tYXRjaCh0eXBlcy5jb21tYSkpIHtcbiAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmVsbGlwc2lzKSkge1xuICAgICAgZWx0cy5wdXNoKHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyh0aGlzLnBhcnNlUmVzdCgpKSk7XG4gICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlY29yYXRvcnMgPSBbXTtcbiAgICAgIHdoaWxlICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIGxlZnQuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXMobGVmdCk7XG4gICAgICBlbHRzLnB1c2godGhpcy5wYXJzZU1heWJlRGVmYXVsdChsZWZ0LnN0YXJ0LCBsZWZ0LmxvYy5zdGFydCwgbGVmdCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWx0cztcbn07XG5cbnBwJDIucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICByZXR1cm4gcGFyYW07XG59O1xuXG4vLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICBzdGFydExvYyA9IHN0YXJ0TG9jIHx8IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHN0YXJ0UG9zID0gc3RhcnRQb3MgfHwgdGhpcy5zdGF0ZS5zdGFydDtcbiAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIGlmICghdGhpcy5lYXQodHlwZXMuZXEpKSByZXR1cm4gbGVmdDtcblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIik7XG59O1xuXG4vLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4vLyB0by5cblxucHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbiAoZXhwciwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMsIGNvbnRleHREZXNjcmlwdGlvbikge1xuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGV4cHIubmFtZSwgZXhwci5zdGFydCwgZmFsc2UsIHRydWUpO1xuXG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcHJlZml4IHRoaXMgd2l0aCBhbiB1bmRlcnNjb3JlIGZvciB0aGUgY2FzZXMgd2hlcmUgd2UgaGF2ZSBhIGtleSBvZlxuICAgICAgICAvLyBgX19wcm90b19fYC4gdGhlcmUncyBhIGJ1ZyBpbiBvbGQgVjggd2hlcmUgdGhlIGZvbGxvd2luZyB3b3VsZG4ndCB3b3JrOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgID4gdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vICAgdW5kZWZpbmVkXG4gICAgICAgIC8vICAgPiBvYmouX19wcm90b19fXG4gICAgICAgIC8vICAgbnVsbFxuICAgICAgICAvLyAgID4gb2JqLl9fcHJvdG9fXyA9IHRydWU7XG4gICAgICAgIC8vICAgdHJ1ZVxuICAgICAgICAvLyAgID4gb2JqLl9fcHJvdG9fX1xuICAgICAgICAvLyAgIG51bGxcbiAgICAgICAgdmFyIGtleSA9IFwiX1wiICsgZXhwci5uYW1lO1xuXG4gICAgICAgIGlmIChjaGVja0NsYXNoZXNba2V5XSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrQ2xhc2hlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGlzQmluZGluZykgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoaXNCaW5kaW5nID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIG1lbWJlciBleHByZXNzaW9uXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGV4cHIucHJvcGVydGllcywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMjtcblxuICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3AgPSBfcmVmMjtcblxuICAgICAgICBpZiAocHJvcC50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIpIHByb3AgPSBwcm9wLnZhbHVlO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChwcm9wLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcywgXCJvYmplY3QgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gZXhwci5lbGVtZW50cywgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTMgPSBfaXRlcmF0b3IzLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW0gPSBfcmVmMztcblxuICAgICAgICBpZiAoZWxlbSkgdGhpcy5jaGVja0xWYWwoZWxlbSwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMsIFwiYXJyYXkgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMsIFwiYXNzaWdubWVudCBwYXR0ZXJuXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiUmVzdFByb3BlcnR5XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcywgXCJyZXN0IHByb3BlcnR5XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuYXJndW1lbnQsIGlzQmluZGluZywgY2hlY2tDbGFzaGVzLCBcInJlc3QgZWxlbWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAoaXNCaW5kaW5nID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cIkJpbmRpbmcgaW52YWxpZFwiIDogXCJJbnZhbGlkXCIpICsgXCIgbGVmdC1oYW5kIHNpZGVcIiArIChjb250ZXh0RGVzY3JpcHRpb24gPyBcIiBpbiBcIiArIGNvbnRleHREZXNjcmlwdGlvbiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXCJleHByZXNzaW9uXCIpO1xuICAgICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIG1lc3NhZ2UpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQgbWF4LWxlbjogMCAqL1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuLy8gc3ludGFjdGljIGVsZW1lbnRzLCBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aG9zZSwgZWFjaCBmdW5jdGlvblxuLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuLy8gb2YgY29uc3RydWN0cyAoZm9yIGV4YW1wbGUsIHRoZSBmYWN0IHRoYXQgYCF4WzFdYCBtZWFucyBgISh4WzFdKWBcbi8vIGluc3RlYWQgb2YgYCgheClbMV1gIGlzIGhhbmRsZWQgYnkgdGhlIGZhY3QgdGhhdCB0aGUgcGFyc2VyXG4vLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4vLyBpbiB0dXJuIGNhbGxzIHRoZSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBgW11gIHN1YnNjcmlwdHMg4oCUIHRoYXRcbi8vIHdheSwgaXQnbGwgcmVjZWl2ZSB0aGUgbm9kZSBmb3IgYHhbMV1gIGFscmVhZHkgcGFyc2VkLCBhbmQgd3JhcHNcbi8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbi8vXG4vLyBBY29ybiB1c2VzIGFuIFtvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNlcl1bb3BwXSB0byBoYW5kbGUgYmluYXJ5XG4vLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbi8vIHRoZSB0ZWNobmlxdWUgb3V0bGluZWQgYWJvdmUsIHdoaWNoIHVzZXMgZGlmZmVyZW50LCBuZXN0aW5nXG4vLyBmdW5jdGlvbnMgdG8gc3BlY2lmeSBwcmVjZWRlbmNlLCBmb3IgYWxsIG9mIHRoZSB0ZW4gYmluYXJ5XG4vLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbi8vXG4vLyBbb3BwXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlclxuXG52YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIENoZWNrIGlmIHByb3BlcnR5IG5hbWUgY2xhc2hlcyB3aXRoIGFscmVhZHkgYWRkZWQuXG4vLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4vLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4vLyBzdHJpY3QgbW9kZSwgaW5pdCBwcm9wZXJ0aWVzIGFyZSBhbHNvIG5vdCBhbGxvd2VkIHRvIGJlIHJlcGVhdGVkLlxuXG5wcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24gKHByb3AsIHByb3BIYXNoKSB7XG4gIGlmIChwcm9wLmNvbXB1dGVkIHx8IHByb3Aua2luZCkgcmV0dXJuO1xuXG4gIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgLy8gSXQgaXMgZWl0aGVyIGFuIElkZW50aWZpZXIgb3IgYSBTdHJpbmcvTnVtZXJpY0xpdGVyYWxcbiAgdmFyIG5hbWUgPSBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA6IFN0cmluZyhrZXkudmFsdWUpO1xuXG4gIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgaWYgKHByb3BIYXNoLnByb3RvKSB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpO1xuICAgIHByb3BIYXNoLnByb3RvID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHBhcnNlIGFuIEV4cHJlc3Npb24gb25seVxucHAkMy5nZXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5leHRUb2tlbigpO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIGlmICghdGhpcy5tYXRjaCh0eXBlcy5lb2YpKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbiAocykgYmVsb3cgdGhlbSBwYXJzZSxcbi8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4vLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbi8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4vLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0aWFsaXphdGlvbiBleHByZXNzaW9ucylcbi8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuLy8gcHJvcGVydHkgYXNzaWdubWVudCBpbiBjb250ZXh0cyB3aGVyZSBib3RoIG9iamVjdCBleHByZXNzaW9uXG4vLyBhbmQgb2JqZWN0IHBhdHRlcm4gbWlnaHQgYXBwZWFyIChzbyBpdCdzIHBvc3NpYmxlIHRvIHJhaXNlXG4vLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxucHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9JbiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29tbWEpKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKSB7XG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpKTtcbiAgICB9XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZXhwcmVzc2lvbnMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59O1xuXG4vLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4vLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG5wcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbiAobm9JbiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgYWZ0ZXJMZWZ0UGFyc2UsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5feWllbGQpICYmIHRoaXMuc3RhdGUuaW5HZW5lcmF0b3IpIHtcbiAgICB2YXIgX2xlZnQgPSB0aGlzLnBhcnNlWWllbGQoKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIF9sZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBfbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICByZXR1cm4gX2xlZnQ7XG4gIH1cblxuICB2YXIgZmFpbE9uU2hvcnRoYW5kQXNzaWduID0gdm9pZCAwO1xuICBpZiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICAgIGZhaWxPblNob3J0aGFuZEFzc2lnbiA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJlZlNob3J0aGFuZERlZmF1bHRQb3MgPSB7IHN0YXJ0OiAwIH07XG4gICAgZmFpbE9uU2hvcnRoYW5kQXNzaWduID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgfHwgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgIHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MsIHJlZk5lZWRzQXJyb3dQb3MpO1xuICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIGlmICh0aGlzLnN0YXRlLnR5cGUuaXNBc3NpZ24pIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBub2RlLmxlZnQgPSB0aGlzLm1hdGNoKHR5cGVzLmVxKSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIHVuZGVmaW5lZCwgXCJhc3NpZ25tZW50IGV4cHJlc3Npb25cIikgOiBsZWZ0O1xuICAgIHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQgPSAwOyAvLyByZXNldCBiZWNhdXNlIHNob3J0aGFuZCBkZWZhdWx0IHdhcyB1c2VkIGNvcnJlY3RseVxuXG4gICAgdGhpcy5jaGVja0xWYWwobGVmdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiYXNzaWdubWVudCBleHByZXNzaW9uXCIpO1xuXG4gICAgaWYgKGxlZnQuZXh0cmEgJiYgbGVmdC5leHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgICB2YXIgZXJyb3JNc2cgPSB2b2lkIDA7XG4gICAgICBpZiAobGVmdC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIikge1xuICAgICAgICBlcnJvck1zZyA9IFwiYCh7YX0pID0gMGAgdXNlIGAoe2F9ID0gMClgXCI7XG4gICAgICB9IGVsc2UgaWYgKGxlZnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikge1xuICAgICAgICBlcnJvck1zZyA9IFwiYChbYV0pID0gMGAgdXNlIGAoW2FdID0gMClgXCI7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgICAgdGhpcy5yYWlzZShsZWZ0LnN0YXJ0LCBcIllvdSdyZSB0cnlpbmcgdG8gYXNzaWduIHRvIGEgcGFyZW50aGVzaXplZCBleHByZXNzaW9uLCBlZy4gaW5zdGVhZCBvZiBcIiArIGVycm9yTXNnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmIChmYWlsT25TaG9ydGhhbmRBc3NpZ24gJiYgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCkge1xuICAgIHRoaXMudW5leHBlY3RlZChyZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiBsZWZ0O1xufTtcblxuLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxucHAkMy5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAobm9JbiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgcmVmTmVlZHNBcnJvd1Bvcykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICBpZiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyAmJiByZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSByZXR1cm4gZXhwcjtcblxuICByZXR1cm4gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKGV4cHIsIG5vSW4sIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmTmVlZHNBcnJvd1Bvcyk7XG59O1xuXG5wcCQzLnBhcnNlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoZXhwciwgbm9Jbiwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuICB9XG4gIHJldHVybiBleHByO1xufTtcblxuLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG5wcCQzLnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uIChub0luLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG4gIGlmIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zICYmIHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKTtcbiAgfVxufTtcblxuLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbi8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4vLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbi8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbi8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxucHAkMy5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uIChsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICB2YXIgcHJlYyA9IHRoaXMuc3RhdGUudHlwZS5iaW5vcDtcbiAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgIXRoaXMubWF0Y2godHlwZXMuX2luKSkpIHtcbiAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYyk7XG4gICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG5cbiAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSBcIioqXCIgJiYgbGVmdC50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiICYmIGxlZnQuZXh0cmEgJiYgIWxlZnQuZXh0cmEucGFyZW50aGVzaXplZEFyZ3VtZW50ICYmICFsZWZ0LmV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShsZWZ0LmFyZ3VtZW50LnN0YXJ0LCBcIklsbGVnYWwgZXhwcmVzc2lvbi4gV3JhcCBsZWZ0IGhhbmQgc2lkZSBvciBlbnRpcmUgZXhwb25lbnRpYXRpb24gaW4gcGFyZW50aGVzZXMuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3AgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIG9wLnJpZ2h0QXNzb2NpYXRpdmUgPyBwcmVjIC0gMSA6IHByZWMsIG5vSW4pO1xuXG4gICAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgb3AgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCBvcCA9PT0gdHlwZXMubG9naWNhbEFORCA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlZnQ7XG59O1xuXG4vLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG5wcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIGlmICh0aGlzLnN0YXRlLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciB1cGRhdGUgPSB0aGlzLm1hdGNoKHR5cGVzLmluY0RlYyk7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIGFyZ1R5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG5cbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwicGFyZW50aGVzaXplZEFyZ3VtZW50XCIsIGFyZ1R5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiAoIW5vZGUuYXJndW1lbnQuZXh0cmEgfHwgIW5vZGUuYXJndW1lbnQuZXh0cmEucGFyZW50aGVzaXplZCkpO1xuXG4gICAgaWYgKHJlZlNob3J0aGFuZERlZmF1bHRQb3MgJiYgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcInByZWZpeCBvcGVyYXRpb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gIH1cblxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgaWYgKHJlZlNob3J0aGFuZERlZmF1bHRQb3MgJiYgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCkgcmV0dXJuIGV4cHI7XG4gIHdoaWxlICh0aGlzLnN0YXRlLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgIHZhciBfbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBfbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgX25vZGUucHJlZml4ID0gZmFsc2U7XG4gICAgX25vZGUuYXJndW1lbnQgPSBleHByO1xuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcInBvc3RmaXggb3BlcmF0aW9uXCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUoX25vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgfVxuICByZXR1cm4gZXhwcjtcbn07XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgcG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdDtcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG5cbiAgaWYgKGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIGV4cHIuc3RhcnQgPT09IHBvdGVudGlhbEFycm93QXQpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGlmIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zICYmIHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcnNlU3Vic2NyaXB0cyhleHByLCBzdGFydFBvcywgc3RhcnRMb2MpO1xufTtcblxucHAkMy5wYXJzZVN1YnNjcmlwdHMgPSBmdW5jdGlvbiAoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gIGZvciAoOzspIHtcbiAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMuZG91YmxlQ29sb24pKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCaW5kRXhwcmVzc2lvblwiKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIHZhciBfbm9kZTIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBfbm9kZTIub2JqZWN0ID0gYmFzZTtcbiAgICAgIF9ub2RlMi5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgX25vZGUyLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKF9ub2RlMiwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICB2YXIgX25vZGUzID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgX25vZGUzLm9iamVjdCA9IGJhc2U7XG4gICAgICBfbm9kZTMucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgX25vZGUzLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUoX25vZGUzLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIHZhciBwb3NzaWJsZUFzeW5jID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIF9ub2RlNCA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIF9ub2RlNC5jYWxsZWUgPSBiYXNlO1xuICAgICAgX25vZGU0LmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyh0eXBlcy5wYXJlblIsIHBvc3NpYmxlQXN5bmMpO1xuICAgICAgaWYgKF9ub2RlNC5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIiAmJiBfbm9kZTQuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aGlzLnJhaXNlKF9ub2RlNC5zdGFydCwgXCJpbXBvcnQoKSByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudFwiKTtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUoX25vZGU0LCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuXG4gICAgICBpZiAocG9zc2libGVBc3luYyAmJiB0aGlzLnNob3VsZFBhcnNlQXN5bmNBcnJvdygpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIF9ub2RlNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3QoX25vZGU0LmFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmJhY2tRdW90ZSkpIHtcbiAgICAgIHZhciBfbm9kZTUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBfbm9kZTUudGFnID0gYmFzZTtcbiAgICAgIF9ub2RlNS5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh0cnVlKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUoX25vZGU1LCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICB9XG59O1xuXG5wcCQzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMgPSBmdW5jdGlvbiAoY2xvc2UsIHBvc3NpYmxlQXN5bmNBcnJvdykge1xuICB2YXIgZWx0cyA9IFtdO1xuICB2YXIgaW5uZXJQYXJlblN0YXJ0ID0gdm9pZCAwO1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuXG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5lYXQoY2xvc2UpKSBicmVhaztcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHRoaXMgaXMgYW4gYXN5bmMgYXJyb3cgZnVuY3Rpb25zLCB0aGF0IHdlIGRvbid0IGFsbG93IGlubmVyIHBhcmVucyBpbnNpZGUgdGhlIHBhcmFtc1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgJiYgIWlubmVyUGFyZW5TdGFydCkge1xuICAgICAgaW5uZXJQYXJlblN0YXJ0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICB9XG5cbiAgICBlbHRzLnB1c2godGhpcy5wYXJzZUV4cHJMaXN0SXRlbShmYWxzZSwgcG9zc2libGVBc3luY0Fycm93ID8geyBzdGFydDogMCB9IDogdW5kZWZpbmVkLCBwb3NzaWJsZUFzeW5jQXJyb3cgPyB7IHN0YXJ0OiAwIH0gOiB1bmRlZmluZWQpKTtcbiAgfVxuXG4gIC8vIHdlIGZvdW5kIGFuIGFzeW5jIGFycm93IGZ1bmN0aW9uIHNvIGxldCdzIG5vdCBhbGxvdyBhbnkgaW5uZXIgcGFyZW5zXG4gIGlmIChwb3NzaWJsZUFzeW5jQXJyb3cgJiYgaW5uZXJQYXJlblN0YXJ0ICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIHJldHVybiBlbHRzO1xufTtcblxucHAkMy5zaG91bGRQYXJzZUFzeW5jQXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmFycm93KTtcbn07XG5cbnBwJDMucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIGNhbGwpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMuYXJyb3cpO1xuICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBjYWxsLmFyZ3VtZW50cywgdHJ1ZSk7XG59O1xuXG4vLyBQYXJzZSBhIG5vLWNhbGwgZXhwcmVzc2lvbiAobGlrZSBhcmd1bWVudCBvZiBgbmV3YCBvciBgOjpgIG9wZXJhdG9ycykuXG5cbnBwJDMucGFyc2VOb0NhbGxFeHByID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG59O1xuXG4vLyBQYXJzZSBhbiBhdG9taWMgZXhwcmVzc2lvbiDigJQgZWl0aGVyIGEgc2luZ2xlIHRva2VuIHRoYXQgaXMgYW5cbi8vIGV4cHJlc3Npb24sIGFuIGV4cHJlc3Npb24gc3RhcnRlZCBieSBhIGtleXdvcmQgbGlrZSBgZnVuY3Rpb25gIG9yXG4vLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbi8vIG9yIGB7fWAuXG5cbnBwJDMucGFyc2VFeHByQXRvbSA9IGZ1bmN0aW9uIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIHZhciBjYW5CZUFycm93ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgbm9kZSA9IHZvaWQgMDtcblxuICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgIGNhc2UgdHlwZXMuX3N1cGVyOlxuICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTWV0aG9kICYmICF0aGlzLnN0YXRlLmluQ2xhc3NQcm9wZXJ0eSAmJiAhdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgXCInc3VwZXInIG91dHNpZGUgb2YgZnVuY3Rpb24gb3IgY2xhc3NcIik7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5MKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5icmFja2V0TCkgJiYgIXRoaXMubWF0Y2godHlwZXMuZG90KSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgJiYgdGhpcy5zdGF0ZS5pbk1ldGhvZCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmICF0aGlzLm9wdGlvbnMuYWxsb3dTdXBlck91dHNpZGVNZXRob2QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcInN1cGVyKCkgb3V0c2lkZSBvZiBjbGFzcyBjb25zdHJ1Y3RvclwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKTtcblxuICAgIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4oXCJkeW5hbWljSW1wb3J0XCIpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcblxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCB0eXBlcy5wYXJlbkwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFwiKTtcblxuICAgIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5feWllbGQ6XG4gICAgICBpZiAodGhpcy5zdGF0ZS5pbkdlbmVyYXRvcikgdGhpcy51bmV4cGVjdGVkKCk7XG5cbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHZhciBhbGxvd0F3YWl0ID0gdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJhd2FpdFwiICYmIHRoaXMuc3RhdGUuaW5Bc3luYztcbiAgICAgIHZhciBhbGxvd1lpZWxkID0gdGhpcy5zaG91bGRBbGxvd1lpZWxkSWRlbnRpZmllcigpO1xuICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoYWxsb3dBd2FpdCB8fCBhbGxvd1lpZWxkKTtcblxuICAgICAgaWYgKGlkLm5hbWUgPT09IFwiYXdhaXRcIikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbkFzeW5jIHx8IHRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF3YWl0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLm1hdGNoKHR5cGVzLl9mdW5jdGlvbikgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQmVBcnJvdyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgICAgICB2YXIgcGFyYW1zID0gW3RoaXMucGFyc2VJZGVudGlmaWVyKCldO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5hcnJvdyk7XG4gICAgICAgIC8vIGxldCBmb28gPSBiYXIgPT4ge307XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHBhcmFtcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBbaWRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkO1xuXG4gICAgY2FzZSB0eXBlcy5fZG86XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkb0V4cHJlc3Npb25zXCIpKSB7XG4gICAgICAgIHZhciBfbm9kZTYgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdmFyIG9sZEluRnVuY3Rpb24gPSB0aGlzLnN0YXRlLmluRnVuY3Rpb247XG4gICAgICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgICAgIF9ub2RlNi5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbkZ1bmN0aW9uID0gb2xkSW5GdW5jdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoX25vZGU2LCBcIkRvRXhwcmVzc2lvblwiKTtcbiAgICAgIH1cblxuICAgIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZS52YWx1ZSwgXCJSZWdFeHBMaXRlcmFsXCIpO1xuICAgICAgbm9kZS5wYXR0ZXJuID0gdmFsdWUucGF0dGVybjtcbiAgICAgIG5vZGUuZmxhZ3MgPSB2YWx1ZS5mbGFncztcbiAgICAgIHJldHVybiBub2RlO1xuXG4gICAgY2FzZSB0eXBlcy5udW06XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1lcmljTGl0ZXJhbFwiKTtcblxuICAgIGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcblxuICAgIGNhc2UgdHlwZXMuX251bGw6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxMaXRlcmFsXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5fdHJ1ZTpjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMubWF0Y2godHlwZXMuX3RydWUpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxcIik7XG5cbiAgICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24obnVsbCwgbnVsbCwgY2FuQmVBcnJvdyk7XG5cbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZWxlbWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKTtcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpO1xuXG4gICAgY2FzZSB0eXBlcy5hdDpcbiAgICAgIHRoaXMucGFyc2VEZWNvcmF0b3JzKCk7XG5cbiAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy50YWtlRGVjb3JhdG9ycyhub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgZmFsc2UpO1xuXG4gICAgY2FzZSB0eXBlcy5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKTtcblxuICAgIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZShmYWxzZSk7XG5cbiAgICBjYXNlIHR5cGVzLmRvdWJsZUNvbG9uOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gbnVsbDtcbiAgICAgIHZhciBjYWxsZWUgPSBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG4gICAgICBpZiAoY2FsbGVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCaW5kRXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2UoY2FsbGVlLnN0YXJ0LCBcIkJpbmRpbmcgc2hvdWxkIGJlIHBlcmZvcm1lZCBvbiBvYmplY3QgcHJvcGVydHkuXCIpO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gIGlmICh0aGlzLnN0YXRlLmluR2VuZXJhdG9yICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkgJiYgdGhpcy5oYXNQbHVnaW4oXCJmdW5jdGlvblNlbnRcIikpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBtZXRhLCBcInNlbnRcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBmYWxzZSk7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VNZXRhUHJvcGVydHkgPSBmdW5jdGlvbiAobm9kZSwgbWV0YSwgcHJvcGVydHlOYW1lKSB7XG4gIG5vZGUubWV0YSA9IG1ldGE7XG4gIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBwcm9wZXJ0eU5hbWUpIHtcbiAgICB0aGlzLnJhaXNlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzIFwiICsgbWV0YS5uYW1lICsgXCIuXCIgKyBwcm9wZXJ0eU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKTtcbn07XG5cbnBwJDMucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlLCBzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgc3RhcnRQb3MgPSBzdGFydFBvcyB8fCB0aGlzLnN0YXRlLnN0YXJ0O1xuICBzdGFydExvYyA9IHN0YXJ0TG9jIHx8IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJyYXdWYWx1ZVwiLCB2YWx1ZSk7XG4gIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJyYXdcIiwgdGhpcy5pbnB1dC5zbGljZShzdGFydFBvcywgdGhpcy5zdGF0ZS5lbmQpKTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbn07XG5cbnBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICByZXR1cm4gdmFsO1xufTtcblxucHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYywgY2FuQmVBcnJvdykge1xuICBzdGFydFBvcyA9IHN0YXJ0UG9zIHx8IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIHN0YXJ0TG9jID0gc3RhcnRMb2MgfHwgdGhpcy5zdGF0ZS5zdGFydExvYztcblxuICB2YXIgdmFsID0gdm9pZCAwO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuXG4gIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdmFyIGlubmVyU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgZXhwckxpc3QgPSBbXTtcbiAgdmFyIHJlZlNob3J0aGFuZERlZmF1bHRQb3MgPSB7IHN0YXJ0OiAwIH07XG4gIHZhciByZWZOZWVkc0Fycm93UG9zID0geyBzdGFydDogMCB9O1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgc3ByZWFkU3RhcnQgPSB2b2lkIDA7XG4gIHZhciBvcHRpb25hbENvbW1hU3RhcnQgPSB2b2lkIDA7XG5cbiAgd2hpbGUgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikpIHtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hLCByZWZOZWVkc0Fycm93UG9zLnN0YXJ0IHx8IG51bGwpO1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMucGFyZW5SKSkge1xuICAgICAgICBvcHRpb25hbENvbW1hU3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIHZhciBzcHJlYWROb2RlU3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgdmFyIHNwcmVhZE5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3QoKSwgc3ByZWFkTm9kZVN0YXJ0UG9zLCBzcHJlYWROb2RlU3RhcnRMb2MpKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgdGhpcy5wYXJzZVBhcmVuSXRlbSwgcmVmTmVlZHNBcnJvd1BvcykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbm5lckVuZFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIHZhciBpbm5lckVuZExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG5cbiAgdmFyIGFycm93Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5zaG91bGRQYXJzZUFycm93KCkgJiYgKGFycm93Tm9kZSA9IHRoaXMucGFyc2VBcnJvdyhhcnJvd05vZGUpKSkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGV4cHJMaXN0LCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyYW0gPSBfcmVmO1xuXG4gICAgICBpZiAocGFyYW0uZXh0cmEgJiYgcGFyYW0uZXh0cmEucGFyZW50aGVzaXplZCkgdGhpcy51bmV4cGVjdGVkKHBhcmFtLmV4dHJhLnBhcmVuU3RhcnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKGFycm93Tm9kZSwgZXhwckxpc3QpO1xuICB9XG5cbiAgaWYgKCFleHByTGlzdC5sZW5ndGgpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpO1xuICB9XG4gIGlmIChvcHRpb25hbENvbW1hU3RhcnQpIHRoaXMudW5leHBlY3RlZChvcHRpb25hbENvbW1hU3RhcnQpO1xuICBpZiAoc3ByZWFkU3RhcnQpIHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7XG4gIGlmIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSB0aGlzLnVuZXhwZWN0ZWQocmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCk7XG4gIGlmIChyZWZOZWVkc0Fycm93UG9zLnN0YXJ0KSB0aGlzLnVuZXhwZWN0ZWQocmVmTmVlZHNBcnJvd1Bvcy5zdGFydCk7XG5cbiAgaWYgKGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdCh2YWwuZXhwcmVzc2lvbnMpO1xuICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgfVxuXG4gIHRoaXMuYWRkRXh0cmEodmFsLCBcInBhcmVudGhlc2l6ZWRcIiwgdHJ1ZSk7XG4gIHRoaXMuYWRkRXh0cmEodmFsLCBcInBhcmVuU3RhcnRcIiwgc3RhcnRQb3MpO1xuXG4gIHJldHVybiB2YWw7XG59O1xuXG5wcCQzLnNob3VsZFBhcnNlQXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTtcbn07XG5cbnBwJDMucGFyc2VBcnJvdyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufTtcblxucHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlO1xufTtcblxuLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50XG4vLyB0byBiZSBhIGBbXWAgb3IgZG90IHN1YnNjcmlwdCBleHByZXNzaW9uLCBidXQgbm90IGEgY2FsbCDigJQgYXRcbi8vIGxlYXN0LCBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGVcblxucHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgdmFyIG1ldGFQcm9wID0gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBtZXRhLCBcInRhcmdldFwiKTtcblxuICAgIGlmICghdGhpcy5zdGF0ZS5pbkZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLnJhaXNlKG1ldGFQcm9wLnByb3BlcnR5LnN0YXJ0LCBcIm5ldy50YXJnZXQgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGFQcm9wO1xuICB9XG5cbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlTm9DYWxsRXhwcigpO1xuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SKTtcbiAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5hcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXJndW1lbnRzID0gW107XG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKTtcbn07XG5cbi8vIFBhcnNlIHRlbXBsYXRlIGV4cHJlc3Npb24uXG5cbnBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoaXNUYWdnZWQpIHtcbiAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gbnVsbCkge1xuICAgIGlmICghaXNUYWdnZWQgfHwgIXRoaXMuaGFzUGx1Z2luKFwidGVtcGxhdGVJbnZhbGlkRXNjYXBlc1wiKSkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLmludmFsaWRUZW1wbGF0ZUVzY2FwZVBvc2l0aW9uLCBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmludmFsaWRUZW1wbGF0ZUVzY2FwZVBvc2l0aW9uID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZWxlbS52YWx1ZSA9IHtcbiAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgY29va2VkOiB0aGlzLnN0YXRlLnZhbHVlXG4gIH07XG4gIHRoaXMubmV4dCgpO1xuICBlbGVtLnRhaWwgPSB0aGlzLm1hdGNoKHR5cGVzLmJhY2tRdW90ZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIik7XG59O1xuXG5wcCQzLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbiAoaXNUYWdnZWQpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCk7XG4gIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xufTtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG5wcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24gKGlzUGF0dGVybiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICB2YXIgZGVjb3JhdG9ycyA9IFtdO1xuICB2YXIgcHJvcEhhc2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gIHRoaXMubmV4dCgpO1xuXG4gIHZhciBmaXJzdFJlc3RMb2NhdGlvbiA9IG51bGw7XG5cbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2VSKSkgYnJlYWs7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMubWF0Y2godHlwZXMuYXQpKSB7XG4gICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksXG4gICAgICAgIGlzR2VuZXJhdG9yID0gZmFsc2UsXG4gICAgICAgIGlzQXN5bmMgPSBmYWxzZSxcbiAgICAgICAgc3RhcnRQb3MgPSB2b2lkIDAsXG4gICAgICAgIHN0YXJ0TG9jID0gdm9pZCAwO1xuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgcHJvcC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJvYmplY3RSZXN0U3ByZWFkXCIpICYmIHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICBwcm9wID0gdGhpcy5wYXJzZVNwcmVhZChpc1BhdHRlcm4gPyB7IHN0YXJ0OiAwIH0gOiB1bmRlZmluZWQpO1xuICAgICAgcHJvcC50eXBlID0gaXNQYXR0ZXJuID8gXCJSZXN0UHJvcGVydHlcIiA6IFwiU3ByZWFkUHJvcGVydHlcIjtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AuYXJndW1lbnQsIHRydWUsIFwib2JqZWN0IHBhdHRlcm5cIik7XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgaWYgKGZpcnN0UmVzdExvY2F0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKGZpcnN0UmVzdExvY2F0aW9uLCBcIkNhbm5vdCBoYXZlIG11bHRpcGxlIHJlc3QgZWxlbWVudHMgd2hlbiBkZXN0cnVjdHVyaW5nXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbW1hKSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR5cGVzLmJyYWNlUikge1xuICAgICAgICAgIC8vIFRPRE86IHRlbXBvcmFyeSByb2xsYmFja1xuICAgICAgICAgIC8vIHRoaXMudW5leHBlY3RlZChwb3NpdGlvbiwgXCJBIHRyYWlsaW5nIGNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdFJlc3RMb2NhdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG5cbiAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB9XG5cbiAgICBpZiAoIWlzUGF0dGVybikge1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGF0dGVybiAmJiB0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IpIHRoaXMudW5leHBlY3RlZCgpO1xuXG4gICAgICB2YXIgYXN5bmNJZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgfHwgdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2VSKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmVxKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmNvbW1hKSkge1xuICAgICAgICBwcm9wLmtleSA9IGFzeW5jSWQ7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJhc3luY0dlbmVyYXRvcnNcIikpIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICAgIHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gpO1xuXG4gICAgaWYgKHByb3Auc2hvcnRoYW5kKSB7XG4gICAgICB0aGlzLmFkZEV4dHJhKHByb3AsIFwic2hvcnRoYW5kXCIsIHRydWUpO1xuICAgIH1cblxuICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICB9XG5cbiAgaWYgKGZpcnN0UmVzdExvY2F0aW9uICE9PSBudWxsKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKGZpcnN0UmVzdExvY2F0aW9uLCBcIlRoZSByZXN0IGVsZW1lbnQgaGFzIHRvIGJlIHRoZSBsYXN0IGVsZW1lbnQgd2hlbiBkZXN0cnVjdHVyaW5nXCIpO1xuICB9XG5cbiAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIllvdSBoYXZlIHRyYWlsaW5nIGRlY29yYXRvcnMgd2l0aCBubyBwcm9wZXJ0eVwiKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIik7XG59O1xuXG5wcCQzLmlzR2V0dGVyT3JTZXR0ZXJNZXRob2QgPSBmdW5jdGlvbiAocHJvcCwgaXNQYXR0ZXJuKSB7XG4gIHJldHVybiAhaXNQYXR0ZXJuICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmICh0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykgfHwgLy8gZ2V0IFwic3RyaW5nXCIoKSB7fVxuICB0aGlzLm1hdGNoKHR5cGVzLm51bSkgfHwgLy8gZ2V0IDEoKSB7fVxuICB0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRMKSB8fCAvLyBnZXQgW1wic3RyaW5nXCJdKCkge31cbiAgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCAvLyBnZXQgZm9vKCkge31cbiAgdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQgLy8gZ2V0IGRlYnVnZ2VyKCkge31cbiAgKTtcbn07XG5cbi8vIGdldCBtZXRob2RzIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgYW55IHBhcmFtZXRlcnNcbi8vIHNldCBtZXRob2RzIG11c3QgaGF2ZSBleGFjdGx5IDEgcGFyYW1ldGVyXG5wcCQzLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1Db3VudCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgdmFyIHBhcmFtQ291bnQgPSBtZXRob2Qua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICBpZiAobWV0aG9kLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICB2YXIgc3RhcnQgPSBtZXRob2Quc3RhcnQ7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpO1xuICAgIH1cbiAgfVxufTtcblxucHAkMy5wYXJzZU9iamVjdE1ldGhvZCA9IGZ1bmN0aW9uIChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuKSB7XG4gIGlmIChpc0FzeW5jIHx8IGlzR2VuZXJhdG9yIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkge1xuICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHByb3Aua2luZCA9IFwibWV0aG9kXCI7XG4gICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgIHRoaXMucGFyc2VNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIk9iamVjdE1ldGhvZFwiKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzR2V0dGVyT3JTZXR0ZXJNZXRob2QocHJvcCwgaXNQYXR0ZXJuKSkge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgdGhpcy5wYXJzZU1ldGhvZChwcm9wKTtcbiAgICB0aGlzLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1Db3VudChwcm9wKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJPYmplY3RNZXRob2RcIik7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIk9iamVjdFByb3BlcnR5XCIpO1xuICB9XG5cbiAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChwcm9wLmtleS5uYW1lLCBwcm9wLmtleS5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5Ll9fY2xvbmUoKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmVxKSAmJiByZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gICAgICBpZiAoIXJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpIHtcbiAgICAgICAgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICB9XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5Ll9fY2xvbmUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleS5fX2Nsb25lKCk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJPYmplY3RQcm9wZXJ0eVwiKTtcbiAgfVxufTtcblxucHAkMy5wYXJzZU9ialByb3BWYWx1ZSA9IGZ1bmN0aW9uIChwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4pIHx8IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG5cbiAgaWYgKCFub2RlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAocHJvcCkge1xuICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gIH0gZWxzZSB7XG4gICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIHZhciBvbGRJblByb3BlcnR5TmFtZSA9IHRoaXMuc3RhdGUuaW5Qcm9wZXJ0eU5hbWU7XG4gICAgdGhpcy5zdGF0ZS5pblByb3BlcnR5TmFtZSA9IHRydWU7XG4gICAgcHJvcC5rZXkgPSB0aGlzLm1hdGNoKHR5cGVzLm51bSkgfHwgdGhpcy5tYXRjaCh0eXBlcy5zdHJpbmcpID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB0aGlzLnN0YXRlLmluUHJvcGVydHlOYW1lID0gb2xkSW5Qcm9wZXJ0eU5hbWU7XG4gIH1cbiAgcmV0dXJuIHByb3Aua2V5O1xufTtcblxuLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG5wcCQzLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBpc0FzeW5jKSB7XG4gIG5vZGUuaWQgPSBudWxsO1xuICBub2RlLmdlbmVyYXRvciA9IGZhbHNlO1xuICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgbm9kZS5hc3luYyA9ICEhaXNBc3luYztcbn07XG5cbi8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbnBwJDMucGFyc2VNZXRob2QgPSBmdW5jdGlvbiAobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgdmFyIG9sZEluTWV0aG9kID0gdGhpcy5zdGF0ZS5pbk1ldGhvZDtcbiAgdGhpcy5zdGF0ZS5pbk1ldGhvZCA9IG5vZGUua2luZCB8fCB0cnVlO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5nZW5lcmF0b3IgPSAhIWlzR2VuZXJhdG9yO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUpO1xuICB0aGlzLnN0YXRlLmluTWV0aG9kID0gb2xkSW5NZXRob2Q7XG4gIHJldHVybiBub2RlO1xufTtcblxuLy8gUGFyc2UgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuXG5cbnBwJDMucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUsIFwiYXJyb3cgZnVuY3Rpb24gcGFyYW1ldGVyc1wiKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpO1xufTtcblxucHAkMy5pc1N0cmljdEJvZHkgPSBmdW5jdGlvbiAobm9kZSwgaXNFeHByZXNzaW9uKSB7XG4gIGlmICghaXNFeHByZXNzaW9uICYmIG5vZGUuYm9keS5kaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBub2RlLmJvZHkuZGlyZWN0aXZlcywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICB2YXIgX3JlZjI7XG5cbiAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3RpdmUgPSBfcmVmMjtcblxuICAgICAgaWYgKGRpcmVjdGl2ZS52YWx1ZS52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cbnBwJDMucGFyc2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbiAobm9kZSwgYWxsb3dFeHByZXNzaW9uKSB7XG4gIHZhciBpc0V4cHJlc3Npb24gPSBhbGxvd0V4cHJlc3Npb24gJiYgIXRoaXMubWF0Y2godHlwZXMuYnJhY2VMKTtcblxuICB2YXIgb2xkSW5Bc3luYyA9IHRoaXMuc3RhdGUuaW5Bc3luYztcbiAgdGhpcy5zdGF0ZS5pbkFzeW5jID0gbm9kZS5hc3luYztcbiAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgLy8gZmxhZyAocmVzdG9yZSB0aGVtIHRvIHRoZWlyIG9sZCB2YWx1ZSBhZnRlcndhcmRzKS5cbiAgICB2YXIgb2xkSW5GdW5jID0gdGhpcy5zdGF0ZS5pbkZ1bmN0aW9uO1xuICAgIHZhciBvbGRJbkdlbiA9IHRoaXMuc3RhdGUuaW5HZW5lcmF0b3I7XG4gICAgdmFyIG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUuaW5GdW5jdGlvbiA9IHRydWU7dGhpcy5zdGF0ZS5pbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yO3RoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKHRydWUpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUuaW5GdW5jdGlvbiA9IG9sZEluRnVuYzt0aGlzLnN0YXRlLmluR2VuZXJhdG9yID0gb2xkSW5HZW47dGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gIH1cbiAgdGhpcy5zdGF0ZS5pbkFzeW5jID0gb2xkSW5Bc3luYztcblxuICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gIC8vIG9yIGBhcmd1bWVudHNgLlxuICB2YXIgaXNTdHJpY3QgPSB0aGlzLmlzU3RyaWN0Qm9keShub2RlLCBpc0V4cHJlc3Npb24pO1xuICAvLyBBbHNvIGNoZWNrIHdoZW4gYWxsb3dFeHByZXNzaW9uID09PSB0cnVlIGZvciBhcnJvdyBmdW5jdGlvbnNcbiAgdmFyIGNoZWNrTFZhbCA9IHRoaXMuc3RhdGUuc3RyaWN0IHx8IGFsbG93RXhwcmVzc2lvbiB8fCBpc1N0cmljdDtcblxuICBpZiAoaXNTdHJpY3QgJiYgbm9kZS5pZCAmJiBub2RlLmlkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG5vZGUuaWQubmFtZSA9PT0gXCJ5aWVsZFwiKSB7XG4gICAgdGhpcy5yYWlzZShub2RlLmlkLnN0YXJ0LCBcIkJpbmRpbmcgeWllbGQgaW4gc3RyaWN0IG1vZGVcIik7XG4gIH1cblxuICBpZiAoY2hlY2tMVmFsKSB7XG4gICAgdmFyIG5hbWVIYXNoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgaWYgKGlzU3RyaWN0KSB0aGlzLnN0YXRlLnN0cmljdCA9IHRydWU7XG4gICAgaWYgKG5vZGUuaWQpIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIHRydWUsIHVuZGVmaW5lZCwgXCJmdW5jdGlvbiBuYW1lXCIpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gbm9kZS5wYXJhbXMsIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XG4gICAgICAgIGlmIChfaTMuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyYW0gPSBfcmVmMztcblxuICAgICAgaWYgKGlzU3RyaWN0ICYmIHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UocGFyYW0uc3RhcnQsIFwiTm9uLXNpbXBsZSBwYXJhbWV0ZXIgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwgdHJ1ZSwgbmFtZUhhc2gsIFwiZnVuY3Rpb24gcGFyYW1ldGVyIGxpc3RcIik7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbi8vIGBhbGxvd0VtcHR5YCBjYW4gYmUgdHVybmVkIG9uIHRvIGFsbG93IHN1YnNlcXVlbnQgY29tbWFzIHdpdGhcbi8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxucHAkMy5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24gKGNsb3NlLCBhbGxvd0VtcHR5LCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIHZhciBlbHRzID0gW107XG4gIHZhciBmaXJzdCA9IHRydWU7XG5cbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmVhdChjbG9zZSkpIGJyZWFrO1xuICAgIH1cblxuICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlRXhwckxpc3RJdGVtKGFsbG93RW1wdHksIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpKTtcbiAgfVxuICByZXR1cm4gZWx0cztcbn07XG5cbnBwJDMucGFyc2VFeHByTGlzdEl0ZW0gPSBmdW5jdGlvbiAoYWxsb3dFbXB0eSwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgcmVmTmVlZHNBcnJvd1Bvcykge1xuICB2YXIgZWx0ID0gdm9pZCAwO1xuICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLm1hdGNoKHR5cGVzLmNvbW1hKSkge1xuICAgIGVsdCA9IG51bGw7XG4gIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICB9IGVsc2Uge1xuICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgdGhpcy5wYXJzZVBhcmVuSXRlbSwgcmVmTmVlZHNBcnJvd1Bvcyk7XG4gIH1cbiAgcmV0dXJuIGVsdDtcbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQzLnBhcnNlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChsaWJlcmFsKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKCFsaWJlcmFsKSB7XG4gICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZCh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0LCAhIXRoaXMuc3RhdGUudHlwZS5rZXl3b3JkLCBmYWxzZSk7XG4gIH1cblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnN0YXRlLnR5cGUua2V5d29yZDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIGlmICghbGliZXJhbCAmJiBub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiB0aGlzLnN0YXRlLmluQXN5bmMpIHtcbiAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiaW52YWxpZCB1c2Ugb2YgYXdhaXQgaW5zaWRlIG9mIGFuIGFzeW5jIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgbm9kZS5sb2MuaWRlbnRpZmllck5hbWUgPSBub2RlLm5hbWU7XG5cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xufTtcblxucHAkMy5jaGVja1Jlc2VydmVkV29yZCA9IGZ1bmN0aW9uICh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gIGlmICh0aGlzLmlzUmVzZXJ2ZWRXb3JkKHdvcmQpIHx8IGNoZWNrS2V5d29yZHMgJiYgdGhpcy5pc0tleXdvcmQod29yZCkpIHtcbiAgICB0aGlzLnJhaXNlKHN0YXJ0TG9jLCB3b3JkICsgXCIgaXMgYSByZXNlcnZlZCB3b3JkXCIpO1xuICB9XG5cbiAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIChyZXNlcnZlZFdvcmRzLnN0cmljdCh3b3JkKSB8fCBpc0JpbmRpbmcgJiYgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKHdvcmQpKSkge1xuICAgIHRoaXMucmFpc2Uoc3RhcnRMb2MsIHdvcmQgKyBcIiBpcyBhIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGVcIik7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhd2FpdCBleHByZXNzaW9uIGluc2lkZSBhc3luYyBmdW5jdGlvbi5cblxucHAkMy5wYXJzZUF3YWl0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IHRoaXMgY29uZGl0aW9uIGlzIGNoZWNrZWQgYXQgdGhlIGNhbGwgc2l0ZSBzbyB3b24ndCBiZSBoaXQgaGVyZVxuICBpZiAoIXRoaXMuc3RhdGUuaW5Bc3luYykge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnN0YXIpKSB7XG4gICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcImF3YWl0KiBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9ucyBwcm9wb3NhbC4gVXNlIFByb21pc2UuYWxsKCkgaW5zdGVhZC5cIik7XG4gIH1cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIik7XG59O1xuXG4vLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG5wcCQzLnBhcnNlWWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnNlbWkpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMubWF0Y2godHlwZXMuc3RhcikgJiYgIXRoaXMuc3RhdGUudHlwZS5zdGFydHNFeHByKSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKTtcbn07XG5cbi8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbnZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcbnZhciBjb21tZW50S2V5cyA9IFtcImxlYWRpbmdDb21tZW50c1wiLCBcInRyYWlsaW5nQ29tbWVudHNcIiwgXCJpbm5lckNvbW1lbnRzXCJdO1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZShwb3MsIGxvYywgZmlsZW5hbWUpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcblxuICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IHBvcztcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24obG9jKTtcbiAgICBpZiAoZmlsZW5hbWUpIHRoaXMubG9jLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gIH1cblxuICBOb2RlLnByb3RvdHlwZS5fX2Nsb25lID0gZnVuY3Rpb24gX19jbG9uZSgpIHtcbiAgICB2YXIgbm9kZTIgPSBuZXcgTm9kZSgpO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAvLyBEbyBub3QgY2xvbmUgY29tbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgbm9kZVxuICAgICAgaWYgKGNvbW1lbnRLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgbm9kZTJba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTI7XG4gIH07XG5cbiAgcmV0dXJuIE5vZGU7XG59KCk7XG5cbnBwJDQuc3RhcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE5vZGUodGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5zdGFydExvYywgdGhpcy5maWxlbmFtZSk7XG59O1xuXG5wcCQ0LnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24gKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZShwb3MsIGxvYywgdGhpcy5maWxlbmFtZSk7XG59O1xuXG5mdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgbm9kZS50eXBlID0gdHlwZTtcbiAgbm9kZS5lbmQgPSBwb3M7XG4gIG5vZGUubG9jLmVuZCA9IGxvYztcbiAgdGhpcy5wcm9jZXNzQ29tbWVudChub2RlKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxucHAkNC5maW5pc2hOb2RlID0gZnVuY3Rpb24gKG5vZGUsIHR5cGUpIHtcbiAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMuc3RhdGUubGFzdFRva0VuZCwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbn07XG5cbi8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbnBwJDQuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24gKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYyk7XG59O1xuXG52YXIgcHAkNSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbi8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4vLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4vLyBtZXNzYWdlLlxuXG5wcCQ1LnJhaXNlID0gZnVuY3Rpb24gKHBvcywgbWVzc2FnZSkge1xuICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICBlcnIucG9zID0gcG9zO1xuICBlcnIubG9jID0gbG9jO1xuICB0aHJvdyBlcnI7XG59O1xuXG4vKiBlc2xpbnQgbWF4LWxlbjogMCAqL1xuXG4vKipcbiAqIEJhc2VkIG9uIHRoZSBjb21tZW50IGF0dGFjaG1lbnQgYWxnb3JpdGhtIHVzZWQgaW4gZXNwcmVlIGFuZCBlc3RyYXZlcnNlLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAqIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gKiAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gKiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAqIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAqIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuZnVuY3Rpb24gbGFzdChzdGFjaykge1xuICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG59XG5cbnZhciBwcCQ2ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNi5hZGRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgaWYgKHRoaXMuZmlsZW5hbWUpIGNvbW1lbnQubG9jLmZpbGVuYW1lID0gdGhpcy5maWxlbmFtZTtcbiAgdGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gIHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG59O1xuXG5wcCQ2LnByb2Nlc3NDb21tZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJQcm9ncmFtXCIgJiYgbm9kZS5ib2R5Lmxlbmd0aCA+IDApIHJldHVybjtcblxuICB2YXIgc3RhY2sgPSB0aGlzLnN0YXRlLmNvbW1lbnRTdGFjaztcblxuICB2YXIgZmlyc3RDaGlsZCA9IHZvaWQgMCxcbiAgICAgIGxhc3RDaGlsZCA9IHZvaWQgMCxcbiAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSB2b2lkIDAsXG4gICAgICBpID0gdm9pZCAwLFxuICAgICAgaiA9IHZvaWQgMDtcblxuICBpZiAodGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBJZiB0aGUgZmlyc3QgY29tbWVudCBpbiB0cmFpbGluZ0NvbW1lbnRzIGNvbWVzIGFmdGVyIHRoZVxuICAgIC8vIGN1cnJlbnQgbm9kZSwgdGhlbiB3ZSdyZSBnb29kIC0gYWxsIGNvbW1lbnRzIGluIHRoZSBhcnJheSB3aWxsXG4gICAgLy8gY29tZSBhZnRlciB0aGUgbm9kZSBhbmQgc28gaXQncyBzYWZlIHRvIGFkZCB0aGVtIGFzIG9mZmljaWFsXG4gICAgLy8gdHJhaWxpbmdDb21tZW50cy5cbiAgICBpZiAodGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzWzBdLnN0YXJ0ID49IG5vZGUuZW5kKSB7XG4gICAgICB0cmFpbGluZ0NvbW1lbnRzID0gdGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgdGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIGZpcnN0IGNvbW1lbnQgZG9lc24ndCBjb21lIGFmdGVyIHRoZVxuICAgICAgLy8gY3VycmVudCBub2RlLCB0aGF0IG1lYW5zIHdlIGhhdmUgYSBtaXggb2YgbGVhZGluZyBhbmQgdHJhaWxpbmdcbiAgICAgIC8vIGNvbW1lbnRzIGluIHRoZSBhcnJheSBhbmQgdGhhdCBsZWFkaW5nQ29tbWVudHMgY29udGFpbnMgdGhlXG4gICAgICAvLyBzYW1lIGl0ZW1zIGFzIHRyYWlsaW5nQ29tbWVudHMuIFJlc2V0IHRyYWlsaW5nQ29tbWVudHMgdG9cbiAgICAgIC8vIHplcm8gaXRlbXMgYW5kIHdlJ2xsIGhhbmRsZSB0aGlzIGJ5IGV2YWx1YXRpbmcgbGVhZGluZ0NvbW1lbnRzXG4gICAgICAvLyBsYXRlci5cbiAgICAgIHRoaXMuc3RhdGUudHJhaWxpbmdDb21tZW50cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdEluU3RhY2sgPSBsYXN0KHN0YWNrKTtcbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiBsYXN0SW5TdGFjay50cmFpbGluZ0NvbW1lbnRzICYmIGxhc3RJblN0YWNrLnRyYWlsaW5nQ29tbWVudHNbMF0uc3RhcnQgPj0gbm9kZS5lbmQpIHtcbiAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBsYXN0SW5TdGFjay50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgbGFzdEluU3RhY2sudHJhaWxpbmdDb21tZW50cyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gRWF0aW5nIHRoZSBzdGFjay5cbiAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgbGFzdChzdGFjaykuc3RhcnQgPj0gbm9kZS5zdGFydCkge1xuICAgIGZpcnN0Q2hpbGQgPSBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmIGxhc3Qoc3RhY2spLnN0YXJ0ID49IG5vZGUuc3RhcnQpIHtcbiAgICBsYXN0Q2hpbGQgPSBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICghbGFzdENoaWxkICYmIGZpcnN0Q2hpbGQpIGxhc3RDaGlsZCA9IGZpcnN0Q2hpbGQ7XG5cbiAgLy8gQXR0YWNoIGNvbW1lbnRzIHRoYXQgZm9sbG93IGEgdHJhaWxpbmcgY29tbWEgb24gdGhlIGxhc3RcbiAgLy8gcHJvcGVydHkgaW4gYW4gb2JqZWN0IGxpdGVyYWwgb3IgYSB0cmFpbGluZyBjb21tYSBpbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgLy8gYXMgdHJhaWxpbmcgY29tbWVudHNcbiAgaWYgKGZpcnN0Q2hpbGQgJiYgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBsYXN0Q29tbWVudCA9IGxhc3QodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMpO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSB7XG4gICAgICBpZiAobGFzdENvbW1lbnQuc3RhcnQgPj0gbm9kZS5zdGFydCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHNbal0uZW5kIDwgdGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlLmVuZCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmlyc3RDaGlsZC50cmFpbGluZ0NvbW1lbnRzID0gdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgbm9kZS5hcmd1bWVudHMgJiYgbm9kZS5hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgbGFzdEFyZyA9IGxhc3Qobm9kZS5hcmd1bWVudHMpO1xuXG4gICAgICBpZiAobGFzdEFyZyAmJiBsYXN0Q29tbWVudC5zdGFydCA+PSBsYXN0QXJnLnN0YXJ0ICYmIGxhc3RDb21tZW50LmVuZCA8PSBub2RlLmVuZCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxhc3RBcmcudHJhaWxpbmdDb21tZW50cyA9IHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGFzdENoaWxkKSB7XG4gICAgaWYgKGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgIGlmIChsYXN0Q2hpbGQgIT09IG5vZGUgJiYgbGFzdChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzKS5lbmQgPD0gbm9kZS5zdGFydCkge1xuICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQSBsZWFkaW5nIGNvbW1lbnQgZm9yIGFuIGFub255bW91cyBjbGFzcyBoYWQgYmVlbiBzdG9sZW4gYnkgaXRzIGZpcnN0IENsYXNzTWV0aG9kLFxuICAgICAgICAvLyBzbyB0aGlzIHRha2VzIGJhY2sgdGhlIGxlYWRpbmcgY29tbWVudC5cbiAgICAgICAgLy8gU2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNwcmVlL2lzc3Vlcy8xNThcbiAgICAgICAgZm9yIChpID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzW2ldLmVuZCA8PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGxhc3QodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMpLmVuZCA8PSBub2RlLnN0YXJ0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50c1tqXS5lbmQgPCB0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzO1xuICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzcHJlZS9pc3N1ZXMvMlxuICAgICAgLy9cbiAgICAgIC8vIEluIHNwZWNpYWwgY2FzZXMsIHN1Y2ggYXMgcmV0dXJuICh3aXRob3V0IGEgdmFsdWUpIGFuZFxuICAgICAgLy8gZGVidWdnZXIsIGFsbCBjb21tZW50cyB3aWxsIGVuZCB1cCBhcyBsZWFkaW5nQ29tbWVudHMgYW5kXG4gICAgICAvLyB3aWxsIG90aGVyd2lzZSBiZSBlbGltaW5hdGVkLiBUaGlzIHN0ZXAgcnVucyB3aGVuIHRoZVxuICAgICAgLy8gY29tbWVudFN0YWNrIGlzIGVtcHR5IGFuZCB0aGVyZSBhcmUgY29tbWVudHMgbGVmdFxuICAgICAgLy8gaW4gbGVhZGluZ0NvbW1lbnRzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbG9vcCBmaWd1cmVzIG91dCB0aGUgc3RvcHBpbmcgcG9pbnQgYmV0d2VlbiB0aGUgYWN0dWFsXG4gICAgICAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBjb21tZW50cyBieSBmaW5kaW5nIHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgICAgIC8vIGZpcnN0IGNvbW1lbnQgdGhhdCBjb21lcyBhZnRlciB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHNbaV0uZW5kID4gbm9kZS5zdGFydCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNwbGl0IHRoZSBhcnJheSBiYXNlZCBvbiB0aGUgbG9jYXRpb24gb2YgdGhlIGZpcnN0IGNvbW1lbnRcbiAgICAgIC8vIHRoYXQgY29tZXMgYWZ0ZXIgdGhlIG5vZGUuIEtlZXAgaW4gbWluZCB0aGF0IHRoaXMgY291bGRcbiAgICAgIC8vIHJlc3VsdCBpbiBhbiBlbXB0eSBhcnJheSwgYW5kIGlmIHNvLCB0aGUgYXJyYXkgbXVzdCBiZVxuICAgICAgLy8gZGVsZXRlZC5cbiAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMuc2xpY2UoMCwgaSk7XG4gICAgICBpZiAobm9kZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU2ltaWxhcmx5LCB0cmFpbGluZyBjb21tZW50cyBhcmUgYXR0YWNoZWQgbGF0ZXIuIFRoZSB2YXJpYWJsZVxuICAgICAgLy8gbXVzdCBiZSByZXNldCB0byBudWxsIGlmIHRoZXJlIGFyZSBubyB0cmFpbGluZyBjb21tZW50cy5cbiAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zbGljZShpKTtcbiAgICAgIGlmICh0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUgPSBub2RlO1xuXG4gIGlmICh0cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgaWYgKHRyYWlsaW5nQ29tbWVudHMubGVuZ3RoICYmIHRyYWlsaW5nQ29tbWVudHNbMF0uc3RhcnQgPj0gbm9kZS5zdGFydCAmJiBsYXN0KHRyYWlsaW5nQ29tbWVudHMpLmVuZCA8PSBub2RlLmVuZCkge1xuICAgICAgbm9kZS5pbm5lckNvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cztcbiAgICB9XG4gIH1cblxuICBzdGFjay5wdXNoKG5vZGUpO1xufTtcblxudmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ3LmVzdHJlZVBhcnNlUmVnRXhwTGl0ZXJhbCA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwYXR0ZXJuID0gX3JlZi5wYXR0ZXJuLFxuICAgICAgZmxhZ3MgPSBfcmVmLmZsYWdzO1xuXG4gIHZhciByZWdleCA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEluIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlc2UgZmxhZ3MgdmFsdWUgd2lsbFxuICAgIC8vIGJlIG51bGwgYXMgdGhlIHJlZ2V4IGNhbid0IGJlIHJlcHJlc2VudGVkIG5hdGl2ZWx5LlxuICB9XG4gIHZhciBub2RlID0gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwocmVnZXgpO1xuICBub2RlLnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnBwJDcuZXN0cmVlUGFyc2VMaXRlcmFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJMaXRlcmFsXCIpO1xufTtcblxucHAkNy5kaXJlY3RpdmVUb1N0bXQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gIHZhciBkaXJlY3RpdmVMaXRlcmFsID0gZGlyZWN0aXZlLnZhbHVlO1xuXG4gIHZhciBzdG10ID0gdGhpcy5zdGFydE5vZGVBdChkaXJlY3RpdmUuc3RhcnQsIGRpcmVjdGl2ZS5sb2Muc3RhcnQpO1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuc3RhcnROb2RlQXQoZGlyZWN0aXZlTGl0ZXJhbC5zdGFydCwgZGlyZWN0aXZlTGl0ZXJhbC5sb2Muc3RhcnQpO1xuXG4gIGV4cHJlc3Npb24udmFsdWUgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlO1xuICBleHByZXNzaW9uLnJhdyA9IGRpcmVjdGl2ZUxpdGVyYWwuZXh0cmEucmF3O1xuXG4gIHN0bXQuZXhwcmVzc2lvbiA9IHRoaXMuZmluaXNoTm9kZUF0KGV4cHJlc3Npb24sIFwiTGl0ZXJhbFwiLCBkaXJlY3RpdmVMaXRlcmFsLmVuZCwgZGlyZWN0aXZlTGl0ZXJhbC5sb2MuZW5kKTtcbiAgc3RtdC5kaXJlY3RpdmUgPSBkaXJlY3RpdmVMaXRlcmFsLmV4dHJhLnJhdy5zbGljZSgxLCAtMSk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KHN0bXQsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCBkaXJlY3RpdmUuZW5kLCBkaXJlY3RpdmUubG9jLmVuZCk7XG59O1xuXG5mdW5jdGlvbiBpc1NpbXBsZVByb3BlcnR5KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgbm9kZS5raW5kID09PSBcImluaXRcIiAmJiBub2RlLm1ldGhvZCA9PT0gZmFsc2U7XG59XG5cbnZhciBlc3RyZWVQbHVnaW4gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuZXh0ZW5kKFwiY2hlY2tEZWNsYXJhdGlvblwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChpc1NpbXBsZVByb3BlcnR5KG5vZGUpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwiY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbUNvdW50XCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHByb3Auc3RhcnQ7XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJjaGVja0xWYWxcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChleHByLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgICBleHByLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgX3RoaXMuY2hlY2tMVmFsKHByb3AudHlwZSA9PT0gXCJQcm9wZXJ0eVwiID8gcHJvcC52YWx1ZSA6IHByb3AsIGlzQmluZGluZywgY2hlY2tDbGFzaGVzLCBcIm9iamVjdCBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpcywgZXhwciwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwiY2hlY2tQcm9wQ2xhc2hcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcCwgcHJvcEhhc2gpIHtcbiAgICAgIGlmIChwcm9wLmNvbXB1dGVkIHx8ICFpc1NpbXBsZVByb3BlcnR5KHByb3ApKSByZXR1cm47XG5cbiAgICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICAgIC8vIEl0IGlzIGVpdGhlciBhbiBJZGVudGlmaWVyIG9yIGEgU3RyaW5nL051bWVyaWNMaXRlcmFsXG4gICAgICB2YXIgbmFtZSA9IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lIDogU3RyaW5nKGtleS52YWx1ZSk7XG5cbiAgICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgIGlmIChwcm9wSGFzaC5wcm90bykgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcImlzU3RyaWN0Qm9keVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBpc0V4cHJlc3Npb24pIHtcbiAgICAgIGlmICghaXNFeHByZXNzaW9uICYmIG5vZGUuYm9keS5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbm9kZS5ib2R5LmJvZHksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjIgPSBfaS52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gX3JlZjI7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aXZlLnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIGRpcmVjdGl2ZS5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlLmV4cHJlc3Npb24udmFsdWUgPT09IFwidXNlIHN0cmljdFwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQnJlYWsgZm9yIHRoZSBmaXJzdCBub24gbGl0ZXJhbCBleHByZXNzaW9uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcImlzVmFsaWREaXJlY3RpdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgcmV0dXJuIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHR5cGVvZiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiYgKCFzdG10LmV4cHJlc3Npb24uZXh0cmEgfHwgIXN0bXQuZXhwcmVzc2lvbi5leHRyYS5wYXJlbnRoZXNpemVkKTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJzdG10VG9EaXJlY3RpdmVcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICB2YXIgZGlyZWN0aXZlID0gaW5uZXIuY2FsbCh0aGlzLCBzdG10KTtcbiAgICAgIHZhciB2YWx1ZSA9IHN0bXQuZXhwcmVzc2lvbi52YWx1ZTtcblxuICAgICAgLy8gUmVzZXQgdmFsdWUgdG8gdGhlIGFjdHVhbCB2YWx1ZSBhcyBpbiBlc3RyZWUgbW9kZSB3ZSB3YW50XG4gICAgICAvLyB0aGUgc3RtdCB0byBoYXZlIHRoZSByZWFsIHZhbHVlIGFuZCBub3QgdGhlIHJhdyB2YWx1ZVxuICAgICAgZGlyZWN0aXZlLnZhbHVlLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHJldHVybiBkaXJlY3RpdmU7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VCbG9ja0JvZHlcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpcywgbm9kZV0uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgbm9kZS5kaXJlY3RpdmVzLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgbm9kZS5ib2R5LnVuc2hpZnQoX3RoaXMyLmRpcmVjdGl2ZVRvU3RtdChkaXJlY3RpdmUpKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIG5vZGUuZGlyZWN0aXZlcztcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUNsYXNzTWV0aG9kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgICAgdGhpcy5wYXJzZU1ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICAgIGlmIChtZXRob2QudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgbWV0aG9kLnZhbHVlLnR5cGVQYXJhbWV0ZXJzID0gbWV0aG9kLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICBkZWxldGUgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgfVxuICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIikpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlRXhwckF0b21cIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgICAgICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlUmVnRXhwTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcblxuICAgICAgICBjYXNlIHR5cGVzLm51bTpcbiAgICAgICAgY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuX251bGw6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKG51bGwpO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuX3RydWU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHRydWUpO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgICAgICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChmYWxzZSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUxpdGVyYWxcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIG5vZGUucmF3ID0gbm9kZS5leHRyYS5yYXc7XG4gICAgICBkZWxldGUgbm9kZS5leHRyYTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VNZXRob2RcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgZnVuY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgZnVuY05vZGUua2luZCA9IG5vZGUua2luZDsgLy8gcHJvdmlkZSBraW5kLCBzbyBpbm5lciBtZXRob2QgY29ycmVjdGx5IHNldHMgc3RhdGVcblxuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICBmdW5jTm9kZSA9IGlubmVyLmNhbGwuYXBwbHkoaW5uZXIsIFt0aGlzLCBmdW5jTm9kZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIGRlbGV0ZSBmdW5jTm9kZS5raW5kO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMuZmluaXNoTm9kZShmdW5jTm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlT2JqZWN0TWV0aG9kXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gaW5uZXIuY2FsbC5hcHBseShpbm5lciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIG5vZGUua2luZCA9IFwiaW5pdFwiO1xuICAgICAgICBub2RlLnR5cGUgPSBcIlByb3BlcnR5XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlT2JqZWN0UHJvcGVydHlcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICAgIG5vZGUudHlwZSA9IFwiUHJvcGVydHlcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwidG9Bc3NpZ25hYmxlXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgaXNCaW5kaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuOCA+IDIgPyBfbGVuOCAtIDIgOiAwKSwgX2tleTggPSAyOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTggLSAyXSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1NpbXBsZVByb3BlcnR5KG5vZGUpKSB7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlLmFwcGx5KHRoaXMsIFtub2RlLnZhbHVlLCBpc0JpbmRpbmddLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBub2RlLnByb3BlcnRpZXMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjMgPSBfaTIudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByb3AgPSBfcmVmMztcblxuICAgICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIgfHwgcHJvcC5raW5kID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3AubWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gbWV0aG9kc1wiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nLCBcIm9iamVjdCBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpcywgbm9kZSwgaXNCaW5kaW5nXS5jb25jYXQoYXJncykpO1xuICAgIH07XG4gIH0pO1xufTtcblxuLyogZXNsaW50IG1heC1sZW46IDAgKi9cblxudmFyIHByaW1pdGl2ZVR5cGVzID0gW1wiYW55XCIsIFwibWl4ZWRcIiwgXCJlbXB0eVwiLCBcImJvb2xcIiwgXCJib29sZWFuXCIsIFwibnVtYmVyXCIsIFwic3RyaW5nXCIsIFwidm9pZFwiLCBcIm51bGxcIl07XG5cbnZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkOC5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIgPSBmdW5jdGlvbiAodG9rKSB7XG4gIHZhciBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICB0aGlzLmV4cGVjdCh0b2sgfHwgdHlwZXMuY29sb24pO1xuXG4gIHZhciB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICByZXR1cm4gdHlwZTtcbn07XG5cbnBwJDguZmxvd1BhcnNlUHJlZGljYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtb2R1bG9Mb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgbW9kdWxvUG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdGhpcy5leHBlY3QodHlwZXMubW9kdWxvKTtcbiAgdmFyIGNoZWNrc0xvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImNoZWNrc1wiKTtcbiAgLy8gRm9yY2UgJyUnIGFuZCAnY2hlY2tzJyB0byBiZSBhZGphY2VudFxuICBpZiAobW9kdWxvTG9jLmxpbmUgIT09IGNoZWNrc0xvYy5saW5lIHx8IG1vZHVsb0xvYy5jb2x1bW4gIT09IGNoZWNrc0xvYy5jb2x1bW4gLSAxKSB7XG4gICAgdGhpcy5yYWlzZShtb2R1bG9Qb3MsIFwiU3BhY2VzIGJldHdlZW4gwrQlwrQgYW5kIMK0Y2hlY2tzwrQgYXJlIG5vdCBhbGxvd2VkIGhlcmUuXCIpO1xuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlZFByZWRpY2F0ZVwiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW5mZXJyZWRQcmVkaWNhdGVcIik7XG4gIH1cbn07XG5cbnBwJDguZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICB2YXIgdHlwZSA9IG51bGw7XG4gIHZhciBwcmVkaWNhdGUgPSBudWxsO1xuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5tb2R1bG8pKSB7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcHJlZGljYXRlID0gdGhpcy5mbG93UGFyc2VQcmVkaWNhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubW9kdWxvKSkge1xuICAgICAgcHJlZGljYXRlID0gdGhpcy5mbG93UGFyc2VQcmVkaWNhdGUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt0eXBlLCBwcmVkaWNhdGVdO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlQ2xhc3MgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlQ2xhc3NcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIHZhciBpZCA9IG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuXG4gIHZhciB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciB0eXBlQ29udGFpbmVyID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgdHlwZU5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIHZhciB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICB0eXBlTm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICB0eXBlTm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIHZhciBwcmVkaWNhdGUgPSBudWxsO1xuXG4gIHZhciBfZmxvd1BhcnNlVHlwZUFuZFByZWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVJbml0aWFsaXNlcigpO1xuXG4gIHR5cGVOb2RlLnJldHVyblR5cGUgPSBfZmxvd1BhcnNlVHlwZUFuZFByZWRbMF07XG4gIHByZWRpY2F0ZSA9IF9mbG93UGFyc2VUeXBlQW5kUHJlZFsxXTtcblxuICB0eXBlQ29udGFpbmVyLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVOb2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIHR5cGVDb250YWluZXIucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICBpZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZSh0eXBlQ29udGFpbmVyLCBcIlR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gIHRoaXMuZmluaXNoTm9kZShpZCwgaWQudHlwZSk7XG5cbiAgdGhpcy5zZW1pY29sb24oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUZ1bmN0aW9uXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2NsYXNzKSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVDbGFzcyhub2RlKTtcbiAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLl9mdW5jdGlvbikpIHtcbiAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlRnVuY3Rpb24obm9kZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5fdmFyKSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVWYXJpYWJsZShub2RlKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcIm1vZHVsZVwiKSkge1xuICAgIGlmICh0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR5cGVzLmRvdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGUobm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwidHlwZVwiKSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJvcGFxdWVcIikpIHtcbiAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlT3BhcXVlVHlwZShub2RlKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImludGVyZmFjZVwiKSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5fZXhwb3J0KSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5fZXhwb3J0KTtcbiAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwib3BhcXVlXCIpIC8vIGRlY2xhcmUgZXhwb3J0IG9wYXF1ZSAuLi5cbiAgKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5mbG93UGFyc2VEZWNsYXJlKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgbm9kZS5kZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgfVxuXG4gIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcigpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZVZhcmlhYmxlXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlTW9kdWxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgfVxuXG4gIHZhciBib2R5Tm9kZSA9IG5vZGUuYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBib2R5ID0gYm9keU5vZGUuYm9keSA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMubWF0Y2godHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBfYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2ltcG9ydCkpIHtcbiAgICAgIHZhciBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgaWYgKGxvb2thaGVhZC52YWx1ZSAhPT0gXCJ0eXBlXCIgJiYgbG9va2FoZWFkLnZhbHVlICE9PSBcInR5cGVvZlwiKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCBcIkltcG9ydHMgd2l0aGluIGEgYGRlY2xhcmUgbW9kdWxlYCBib2R5IG11c3QgYWx3YXlzIGJlIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcnNlSW1wb3J0KF9ib2R5Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImRlY2xhcmVcIiwgXCJPbmx5IGRlY2xhcmVzIGFuZCB0eXBlIGltcG9ydHMgYXJlIGFsbG93ZWQgaW5zaWRlIGRlY2xhcmUgbW9kdWxlXCIpO1xuXG4gICAgICBfYm9keU5vZGUgPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUoX2JvZHlOb2RlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBib2R5LnB1c2goX2JvZHlOb2RlKTtcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuXG4gIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVNb2R1bGVcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwibW9kdWxlXCIpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5kb3QpO1xuICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJleHBvcnRzXCIpO1xuICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlRGVjbGFyZVR5cGVBbGlhcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVUeXBlQWxpYXNcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZURlY2xhcmVPcGFxdWVUeXBlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZmxvd1BhcnNlT3BhcXVlVHlwZShub2RlLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVPcGFxdWVUeXBlXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlSW50ZXJmYWNlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUludGVyZmFjZVwiKTtcbn07XG5cbi8vIEludGVyZmFjZXNcblxucHAkOC5mbG93UGFyc2VJbnRlcmZhY2Vpc2ggPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcblxuICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gIH1cblxuICBub2RlLmV4dGVuZHMgPSBbXTtcbiAgbm9kZS5taXhpbnMgPSBbXTtcblxuICBpZiAodGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpKSB7XG4gICAgZG8ge1xuICAgICAgbm9kZS5leHRlbmRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSk7XG4gIH1cblxuICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJtaXhpbnNcIikpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBkbyB7XG4gICAgICBub2RlLm1peGlucy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICB9IHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpO1xuICB9XG5cbiAgbm9kZS5ib2R5ID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHRydWUsIGZhbHNlLCBmYWxzZSk7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcigpO1xuICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VFeHRlbmRzXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VJbnRlcmZhY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCBmYWxzZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIgPSBmdW5jdGlvbiAobGliZXJhbCkge1xuICBpZiAocHJpbWl0aXZlVHlwZXMuaW5kZXhPZih0aGlzLnN0YXRlLnZhbHVlKSA+IC0xKSB7XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIkNhbm5vdCBvdmVyd3JpdGUgcHJpbWl0aXZlIHR5cGUgXCIgKyB0aGlzLnN0YXRlLnZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcihsaWJlcmFsKTtcbn07XG5cbi8vIFR5cGUgYWxpYXNlc1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGVBbGlhcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCk7XG5cbiAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICB9XG5cbiAgbm9kZS5yaWdodCA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKHR5cGVzLmVxKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZUFsaWFzXCIpO1xufTtcblxuLy8gT3BhcXVlIHR5cGUgYWxpYXNlc1xuXG5wcCQ4LmZsb3dQYXJzZU9wYXF1ZVR5cGUgPSBmdW5jdGlvbiAobm9kZSwgZGVjbGFyZSkge1xuICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJ0eXBlXCIpO1xuICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcigpO1xuXG4gIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBzdXBlcnR5cGVcbiAgbm9kZS5zdXBlcnR5cGUgPSBudWxsO1xuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikpIHtcbiAgICBub2RlLnN1cGVydHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKHR5cGVzLmNvbG9uKTtcbiAgfVxuXG4gIG5vZGUuaW1wbHR5cGUgPSBudWxsO1xuICBpZiAoIWRlY2xhcmUpIHtcbiAgICBub2RlLmltcGx0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIodHlwZXMuZXEpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9wYXF1ZVR5cGVcIik7XG59O1xuXG4vLyBUeXBlIGFubm90YXRpb25zXG5cbnBwJDguZmxvd1BhcnNlVHlwZVBhcmFtZXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gIHZhciB2YXJpYW5jZSA9IHRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKTtcblxuICB2YXIgaWRlbnQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoKTtcbiAgbm9kZS5uYW1lID0gaWRlbnQubmFtZTtcbiAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICBub2RlLmJvdW5kID0gaWRlbnQudHlwZUFubm90YXRpb247XG5cbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuZXEpKSB7XG4gICAgdGhpcy5lYXQodHlwZXMuZXEpO1xuICAgIG5vZGUuZGVmYXVsdCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUucGFyYW1zID0gW107XG5cbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuXG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiB0aGlzIGNvbmRpdGlvbiBpcyBhbHJlYWR5IGNoZWNrZWQgYXQgYWxsIGNhbGwgc2l0ZXNcbiAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ1N0YXJ0KSkge1xuICAgIHRoaXMubmV4dCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG5cbiAgZG8ge1xuICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyKCkpO1xuICAgIGlmICghdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpKSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgfVxuICB9IHdoaWxlICghdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpKTtcbiAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPlwiKTtcblxuICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gIG5vZGUucGFyYW1zID0gW107XG5cbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuXG4gIHRoaXMuZXhwZWN0UmVsYXRpb25hbChcIjxcIik7XG4gIHdoaWxlICghdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpKSB7XG4gICAgbm9kZS5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSk7XG4gICAgaWYgKCF0aGlzLmlzUmVsYXRpb25hbChcIj5cIikpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPlwiKTtcblxuICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5udW0pIHx8IHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRMKTtcbiAgaWYgKHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMuY29sb24pIHtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICB9XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcblxuICB0aGlzLmZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlSW5kZXhlclwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUucGFyYW1zID0gW107XG4gIG5vZGUucmVzdCA9IG51bGw7XG4gIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuXG4gIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgfVxuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIHdoaWxlICghdGhpcy5tYXRjaCh0eXBlcy5wYXJlblIpICYmICF0aGlzLm1hdGNoKHR5cGVzLmVsbGlwc2lzKSkge1xuICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpKTtcbiAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5SKSkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICBub2RlLnJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKCk7XG4gIH1cbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZCA9IGZ1bmN0aW9uIChzdGFydFBvcywgc3RhcnRMb2MsIGlzU3RhdGljLCBrZXkpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpKTtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgdGhpcy5mbG93T2JqZWN0VHlwZVNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGljKSB7XG4gIHZhciB2YWx1ZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHZhbHVlTm9kZSk7XG4gIHRoaXMuZmxvd09iamVjdFR5cGVTZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZU9iamVjdFR5cGUgPSBmdW5jdGlvbiAoYWxsb3dTdGF0aWMsIGFsbG93RXhhY3QsIGFsbG93U3ByZWFkKSB7XG4gIHZhciBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuXG4gIHZhciBub2RlU3RhcnQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdm9pZCAwO1xuICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcblxuICBub2RlU3RhcnQuY2FsbFByb3BlcnRpZXMgPSBbXTtcbiAgbm9kZVN0YXJ0LnByb3BlcnRpZXMgPSBbXTtcbiAgbm9kZVN0YXJ0LmluZGV4ZXJzID0gW107XG5cbiAgdmFyIGVuZERlbGltID0gdm9pZCAwO1xuICB2YXIgZXhhY3QgPSB2b2lkIDA7XG4gIGlmIChhbGxvd0V4YWN0ICYmIHRoaXMubWF0Y2godHlwZXMuYnJhY2VCYXJMKSkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlQmFyTCk7XG4gICAgZW5kRGVsaW0gPSB0eXBlcy5icmFjZUJhclI7XG4gICAgZXhhY3QgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgZW5kRGVsaW0gPSB0eXBlcy5icmFjZVI7XG4gICAgZXhhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIG5vZGVTdGFydC5leGFjdCA9IGV4YWN0O1xuXG4gIHdoaWxlICghdGhpcy5tYXRjaChlbmREZWxpbSkpIHtcbiAgICB2YXIgb3B0aW9uYWwgPSBmYWxzZTtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKGFsbG93U3RhdGljICYmIHRoaXMuaXNDb250ZXh0dWFsKFwic3RhdGljXCIpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSAhPT0gdHlwZXMuY29sb24pIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB2YXJpYW5jZVBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgdmFyIHZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICBub2RlU3RhcnQuaW5kZXhlcnMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpIHx8IHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZVBvcyk7XG4gICAgICB9XG4gICAgICBub2RlU3RhcnQuY2FsbFByb3BlcnRpZXMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgaXNTdGF0aWMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICAgIGlmICghYWxsb3dTcHJlYWQpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgXCJTcHJlYWQgb3BlcmF0b3IgY2Fubm90IGFwcGVhciBpbiBjbGFzcyBvciBpbnRlcmZhY2UgZGVmaW5pdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLnN0YXJ0LCBcIlNwcmVhZCBwcm9wZXJ0aWVzIGNhbm5vdCBoYXZlIHZhcmlhbmNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmVsbGlwc2lzKTtcbiAgICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLmZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCk7XG4gICAgICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnR5S2V5ID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2QgcHJvcGVydHlcbiAgICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZS5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kKHN0YXJ0UG9zLCBzdGFydExvYywgaXNTdGF0aWMsIHByb3BlcnR5S2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgICAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgICAgICB0aGlzLmZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCk7XG4gICAgICAgICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlUHJvcGVydHlcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNTdGF0aWMgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuZXhwZWN0KGVuZERlbGltKTtcblxuICB2YXIgb3V0ID0gdGhpcy5maW5pc2hOb2RlKG5vZGVTdGFydCwgXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKTtcblxuICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcblxuICByZXR1cm4gb3V0O1xufTtcblxucHAkOC5mbG93T2JqZWN0VHlwZVNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmVhdCh0eXBlcy5zZW1pKSAmJiAhdGhpcy5lYXQodHlwZXMuY29tbWEpICYmICF0aGlzLm1hdGNoKHR5cGVzLmJyYWNlUikgJiYgIXRoaXMubWF0Y2godHlwZXMuYnJhY2VCYXJSKSkge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYywgaWQpIHtcbiAgc3RhcnRQb3MgPSBzdGFydFBvcyB8fCB0aGlzLnN0YXRlLnN0YXJ0O1xuICBzdGFydExvYyA9IHN0YXJ0TG9jIHx8IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHZhciBub2RlID0gaWQgfHwgdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcblxuICB3aGlsZSAodGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgIHZhciBub2RlMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlMi5xdWFsaWZpY2F0aW9uID0gbm9kZTtcbiAgICBub2RlMi5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxucHAkOC5mbG93UGFyc2VHZW5lcmljVHlwZSA9IGZ1bmN0aW9uIChzdGFydFBvcywgc3RhcnRMb2MsIGlkKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuXG4gIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihzdGFydFBvcywgc3RhcnRMb2MsIGlkKTtcblxuICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGVvZlR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuX3R5cGVvZik7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlVHVwbGVUeXBlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUudHlwZXMgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldEwpO1xuICAvLyBXZSBhbGxvdyB0cmFpbGluZyBjb21tYXNcbiAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIXRoaXMubWF0Y2godHlwZXMuYnJhY2tldFIpKSB7XG4gICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZSgpKTtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFja2V0UikpIGJyZWFrO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWUgPSBudWxsO1xuICB2YXIgb3B0aW9uYWwgPSBmYWxzZTtcbiAgdmFyIHR5cGVBbm5vdGF0aW9uID0gbnVsbDtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuICBpZiAobGgudHlwZSA9PT0gdHlwZXMuY29sb24gfHwgbGgudHlwZSA9PT0gdHlwZXMucXVlc3Rpb24pIHtcbiAgICBuYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIHR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICB9XG4gIG5vZGUubmFtZSA9IG5hbWU7XG4gIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGVBbm5vdGF0aW9uO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG59O1xuXG5wcCQ4LnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0gPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQodHlwZS5zdGFydCwgdHlwZS5sb2Muc3RhcnQpO1xuICBub2RlLm5hbWUgPSBudWxsO1xuICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgdmFyIHJldCA9IHsgcGFyYW1zOiBwYXJhbXMsIHJlc3Q6IG51bGwgfTtcbiAgd2hpbGUgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikgJiYgIXRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgcmV0LnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oKSk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLmVsbGlwc2lzKSkge1xuICAgIHJldC5yZXN0ID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5wcCQ4LmZsb3dJZGVudFRvVHlwZUFubm90YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jLCBub2RlLCBpZCkge1xuICBzd2l0Y2ggKGlkLm5hbWUpIHtcbiAgICBjYXNlIFwiYW55XCI6XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQW55VHlwZUFubm90YXRpb25cIik7XG5cbiAgICBjYXNlIFwidm9pZFwiOlxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGNhc2UgXCJib29sXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIik7XG5cbiAgICBjYXNlIFwibWl4ZWRcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgY2FzZSBcImVtcHR5XCI6XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VHZW5lcmljVHlwZShzdGFydFBvcywgc3RhcnRMb2MsIGlkKTtcbiAgfVxufTtcblxuLy8gVGhlIHBhcnNpbmcgb2YgdHlwZXMgcm91Z2hseSBwYXJhbGxlbHMgdGhlIHBhcnNpbmcgb2YgZXhwcmVzc2lvbnMsIGFuZFxuLy8gcHJpbWFyeSB0eXBlcyBhcmUga2luZCBvZiBsaWtlIHByaW1hcnkgZXhwcmVzc2lvbnMuLi50aGV5J3JlIHRoZVxuLy8gcHJpbWl0aXZlcyB3aXRoIHdoaWNoIG90aGVyIHR5cGVzIGFyZSBjb25zdHJ1Y3RlZC5cbnBwJDguZmxvd1BhcnNlUHJpbWFyeVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIHRtcCA9IHZvaWQgMDtcbiAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gIHZhciBpc0dyb3VwZWRUeXBlID0gZmFsc2U7XG4gIHZhciBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcblxuICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgIGNhc2UgdHlwZXMubmFtZTpcbiAgICAgIHJldHVybiB0aGlzLmZsb3dJZGVudFRvVHlwZUFubm90YXRpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBub2RlLCB0aGlzLnBhcnNlSWRlbnRpZmllcigpKTtcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZShmYWxzZSwgZmFsc2UsIHRydWUpO1xuXG4gICAgY2FzZSB0eXBlcy5icmFjZUJhckw6XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKGZhbHNlLCB0cnVlLCB0cnVlKTtcblxuICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUdXBsZVR5cGUoKTtcblxuICAgIGNhc2UgdHlwZXMucmVsYXRpb25hbDpcbiAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIjxcIikge1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICAgICAgdG1wID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKTtcbiAgICAgICAgbm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5hcnJvdyk7XG5cbiAgICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGFjdHVhbGx5IGEgZ3JvdXBlZCB0eXBlXG4gICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5SKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZCgpLnR5cGU7XG4gICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRva2VuICE9PSB0eXBlcy5xdWVzdGlvbiAmJiB0b2tlbiAhPT0gdHlwZXMuY29sb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzR3JvdXBlZFR5cGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcblxuICAgICAgICAvLyBBIGAsYCBvciBhIGApID0+YCBtZWFucyB0aGlzIGlzIGFuIGFub255bW91cyBmdW5jdGlvbiB0eXBlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSB8fCAhKHRoaXMubWF0Y2godHlwZXMuY29tbWEpIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5SKSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR5cGVzLmFycm93KSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRWF0IGEgY29tbWEgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgdGhpcy5lYXQodHlwZXMuY29tbWEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKFt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odHlwZSldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgIG5vZGUucmVzdCA9IHRtcC5yZXN0O1xuXG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5hcnJvdyk7XG5cbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuXG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG5cbiAgICBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGNhc2UgdHlwZXMuX3RydWU6Y2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5tYXRjaCh0eXBlcy5fdHJ1ZSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5wbHVzTWluOlxuICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMubnVtKSkgdGhpcy51bmV4cGVjdGVkKG51bGwsIFwiVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgbnVtYmVyXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUuc3RhcnQsIG5vZGUubG9jLnN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgY2FzZSB0eXBlcy5udW06XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5fbnVsbDpcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLm1hdGNoKHR5cGVzLl9udWxsKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIik7XG5cbiAgICBjYXNlIHR5cGVzLl90aGlzOlxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMubWF0Y2godHlwZXMuX3RoaXMpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5zdGFyOlxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhpc3RlbnRpYWxUeXBlUGFyYW1cIik7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkID09PSBcInR5cGVvZlwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVvZlR5cGUoKTtcbiAgICAgIH1cbiAgfVxuXG4gIHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxucHAkOC5mbG93UGFyc2VQb3N0Zml4VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydCxcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgdmFyIHR5cGUgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gIHdoaWxlICghdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRMKSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRMKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5VHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVByZWZpeFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVByZWZpeFR5cGUoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VQb3N0Zml4VHlwZSgpO1xuICB9XG59O1xuXG5wcCQ4LmZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbSA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuICBpZiAoIXRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChwYXJhbS5zdGFydCwgcGFyYW0ubG9jLnN0YXJ0KTtcbiAgICBub2RlLnBhcmFtcyA9IFt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0ocGFyYW0pXTtcbiAgICBub2RlLnJlc3QgPSBudWxsO1xuICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIHJldHVybiBwYXJhbTtcbn07XG5cbnBwJDguZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLmVhdCh0eXBlcy5iaXR3aXNlQU5EKTtcbiAgdmFyIHR5cGUgPSB0aGlzLmZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMoKTtcbiAgbm9kZS50eXBlcyA9IFt0eXBlXTtcbiAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmJpdHdpc2VBTkQpKSB7XG4gICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpKTtcbiAgfVxuICByZXR1cm4gbm9kZS50eXBlcy5sZW5ndGggPT09IDEgPyB0eXBlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVVuaW9uVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLmVhdCh0eXBlcy5iaXR3aXNlT1IpO1xuICB2YXIgdHlwZSA9IHRoaXMuZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpO1xuICBub2RlLnR5cGVzID0gW3R5cGVdO1xuICB3aGlsZSAodGhpcy5lYXQodHlwZXMuYml0d2lzZU9SKSkge1xuICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVuaW9uVHlwZUFubm90YXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICB2YXIgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVW5pb25UeXBlKCk7XG4gIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICByZXR1cm4gdHlwZTtcbn07XG5cbnBwJDguZmxvd1BhcnNlVHlwZUFubm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUFubm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICB2YXIgX2Zsb3dQYXJzZVR5cGVBbmRQcmVkMiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG5cbiAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IF9mbG93UGFyc2VUeXBlQW5kUHJlZDJbMF07XG4gIG5vZGUucHJlZGljYXRlID0gX2Zsb3dQYXJzZVR5cGVBbmRQcmVkMlsxXTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZUFubm90YXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZGVudCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoKTtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgaWRlbnQudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGlkZW50LCBpZGVudC50eXBlKTtcbiAgfVxuICByZXR1cm4gaWRlbnQ7XG59O1xuXG5wcCQ4LnR5cGVDYXN0VG9QYXJhbWV0ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlLmV4cHJlc3Npb24udHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChub2RlLmV4cHJlc3Npb24sIG5vZGUuZXhwcmVzc2lvbi50eXBlLCBub2RlLnR5cGVBbm5vdGF0aW9uLmVuZCwgbm9kZS50eXBlQW5ub3RhdGlvbi5sb2MuZW5kKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlVmFyaWFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YXJpYW5jZSA9IG51bGw7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBsdXNNaW4pKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiK1wiKSB7XG4gICAgICB2YXJpYW5jZSA9IFwicGx1c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgIHZhcmlhbmNlID0gXCJtaW51c1wiO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuICByZXR1cm4gdmFyaWFuY2U7XG59O1xuXG52YXIgZmxvd1BsdWdpbiA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAvLyBwbGFpbiBmdW5jdGlvbiByZXR1cm4gdHlwZXM6IGZ1bmN0aW9uIG5hbWUoKTogc3RyaW5nIHt9XG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlRnVuY3Rpb25Cb2R5XCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgYWxsb3dFeHByZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgJiYgIWFsbG93RXhwcmVzc2lvbikge1xuICAgICAgICAvLyBpZiBhbGxvd0V4cHJlc3Npb24gaXMgdHJ1ZSB0aGVuIHdlJ3JlIHBhcnNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gYW5kIGlmXG4gICAgICAgIC8vIHRoZXJlJ3MgYSByZXR1cm4gdHlwZSB0aGVuIGl0J3MgYmVlbiBoYW5kbGVkIGVsc2V3aGVyZVxuICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVBbm5vdGF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIG5vZGUsIGFsbG93RXhwcmVzc2lvbik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gaW50ZXJmYWNlc1xuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZVN0YXRlbWVudFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRlY2xhcmF0aW9uLCB0b3BMZXZlbCkge1xuICAgICAgLy8gc3RyaWN0IG1vZGUgaGFuZGxpbmcgb2YgYGludGVyZmFjZWAgc2luY2UgaXQncyBhIHJlc2VydmVkIHdvcmRcbiAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiB0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmNhbGwodGhpcywgZGVjbGFyYXRpb24sIHRvcExldmVsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBkZWNsYXJlcywgaW50ZXJmYWNlcyBhbmQgdHlwZSBhbGlhc2VzXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlRXhwcmVzc2lvblN0YXRlbWVudFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGV4cHIpIHtcbiAgICAgIGlmIChleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIGlmIChleHByLm5hbWUgPT09IFwiZGVjbGFyZVwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2NsYXNzKSB8fCB0aGlzLm1hdGNoKHR5cGVzLm5hbWUpIHx8IHRoaXMubWF0Y2godHlwZXMuX2Z1bmN0aW9uKSB8fCB0aGlzLm1hdGNoKHR5cGVzLl92YXIpIHx8IHRoaXMubWF0Y2godHlwZXMuX2V4cG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmUobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgICAgICBpZiAoZXhwci5uYW1lID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXMobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwib3BhcXVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZU9wYXF1ZVR5cGUobm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBub2RlLCBleHByKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBleHBvcnQgdHlwZVxuICBpbnN0YW5jZS5leHRlbmQoXCJzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwiaW50ZXJmYWNlXCIpIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib3BhcXVlXCIpIHx8IGlubmVyLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwiaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSAmJiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJ0eXBlXCIgfHwgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJpbnRlcmZhY2VcIiB8fCB0aGlzLnN0YXRlLnZhbHVlID09PSBcIm9wYXF1ZVwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlQ29uZGl0aW9uYWxcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChleHByLCBub0luLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgICAgIC8vIG9ubHkgZG8gdGhlIGV4cGVuc2l2ZSBjbG9uZSBpZiB0aGVyZSBpcyBhIHF1ZXN0aW9uIG1hcmtcbiAgICAgIC8vIGFuZCBpZiB3ZSBjb21lIGZyb20gaW5zaWRlIHBhcmVuc1xuICAgICAgaWYgKHJlZk5lZWRzQXJyb3dQb3MgJiYgdGhpcy5tYXRjaCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIGV4cHIsIG5vSW4sIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmVmTmVlZHNBcnJvd1Bvcy5zdGFydCA9IGVyci5wb3MgfHwgdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm8gc3VjaCBlcnJvciBpcyBleHBlY3RlZFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBleHByLCBub0luLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlUGFyZW5JdGVtXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgICBub2RlID0gaW5uZXIuY2FsbCh0aGlzLCBub2RlLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIHZhciB0eXBlQ2FzdE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIHR5cGVDYXN0Tm9kZS5leHByZXNzaW9uID0gbm9kZTtcbiAgICAgICAgdHlwZUNhc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodHlwZUNhc3ROb2RlLCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VFeHBvcnRcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlID0gaW5uZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgIG5vZGUuZXhwb3J0S2luZCA9IG5vZGUuZXhwb3J0S2luZCB8fCBcInZhbHVlXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUV4cG9ydERlY2xhcmF0aW9uXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwidHlwZVwiKSkge1xuICAgICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcblxuICAgICAgICB2YXIgZGVjbGFyYXRpb25Ob2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2VMKSkge1xuICAgICAgICAgIC8vIGV4cG9ydCB0eXBlIHsgZm9vLCBiYXIgfTtcbiAgICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycygpO1xuICAgICAgICAgIHRoaXMucGFyc2VFeHBvcnRGcm9tKG5vZGUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGV4cG9ydCB0eXBlIEZvbyA9IEJhcjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXMoZGVjbGFyYXRpb25Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcIm9wYXF1ZVwiKSkge1xuICAgICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcblxuICAgICAgICB2YXIgX2RlY2xhcmF0aW9uTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAvLyBleHBvcnQgb3BhcXVlIHR5cGUgRm9vID0gQmFyO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKF9kZWNsYXJhdGlvbk5vZGUsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJpbnRlcmZhY2VcIikpIHtcbiAgICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICAgIHZhciBfZGVjbGFyYXRpb25Ob2RlMiA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2UoX2RlY2xhcmF0aW9uTm9kZTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VDbGFzc0lkXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaW5uZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZG9uJ3QgY29uc2lkZXIgYHZvaWRgIHRvIGJlIGEga2V5d29yZCBhcyB0aGVuIGl0J2xsIHVzZSB0aGUgdm9pZCB0b2tlbiB0eXBlXG4gIC8vIGFuZCBzZXQgc3RhcnRFeHByXG4gIGluc3RhbmNlLmV4dGVuZChcImlzS2V5d29yZFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiBuYW1lID09PSBcInZvaWRcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBlbnN1cmUgdGhhdCBpbnNpZGUgZmxvdyB0eXBlcywgd2UgYnlwYXNzIHRoZSBqc3ggcGFyc2VyIHBsdWdpblxuICBpbnN0YW5jZS5leHRlbmQoXCJyZWFkVG9rZW5cIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5pblR5cGUgJiYgKGNvZGUgPT09IDYyIHx8IGNvZGUgPT09IDYwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5yZWxhdGlvbmFsLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIGNvZGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIGRvbid0IGxleCBhbnkgdG9rZW4gYXMgYSBqc3ggb25lIGluc2lkZSBhIGZsb3cgdHlwZVxuICBpbnN0YW5jZS5leHRlbmQoXCJqc3hfcmVhZFRva2VuXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuaW5UeXBlKSByZXR1cm4gaW5uZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJ0b0Fzc2lnbmFibGVcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBpc0JpbmRpbmcsIGNvbnRleHREZXNjcmlwdGlvbikge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSksIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIG5vZGUsIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyB0dXJuIHR5cGUgY2FzdHMgdGhhdCB3ZSBmb3VuZCBpbiBmdW5jdGlvbiBwYXJhbWV0ZXIgaGVhZCBpbnRvIHR5cGUgYW5ub3RhdGVkIHBhcmFtc1xuICBpbnN0YW5jZS5leHRlbmQoXCJ0b0Fzc2lnbmFibGVMaXN0XCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXhwckxpc3QsIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBleHByID0gZXhwckxpc3RbaV07XG4gICAgICAgIGlmIChleHByICYmIGV4cHIudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIGV4cHJMaXN0W2ldID0gdGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKGV4cHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBleHByTGlzdCwgaXNCaW5kaW5nLCBjb250ZXh0RGVzY3JpcHRpb24pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgYSBsaXN0IG9mIG5vZGVzLCBmcm9tIHNvbWV0aGluZyBsaWtlIGEgY2FsbCBleHByZXNzaW9uLCB3ZSBuZWVkIHRvIGZpbHRlciB0aGVcbiAgLy8gdHlwZSBjYXN0cyB0aGF0IHdlJ3ZlIGZvdW5kIHRoYXQgYXJlIGlsbGVnYWwgaW4gdGhpcyBjb250ZXh0XG4gIGluc3RhbmNlLmV4dGVuZChcInRvUmVmZXJlbmNlZExpc3RcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXhwckxpc3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV4cHIgPSBleHByTGlzdFtpXTtcbiAgICAgICAgaWYgKGV4cHIgJiYgZXhwci5fZXhwckxpc3RJdGVtICYmIGV4cHIudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJVbmV4cGVjdGVkIHR5cGUgY2FzdFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwckxpc3Q7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgYW4gaXRlbSBpbnNpZGUgYSBleHByZXNzaW9uIGxpc3QgZWcuIGAoTk9ERSwgTk9ERSlgIHdoZXJlIE5PREUgcmVwcmVzZW50c1xuICAvLyB0aGUgcG9zaXRpb24gd2hlcmUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VFeHByTGlzdEl0ZW1cIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IGlubmVyLmNhbGwuYXBwbHkoaW5uZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIGNvbnRhaW5lci5fZXhwckxpc3RJdGVtID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbmVyLmV4cHJlc3Npb24gPSBub2RlO1xuICAgICAgICBjb250YWluZXIudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoY29udGFpbmVyLCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcImNoZWNrTFZhbFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgIT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgY2xhc3MgcHJvcGVydHkgdHlwZSBhbm5vdGF0aW9uc1xuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUNsYXNzUHJvcGVydHlcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBkZWxldGUgbm9kZS52YXJpYW5jZVBvcztcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSkge1xuICAgICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlubmVyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHdlJ3JlIGN1cnJlbnRseSBpbiB0aGUgcG9zaXRpb24gd2hlcmUgYSBjbGFzcyBtZXRob2Qgd291bGQgYXBwZWFyXG4gIGluc3RhbmNlLmV4dGVuZChcImlzQ2xhc3NNZXRob2RcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikgfHwgaW5uZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBvciBub3Qgd2UncmUgY3VycmVudGx5IGluIHRoZSBwb3NpdGlvbiB3aGVyZSBhIGNsYXNzIHByb3BlcnR5IHdvdWxkIGFwcGVhclxuICBpbnN0YW5jZS5leHRlbmQoXCJpc0NsYXNzUHJvcGVydHlcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSB8fCBpbm5lci5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcImlzTm9uc3RhdGljQ29uc3RydWN0b3JcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHJldHVybiAhdGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgJiYgaW5uZXIuY2FsbCh0aGlzLCBtZXRob2QpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHBhcnNlIHR5cGUgcGFyYW1ldGVycyBmb3IgY2xhc3MgbWV0aG9kc1xuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUNsYXNzTWV0aG9kXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2xhc3NCb2R5LCBtZXRob2QpIHtcbiAgICAgIGlmIChtZXRob2QudmFyaWFuY2UpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG1ldGhvZC52YXJpYW5jZVBvcyk7XG4gICAgICB9XG4gICAgICBkZWxldGUgbWV0aG9kLnZhcmlhbmNlO1xuICAgICAgZGVsZXRlIG1ldGhvZC52YXJpYW5jZVBvcztcbiAgICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgICAgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpcywgY2xhc3NCb2R5LCBtZXRob2RdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgYSB0aGUgc3VwZXIgY2xhc3MgdHlwZSBwYXJhbWV0ZXJzIGFuZCBpbXBsZW1lbnRzXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlQ2xhc3NTdXBlclwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gICAgICBpbm5lci5jYWxsKHRoaXMsIG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICAgIG5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImltcGxlbWVudHNcIikpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHZhciBpbXBsZW1lbnRlZCA9IG5vZGUuaW1wbGVtZW50cyA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICBfbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICAgICAgX25vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9ub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW1wbGVtZW50ZWQucHVzaCh0aGlzLmZpbmlzaE5vZGUoX25vZGUsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZVByb3BlcnR5TmFtZVwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciB2YXJpYW5jZVBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICB2YXIgdmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gICAgICB2YXIga2V5ID0gaW5uZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgIG5vZGUudmFyaWFuY2VQb3MgPSB2YXJpYW5jZVBvcztcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgdHlwZSBwYXJhbWV0ZXJzIGZvciBvYmplY3QgbWV0aG9kIHNob3J0aGFuZFxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZU9ialByb3BWYWx1ZVwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGlmIChwcm9wLnZhcmlhbmNlKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChwcm9wLnZhcmlhbmNlUG9zKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBwcm9wLnZhcmlhbmNlO1xuICAgICAgZGVsZXRlIHByb3AudmFyaWFuY2VQb3M7XG5cbiAgICAgIHZhciB0eXBlUGFyYW1ldGVycyA9IHZvaWQgMDtcblxuICAgICAgLy8gbWV0aG9kIHNob3J0aGFuZFxuICAgICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICB0eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgaW5uZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgLy8gYWRkIHR5cGVQYXJhbWV0ZXJzIGlmIHdlIGZvdW5kIHRoZW1cbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycykge1xuICAgICAgICAocHJvcC52YWx1ZSB8fCBwcm9wKS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgICAgcGFyYW0ub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIHBhcmFtLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2hOb2RlKHBhcmFtLCBwYXJhbS50eXBlKTtcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZU1heWJlRGVmYXVsdFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IGlubmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbm9kZS50eXBlQW5ub3RhdGlvbiAmJiBub2RlLnJpZ2h0LnN0YXJ0IDwgbm9kZS50eXBlQW5ub3RhdGlvbi5zdGFydCkge1xuICAgICAgICB0aGlzLnJhaXNlKG5vZGUudHlwZUFubm90YXRpb24uc3RhcnQsIFwiVHlwZSBhbm5vdGF0aW9ucyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXNzaWdubWVudHMsIGUuZy4gaW5zdGVhZCBvZiBgYWdlID0gMjU6IG51bWJlcmAgdXNlIGBhZ2U6IG51bWJlciA9IDI1YFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgdHlwZW9mIGFuZCB0eXBlIGltcG9ydHNcbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VJbXBvcnRTcGVjaWZpZXJzXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gXCJ2YWx1ZVwiO1xuXG4gICAgICB2YXIga2luZCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fdHlwZW9mKSkge1xuICAgICAgICBraW5kID0gXCJ0eXBlb2ZcIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpKSB7XG4gICAgICAgIGtpbmQgPSBcInR5cGVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChraW5kKSB7XG4gICAgICAgIHZhciBsaCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgIGlmIChsaC50eXBlID09PSB0eXBlcy5uYW1lICYmIGxoLnZhbHVlICE9PSBcImZyb21cIiB8fCBsaC50eXBlID09PSB0eXBlcy5icmFjZUwgfHwgbGgudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUuaW1wb3J0S2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5uZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBwYXJzZSBpbXBvcnQtdHlwZS90eXBlb2Ygc2hvcnRoYW5kXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlSW1wb3J0U3BlY2lmaWVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdmFyIGZpcnN0SWRlbnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgdmFyIGZpcnN0SWRlbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICAgICAgdmFyIHNwZWNpZmllclR5cGVLaW5kID0gbnVsbDtcbiAgICAgIGlmIChmaXJzdElkZW50Lm5hbWUgPT09IFwidHlwZVwiKSB7XG4gICAgICAgIHNwZWNpZmllclR5cGVLaW5kID0gXCJ0eXBlXCI7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0SWRlbnQubmFtZSA9PT0gXCJ0eXBlb2ZcIikge1xuICAgICAgICBzcGVjaWZpZXJUeXBlS2luZCA9IFwidHlwZW9mXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICAgIHZhciBhc19pZGVudCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBpZiAoc3BlY2lmaWVyVHlwZUtpbmQgIT09IG51bGwgJiYgIXRoaXMubWF0Y2godHlwZXMubmFtZSkgJiYgIXRoaXMuc3RhdGUudHlwZS5rZXl3b3JkKSB7XG4gICAgICAgICAgLy8gYGltcG9ydCB7dHlwZSBhcyAsYCBvciBgaW1wb3J0IHt0eXBlIGFzIH1gXG4gICAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gYXNfaWRlbnQ7XG4gICAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSBhc19pZGVudC5fX2Nsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYGltcG9ydCB7dHlwZSBhcyBmb29gXG4gICAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IG51bGw7XG4gICAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzcGVjaWZpZXJUeXBlS2luZCAhPT0gbnVsbCAmJiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCB0aGlzLnN0YXRlLnR5cGUua2V5d29yZCkpIHtcbiAgICAgICAgLy8gYGltcG9ydCB7dHlwZSBmb29gXG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IHNwZWNpZmllclR5cGVLaW5kO1xuICAgICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzQmluZGluZyA9IHRydWU7XG4gICAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gc3BlY2lmaWVyLmltcG9ydGVkLl9fY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBudWxsO1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSBzcGVjaWZpZXIuaW1wb3J0ZWQuX19jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSAmJiAoc3BlY2lmaWVyLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IHNwZWNpZmllci5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKGZpcnN0SWRlbnRMb2MsIFwiYFRoZSBgdHlwZWAgYW5kIGB0eXBlb2ZgIGtleXdvcmRzIG9uIG5hbWVkIGltcG9ydHMgY2FuIG9ubHkgYmUgdXNlZCBvbiByZWd1bGFyIGBpbXBvcnRgIHN0YXRlbWVudHMuIEl0IGNhbm5vdCBiZSB1c2VkIHdpdGggYGltcG9ydCB0eXBlYCBvciBgaW1wb3J0IHR5cGVvZmAgc3RhdGVtZW50c2BcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0JpbmRpbmcpIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllci5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHNwZWNpZmllci5sb2NhbCwgdHJ1ZSwgdW5kZWZpbmVkLCBcImltcG9ydCBzcGVjaWZpZXJcIik7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgZnVuY3Rpb24gdHlwZSBwYXJhbWV0ZXJzIC0gZnVuY3Rpb24gZm9vPFQ+KCkge31cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VGdW5jdGlvblBhcmFtc1wiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICB9XG4gICAgICBpbm5lci5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHBhcnNlIGZsb3cgdHlwZSBhbm5vdGF0aW9ucyBvbiB2YXJpYWJsZSBkZWNsYXJhdG9yIGhlYWRzIC0gbGV0IGZvbzogc3RyaW5nID0gYmFyXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlVmFySGVhZFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRlY2wpIHtcbiAgICAgIGlubmVyLmNhbGwodGhpcywgZGVjbCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikpIHtcbiAgICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlKGRlY2wuaWQsIGRlY2wuaWQudHlwZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgdGhlIHJldHVybiB0eXBlIG9mIGFuIGFzeW5jIGFycm93IGZ1bmN0aW9uIC0gbGV0IGZvbyA9IChhc3luYyAoKTogbnVtYmVyID0+IHt9KTtcbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgY2FsbCkge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIHZhciBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBub2RlLCBjYWxsKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyB0b2RvIGRlc2NyaXB0aW9uXG4gIGluc3RhbmNlLmV4dGVuZChcInNob3VsZFBhcnNlQXN5bmNBcnJvd1wiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMuY29sb24pIHx8IGlubmVyLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gV2UgbmVlZCB0byBzdXBwb3J0IHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9ucyBmb3IgYXJyb3cgZnVuY3Rpb25zLiBUaGlzXG4gIC8vIGlzIHRyaWNreS4gVGhlcmUgYXJlIHRocmVlIHNpdHVhdGlvbnMgd2UgbmVlZCB0byBoYW5kbGVcbiAgLy9cbiAgLy8gMS4gVGhpcyBpcyBlaXRoZXIgSlNYIG9yIGFuIGFycm93IGZ1bmN0aW9uLiBXZSdsbCB0cnkgSlNYIGZpcnN0LiBJZiB0aGF0XG4gIC8vICAgIGZhaWxzLCB3ZSdsbCB0cnkgYW4gYXJyb3cgZnVuY3Rpb24uIElmIHRoYXQgZmFpbHMsIHdlJ2xsIHRocm93IHRoZSBKU1hcbiAgLy8gICAgZXJyb3IuXG4gIC8vIDIuIFRoaXMgaXMgYW4gYXJyb3cgZnVuY3Rpb24uIFdlJ2xsIHBhcnNlIHRoZSB0eXBlIHBhcmFtZXRlciBkZWNsYXJhdGlvbixcbiAgLy8gICAgcGFyc2UgdGhlIHJlc3QsIG1ha2Ugc3VyZSB0aGUgcmVzdCBpcyBhbiBhcnJvdyBmdW5jdGlvbiwgYW5kIGdvIGZyb21cbiAgLy8gICAgdGhlcmVcbiAgLy8gMy4gVGhpcyBpcyBuZWl0aGVyLiBKdXN0IGNhbGwgdGhlIGlubmVyIGZ1bmN0aW9uXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlTWF5YmVBc3NpZ25cIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBqc3hFcnJvciA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVzLmpzeFRhZ1N0YXJ0ICYmIHRoaXMubWF0Y2godHlwZXMuanN4VGFnU3RhcnQpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gaW5uZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYHRjLmpfZXhwcmAgYW5kIGB0Yy5qX29UYWdgIGZyb20gY29udGV4dCBhZGRlZFxuICAgICAgICAgICAgLy8gYnkgcGFyc2luZyBganN4VGFnU3RhcnRgIHRvIHN0b3AgdGhlIEpTWCBwbHVnaW4gZnJvbVxuICAgICAgICAgICAgLy8gbWVzc2luZyB3aXRoIHRoZSB0b2tlbnNcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggLT0gMjtcblxuICAgICAgICAgICAganN4RXJyb3IgPSBlcnI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBubyBzdWNoIGVycm9yIGlzIGV4cGVjdGVkXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChqc3hFcnJvciAhPSBudWxsIHx8IHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICB2YXIgYXJyb3dFeHByZXNzaW9uID0gdm9pZCAwO1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuXG4gICAgICAgICAgYXJyb3dFeHByZXNzaW9uID0gaW5uZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgYXJyb3dFeHByZXNzaW9uLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgICAgICAgYXJyb3dFeHByZXNzaW9uLnN0YXJ0ID0gdHlwZVBhcmFtZXRlcnMuc3RhcnQ7XG4gICAgICAgICAgYXJyb3dFeHByZXNzaW9uLmxvYy5zdGFydCA9IHR5cGVQYXJhbWV0ZXJzLmxvYy5zdGFydDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cganN4RXJyb3IgfHwgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycm93RXhwcmVzc2lvbi50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3dFeHByZXNzaW9uO1xuICAgICAgICB9IGVsc2UgaWYgKGpzeEVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBqc3hFcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHR5cGVQYXJhbWV0ZXJzLnN0YXJ0LCBcIkV4cGVjdGVkIGFuIGFycm93IGZ1bmN0aW9uIGFmdGVyIHRoaXMgdHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlubmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIGhhbmRsZSByZXR1cm4gdHlwZXMgZm9yIGFycm93IGZ1bmN0aW9uc1xuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUFycm93XCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSB0cnVlO1xuICAgICAgICAgIHZhciByZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlQW5ub3RhdGlvbigpO1xuICAgICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5hcnJvdykpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIC8vIGFzc2lnbiBhZnRlciBpdCBpcyBjbGVhciBpdCBpcyBhbiBhcnJvd1xuICAgICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHJldHVyblR5cGU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm8gc3VjaCBlcnJvciBpcyBleHBlY3RlZFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJzaG91bGRQYXJzZUFycm93XCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgfHwgaW5uZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9KTtcbn07XG5cbi8vIEFkYXB0ZWQgZnJvbSBTdHJpbmcuZnJvbWNvZGVwb2ludCB0byBleHBvcnQgdGhlIGZ1bmN0aW9uIHdpdGhvdXQgbW9kaWZ5aW5nIFN0cmluZ1xuLyohIGh0dHBzOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjIuMSBieSBAbWF0aGlhcyAqL1xuXG4vLyBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbi8vIENvcHlyaWdodCAoYykgTWF0aGlhcyBCeW5lbnNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kXG4vLyBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuLy8gaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSxcbi8vIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yXG4vLyBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUXG4vLyBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG5pZiAoIWZyb21Db2RlUG9pbnQpIHtcbiAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KCkge1xuICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMDtcbiAgICB2YXIgY29kZVVuaXRzID0gW107XG4gICAgdmFyIGhpZ2hTdXJyb2dhdGUgPSB2b2lkIDA7XG4gICAgdmFyIGxvd1N1cnJvZ2F0ZSA9IHZvaWQgMDtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3VtZW50c1tpbmRleF0pO1xuICAgICAgaWYgKCFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgIGZsb29yKGNvZGVQb2ludCkgIT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICApIHtcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50OiBcIiArIGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7XG4gICAgICAgIC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMDtcbiAgICAgICAgbG93U3Vycm9nYXRlID0gY29kZVBvaW50ICUgMHg0MDAgKyAweERDMDA7XG4gICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggKyAxID09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpO1xuICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxudmFyIGZyb21Db2RlUG9pbnQkMSA9IGZyb21Db2RlUG9pbnQ7XG5cbnZhciBYSFRNTEVudGl0aWVzID0ge1xuICBxdW90OiBcIlxcXCJcIixcbiAgYW1wOiBcIiZcIixcbiAgYXBvczogXCInXCIsXG4gIGx0OiBcIjxcIixcbiAgZ3Q6IFwiPlwiLFxuICBuYnNwOiBcIlxceEEwXCIsXG4gIGlleGNsOiBcIlxceEExXCIsXG4gIGNlbnQ6IFwiXFx4QTJcIixcbiAgcG91bmQ6IFwiXFx4QTNcIixcbiAgY3VycmVuOiBcIlxceEE0XCIsXG4gIHllbjogXCJcXHhBNVwiLFxuICBicnZiYXI6IFwiXFx4QTZcIixcbiAgc2VjdDogXCJcXHhBN1wiLFxuICB1bWw6IFwiXFx4QThcIixcbiAgY29weTogXCJcXHhBOVwiLFxuICBvcmRmOiBcIlxceEFBXCIsXG4gIGxhcXVvOiBcIlxceEFCXCIsXG4gIG5vdDogXCJcXHhBQ1wiLFxuICBzaHk6IFwiXFx4QURcIixcbiAgcmVnOiBcIlxceEFFXCIsXG4gIG1hY3I6IFwiXFx4QUZcIixcbiAgZGVnOiBcIlxceEIwXCIsXG4gIHBsdXNtbjogXCJcXHhCMVwiLFxuICBzdXAyOiBcIlxceEIyXCIsXG4gIHN1cDM6IFwiXFx4QjNcIixcbiAgYWN1dGU6IFwiXFx4QjRcIixcbiAgbWljcm86IFwiXFx4QjVcIixcbiAgcGFyYTogXCJcXHhCNlwiLFxuICBtaWRkb3Q6IFwiXFx4QjdcIixcbiAgY2VkaWw6IFwiXFx4QjhcIixcbiAgc3VwMTogXCJcXHhCOVwiLFxuICBvcmRtOiBcIlxceEJBXCIsXG4gIHJhcXVvOiBcIlxceEJCXCIsXG4gIGZyYWMxNDogXCJcXHhCQ1wiLFxuICBmcmFjMTI6IFwiXFx4QkRcIixcbiAgZnJhYzM0OiBcIlxceEJFXCIsXG4gIGlxdWVzdDogXCJcXHhCRlwiLFxuICBBZ3JhdmU6IFwiXFx4QzBcIixcbiAgQWFjdXRlOiBcIlxceEMxXCIsXG4gIEFjaXJjOiBcIlxceEMyXCIsXG4gIEF0aWxkZTogXCJcXHhDM1wiLFxuICBBdW1sOiBcIlxceEM0XCIsXG4gIEFyaW5nOiBcIlxceEM1XCIsXG4gIEFFbGlnOiBcIlxceEM2XCIsXG4gIENjZWRpbDogXCJcXHhDN1wiLFxuICBFZ3JhdmU6IFwiXFx4QzhcIixcbiAgRWFjdXRlOiBcIlxceEM5XCIsXG4gIEVjaXJjOiBcIlxceENBXCIsXG4gIEV1bWw6IFwiXFx4Q0JcIixcbiAgSWdyYXZlOiBcIlxceENDXCIsXG4gIElhY3V0ZTogXCJcXHhDRFwiLFxuICBJY2lyYzogXCJcXHhDRVwiLFxuICBJdW1sOiBcIlxceENGXCIsXG4gIEVUSDogXCJcXHhEMFwiLFxuICBOdGlsZGU6IFwiXFx4RDFcIixcbiAgT2dyYXZlOiBcIlxceEQyXCIsXG4gIE9hY3V0ZTogXCJcXHhEM1wiLFxuICBPY2lyYzogXCJcXHhENFwiLFxuICBPdGlsZGU6IFwiXFx4RDVcIixcbiAgT3VtbDogXCJcXHhENlwiLFxuICB0aW1lczogXCJcXHhEN1wiLFxuICBPc2xhc2g6IFwiXFx4RDhcIixcbiAgVWdyYXZlOiBcIlxceEQ5XCIsXG4gIFVhY3V0ZTogXCJcXHhEQVwiLFxuICBVY2lyYzogXCJcXHhEQlwiLFxuICBVdW1sOiBcIlxceERDXCIsXG4gIFlhY3V0ZTogXCJcXHhERFwiLFxuICBUSE9STjogXCJcXHhERVwiLFxuICBzemxpZzogXCJcXHhERlwiLFxuICBhZ3JhdmU6IFwiXFx4RTBcIixcbiAgYWFjdXRlOiBcIlxceEUxXCIsXG4gIGFjaXJjOiBcIlxceEUyXCIsXG4gIGF0aWxkZTogXCJcXHhFM1wiLFxuICBhdW1sOiBcIlxceEU0XCIsXG4gIGFyaW5nOiBcIlxceEU1XCIsXG4gIGFlbGlnOiBcIlxceEU2XCIsXG4gIGNjZWRpbDogXCJcXHhFN1wiLFxuICBlZ3JhdmU6IFwiXFx4RThcIixcbiAgZWFjdXRlOiBcIlxceEU5XCIsXG4gIGVjaXJjOiBcIlxceEVBXCIsXG4gIGV1bWw6IFwiXFx4RUJcIixcbiAgaWdyYXZlOiBcIlxceEVDXCIsXG4gIGlhY3V0ZTogXCJcXHhFRFwiLFxuICBpY2lyYzogXCJcXHhFRVwiLFxuICBpdW1sOiBcIlxceEVGXCIsXG4gIGV0aDogXCJcXHhGMFwiLFxuICBudGlsZGU6IFwiXFx4RjFcIixcbiAgb2dyYXZlOiBcIlxceEYyXCIsXG4gIG9hY3V0ZTogXCJcXHhGM1wiLFxuICBvY2lyYzogXCJcXHhGNFwiLFxuICBvdGlsZGU6IFwiXFx4RjVcIixcbiAgb3VtbDogXCJcXHhGNlwiLFxuICBkaXZpZGU6IFwiXFx4RjdcIixcbiAgb3NsYXNoOiBcIlxceEY4XCIsXG4gIHVncmF2ZTogXCJcXHhGOVwiLFxuICB1YWN1dGU6IFwiXFx4RkFcIixcbiAgdWNpcmM6IFwiXFx4RkJcIixcbiAgdXVtbDogXCJcXHhGQ1wiLFxuICB5YWN1dGU6IFwiXFx4RkRcIixcbiAgdGhvcm46IFwiXFx4RkVcIixcbiAgeXVtbDogXCJcXHhGRlwiLFxuICBPRWxpZzogXCJcXHUwMTUyXCIsXG4gIG9lbGlnOiBcIlxcdTAxNTNcIixcbiAgU2Nhcm9uOiBcIlxcdTAxNjBcIixcbiAgc2Nhcm9uOiBcIlxcdTAxNjFcIixcbiAgWXVtbDogXCJcXHUwMTc4XCIsXG4gIGZub2Y6IFwiXFx1MDE5MlwiLFxuICBjaXJjOiBcIlxcdTAyQzZcIixcbiAgdGlsZGU6IFwiXFx1MDJEQ1wiLFxuICBBbHBoYTogXCJcXHUwMzkxXCIsXG4gIEJldGE6IFwiXFx1MDM5MlwiLFxuICBHYW1tYTogXCJcXHUwMzkzXCIsXG4gIERlbHRhOiBcIlxcdTAzOTRcIixcbiAgRXBzaWxvbjogXCJcXHUwMzk1XCIsXG4gIFpldGE6IFwiXFx1MDM5NlwiLFxuICBFdGE6IFwiXFx1MDM5N1wiLFxuICBUaGV0YTogXCJcXHUwMzk4XCIsXG4gIElvdGE6IFwiXFx1MDM5OVwiLFxuICBLYXBwYTogXCJcXHUwMzlBXCIsXG4gIExhbWJkYTogXCJcXHUwMzlCXCIsXG4gIE11OiBcIlxcdTAzOUNcIixcbiAgTnU6IFwiXFx1MDM5RFwiLFxuICBYaTogXCJcXHUwMzlFXCIsXG4gIE9taWNyb246IFwiXFx1MDM5RlwiLFxuICBQaTogXCJcXHUwM0EwXCIsXG4gIFJobzogXCJcXHUwM0ExXCIsXG4gIFNpZ21hOiBcIlxcdTAzQTNcIixcbiAgVGF1OiBcIlxcdTAzQTRcIixcbiAgVXBzaWxvbjogXCJcXHUwM0E1XCIsXG4gIFBoaTogXCJcXHUwM0E2XCIsXG4gIENoaTogXCJcXHUwM0E3XCIsXG4gIFBzaTogXCJcXHUwM0E4XCIsXG4gIE9tZWdhOiBcIlxcdTAzQTlcIixcbiAgYWxwaGE6IFwiXFx1MDNCMVwiLFxuICBiZXRhOiBcIlxcdTAzQjJcIixcbiAgZ2FtbWE6IFwiXFx1MDNCM1wiLFxuICBkZWx0YTogXCJcXHUwM0I0XCIsXG4gIGVwc2lsb246IFwiXFx1MDNCNVwiLFxuICB6ZXRhOiBcIlxcdTAzQjZcIixcbiAgZXRhOiBcIlxcdTAzQjdcIixcbiAgdGhldGE6IFwiXFx1MDNCOFwiLFxuICBpb3RhOiBcIlxcdTAzQjlcIixcbiAga2FwcGE6IFwiXFx1MDNCQVwiLFxuICBsYW1iZGE6IFwiXFx1MDNCQlwiLFxuICBtdTogXCJcXHUwM0JDXCIsXG4gIG51OiBcIlxcdTAzQkRcIixcbiAgeGk6IFwiXFx1MDNCRVwiLFxuICBvbWljcm9uOiBcIlxcdTAzQkZcIixcbiAgcGk6IFwiXFx1MDNDMFwiLFxuICByaG86IFwiXFx1MDNDMVwiLFxuICBzaWdtYWY6IFwiXFx1MDNDMlwiLFxuICBzaWdtYTogXCJcXHUwM0MzXCIsXG4gIHRhdTogXCJcXHUwM0M0XCIsXG4gIHVwc2lsb246IFwiXFx1MDNDNVwiLFxuICBwaGk6IFwiXFx1MDNDNlwiLFxuICBjaGk6IFwiXFx1MDNDN1wiLFxuICBwc2k6IFwiXFx1MDNDOFwiLFxuICBvbWVnYTogXCJcXHUwM0M5XCIsXG4gIHRoZXRhc3ltOiBcIlxcdTAzRDFcIixcbiAgdXBzaWg6IFwiXFx1MDNEMlwiLFxuICBwaXY6IFwiXFx1MDNENlwiLFxuICBlbnNwOiBcIlxcdTIwMDJcIixcbiAgZW1zcDogXCJcXHUyMDAzXCIsXG4gIHRoaW5zcDogXCJcXHUyMDA5XCIsXG4gIHp3bmo6IFwiXFx1MjAwQ1wiLFxuICB6d2o6IFwiXFx1MjAwRFwiLFxuICBscm06IFwiXFx1MjAwRVwiLFxuICBybG06IFwiXFx1MjAwRlwiLFxuICBuZGFzaDogXCJcXHUyMDEzXCIsXG4gIG1kYXNoOiBcIlxcdTIwMTRcIixcbiAgbHNxdW86IFwiXFx1MjAxOFwiLFxuICByc3F1bzogXCJcXHUyMDE5XCIsXG4gIHNicXVvOiBcIlxcdTIwMUFcIixcbiAgbGRxdW86IFwiXFx1MjAxQ1wiLFxuICByZHF1bzogXCJcXHUyMDFEXCIsXG4gIGJkcXVvOiBcIlxcdTIwMUVcIixcbiAgZGFnZ2VyOiBcIlxcdTIwMjBcIixcbiAgRGFnZ2VyOiBcIlxcdTIwMjFcIixcbiAgYnVsbDogXCJcXHUyMDIyXCIsXG4gIGhlbGxpcDogXCJcXHUyMDI2XCIsXG4gIHBlcm1pbDogXCJcXHUyMDMwXCIsXG4gIHByaW1lOiBcIlxcdTIwMzJcIixcbiAgUHJpbWU6IFwiXFx1MjAzM1wiLFxuICBsc2FxdW86IFwiXFx1MjAzOVwiLFxuICByc2FxdW86IFwiXFx1MjAzQVwiLFxuICBvbGluZTogXCJcXHUyMDNFXCIsXG4gIGZyYXNsOiBcIlxcdTIwNDRcIixcbiAgZXVybzogXCJcXHUyMEFDXCIsXG4gIGltYWdlOiBcIlxcdTIxMTFcIixcbiAgd2VpZXJwOiBcIlxcdTIxMThcIixcbiAgcmVhbDogXCJcXHUyMTFDXCIsXG4gIHRyYWRlOiBcIlxcdTIxMjJcIixcbiAgYWxlZnN5bTogXCJcXHUyMTM1XCIsXG4gIGxhcnI6IFwiXFx1MjE5MFwiLFxuICB1YXJyOiBcIlxcdTIxOTFcIixcbiAgcmFycjogXCJcXHUyMTkyXCIsXG4gIGRhcnI6IFwiXFx1MjE5M1wiLFxuICBoYXJyOiBcIlxcdTIxOTRcIixcbiAgY3JhcnI6IFwiXFx1MjFCNVwiLFxuICBsQXJyOiBcIlxcdTIxRDBcIixcbiAgdUFycjogXCJcXHUyMUQxXCIsXG4gIHJBcnI6IFwiXFx1MjFEMlwiLFxuICBkQXJyOiBcIlxcdTIxRDNcIixcbiAgaEFycjogXCJcXHUyMUQ0XCIsXG4gIGZvcmFsbDogXCJcXHUyMjAwXCIsXG4gIHBhcnQ6IFwiXFx1MjIwMlwiLFxuICBleGlzdDogXCJcXHUyMjAzXCIsXG4gIGVtcHR5OiBcIlxcdTIyMDVcIixcbiAgbmFibGE6IFwiXFx1MjIwN1wiLFxuICBpc2luOiBcIlxcdTIyMDhcIixcbiAgbm90aW46IFwiXFx1MjIwOVwiLFxuICBuaTogXCJcXHUyMjBCXCIsXG4gIHByb2Q6IFwiXFx1MjIwRlwiLFxuICBzdW06IFwiXFx1MjIxMVwiLFxuICBtaW51czogXCJcXHUyMjEyXCIsXG4gIGxvd2FzdDogXCJcXHUyMjE3XCIsXG4gIHJhZGljOiBcIlxcdTIyMUFcIixcbiAgcHJvcDogXCJcXHUyMjFEXCIsXG4gIGluZmluOiBcIlxcdTIyMUVcIixcbiAgYW5nOiBcIlxcdTIyMjBcIixcbiAgYW5kOiBcIlxcdTIyMjdcIixcbiAgb3I6IFwiXFx1MjIyOFwiLFxuICBjYXA6IFwiXFx1MjIyOVwiLFxuICBjdXA6IFwiXFx1MjIyQVwiLFxuICBcImludFwiOiBcIlxcdTIyMkJcIixcbiAgdGhlcmU0OiBcIlxcdTIyMzRcIixcbiAgc2ltOiBcIlxcdTIyM0NcIixcbiAgY29uZzogXCJcXHUyMjQ1XCIsXG4gIGFzeW1wOiBcIlxcdTIyNDhcIixcbiAgbmU6IFwiXFx1MjI2MFwiLFxuICBlcXVpdjogXCJcXHUyMjYxXCIsXG4gIGxlOiBcIlxcdTIyNjRcIixcbiAgZ2U6IFwiXFx1MjI2NVwiLFxuICBzdWI6IFwiXFx1MjI4MlwiLFxuICBzdXA6IFwiXFx1MjI4M1wiLFxuICBuc3ViOiBcIlxcdTIyODRcIixcbiAgc3ViZTogXCJcXHUyMjg2XCIsXG4gIHN1cGU6IFwiXFx1MjI4N1wiLFxuICBvcGx1czogXCJcXHUyMjk1XCIsXG4gIG90aW1lczogXCJcXHUyMjk3XCIsXG4gIHBlcnA6IFwiXFx1MjJBNVwiLFxuICBzZG90OiBcIlxcdTIyQzVcIixcbiAgbGNlaWw6IFwiXFx1MjMwOFwiLFxuICByY2VpbDogXCJcXHUyMzA5XCIsXG4gIGxmbG9vcjogXCJcXHUyMzBBXCIsXG4gIHJmbG9vcjogXCJcXHUyMzBCXCIsXG4gIGxhbmc6IFwiXFx1MjMyOVwiLFxuICByYW5nOiBcIlxcdTIzMkFcIixcbiAgbG96OiBcIlxcdTI1Q0FcIixcbiAgc3BhZGVzOiBcIlxcdTI2NjBcIixcbiAgY2x1YnM6IFwiXFx1MjY2M1wiLFxuICBoZWFydHM6IFwiXFx1MjY2NVwiLFxuICBkaWFtczogXCJcXHUyNjY2XCJcbn07XG5cbnZhciBIRVhfTlVNQkVSID0gL15bXFxkYS1mQS1GXSskLztcbnZhciBERUNJTUFMX05VTUJFUiA9IC9eXFxkKyQvO1xuXG50eXBlcyQxLmpfb1RhZyA9IG5ldyBUb2tDb250ZXh0KFwiPHRhZ1wiLCBmYWxzZSk7XG50eXBlcyQxLmpfY1RhZyA9IG5ldyBUb2tDb250ZXh0KFwiPC90YWdcIiwgZmFsc2UpO1xudHlwZXMkMS5qX2V4cHIgPSBuZXcgVG9rQ29udGV4dChcIjx0YWc+Li4uPC90YWc+XCIsIHRydWUsIHRydWUpO1xuXG50eXBlcy5qc3hOYW1lID0gbmV3IFRva2VuVHlwZShcImpzeE5hbWVcIik7XG50eXBlcy5qc3hUZXh0ID0gbmV3IFRva2VuVHlwZShcImpzeFRleHRcIiwgeyBiZWZvcmVFeHByOiB0cnVlIH0pO1xudHlwZXMuanN4VGFnU3RhcnQgPSBuZXcgVG9rZW5UeXBlKFwianN4VGFnU3RhcnRcIiwgeyBzdGFydHNFeHByOiB0cnVlIH0pO1xudHlwZXMuanN4VGFnRW5kID0gbmV3IFRva2VuVHlwZShcImpzeFRhZ0VuZFwiKTtcblxudHlwZXMuanN4VGFnU3RhcnQudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2godHlwZXMkMS5qX2V4cHIpOyAvLyB0cmVhdCBhcyBiZWdpbm5pbmcgb2YgSlNYIGV4cHJlc3Npb25cbiAgdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2godHlwZXMkMS5qX29UYWcpOyAvLyBzdGFydCBvcGVuaW5nIHRhZyBjb250ZXh0XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLmpzeFRhZ0VuZC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSB7XG4gIHZhciBvdXQgPSB0aGlzLnN0YXRlLmNvbnRleHQucG9wKCk7XG4gIGlmIChvdXQgPT09IHR5cGVzJDEual9vVGFnICYmIHByZXZUeXBlID09PSB0eXBlcy5zbGFzaCB8fCBvdXQgPT09IHR5cGVzJDEual9jVGFnKSB7XG4gICAgdGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpO1xuICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5qX2V4cHI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IHRydWU7XG4gIH1cbn07XG5cbnZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gUmVhZHMgaW5saW5lIEpTWCBjb250ZW50cyB0b2tlbi5cblxucHAkOS5qc3hSZWFkVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBcIlwiO1xuICB2YXIgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIEpTWCBjb250ZW50c1wiKTtcbiAgICB9XG5cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuXG4gICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSA2MDogLy8gXCI8XCJcbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICAvLyBcIntcIlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUuc3RhcnQpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDYwICYmIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQpIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5qc3hUYWdTdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY2gpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuanN4VGV4dCwgb3V0KTtcblxuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gXCImXCJcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkRW50aXR5KCk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWROZXdMaW5lKHRydWUpO1xuICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5wcCQ5LmpzeFJlYWROZXdMaW5lID0gZnVuY3Rpb24gKG5vcm1hbGl6ZUNSTEYpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgdmFyIG91dCA9IHZvaWQgMDtcbiAgKyt0aGlzLnN0YXRlLnBvcztcbiAgaWYgKGNoID09PSAxMyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpID09PSAxMCkge1xuICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgb3V0ID0gbm9ybWFsaXplQ1JMRiA/IFwiXFxuXCIgOiBcIlxcclxcblwiO1xuICB9IGVsc2Uge1xuICAgIG91dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICB9XG4gICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5wcCQ5LmpzeFJlYWRTdHJpbmcgPSBmdW5jdGlvbiAocXVvdGUpIHtcbiAgdmFyIG91dCA9IFwiXCI7XG4gIHZhciBjaHVua1N0YXJ0ID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAoY2ggPT09IHF1b3RlKSBicmVhaztcbiAgICBpZiAoY2ggPT09IDM4KSB7XG4gICAgICAvLyBcIiZcIlxuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZEVudGl0eSgpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZE5ld0xpbmUoZmFsc2UpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgIH1cbiAgfVxuICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcysrKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpO1xufTtcblxucHAkOS5qc3hSZWFkRW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGVudGl0eSA9IHZvaWQgMDtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dFt0aGlzLnN0YXRlLnBvc107XG5cbiAgdmFyIHN0YXJ0UG9zID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgY291bnQrKyA8IDEwKSB7XG4gICAgY2ggPSB0aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zKytdO1xuICAgIGlmIChjaCA9PT0gXCI7XCIpIHtcbiAgICAgIGlmIChzdHJbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIGlmIChzdHJbMV0gPT09IFwieFwiKSB7XG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigyKTtcbiAgICAgICAgICBpZiAoSEVYX05VTUJFUi50ZXN0KHN0cikpIGVudGl0eSA9IGZyb21Db2RlUG9pbnQkMShwYXJzZUludChzdHIsIDE2KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgICAgICAgICBpZiAoREVDSU1BTF9OVU1CRVIudGVzdChzdHIpKSBlbnRpdHkgPSBmcm9tQ29kZVBvaW50JDEocGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRpdHkgPSBYSFRNTEVudGl0aWVzW3N0cl07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3RyICs9IGNoO1xuICB9XG4gIGlmICghZW50aXR5KSB7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBzdGFydFBvcztcbiAgICByZXR1cm4gXCImXCI7XG4gIH1cbiAgcmV0dXJuIGVudGl0eTtcbn07XG5cbi8vIFJlYWQgYSBKU1ggaWRlbnRpZmllciAodmFsaWQgdGFnIG9yIGF0dHJpYnV0ZSBuYW1lKS5cbi8vXG4vLyBPcHRpbWl6ZWQgdmVyc2lvbiBzaW5jZSBKU1ggaWRlbnRpZmllcnMgY2FuXCJ0IGNvbnRhaW5cbi8vIGVzY2FwZSBjaGFyYWN0ZXJzIGFuZCBzbyBjYW4gYmUgcmVhZCBhcyBzaW5nbGUgc2xpY2UuXG4vLyBBbHNvIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgd2FzIGFscmVhZHkgY2hlY2tlZFxuLy8gYnkgaXNJZGVudGlmaWVyU3RhcnQgaW4gcmVhZFRva2VuLlxuXG5wcCQ5LmpzeFJlYWRXb3JkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2ggPSB2b2lkIDA7XG4gIHZhciBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICBkbyB7XG4gICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG4gIH0gd2hpbGUgKGlzSWRlbnRpZmllckNoYXIoY2gpIHx8IGNoID09PSA0NSk7IC8vIFwiLVwiXG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmpzeE5hbWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKSk7XG59O1xuXG4vLyBUcmFuc2Zvcm1zIEpTWCBlbGVtZW50IG5hbWUgdG8gc3RyaW5nLlxuXG5mdW5jdGlvbiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdCkge1xuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYSWRlbnRpZmllclwiKSB7XG4gICAgcmV0dXJuIG9iamVjdC5uYW1lO1xuICB9XG5cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICByZXR1cm4gb2JqZWN0Lm5hbWVzcGFjZS5uYW1lICsgXCI6XCIgKyBvYmplY3QubmFtZS5uYW1lO1xuICB9XG5cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIHJldHVybiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5vYmplY3QpICsgXCIuXCIgKyBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5wcm9wZXJ0eSk7XG4gIH1cbn1cblxuLy8gUGFyc2UgbmV4dCB0b2tlbiBhcyBKU1ggaWRlbnRpZmllclxuXG5wcCQ5LmpzeFBhcnNlSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5qc3hOYW1lKSkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnN0YXRlLnR5cGUua2V5d29yZDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWElkZW50aWZpZXJcIik7XG59O1xuXG4vLyBQYXJzZSBuYW1lc3BhY2VkIGlkZW50aWZpZXIuXG5cbnBwJDkuanN4UGFyc2VOYW1lc3BhY2VkTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgdmFyIG5hbWUgPSB0aGlzLmpzeFBhcnNlSWRlbnRpZmllcigpO1xuICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbG9uKSkgcmV0dXJuIG5hbWU7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubmFtZXNwYWNlID0gbmFtZTtcbiAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUlkZW50aWZpZXIoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpO1xufTtcblxuLy8gUGFyc2VzIGVsZW1lbnQgbmFtZSBpbiBhbnkgZm9ybSAtIG5hbWVzcGFjZWQsIG1lbWJlclxuLy8gb3Igc2luZ2xlIGlkZW50aWZpZXIuXG5cbnBwJDkuanN4UGFyc2VFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgdmFyIG5vZGUgPSB0aGlzLmpzeFBhcnNlTmFtZXNwYWNlZE5hbWUoKTtcbiAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICB2YXIgbmV3Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBuZXdOb2RlLm9iamVjdCA9IG5vZGU7XG4gICAgbmV3Tm9kZS5wcm9wZXJ0eSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShuZXdOb2RlLCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vLyBQYXJzZXMgYW55IHR5cGUgb2YgSlNYIGF0dHJpYnV0ZSB2YWx1ZS5cblxucHAkOS5qc3hQYXJzZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIG5vZGUgPSB0aGlzLmpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcigpO1xuICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJKU1ggYXR0cmlidXRlcyBtdXN0IG9ubHkgYmUgYXNzaWduZWQgYSBub24tZW1wdHkgZXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgY2FzZSB0eXBlcy5qc3hUYWdTdGFydDpcbiAgICBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIG5vZGUuZXh0cmEgPSBudWxsO1xuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIkpTWCB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGFuIGV4cHJlc3Npb24gb3IgYSBxdW90ZWQgSlNYIHRleHRcIik7XG4gIH1cbn07XG5cbi8vIEpTWEVtcHR5RXhwcmVzc2lvbiBpcyB1bmlxdWUgdHlwZSBzaW5jZSBpdCBkb2Vzbid0IGFjdHVhbGx5IHBhcnNlIGFueXRoaW5nLFxuLy8gYW5kIHNvIGl0IHNob3VsZCBzdGFydCBhdCB0aGUgZW5kIG9mIGxhc3QgcmVhZCB0b2tlbiAobGVmdCBicmFjZSkgYW5kIGZpbmlzaFxuLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBvbmUgKHJpZ2h0IGJyYWNlKS5cblxucHAkOS5qc3hQYXJzZUVtcHR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMuc3RhdGUubGFzdFRva0VuZCwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHRoaXMuc3RhdGUuc3RhcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xufTtcblxuLy8gUGFyc2UgSlNYIHNwcmVhZCBjaGlsZFxuXG5wcCQ5LmpzeFBhcnNlU3ByZWFkQ2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuZWxsaXBzaXMpO1xuICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRDaGlsZFwiKTtcbn07XG5cbi8vIFBhcnNlcyBKU1ggZXhwcmVzc2lvbiBlbmNsb3NlZCBpbnRvIGN1cmx5IGJyYWNrZXRzLlxuXG5cbnBwJDkuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFjZVIpKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5qc3hQYXJzZUVtcHR5RXhwcmVzc2lvbigpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIH1cbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIik7XG59O1xuXG4vLyBQYXJzZXMgZm9sbG93aW5nIEpTWCBhdHRyaWJ1dGUgbmFtZS12YWx1ZSBwYWlyLlxuXG5wcCQ5LmpzeFBhcnNlQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5icmFjZUwpKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuZWxsaXBzaXMpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIik7XG4gIH1cbiAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG4gIG5vZGUudmFsdWUgPSB0aGlzLmVhdCh0eXBlcy5lcSkgPyB0aGlzLmpzeFBhcnNlQXR0cmlidXRlVmFsdWUoKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hBdHRyaWJ1dGVcIik7XG59O1xuXG4vLyBQYXJzZXMgSlNYIG9wZW5pbmcgdGFnIHN0YXJ0aW5nIGFmdGVyIFwiPFwiLlxuXG5wcCQ5LmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBdCA9IGZ1bmN0aW9uIChzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUuYXR0cmlidXRlcyA9IFtdO1xuICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlRWxlbWVudE5hbWUoKTtcbiAgd2hpbGUgKCF0aGlzLm1hdGNoKHR5cGVzLnNsYXNoKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5qc3hUYWdFbmQpKSB7XG4gICAgbm9kZS5hdHRyaWJ1dGVzLnB1c2godGhpcy5qc3hQYXJzZUF0dHJpYnV0ZSgpKTtcbiAgfVxuICBub2RlLnNlbGZDbG9zaW5nID0gdGhpcy5lYXQodHlwZXMuc2xhc2gpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5qc3hUYWdFbmQpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYT3BlbmluZ0VsZW1lbnRcIik7XG59O1xuXG4vLyBQYXJzZXMgSlNYIGNsb3NpbmcgdGFnIHN0YXJ0aW5nIGFmdGVyIFwiPC9cIi5cblxucHAkOS5qc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlRWxlbWVudE5hbWUoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuanN4VGFnRW5kKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWENsb3NpbmdFbGVtZW50XCIpO1xufTtcblxuLy8gUGFyc2VzIGVudGlyZSBKU1ggZWxlbWVudCwgaW5jbHVkaW5nIGl0XCJzIG9wZW5pbmcgdGFnXG4vLyAoc3RhcnRpbmcgYWZ0ZXIgXCI8XCIpLCBhdHRyaWJ1dGVzLCBjb250ZW50cyBhbmQgY2xvc2luZyB0YWcuXG5cbnBwJDkuanN4UGFyc2VFbGVtZW50QXQgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgdmFyIG9wZW5pbmdFbGVtZW50ID0gdGhpcy5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgdmFyIGNsb3NpbmdFbGVtZW50ID0gbnVsbDtcblxuICBpZiAoIW9wZW5pbmdFbGVtZW50LnNlbGZDbG9zaW5nKSB7XG4gICAgY29udGVudHM6IGZvciAoOzspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMuanN4VGFnU3RhcnQ6XG4gICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O3N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpZiAodGhpcy5lYXQodHlwZXMuc2xhc2gpKSB7XG4gICAgICAgICAgICBjbG9zaW5nRWxlbWVudCA9IHRoaXMuanN4UGFyc2VDbG9zaW5nRWxlbWVudEF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgICBicmVhayBjb250ZW50cztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlRWxlbWVudEF0KHN0YXJ0UG9zLCBzdGFydExvYykpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuanN4VGV4dDpcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMucGFyc2VFeHByQXRvbSgpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQoKS50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlU3ByZWFkQ2hpbGQoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdldFF1YWxpZmllZEpTWE5hbWUoY2xvc2luZ0VsZW1lbnQubmFtZSkgIT09IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSkpIHtcbiAgICAgIHRoaXMucmFpc2UoY2xvc2luZ0VsZW1lbnQuc3RhcnQsIFwiRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDxcIiArIGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSkgKyBcIj5cIik7XG4gICAgfVxuICB9XG5cbiAgbm9kZS5vcGVuaW5nRWxlbWVudCA9IG9wZW5pbmdFbGVtZW50O1xuICBub2RlLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XG4gIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMucmVsYXRpb25hbCkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCI8XCIpIHtcbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiQWRqYWNlbnQgSlNYIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBhbiBlbmNsb3NpbmcgdGFnXCIpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hFbGVtZW50XCIpO1xufTtcblxuLy8gUGFyc2VzIGVudGlyZSBKU1ggZWxlbWVudCBmcm9tIGN1cnJlbnQgcG9zaXRpb24uXG5cbnBwJDkuanN4UGFyc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbn07XG5cbnZhciBqc3hQbHVnaW4gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VFeHByQXRvbVwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZlNob3J0SGFuZERlZmF1bHRQb3MpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmpzeFRleHQpKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJKU1hUZXh0XCIpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzIwNzhcbiAgICAgICAgbm9kZS5leHRyYSA9IG51bGw7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ1N0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIHJlZlNob3J0SGFuZERlZmF1bHRQb3MpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInJlYWRUb2tlblwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmluUHJvcGVydHlOYW1lKSByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBjb2RlKTtcblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcblxuICAgICAgaWYgKGNvbnRleHQgPT09IHR5cGVzJDEual9leHByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzeFJlYWRUb2tlbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dCA9PT0gdHlwZXMkMS5qX29UYWcgfHwgY29udGV4dCA9PT0gdHlwZXMkMS5qX2NUYWcpIHtcbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanN4UmVhZFdvcmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuanN4VGFnRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoY29kZSA9PT0gMzQgfHwgY29kZSA9PT0gMzkpICYmIGNvbnRleHQgPT09IHR5cGVzJDEual9vVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanN4UmVhZFN0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA9PT0gNjAgJiYgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5qc3hUYWdTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIGNvZGUpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInVwZGF0ZUNvbnRleHRcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2VMKSkge1xuICAgICAgICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgICAgICBpZiAoY3VyQ29udGV4dCA9PT0gdHlwZXMkMS5qX29UYWcpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQucHVzaCh0eXBlcyQxLmJyYWNlRXhwcmVzc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyQ29udGV4dCA9PT0gdHlwZXMkMS5qX2V4cHIpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQucHVzaCh0eXBlcyQxLnRlbXBsYXRlUXVhc2kpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlubmVyLmNhbGwodGhpcywgcHJldlR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLnNsYXNoKSAmJiBwcmV2VHlwZSA9PT0gdHlwZXMuanN4VGFnU3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0Lmxlbmd0aCAtPSAyOyAvLyBkbyBub3QgY29uc2lkZXIgSlNYIGV4cHIgLT4gSlNYIG9wZW4gdGFnIC0+IC4uLiBhbnltb3JlXG4gICAgICAgIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEual9jVGFnKTsgLy8gcmVjb25zaWRlciBhcyBjbG9zaW5nIHRhZyBjb250ZXh0XG4gICAgICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIHByZXZUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn07XG5cbnBsdWdpbnMuZXN0cmVlID0gZXN0cmVlUGx1Z2luO1xucGx1Z2lucy5mbG93ID0gZmxvd1BsdWdpbjtcbnBsdWdpbnMuanN4ID0ganN4UGx1Z2luO1xuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0KTtcbiAgaWYgKHBhcnNlci5vcHRpb25zLnN0cmljdE1vZGUpIHtcbiAgICBwYXJzZXIuc3RhdGUuc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcGFyc2VyLmdldEV4cHJlc3Npb24oKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb247XG5leHBvcnRzLnRva1R5cGVzID0gdHlwZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYnlsb25ANi4xOC4wQGJhYnlsb24vbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuRmxvdyA9IGV4cG9ydHMuUHVyZSA9IGV4cG9ydHMuR2VuZXJhdGVkID0gZXhwb3J0cy5Vc2VyID0gZXhwb3J0cy5WYXIgPSBleHBvcnRzLkJsb2NrU2NvcGVkID0gZXhwb3J0cy5SZWZlcmVuY2VkID0gZXhwb3J0cy5TY29wZSA9IGV4cG9ydHMuRXhwcmVzc2lvbiA9IGV4cG9ydHMuU3RhdGVtZW50ID0gZXhwb3J0cy5CaW5kaW5nSWRlbnRpZmllciA9IGV4cG9ydHMuUmVmZXJlbmNlZE1lbWJlckV4cHJlc3Npb24gPSBleHBvcnRzLlJlZmVyZW5jZWRJZGVudGlmaWVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG52YXIgUmVmZXJlbmNlZElkZW50aWZpZXIgPSBleHBvcnRzLlJlZmVyZW5jZWRJZGVudGlmaWVyID0ge1xuICB0eXBlczogW1wiSWRlbnRpZmllclwiLCBcIkpTWElkZW50aWZpZXJcIl0sXG4gIGNoZWNrUGF0aDogZnVuY3Rpb24gY2hlY2tQYXRoKF9yZWYsIG9wdHMpIHtcbiAgICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgICAgcGFyZW50ID0gX3JlZi5wYXJlbnQ7XG5cbiAgICBpZiAoIXQuaXNJZGVudGlmaWVyKG5vZGUsIG9wdHMpICYmICF0LmlzSlNYTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQsIG9wdHMpKSB7XG4gICAgICBpZiAodC5pc0pTWElkZW50aWZpZXIobm9kZSwgb3B0cykpIHtcbiAgICAgICAgaWYgKF9iYWJlbFR5cGVzLnJlYWN0LmlzQ29tcGF0VGFnKG5vZGUubmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdC5pc1JlZmVyZW5jZWQobm9kZSwgcGFyZW50KTtcbiAgfVxufTtcblxudmFyIFJlZmVyZW5jZWRNZW1iZXJFeHByZXNzaW9uID0gZXhwb3J0cy5SZWZlcmVuY2VkTWVtYmVyRXhwcmVzc2lvbiA9IHtcbiAgdHlwZXM6IFtcIk1lbWJlckV4cHJlc3Npb25cIl0sXG4gIGNoZWNrUGF0aDogZnVuY3Rpb24gY2hlY2tQYXRoKF9yZWYyKSB7XG4gICAgdmFyIG5vZGUgPSBfcmVmMi5ub2RlLFxuICAgICAgICBwYXJlbnQgPSBfcmVmMi5wYXJlbnQ7XG5cbiAgICByZXR1cm4gdC5pc01lbWJlckV4cHJlc3Npb24obm9kZSkgJiYgdC5pc1JlZmVyZW5jZWQobm9kZSwgcGFyZW50KTtcbiAgfVxufTtcblxudmFyIEJpbmRpbmdJZGVudGlmaWVyID0gZXhwb3J0cy5CaW5kaW5nSWRlbnRpZmllciA9IHtcbiAgdHlwZXM6IFtcIklkZW50aWZpZXJcIl0sXG4gIGNoZWNrUGF0aDogZnVuY3Rpb24gY2hlY2tQYXRoKF9yZWYzKSB7XG4gICAgdmFyIG5vZGUgPSBfcmVmMy5ub2RlLFxuICAgICAgICBwYXJlbnQgPSBfcmVmMy5wYXJlbnQ7XG5cbiAgICByZXR1cm4gdC5pc0lkZW50aWZpZXIobm9kZSkgJiYgdC5pc0JpbmRpbmcobm9kZSwgcGFyZW50KTtcbiAgfVxufTtcblxudmFyIFN0YXRlbWVudCA9IGV4cG9ydHMuU3RhdGVtZW50ID0ge1xuICB0eXBlczogW1wiU3RhdGVtZW50XCJdLFxuICBjaGVja1BhdGg6IGZ1bmN0aW9uIGNoZWNrUGF0aChfcmVmNCkge1xuICAgIHZhciBub2RlID0gX3JlZjQubm9kZSxcbiAgICAgICAgcGFyZW50ID0gX3JlZjQucGFyZW50O1xuXG4gICAgaWYgKHQuaXNTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIGlmICh0LmlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgICBpZiAodC5pc0ZvclhTdGF0ZW1lbnQocGFyZW50LCB7IGxlZnQ6IG5vZGUgfSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHQuaXNGb3JTdGF0ZW1lbnQocGFyZW50LCB7IGluaXQ6IG5vZGUgfSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBFeHByZXNzaW9uID0gZXhwb3J0cy5FeHByZXNzaW9uID0ge1xuICB0eXBlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgY2hlY2tQYXRoOiBmdW5jdGlvbiBjaGVja1BhdGgocGF0aCkge1xuICAgIGlmIChwYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICByZXR1cm4gcGF0aC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0LmlzRXhwcmVzc2lvbihwYXRoLm5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFNjb3BlID0gZXhwb3J0cy5TY29wZSA9IHtcbiAgdHlwZXM6IFtcIlNjb3BhYmxlXCJdLFxuICBjaGVja1BhdGg6IGZ1bmN0aW9uIGNoZWNrUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHQuaXNTY29wZShwYXRoLm5vZGUsIHBhdGgucGFyZW50KTtcbiAgfVxufTtcblxudmFyIFJlZmVyZW5jZWQgPSBleHBvcnRzLlJlZmVyZW5jZWQgPSB7XG4gIGNoZWNrUGF0aDogZnVuY3Rpb24gY2hlY2tQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gdC5pc1JlZmVyZW5jZWQocGF0aC5ub2RlLCBwYXRoLnBhcmVudCk7XG4gIH1cbn07XG5cbnZhciBCbG9ja1Njb3BlZCA9IGV4cG9ydHMuQmxvY2tTY29wZWQgPSB7XG4gIGNoZWNrUGF0aDogZnVuY3Rpb24gY2hlY2tQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gdC5pc0Jsb2NrU2NvcGVkKHBhdGgubm9kZSk7XG4gIH1cbn07XG5cbnZhciBWYXIgPSBleHBvcnRzLlZhciA9IHtcbiAgdHlwZXM6IFtcIlZhcmlhYmxlRGVjbGFyYXRpb25cIl0sXG4gIGNoZWNrUGF0aDogZnVuY3Rpb24gY2hlY2tQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gdC5pc1ZhcihwYXRoLm5vZGUpO1xuICB9XG59O1xuXG52YXIgVXNlciA9IGV4cG9ydHMuVXNlciA9IHtcbiAgY2hlY2tQYXRoOiBmdW5jdGlvbiBjaGVja1BhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoLm5vZGUgJiYgISFwYXRoLm5vZGUubG9jO1xuICB9XG59O1xuXG52YXIgR2VuZXJhdGVkID0gZXhwb3J0cy5HZW5lcmF0ZWQgPSB7XG4gIGNoZWNrUGF0aDogZnVuY3Rpb24gY2hlY2tQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gIXBhdGguaXNVc2VyKCk7XG4gIH1cbn07XG5cbnZhciBQdXJlID0gZXhwb3J0cy5QdXJlID0ge1xuICBjaGVja1BhdGg6IGZ1bmN0aW9uIGNoZWNrUGF0aChwYXRoLCBvcHRzKSB7XG4gICAgcmV0dXJuIHBhdGguc2NvcGUuaXNQdXJlKHBhdGgubm9kZSwgb3B0cyk7XG4gIH1cbn07XG5cbnZhciBGbG93ID0gZXhwb3J0cy5GbG93ID0ge1xuICB0eXBlczogW1wiRmxvd1wiLCBcIkltcG9ydERlY2xhcmF0aW9uXCIsIFwiRXhwb3J0RGVjbGFyYXRpb25cIiwgXCJJbXBvcnRTcGVjaWZpZXJcIl0sXG4gIGNoZWNrUGF0aDogZnVuY3Rpb24gY2hlY2tQYXRoKF9yZWY1KSB7XG4gICAgdmFyIG5vZGUgPSBfcmVmNS5ub2RlO1xuXG4gICAgaWYgKHQuaXNGbG93KG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHQuaXNJbXBvcnREZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiO1xuICAgIH0gZWxzZSBpZiAodC5pc0V4cG9ydERlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIjtcbiAgICB9IGVsc2UgaWYgKHQuaXNJbXBvcnRTcGVjaWZpZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvcGF0aC9saWIvdmlydHVhbC10eXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG5leHBvcnRzLmdldEJpbmRpbmdJZGVudGlmaWVycyA9IGdldEJpbmRpbmdJZGVudGlmaWVycztcbmV4cG9ydHMuZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMgPSBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycztcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuXG52YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbmRleCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdJZGVudGlmaWVycyhub2RlLCBkdXBsaWNhdGVzLCBvdXRlck9ubHkpIHtcbiAgdmFyIHNlYXJjaCA9IFtdLmNvbmNhdChub2RlKTtcbiAgdmFyIGlkcyA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShudWxsKTtcblxuICB3aGlsZSAoc2VhcmNoLmxlbmd0aCkge1xuICAgIHZhciBpZCA9IHNlYXJjaC5zaGlmdCgpO1xuICAgIGlmICghaWQpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtleXMgPSB0LmdldEJpbmRpbmdJZGVudGlmaWVycy5rZXlzW2lkLnR5cGVdO1xuXG4gICAgaWYgKHQuaXNJZGVudGlmaWVyKGlkKSkge1xuICAgICAgaWYgKGR1cGxpY2F0ZXMpIHtcbiAgICAgICAgdmFyIF9pZHMgPSBpZHNbaWQubmFtZV0gPSBpZHNbaWQubmFtZV0gfHwgW107XG4gICAgICAgIF9pZHMucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHNbaWQubmFtZV0gPSBpZDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0LmlzRXhwb3J0RGVjbGFyYXRpb24oaWQpKSB7XG4gICAgICBpZiAodC5pc0RlY2xhcmF0aW9uKGlkLmRlY2xhcmF0aW9uKSkge1xuICAgICAgICBzZWFyY2gucHVzaChpZC5kZWNsYXJhdGlvbik7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAob3V0ZXJPbmx5KSB7XG4gICAgICBpZiAodC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oaWQpKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0LmlzRnVuY3Rpb25FeHByZXNzaW9uKGlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoaWRba2V5XSkge1xuICAgICAgICAgIHNlYXJjaCA9IHNlYXJjaC5jb25jYXQoaWRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWRzO1xufVxuXG5nZXRCaW5kaW5nSWRlbnRpZmllcnMua2V5cyA9IHtcbiAgRGVjbGFyZUNsYXNzOiBbXCJpZFwiXSxcbiAgRGVjbGFyZUZ1bmN0aW9uOiBbXCJpZFwiXSxcbiAgRGVjbGFyZU1vZHVsZTogW1wiaWRcIl0sXG4gIERlY2xhcmVWYXJpYWJsZTogW1wiaWRcIl0sXG4gIEludGVyZmFjZURlY2xhcmF0aW9uOiBbXCJpZFwiXSxcbiAgVHlwZUFsaWFzOiBbXCJpZFwiXSxcbiAgT3BhcXVlVHlwZTogW1wiaWRcIl0sXG5cbiAgQ2F0Y2hDbGF1c2U6IFtcInBhcmFtXCJdLFxuICBMYWJlbGVkU3RhdGVtZW50OiBbXCJsYWJlbFwiXSxcbiAgVW5hcnlFeHByZXNzaW9uOiBbXCJhcmd1bWVudFwiXSxcbiAgQXNzaWdubWVudEV4cHJlc3Npb246IFtcImxlZnRcIl0sXG5cbiAgSW1wb3J0U3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogW1wibG9jYWxcIl0sXG4gIEltcG9ydERlY2xhcmF0aW9uOiBbXCJzcGVjaWZpZXJzXCJdLFxuXG4gIEV4cG9ydFNwZWNpZmllcjogW1wiZXhwb3J0ZWRcIl0sXG4gIEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjogW1wiZXhwb3J0ZWRcIl0sXG4gIEV4cG9ydERlZmF1bHRTcGVjaWZpZXI6IFtcImV4cG9ydGVkXCJdLFxuXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb246IFtcImlkXCIsIFwicGFyYW1zXCJdLFxuICBGdW5jdGlvbkV4cHJlc3Npb246IFtcImlkXCIsIFwicGFyYW1zXCJdLFxuXG4gIENsYXNzRGVjbGFyYXRpb246IFtcImlkXCJdLFxuICBDbGFzc0V4cHJlc3Npb246IFtcImlkXCJdLFxuXG4gIFJlc3RFbGVtZW50OiBbXCJhcmd1bWVudFwiXSxcbiAgVXBkYXRlRXhwcmVzc2lvbjogW1wiYXJndW1lbnRcIl0sXG5cbiAgUmVzdFByb3BlcnR5OiBbXCJhcmd1bWVudFwiXSxcbiAgT2JqZWN0UHJvcGVydHk6IFtcInZhbHVlXCJdLFxuXG4gIEFzc2lnbm1lbnRQYXR0ZXJuOiBbXCJsZWZ0XCJdLFxuICBBcnJheVBhdHRlcm46IFtcImVsZW1lbnRzXCJdLFxuICBPYmplY3RQYXR0ZXJuOiBbXCJwcm9wZXJ0aWVzXCJdLFxuXG4gIFZhcmlhYmxlRGVjbGFyYXRpb246IFtcImRlY2xhcmF0aW9uc1wiXSxcbiAgVmFyaWFibGVEZWNsYXJhdG9yOiBbXCJpZFwiXVxufTtcblxuZnVuY3Rpb24gZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMobm9kZSwgZHVwbGljYXRlcykge1xuICByZXR1cm4gZ2V0QmluZGluZ0lkZW50aWZpZXJzKG5vZGUsIGR1cGxpY2F0ZXMsIHRydWUpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzL2xpYi9yZXRyaWV2ZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZXhwb3J0cy5hc3QgPSByZXF1aXJlKCcuL2FzdCcpO1xuICAgIGV4cG9ydHMuY29kZSA9IHJlcXVpcmUoJy4vY29kZScpO1xuICAgIGV4cG9ydHMua2V5d29yZCA9IHJlcXVpcmUoJy4va2V5d29yZCcpO1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2VzdXRpbHNAMi4wLjJAZXN1dGlscy9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxNCBJdmFuIE5pa3VsaW4gPGlmYWFhbkBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRVM2UmVnZXgsIEVTNVJlZ2V4LCBOT05fQVNDSUlfV0hJVEVTUEFDRVMsIElERU5USUZJRVJfU1RBUlQsIElERU5USUZJRVJfUEFSVCwgY2g7XG5cbiAgICAvLyBTZWUgYHRvb2xzL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNgLlxuICAgIEVTNVJlZ2V4ID0ge1xuICAgICAgICAvLyBFQ01BU2NyaXB0IDUuMS9Vbmljb2RlIHY3LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDpcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjJcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXS8sXG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNS4xL1VuaWNvZGUgdjcuMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEIyXFx1MDhFNC1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OFxcdTBDNTlcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDYwLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OURcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdL1xuICAgIH07XG5cbiAgICBFUzZSZWdleCA9IHtcbiAgICAgICAgLy8gRUNNQVNjcmlwdCA2L1VuaWNvZGUgdjcuMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCMlxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OFxcdTBDNTlcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ2MFxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk4XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RV18W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNi9Vbmljb2RlIHY3LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiAvW1xceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVEREQwLVxcdUREREFcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAxLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk4XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RV18W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0QwLVxcdURDRDZdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS9cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIDB4MzAgPD0gY2ggJiYgY2ggPD0gMHgzOTsgIC8vIDAuLjlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAweDMwIDw9IGNoICYmIGNoIDw9IDB4MzkgfHwgIC8vIDAuLjlcbiAgICAgICAgICAgIDB4NjEgPD0gY2ggJiYgY2ggPD0gMHg2NiB8fCAgICAgLy8gYS4uZlxuICAgICAgICAgICAgMHg0MSA8PSBjaCAmJiBjaCA8PSAweDQ2OyAgICAgICAvLyBBLi5GXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA+PSAweDMwICYmIGNoIDw9IDB4Mzc7ICAvLyAwLi43XG4gICAgfVxuXG4gICAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgICBOT05fQVNDSUlfV0hJVEVTUEFDRVMgPSBbXG4gICAgICAgIDB4MTY4MCwgMHgxODBFLFxuICAgICAgICAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSxcbiAgICAgICAgMHgyMDJGLCAweDIwNUYsXG4gICAgICAgIDB4MzAwMCxcbiAgICAgICAgMHhGRUZGXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gY2ggPT09IDB4MjAgfHwgY2ggPT09IDB4MDkgfHwgY2ggPT09IDB4MEIgfHwgY2ggPT09IDB4MEMgfHwgY2ggPT09IDB4QTAgfHxcbiAgICAgICAgICAgIGNoID49IDB4MTY4MCAmJiBOT05fQVNDSUlfV0hJVEVTUEFDRVMuaW5kZXhPZihjaCkgPj0gMDtcbiAgICB9XG5cbiAgICAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gICAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgICByZXR1cm4gY2ggPT09IDB4MEEgfHwgY2ggPT09IDB4MEQgfHwgY2ggPT09IDB4MjAyOCB8fCBjaCA9PT0gMHgyMDI5O1xuICAgIH1cblxuICAgIC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gICAgZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjcCkge1xuICAgICAgICBpZiAoY3AgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKTsgfVxuICAgICAgICB2YXIgY3UxID0gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLmZsb29yKChjcCAtIDB4MTAwMDApIC8gMHg0MDApICsgMHhEODAwKTtcbiAgICAgICAgdmFyIGN1MiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjcCAtIDB4MTAwMDApICUgMHg0MDApICsgMHhEQzAwKTtcbiAgICAgICAgcmV0dXJuIGN1MSArIGN1MjtcbiAgICB9XG5cbiAgICBJREVOVElGSUVSX1NUQVJUID0gbmV3IEFycmF5KDB4ODApO1xuICAgIGZvcihjaCA9IDA7IGNoIDwgMHg4MDsgKytjaCkge1xuICAgICAgICBJREVOVElGSUVSX1NUQVJUW2NoXSA9XG4gICAgICAgICAgICBjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EgfHwgIC8vIGEuLnpcbiAgICAgICAgICAgIGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSB8fCAgLy8gQS4uWlxuICAgICAgICAgICAgY2ggPT09IDB4MjQgfHwgY2ggPT09IDB4NUY7ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgIH1cblxuICAgIElERU5USUZJRVJfUEFSVCA9IG5ldyBBcnJheSgweDgwKTtcbiAgICBmb3IoY2ggPSAwOyBjaCA8IDB4ODA7ICsrY2gpIHtcbiAgICAgICAgSURFTlRJRklFUl9QQVJUW2NoXSA9XG4gICAgICAgICAgICBjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EgfHwgIC8vIGEuLnpcbiAgICAgICAgICAgIGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSB8fCAgLy8gQS4uWlxuICAgICAgICAgICAgY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5IHx8ICAvLyAwLi45XG4gICAgICAgICAgICBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RjsgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnRFUzUoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoIDwgMHg4MCA/IElERU5USUZJRVJfU1RBUlRbY2hdIDogRVM1UmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChmcm9tQ29kZVBvaW50KGNoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydEVTNShjaCkge1xuICAgICAgICByZXR1cm4gY2ggPCAweDgwID8gSURFTlRJRklFUl9QQVJUW2NoXSA6IEVTNVJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChmcm9tQ29kZVBvaW50KGNoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnRFUzYoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoIDwgMHg4MCA/IElERU5USUZJRVJfU1RBUlRbY2hdIDogRVM2UmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChmcm9tQ29kZVBvaW50KGNoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydEVTNihjaCkge1xuICAgICAgICByZXR1cm4gY2ggPCAweDgwID8gSURFTlRJRklFUl9QQVJUW2NoXSA6IEVTNlJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChmcm9tQ29kZVBvaW50KGNoKSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzRGVjaW1hbERpZ2l0OiBpc0RlY2ltYWxEaWdpdCxcbiAgICAgICAgaXNIZXhEaWdpdDogaXNIZXhEaWdpdCxcbiAgICAgICAgaXNPY3RhbERpZ2l0OiBpc09jdGFsRGlnaXQsXG4gICAgICAgIGlzV2hpdGVTcGFjZTogaXNXaGl0ZVNwYWNlLFxuICAgICAgICBpc0xpbmVUZXJtaW5hdG9yOiBpc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICBpc0lkZW50aWZpZXJTdGFydEVTNTogaXNJZGVudGlmaWVyU3RhcnRFUzUsXG4gICAgICAgIGlzSWRlbnRpZmllclBhcnRFUzU6IGlzSWRlbnRpZmllclBhcnRFUzUsXG4gICAgICAgIGlzSWRlbnRpZmllclN0YXJ0RVM2OiBpc0lkZW50aWZpZXJTdGFydEVTNixcbiAgICAgICAgaXNJZGVudGlmaWVyUGFydEVTNjogaXNJZGVudGlmaWVyUGFydEVTNlxuICAgIH07XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fZXN1dGlsc0AyLjAuMkBlc3V0aWxzL2xpYi9jb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fZnJlZUdsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19vdmVyQXJnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9jbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2lzRnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL190b1NvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYXJyYXlMaWtlS2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaXNUeXBlZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL3N0dWJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fZ2V0U3ltYm9sc0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2FycmF5UHVzaC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2dldEFsbEtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19TZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fVWludDhBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fU2V0Q2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUluZGV4T2YuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2NhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fZGVidWdAMi42LjlAZGVidWcvc3JjL2RlYnVnLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZVJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbWFwXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VSZXBlYXQgPSByZXF1aXJlKCcuL19iYXNlUmVwZWF0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmVwZWF0KCcqJywgMyk7XG4gKiAvLyA9PiAnKioqJ1xuICpcbiAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAqIC8vID0+ICdhYmNhYmMnXG4gKlxuICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICogLy8gPT4gJydcbiAqL1xuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbiwgZ3VhcmQpIHtcbiAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgIG4gPSAxO1xuICB9IGVsc2Uge1xuICAgIG4gPSB0b0ludGVnZXIobik7XG4gIH1cbiAgcmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSwgbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVwZWF0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvdG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBCaW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCaW5kaW5nKF9yZWYpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBfcmVmLmV4aXN0aW5nLFxuICAgICAgICBpZGVudGlmaWVyID0gX3JlZi5pZGVudGlmaWVyLFxuICAgICAgICBzY29wZSA9IF9yZWYuc2NvcGUsXG4gICAgICAgIHBhdGggPSBfcmVmLnBhdGgsXG4gICAgICAgIGtpbmQgPSBfcmVmLmtpbmQ7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQmluZGluZyk7XG5cbiAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG5cbiAgICB0aGlzLmNvbnN0YW50VmlvbGF0aW9ucyA9IFtdO1xuICAgIHRoaXMuY29uc3RhbnQgPSB0cnVlO1xuXG4gICAgdGhpcy5yZWZlcmVuY2VQYXRocyA9IFtdO1xuICAgIHRoaXMucmVmZXJlbmNlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVmZXJlbmNlcyA9IDA7XG5cbiAgICB0aGlzLmNsZWFyVmFsdWUoKTtcblxuICAgIGlmIChleGlzdGluZykge1xuICAgICAgdGhpcy5jb25zdGFudFZpb2xhdGlvbnMgPSBbXS5jb25jYXQoZXhpc3RpbmcucGF0aCwgZXhpc3RpbmcuY29uc3RhbnRWaW9sYXRpb25zLCB0aGlzLmNvbnN0YW50VmlvbGF0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgQmluZGluZy5wcm90b3R5cGUuZGVvcHRWYWx1ZSA9IGZ1bmN0aW9uIGRlb3B0VmFsdWUoKSB7XG4gICAgdGhpcy5jbGVhclZhbHVlKCk7XG4gICAgdGhpcy5oYXNEZW9wdGVkVmFsdWUgPSB0cnVlO1xuICB9O1xuXG4gIEJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNEZW9wdGVkVmFsdWUpIHJldHVybjtcbiAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUuY2xlYXJWYWx1ZSA9IGZ1bmN0aW9uIGNsZWFyVmFsdWUoKSB7XG4gICAgdGhpcy5oYXNEZW9wdGVkVmFsdWUgPSBmYWxzZTtcbiAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUucmVhc3NpZ24gPSBmdW5jdGlvbiByZWFzc2lnbihwYXRoKSB7XG4gICAgdGhpcy5jb25zdGFudCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmNvbnN0YW50VmlvbGF0aW9ucy5pbmRleE9mKHBhdGgpICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbnN0YW50VmlvbGF0aW9ucy5wdXNoKHBhdGgpO1xuICB9O1xuXG4gIEJpbmRpbmcucHJvdG90eXBlLnJlZmVyZW5jZSA9IGZ1bmN0aW9uIHJlZmVyZW5jZShwYXRoKSB7XG4gICAgaWYgKHRoaXMucmVmZXJlbmNlUGF0aHMuaW5kZXhPZihwYXRoKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWZlcmVuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLnJlZmVyZW5jZXMrKztcbiAgICB0aGlzLnJlZmVyZW5jZVBhdGhzLnB1c2gocGF0aCk7XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUuZGVyZWZlcmVuY2UgPSBmdW5jdGlvbiBkZXJlZmVyZW5jZSgpIHtcbiAgICB0aGlzLnJlZmVyZW5jZXMtLTtcbiAgICB0aGlzLnJlZmVyZW5jZWQgPSAhIXRoaXMucmVmZXJlbmNlcztcbiAgfTtcblxuICByZXR1cm4gQmluZGluZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmluZGluZztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2UvbGliL3Njb3BlL2JpbmRpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9hbnNpLXJlZ2V4QDIuMS4xQGFuc2ktcmVnZXgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIdWIgPSBmdW5jdGlvbiBIdWIoZmlsZSwgb3B0aW9ucykge1xuICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBIdWIpO1xuXG4gIHRoaXMuZmlsZSA9IGZpbGU7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIdWI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9odWIuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgaWYgKCFhQXJncykge1xuICAgIGFBcmdzID0ge307XG4gIH1cbiAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xufVxuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICB9XG4gICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgIC8vIFdoZW4gYU9yaWdpbmFsIGlzIHRydXRoeSBidXQgaGFzIGVtcHR5IHZhbHVlcyBmb3IgLmxpbmUgYW5kIC5jb2x1bW4sXG4gICAgLy8gaXQgaXMgbW9zdCBsaWtlbHkgYSBwcm9ncmFtbWVyIGVycm9yLiBJbiB0aGlzIGNhc2Ugd2UgdGhyb3cgYSB2ZXJ5XG4gICAgLy8gc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSB0byB0cnkgdG8gZ3VpZGUgdGhlbSB0aGUgcmlnaHQgd2F5LlxuICAgIC8vIEZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyLWJ1bmRsZXIvcHVsbC81MTlcbiAgICBpZiAoYU9yaWdpbmFsICYmIHR5cGVvZiBhT3JpZ2luYWwubGluZSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGFPcmlnaW5hbC5jb2x1bW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdvcmlnaW5hbC5saW5lIGFuZCBvcmlnaW5hbC5jb2x1bW4gYXJlIG5vdCBudW1iZXJzIC0tIHlvdSBwcm9iYWJseSBtZWFudCB0byBvbWl0ICcgK1xuICAgICAgICAgICAgJ3RoZSBvcmlnaW5hbCBtYXBwaW5nIGVudGlyZWx5IGFuZCBvbmx5IG1hcCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLiBJZiBzbywgcGFzcyAnICtcbiAgICAgICAgICAgICdudWxsIGZvciB0aGUgb3JpZ2luYWwgbWFwcGluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGVtcHR5IG9yIG51bGwgdmFsdWVzLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgLy8gQ2FzZSAxLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIHNvdXJjZUlkeDtcblxuICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgIG5leHQgPSAnJ1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBuZXh0ICs9ICc7JztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsIGtleSlcbiAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICA6IG51bGw7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9zb3VyY2UtbWFwQDAuNS43QHNvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3NvdXJjZS1tYXBAMC41LjdAc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGhhc05hdGl2ZU1hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAqL1xuZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NldCA9IGhhc05hdGl2ZU1hcCA/IG5ldyBNYXAoKSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9cbkFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICByZXR1cm4gaGFzTmF0aXZlTWFwID8gdGhpcy5fc2V0LnNpemUgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IGhhc05hdGl2ZU1hcCA/IGFTdHIgOiB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICB2YXIgaXNEdXBsaWNhdGUgPSBoYXNOYXRpdmVNYXAgPyB0aGlzLmhhcyhhU3RyKSA6IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICAgIHRoaXMuX3NldC5zZXQoYVN0ciwgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQuaGFzKGFTdHIpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHZhciBpZHggPSB0aGlzLl9zZXQuZ2V0KGFTdHIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAqXG4gKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG59O1xuXG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3NvdXJjZS1tYXBAMC41LjdAc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZpbmQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19jcmVhdGVGaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUlzRXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2VxdWFsQXJyYXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fY2FzdFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG52YXIgX2tleXMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbmV4cG9ydHMubmVlZHNXaGl0ZXNwYWNlID0gbmVlZHNXaGl0ZXNwYWNlO1xuZXhwb3J0cy5uZWVkc1doaXRlc3BhY2VCZWZvcmUgPSBuZWVkc1doaXRlc3BhY2VCZWZvcmU7XG5leHBvcnRzLm5lZWRzV2hpdGVzcGFjZUFmdGVyID0gbmVlZHNXaGl0ZXNwYWNlQWZ0ZXI7XG5leHBvcnRzLm5lZWRzUGFyZW5zID0gbmVlZHNQYXJlbnM7XG5cbnZhciBfd2hpdGVzcGFjZSA9IHJlcXVpcmUoXCIuL3doaXRlc3BhY2VcIik7XG5cbnZhciBfd2hpdGVzcGFjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93aGl0ZXNwYWNlKTtcblxudmFyIF9wYXJlbnRoZXNlcyA9IHJlcXVpcmUoXCIuL3BhcmVudGhlc2VzXCIpO1xuXG52YXIgcGFyZW5zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3BhcmVudGhlc2VzKTtcblxudmFyIF9iYWJlbFR5cGVzID0gcmVxdWlyZShcImJhYmVsLXR5cGVzXCIpO1xuXG52YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9iYWJlbFR5cGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZXhwYW5kQWxpYXNlcyhvYmopIHtcbiAgdmFyIG5ld09iaiA9IHt9O1xuXG4gIGZ1bmN0aW9uIGFkZCh0eXBlLCBmdW5jKSB7XG4gICAgdmFyIGZuID0gbmV3T2JqW3R5cGVdO1xuICAgIG5ld09ialt0eXBlXSA9IGZuID8gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc3RhY2spIHtcbiAgICAgIHZhciByZXN1bHQgPSBmbihub2RlLCBwYXJlbnQsIHN0YWNrKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsID8gZnVuYyhub2RlLCBwYXJlbnQsIHN0YWNrKSA6IHJlc3VsdDtcbiAgICB9IDogZnVuYztcbiAgfVxuXG4gIGZvciAodmFyIF9pdGVyYXRvciA9ICgwLCBfa2V5czIuZGVmYXVsdCkob2JqKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gX3JlZjtcblxuXG4gICAgdmFyIGFsaWFzZXMgPSB0LkZMSVBQRURfQUxJQVNfS0VZU1t0eXBlXTtcbiAgICBpZiAoYWxpYXNlcykge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGFsaWFzZXMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMik7Oykge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbGlhcyA9IF9yZWYyO1xuXG4gICAgICAgIGFkZChhbGlhcywgb2JqW3R5cGVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkKHR5cGUsIG9ialt0eXBlXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxudmFyIGV4cGFuZGVkUGFyZW5zID0gZXhwYW5kQWxpYXNlcyhwYXJlbnMpO1xudmFyIGV4cGFuZGVkV2hpdGVzcGFjZU5vZGVzID0gZXhwYW5kQWxpYXNlcyhfd2hpdGVzcGFjZTIuZGVmYXVsdC5ub2Rlcyk7XG52YXIgZXhwYW5kZWRXaGl0ZXNwYWNlTGlzdCA9IGV4cGFuZEFsaWFzZXMoX3doaXRlc3BhY2UyLmRlZmF1bHQubGlzdCk7XG5cbmZ1bmN0aW9uIGZpbmQob2JqLCBub2RlLCBwYXJlbnQsIHByaW50U3RhY2spIHtcbiAgdmFyIGZuID0gb2JqW25vZGUudHlwZV07XG4gIHJldHVybiBmbiA/IGZuKG5vZGUsIHBhcmVudCwgcHJpbnRTdGFjaykgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc09ySGFzQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuICBpZiAodC5pc0NhbGxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodC5pc01lbWJlckV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gaXNPckhhc0NhbGxFeHByZXNzaW9uKG5vZGUub2JqZWN0KSB8fCAhbm9kZS5jb21wdXRlZCAmJiBpc09ySGFzQ2FsbEV4cHJlc3Npb24obm9kZS5wcm9wZXJ0eSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lZWRzV2hpdGVzcGFjZShub2RlLCBwYXJlbnQsIHR5cGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gMDtcblxuICBpZiAodC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICB9XG5cbiAgdmFyIGxpbmVzSW5mbyA9IGZpbmQoZXhwYW5kZWRXaGl0ZXNwYWNlTm9kZXMsIG5vZGUsIHBhcmVudCk7XG5cbiAgaWYgKCFsaW5lc0luZm8pIHtcbiAgICB2YXIgaXRlbXMgPSBmaW5kKGV4cGFuZGVkV2hpdGVzcGFjZUxpc3QsIG5vZGUsIHBhcmVudCk7XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVzSW5mbyA9IG5lZWRzV2hpdGVzcGFjZShpdGVtc1tpXSwgbm9kZSwgdHlwZSk7XG4gICAgICAgIGlmIChsaW5lc0luZm8pIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaW5lc0luZm8gJiYgbGluZXNJbmZvW3R5cGVdIHx8IDA7XG59XG5cbmZ1bmN0aW9uIG5lZWRzV2hpdGVzcGFjZUJlZm9yZShub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIG5lZWRzV2hpdGVzcGFjZShub2RlLCBwYXJlbnQsIFwiYmVmb3JlXCIpO1xufVxuXG5mdW5jdGlvbiBuZWVkc1doaXRlc3BhY2VBZnRlcihub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIG5lZWRzV2hpdGVzcGFjZShub2RlLCBwYXJlbnQsIFwiYWZ0ZXJcIik7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUGFyZW5zKG5vZGUsIHBhcmVudCwgcHJpbnRTdGFjaykge1xuICBpZiAoIXBhcmVudCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0LmlzTmV3RXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGUpIHtcbiAgICBpZiAoaXNPckhhc0NhbGxFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmaW5kKGV4cGFuZGVkUGFyZW5zLCBub2RlLCBwYXJlbnQsIHByaW50U3RhY2spO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3IvbGliL25vZGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge1BhZ2VGYWN0b3J5fSBmcm9tIFwiLi9wb2pvL1BhZ2VGYWN0b3J5XCJcbmltcG9ydCB7Rm9sZGVyfSBmcm9tIFwiLi9wb2pvL0ZvbGRlclwiXG5pbXBvcnQge0ZpbGVJbnRlcmZhY2V9IGZyb20gXCIuL3Bvam8vRmlsZUludGVyZmFjZVwiXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcydcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCB7aW5wdXRSb290LG91dHB1dFJvb3QsSHRtbDJKc01hcCx1bnBhY2thZ2VkRm9sZGVyfSBmcm9tIFwiLi9jb21tb24vY29uZlwiXG5cblxuXG5cbi8vaW1wb3J0IHsgZG9GaWxlIH0gZnJvbSAnLi9jb21tb24vZmZzJztcblxuXG4vL2RvRmlsZSgpXG5cbi8vIGxldCB0OlBhZ2VGYWN0b3J5ID0gbmV3IFBhZ2VGYWN0b3J5KCk7XG4vLyBjb25zb2xlLmxvZyh0LmZpbGVNYXApXG5cbmNvcHlGb2xkZXIoXCIvXCIpXG5cblxuZnVuY3Rpb24gY29weUZvbGRlcihyZWxhdGl2ZVBhdGg6c3RyaW5nKXtcblxuICAgIGxldCBpbnB1dEZpbGUgPSBwYXRoLmpvaW4oaW5wdXRSb290LHJlbGF0aXZlUGF0aCk7XG4gICAgbGV0IG91dHB1dEZpbGUgPSBwYXRoLmpvaW4ob3V0cHV0Um9vdCxyZWxhdGl2ZVBhdGgpO1xuICAgIFxuXG4gICAgaWYoIWZzLmV4aXN0c1N5bmMoaW5wdXRGaWxlKSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRoZXJlIGlzIG5vIFwiK2lucHV0RmlsZSlcbiAgICB9XG5cblxuXG5cbiAgICBsZXQgc3RhdHMgPSBmcy5zdGF0U3luYyhpbnB1dEZpbGUpO1xuXG5cbiAgIFxuXG4gICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkgICl7XG5cbiAgICAgICAgXG5cbiAgICAgICAgaWYoIHVucGFja2FnZWRGb2xkZXIuaW5kZXhPZihpbnB1dEZpbGUpPi0xICl7XG5cbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICAgIGxldCBmbG9kZXI6RmlsZUludGVyZmFjZSA9IFBhZ2VGYWN0b3J5LmNyZWF0ZUZvbGRlcihpbnB1dEZpbGUsb3V0cHV0RmlsZSk7XG4gICAgICAgICAgICBmbG9kZXIub3BlcmF0ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhpbnB1dEZpbGUpO1xuXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUsaW5kZXgpe1xuICBcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHBhdGguam9pbihyZWxhdGl2ZVBhdGgsZmlsZSk7XG4gICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhmcm9tKVxuICAgIFxuICAgICAgICAgICAgICAgIGNvcHlGb2xkZXIoZnJvbSk7XG4gICAgICAgIFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG5cbiAgICB9ZWxzZSBpZighc3RhdHMuaXNEaXJlY3RvcnkoKSApe1xuXG4gICAgICAgIGxldCBwYWdlOkZpbGVJbnRlcmZhY2UgPSBQYWdlRmFjdG9yeS5jcmVhdGVQYWdlKGlucHV0RmlsZSxvdXRwdXRGaWxlKTtcbiAgICAgICAgcGFnZS5vcGVyYXRlKClcbiAgICB9XG5cblxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy8xLnRzIiwiXHJcbmltcG9ydCB7IGlucHV0Um9vdCwgb3V0cHV0Um9vdCwgSHRtbDJKc01hcCwgdW5wYWNrYWdlZEZpbGUsdW5wYWNrYWdlZEZvbGRlciAsanNTY3JpcHRzLGpzU2NyaXB0c1gsbWFuaWZlc3R9IGZyb20gXCIuLi9jb21tb24vY29uZlwiXHJcbmltcG9ydCB7IGNoZWNrRmlsZU5hbWUgfSBmcm9tIFwiLi4vY29tbW9uL1Rvb2xzXCJcclxuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuL1BhZ2VcIlxyXG5pbXBvcnQgeyBIdG1sUGFnZSB9IGZyb20gXCIuL0h0bWxQYWdlXCJcclxuaW1wb3J0IHsgRmlsZUludGVyZmFjZSB9IGZyb20gXCIuL0ZpbGVJbnRlcmZhY2VcIlxyXG5pbXBvcnQgeyBGb2xkZXIgfSBmcm9tIFwiLi9Gb2xkZXJcIlxyXG5pbXBvcnQge3NjcmlwdFBhZ2V9IGZyb20gXCIuL3NjcmlwdFBhZ2VcIlxyXG5pbXBvcnQge21hbmlmZXN0UGFnZX0gZnJvbSBcIi4vbWFuaWZlc3RQYWdlXCJcclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIGVtcHR5RmlsZSBpbXBsZW1lbnRzIEZpbGVJbnRlcmZhY2Uge1xyXG4gICAgb3BlcmF0ZSgpIHsgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUGFnZUZhY3Rvcnkge1xyXG5cclxuICAgIC8vIHN0YXRpYyBIdG1sMkpzTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+ID0gSHRtbDJKc01hcDtcclxuICAgIC8vIHN0YXRpYyB1bnBhY2thZ2VkRmlsZSA9IHVucGFja2FnZWRGaWxlO1xyXG5cclxuICAgIHN0YXRpYyBjcmVhdGVQYWdlKGlucHV0UGF0aDogc3RyaW5nLCBvdXRwdXRQYXRoOiBzdHJpbmcpOiBGaWxlSW50ZXJmYWNlIHtcclxuXHJcbiAgICAgICAgaWYgKHVucGFja2FnZWRGaWxlLmluZGV4T2YoaW5wdXRQYXRoKSA+IC0xIHx8ICFjaGVja0ZpbGVOYW1lKGlucHV0UGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBlbXB0eUZpbGUoKVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0UGF0aC5lbmRzV2l0aChcIi5odG1sXCIpKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBuZXcgZW1wdHlGaWxlKClcclxuICAgICAgICAgICAgLy9sZXQgbWFwID0gIFBhZ2VGYWN0b3J5Lkh0bWwySnNNYXA7XHJcblxyXG4gICAgICAgICAgICBpZiAoSHRtbDJKc01hcC5oYXMoaW5wdXRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIdG1sUGFnZShpbnB1dFBhdGgsb3V0cHV0UGF0aCAsIEh0bWwySnNNYXAuZ2V0KGlucHV0UGF0aCkpO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZShpbnB1dFBhdGgsIG91dHB1dFBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXRoLmVuZHNXaXRoKFwiLmpzXCIpKSB7XHJcblxyXG4gICAgICAgICAgICBpZigganNTY3JpcHRzLmluZGV4T2YoaW5wdXRQYXRoKT4tMSAgKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzY3JpcHRQYWdlKGlucHV0UGF0aCxvdXRwdXRQYXRoKVxyXG5cclxuICAgICAgICAgICAgfWVsc2UgaWYoanNTY3JpcHRzWC5pbmRleE9mKGlucHV0UGF0aCk+LTEpeyAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzY3JpcHRQYWdlKGlucHV0UGF0aCxvdXRwdXRQYXRoLHRydWUpXHJcblxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZW1wdHlGaWxlKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9ZWxzZSBpZiggbWFuaWZlc3QuaW5kZXhPZihpbnB1dFBhdGgpPi0xICl7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWFuaWZlc3RQYWdlKGlucHV0UGF0aCwgb3V0cHV0UGF0aCk7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2UoaW5wdXRQYXRoLCBvdXRwdXRQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNyZWF0ZUZvbGRlcihpbnB1dFBhdGg6IHN0cmluZywgb3V0cHV0UGF0aDogc3RyaW5nKTogRmlsZUludGVyZmFjZSB7XHJcblxyXG4gICAgICAgIGlmICh1bnBhY2thZ2VkRm9sZGVyLmluZGV4T2YoaW5wdXRQYXRoKSA+IC0xIHx8ICFjaGVja0ZpbGVOYW1lKGlucHV0UGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuXHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRlcihvdXRwdXRQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3Bvam8vUGFnZUZhY3RvcnkudHMiLCJpbXBvcnQgKiBhcyBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0ICogYXMgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3N0TWVzc2FnZShfdXJsOiBzdHJpbmcpOiAgUHJvbWlzZTxhbnk+O1xuZXhwb3J0IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKF91cmw6IHN0cmluZyxwb3N0RGF0YTpvYmplY3QpOiAgUHJvbWlzZTxhbnk+O1xuZXhwb3J0IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKF91cmw6IHN0cmluZyxwb3N0RGF0YTpvYmplY3QsaGVhZGVyczpvYmplY3QpOiAgUHJvbWlzZTxhbnk+O1xuXG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoLi4uYXJncyk6ICBQcm9taXNlPGFueT57XG4gICAgbGV0IF91cmwgPSBhcmdzWzBdO1xuICAgIGxldCBwb3N0RGF0YSA9IGFyZ3NbMV18fHt9O1xuICAgIGxldCBoZWFkZXJzID0gYXJnc1syXXx8e307IFxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCkgPT4ge1xuICAgICAgICAgXG5cbiAgICAgICAgbGV0IHVybERhdGEgPSB1cmwucGFyc2UoX3VybCk7ICAgXG4gICAgICAgIGxldCBwRGF0YSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShwb3N0RGF0YSk7XG4gICAgICAgIGxldCBkZWZhdWx0X2hlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzonYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04JyxcbiAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6QnVmZmVyLmJ5dGVMZW5ndGgocERhdGEpXG4gICAgICAgIH0gICAgXG5cbiAgICAgICAgbGV0IG9wdGlvbnM9e1xuICAgICAgICAgICAgaG9zdG5hbWU6dXJsRGF0YS5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6dXJsRGF0YS5wb3J0fHxcIjQ0M1wiLFxuICAgICAgICAgICAgcGF0aDp1cmxEYXRhLnBhdGgsXG4gICAgICAgICAgICBtZXRob2Q6J1BPU1QnLFxuICAgICAgICAgICAgLy9zZWN1cmVQcm90b2NvbDogJ1NTTHYzX21ldGhvZCcsXG4gICAgICAgICAgICBoZWFkZXJzOk9iamVjdC5hc3NpZ24oZGVmYXVsdF9oZWFkZXJzLGhlYWRlcnMpXG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vY29uc29sZS5sb2cob3B0aW9ucylcblxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcImh0dHAtLS0tLS0tLS0tLVwiLHByb2Nlc3MudXB0aW1lKCkpXG5cbiAgICAgICAgbGV0IHJlcSA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgbGV0IGNodW5rczpzdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgcmVzLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICByZXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVua3MgKz0gYCR7Y2h1bmt9YDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXMub24oJ2VuZCcsZnVuY3Rpb24oKXsgXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjaHVua3MpXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImdldC0tLS0tLS0tLS0tXCIscHJvY2Vzcy51cHRpbWUoKSlcbiAgICAgICAgICAgICB9KVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcS5vbignZXJyb3InLGZ1bmN0aW9uKGVycil7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS53cml0ZShwRGF0YSk7XG4gICAgICAgIHJlcS5lbmQoKTtcblxuICAgIH0pXG59XG5cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL3JlcXVlc3QudHMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImh0dHBzXCJcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInF1ZXJ5c3RyaW5nXCJcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1cmxcIlxuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gVG9rZW5pemVyO1xuXG52YXIgZGVjb2RlQ29kZVBvaW50ID0gcmVxdWlyZShcImVudGl0aWVzL2xpYi9kZWNvZGVfY29kZXBvaW50LmpzXCIpLFxuICAgIGVudGl0eU1hcCA9IHJlcXVpcmUoXCJlbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb25cIiksXG4gICAgbGVnYWN5TWFwID0gcmVxdWlyZShcImVudGl0aWVzL21hcHMvbGVnYWN5Lmpzb25cIiksXG4gICAgeG1sTWFwICAgID0gcmVxdWlyZShcImVudGl0aWVzL21hcHMveG1sLmpzb25cIiksXG5cbiAgICBpID0gMCxcblxuICAgIFRFWFQgICAgICAgICAgICAgICAgICAgICAgPSBpKyssXG4gICAgQkVGT1JFX1RBR19OQU1FICAgICAgICAgICA9IGkrKywgLy9hZnRlciA8XG4gICAgSU5fVEFHX05BTUUgICAgICAgICAgICAgICA9IGkrKyxcbiAgICBJTl9TRUxGX0NMT1NJTkdfVEFHICAgICAgID0gaSsrLFxuICAgIEJFRk9SRV9DTE9TSU5HX1RBR19OQU1FICAgPSBpKyssXG4gICAgSU5fQ0xPU0lOR19UQUdfTkFNRSAgICAgICA9IGkrKyxcbiAgICBBRlRFUl9DTE9TSU5HX1RBR19OQU1FICAgID0gaSsrLFxuXG4gICAgLy9hdHRyaWJ1dGVzXG4gICAgQkVGT1JFX0FUVFJJQlVURV9OQU1FICAgICA9IGkrKyxcbiAgICBJTl9BVFRSSUJVVEVfTkFNRSAgICAgICAgID0gaSsrLFxuICAgIEFGVEVSX0FUVFJJQlVURV9OQU1FICAgICAgPSBpKyssXG4gICAgQkVGT1JFX0FUVFJJQlVURV9WQUxVRSAgICA9IGkrKyxcbiAgICBJTl9BVFRSSUJVVEVfVkFMVUVfRFEgICAgID0gaSsrLCAvLyBcIlxuICAgIElOX0FUVFJJQlVURV9WQUxVRV9TUSAgICAgPSBpKyssIC8vICdcbiAgICBJTl9BVFRSSUJVVEVfVkFMVUVfTlEgICAgID0gaSsrLFxuXG4gICAgLy9kZWNsYXJhdGlvbnNcbiAgICBCRUZPUkVfREVDTEFSQVRJT04gICAgICAgID0gaSsrLCAvLyAhXG4gICAgSU5fREVDTEFSQVRJT04gICAgICAgICAgICA9IGkrKyxcblxuICAgIC8vcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbiAgICBJTl9QUk9DRVNTSU5HX0lOU1RSVUNUSU9OID0gaSsrLCAvLyA/XG5cbiAgICAvL2NvbW1lbnRzXG4gICAgQkVGT1JFX0NPTU1FTlQgICAgICAgICAgICA9IGkrKyxcbiAgICBJTl9DT01NRU5UICAgICAgICAgICAgICAgID0gaSsrLFxuICAgIEFGVEVSX0NPTU1FTlRfMSAgICAgICAgICAgPSBpKyssXG4gICAgQUZURVJfQ09NTUVOVF8yICAgICAgICAgICA9IGkrKyxcblxuICAgIC8vY2RhdGFcbiAgICBCRUZPUkVfQ0RBVEFfMSAgICAgICAgICAgID0gaSsrLCAvLyBbXG4gICAgQkVGT1JFX0NEQVRBXzIgICAgICAgICAgICA9IGkrKywgLy8gQ1xuICAgIEJFRk9SRV9DREFUQV8zICAgICAgICAgICAgPSBpKyssIC8vIERcbiAgICBCRUZPUkVfQ0RBVEFfNCAgICAgICAgICAgID0gaSsrLCAvLyBBXG4gICAgQkVGT1JFX0NEQVRBXzUgICAgICAgICAgICA9IGkrKywgLy8gVFxuICAgIEJFRk9SRV9DREFUQV82ICAgICAgICAgICAgPSBpKyssIC8vIEFcbiAgICBJTl9DREFUQSAgICAgICAgICAgICAgICAgID0gaSsrLCAvLyBbXG4gICAgQUZURVJfQ0RBVEFfMSAgICAgICAgICAgICA9IGkrKywgLy8gXVxuICAgIEFGVEVSX0NEQVRBXzIgICAgICAgICAgICAgPSBpKyssIC8vIF1cblxuICAgIC8vc3BlY2lhbCB0YWdzXG4gICAgQkVGT1JFX1NQRUNJQUwgICAgICAgICAgICA9IGkrKywgLy9TXG4gICAgQkVGT1JFX1NQRUNJQUxfRU5EICAgICAgICA9IGkrKywgICAvL1NcblxuICAgIEJFRk9SRV9TQ1JJUFRfMSAgICAgICAgICAgPSBpKyssIC8vQ1xuICAgIEJFRk9SRV9TQ1JJUFRfMiAgICAgICAgICAgPSBpKyssIC8vUlxuICAgIEJFRk9SRV9TQ1JJUFRfMyAgICAgICAgICAgPSBpKyssIC8vSVxuICAgIEJFRk9SRV9TQ1JJUFRfNCAgICAgICAgICAgPSBpKyssIC8vUFxuICAgIEJFRk9SRV9TQ1JJUFRfNSAgICAgICAgICAgPSBpKyssIC8vVFxuICAgIEFGVEVSX1NDUklQVF8xICAgICAgICAgICAgPSBpKyssIC8vQ1xuICAgIEFGVEVSX1NDUklQVF8yICAgICAgICAgICAgPSBpKyssIC8vUlxuICAgIEFGVEVSX1NDUklQVF8zICAgICAgICAgICAgPSBpKyssIC8vSVxuICAgIEFGVEVSX1NDUklQVF80ICAgICAgICAgICAgPSBpKyssIC8vUFxuICAgIEFGVEVSX1NDUklQVF81ICAgICAgICAgICAgPSBpKyssIC8vVFxuXG4gICAgQkVGT1JFX1NUWUxFXzEgICAgICAgICAgICA9IGkrKywgLy9UXG4gICAgQkVGT1JFX1NUWUxFXzIgICAgICAgICAgICA9IGkrKywgLy9ZXG4gICAgQkVGT1JFX1NUWUxFXzMgICAgICAgICAgICA9IGkrKywgLy9MXG4gICAgQkVGT1JFX1NUWUxFXzQgICAgICAgICAgICA9IGkrKywgLy9FXG4gICAgQUZURVJfU1RZTEVfMSAgICAgICAgICAgICA9IGkrKywgLy9UXG4gICAgQUZURVJfU1RZTEVfMiAgICAgICAgICAgICA9IGkrKywgLy9ZXG4gICAgQUZURVJfU1RZTEVfMyAgICAgICAgICAgICA9IGkrKywgLy9MXG4gICAgQUZURVJfU1RZTEVfNCAgICAgICAgICAgICA9IGkrKywgLy9FXG5cbiAgICBCRUZPUkVfRU5USVRZICAgICAgICAgICAgID0gaSsrLCAvLyZcbiAgICBCRUZPUkVfTlVNRVJJQ19FTlRJVFkgICAgID0gaSsrLCAvLyNcbiAgICBJTl9OQU1FRF9FTlRJVFkgICAgICAgICAgID0gaSsrLFxuICAgIElOX05VTUVSSUNfRU5USVRZICAgICAgICAgPSBpKyssXG4gICAgSU5fSEVYX0VOVElUWSAgICAgICAgICAgICA9IGkrKywgLy9YXG5cbiAgICBqID0gMCxcblxuICAgIFNQRUNJQUxfTk9ORSAgICAgICAgICAgICAgPSBqKyssXG4gICAgU1BFQ0lBTF9TQ1JJUFQgICAgICAgICAgICA9IGorKyxcbiAgICBTUEVDSUFMX1NUWUxFICAgICAgICAgICAgID0gaisrO1xuXG5mdW5jdGlvbiB3aGl0ZXNwYWNlKGMpe1xuXHRyZXR1cm4gYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcdFwiIHx8IGMgPT09IFwiXFxmXCIgfHwgYyA9PT0gXCJcXHJcIjtcbn1cblxuZnVuY3Rpb24gY2hhcmFjdGVyU3RhdGUoY2hhciwgU1VDQ0VTUyl7XG5cdHJldHVybiBmdW5jdGlvbihjKXtcblx0XHRpZihjID09PSBjaGFyKSB0aGlzLl9zdGF0ZSA9IFNVQ0NFU1M7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGlmRWxzZVN0YXRlKHVwcGVyLCBTVUNDRVNTLCBGQUlMVVJFKXtcblx0dmFyIGxvd2VyID0gdXBwZXIudG9Mb3dlckNhc2UoKTtcblxuXHRpZih1cHBlciA9PT0gbG93ZXIpe1xuXHRcdHJldHVybiBmdW5jdGlvbihjKXtcblx0XHRcdGlmKGMgPT09IGxvd2VyKXtcblx0XHRcdFx0dGhpcy5fc3RhdGUgPSBTVUNDRVNTO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc3RhdGUgPSBGQUlMVVJFO1xuXHRcdFx0XHR0aGlzLl9pbmRleC0tO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGMpe1xuXHRcdFx0aWYoYyA9PT0gbG93ZXIgfHwgYyA9PT0gdXBwZXIpe1xuXHRcdFx0XHR0aGlzLl9zdGF0ZSA9IFNVQ0NFU1M7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zdGF0ZSA9IEZBSUxVUkU7XG5cdFx0XHRcdHRoaXMuX2luZGV4LS07XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKHVwcGVyLCBORVhUX1NUQVRFKXtcblx0dmFyIGxvd2VyID0gdXBwZXIudG9Mb3dlckNhc2UoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oYyl7XG5cdFx0aWYoYyA9PT0gbG93ZXIgfHwgYyA9PT0gdXBwZXIpe1xuXHRcdFx0dGhpcy5fc3RhdGUgPSBORVhUX1NUQVRFO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IElOX1RBR19OQU1FO1xuXHRcdFx0dGhpcy5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gVG9rZW5pemVyKG9wdGlvbnMsIGNicyl7XG5cdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0dGhpcy5fYnVmZmVyID0gXCJcIjtcblx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gMDtcblx0dGhpcy5faW5kZXggPSAwO1xuXHR0aGlzLl9idWZmZXJPZmZzZXQgPSAwOyAvL2NoYXJzIHJlbW92ZWQgZnJvbSBfYnVmZmVyXG5cdHRoaXMuX2Jhc2VTdGF0ZSA9IFRFWFQ7XG5cdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX05PTkU7XG5cdHRoaXMuX2NicyA9IGNicztcblx0dGhpcy5fcnVubmluZyA9IHRydWU7XG5cdHRoaXMuX2VuZGVkID0gZmFsc2U7XG5cdHRoaXMuX3htbE1vZGUgPSAhIShvcHRpb25zICYmIG9wdGlvbnMueG1sTW9kZSk7XG5cdHRoaXMuX2RlY29kZUVudGl0aWVzID0gISEob3B0aW9ucyAmJiBvcHRpb25zLmRlY29kZUVudGl0aWVzKTtcbn1cblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVUZXh0ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPFwiKXtcblx0XHRpZih0aGlzLl9pbmRleCA+IHRoaXMuX3NlY3Rpb25TdGFydCl7XG5cdFx0XHR0aGlzLl9jYnMub250ZXh0KHRoaXMuX2dldFNlY3Rpb24oKSk7XG5cdFx0fVxuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX1RBR19OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9IGVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5fc3BlY2lhbCA9PT0gU1BFQ0lBTF9OT05FICYmIGMgPT09IFwiJlwiKXtcblx0XHRpZih0aGlzLl9pbmRleCA+IHRoaXMuX3NlY3Rpb25TdGFydCl7XG5cdFx0XHR0aGlzLl9jYnMub250ZXh0KHRoaXMuX2dldFNlY3Rpb24oKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2Jhc2VTdGF0ZSA9IFRFWFQ7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfRU5USVRZO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVRhZ05hbWUgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCIvXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0NMT1NJTkdfVEFHX05BTUU7XG5cdH0gZWxzZSBpZihjID09PSBcIjxcIil7XG5cdFx0dGhpcy5fY2JzLm9udGV4dCh0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9IGVsc2UgaWYoYyA9PT0gXCI+XCIgfHwgdGhpcy5fc3BlY2lhbCAhPT0gU1BFQ0lBTF9OT05FIHx8IHdoaXRlc3BhY2UoYykpIHtcblx0XHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdH0gZWxzZSBpZihjID09PSBcIiFcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfREVDTEFSQVRJT047XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2UgaWYoYyA9PT0gXCI/XCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fUFJPQ0VTU0lOR19JTlNUUlVDVElPTjtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fc3RhdGUgPSAoIXRoaXMuX3htbE1vZGUgJiYgKGMgPT09IFwic1wiIHx8IGMgPT09IFwiU1wiKSkgP1xuXHRcdFx0XHRcdFx0QkVGT1JFX1NQRUNJQUwgOiBJTl9UQUdfTkFNRTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJblRhZ05hbWUgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSl7XG5cdFx0dGhpcy5fZW1pdFRva2VuKFwib25vcGVudGFnbmFtZVwiKTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfTkFNRTtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNsb3NlaW5nVGFnTmFtZSA9IGZ1bmN0aW9uKGMpe1xuXHRpZih3aGl0ZXNwYWNlKGMpKTtcblx0ZWxzZSBpZihjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHR9IGVsc2UgaWYodGhpcy5fc3BlY2lhbCAhPT0gU1BFQ0lBTF9OT05FKXtcblx0XHRpZihjID09PSBcInNcIiB8fCBjID09PSBcIlNcIil7XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9TUEVDSUFMX0VORDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHRcdFx0dGhpcy5faW5kZXgtLTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DTE9TSU5HX1RBR19OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQ2xvc2VpbmdUYWdOYW1lID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uY2xvc2V0YWdcIik7XG5cdFx0dGhpcy5fc3RhdGUgPSBBRlRFUl9DTE9TSU5HX1RBR19OQU1FO1xuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDbG9zZWluZ1RhZ05hbWUgPSBmdW5jdGlvbihjKXtcblx0Ly9za2lwIGV2ZXJ5dGhpbmcgdW50aWwgXCI+XCJcblx0aWYoYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fY2JzLm9ub3BlbnRhZ2VuZCgpO1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSBpZihjID09PSBcIi9cIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9TRUxGX0NMT1NJTkdfVEFHO1xuXHR9IGVsc2UgaWYoIXdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQVRUUklCVVRFX05BTUU7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5TZWxmQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fY2JzLm9uc2VsZmNsb3Npbmd0YWcoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2UgaWYoIXdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9OQU1FO1xuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPVwiIHx8IGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX2Nicy5vbmF0dHJpYm5hbWUodGhpcy5fZ2V0U2VjdGlvbigpKTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSAtMTtcblx0XHR0aGlzLl9zdGF0ZSA9IEFGVEVSX0FUVFJJQlVURV9OQU1FO1xuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPVwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfVkFMVUU7XG5cdH0gZWxzZSBpZihjID09PSBcIi9cIiB8fCBjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fY2JzLm9uYXR0cmliZW5kKCk7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfQVRUUklCVVRFX05BTUU7XG5cdFx0dGhpcy5faW5kZXgtLTtcblx0fSBlbHNlIGlmKCF3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9jYnMub25hdHRyaWJlbmQoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0FUVFJJQlVURV9OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiXFxcIlwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0FUVFJJQlVURV9WQUxVRV9EUTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSBpZihjID09PSBcIidcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9BVFRSSUJVVEVfVkFMVUVfU1E7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2UgaWYoIXdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQVRUUklCVVRFX1ZBTFVFX05RO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHRcdHRoaXMuX2luZGV4LS07IC8vcmVjb25zdW1lIHRva2VuXG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlcyA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIlxcXCJcIil7XG5cdFx0dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO1xuXHRcdHRoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9OQU1FO1xuXHR9IGVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9FTlRJVFk7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIidcIil7XG5cdFx0dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO1xuXHRcdHRoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9OQU1FO1xuXHR9IGVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9FTlRJVFk7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzID0gZnVuY3Rpb24oYyl7XG5cdGlmKHdoaXRlc3BhY2UoYykgfHwgYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9jYnMub25hdHRyaWJlbmQoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfTkFNRTtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9IGVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9FTlRJVFk7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlRGVjbGFyYXRpb24gPSBmdW5jdGlvbihjKXtcblx0dGhpcy5fc3RhdGUgPSBjID09PSBcIltcIiA/IEJFRk9SRV9DREFUQV8xIDpcblx0XHRcdFx0XHRjID09PSBcIi1cIiA/IEJFRk9SRV9DT01NRU5UIDpcblx0XHRcdFx0XHRcdElOX0RFQ0xBUkFUSU9OO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiKXtcblx0XHR0aGlzLl9jYnMub25kZWNsYXJhdGlvbih0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbih0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIi1cIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DT01NRU5UO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0RFQ0xBUkFUSU9OO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQ29tbWVudCA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIi1cIikgdGhpcy5fc3RhdGUgPSBBRlRFUl9DT01NRU5UXzE7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ29tbWVudDEgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCItXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gQUZURVJfQ09NTUVOVF8yO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQ09NTUVOVDtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNvbW1lbnQyID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiKXtcblx0XHQvL3JlbW92ZSAyIHRyYWlsaW5nIGNoYXJzXG5cdFx0dGhpcy5fY2JzLm9uY29tbWVudCh0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCwgdGhpcy5faW5kZXggLSAyKSk7XG5cdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIGlmKGMgIT09IFwiLVwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0NPTU1FTlQ7XG5cdH1cblx0Ly8gZWxzZTogc3RheSBpbiBBRlRFUl9DT01NRU5UXzIgKGAtLS0+YClcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ2RhdGExID0gaWZFbHNlU3RhdGUoXCJDXCIsIEJFRk9SRV9DREFUQV8yLCBJTl9ERUNMQVJBVElPTik7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhMiA9IGlmRWxzZVN0YXRlKFwiRFwiLCBCRUZPUkVfQ0RBVEFfMywgSU5fREVDTEFSQVRJT04pO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDZGF0YTMgPSBpZkVsc2VTdGF0ZShcIkFcIiwgQkVGT1JFX0NEQVRBXzQsIElOX0RFQ0xBUkFUSU9OKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ2RhdGE0ID0gaWZFbHNlU3RhdGUoXCJUXCIsIEJFRk9SRV9DREFUQV81LCBJTl9ERUNMQVJBVElPTik7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhNSA9IGlmRWxzZVN0YXRlKFwiQVwiLCBCRUZPUkVfQ0RBVEFfNiwgSU5fREVDTEFSQVRJT04pO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhNiA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIltcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DREFUQTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9ERUNMQVJBVElPTjtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQ2RhdGEgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCJdXCIpIHRoaXMuX3N0YXRlID0gQUZURVJfQ0RBVEFfMTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDZGF0YTEgPSBjaGFyYWN0ZXJTdGF0ZShcIl1cIiwgQUZURVJfQ0RBVEFfMik7XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDZGF0YTIgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI+XCIpe1xuXHRcdC8vcmVtb3ZlIDIgdHJhaWxpbmcgY2hhcnNcblx0XHR0aGlzLl9jYnMub25jZGF0YSh0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCwgdGhpcy5faW5kZXggLSAyKSk7XG5cdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIGlmKGMgIT09IFwiXVwiKSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DREFUQTtcblx0fVxuXHQvL2Vsc2U6IHN0YXkgaW4gQUZURVJfQ0RBVEFfMiAoYF1dXT5gKVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTcGVjaWFsID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiY1wiIHx8IGMgPT09IFwiQ1wiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9TQ1JJUFRfMTtcblx0fSBlbHNlIGlmKGMgPT09IFwidFwiIHx8IGMgPT09IFwiVFwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9TVFlMRV8xO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fVEFHX05BTUU7XG5cdFx0dGhpcy5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVNwZWNpYWxFbmQgPSBmdW5jdGlvbihjKXtcblx0aWYodGhpcy5fc3BlY2lhbCA9PT0gU1BFQ0lBTF9TQ1JJUFQgJiYgKGMgPT09IFwiY1wiIHx8IGMgPT09IFwiQ1wiKSl7XG5cdFx0dGhpcy5fc3RhdGUgPSBBRlRFUl9TQ1JJUFRfMTtcblx0fSBlbHNlIGlmKHRoaXMuX3NwZWNpYWwgPT09IFNQRUNJQUxfU1RZTEUgJiYgKGMgPT09IFwidFwiIHx8IGMgPT09IFwiVFwiKSl7XG5cdFx0dGhpcy5fc3RhdGUgPSBBRlRFUl9TVFlMRV8xO1xuXHR9XG5cdGVsc2UgdGhpcy5fc3RhdGUgPSBURVhUO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTY3JpcHQxID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlJcIiwgQkVGT1JFX1NDUklQVF8yKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU2NyaXB0MiA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJJXCIsIEJFRk9SRV9TQ1JJUFRfMyk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVNjcmlwdDMgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiUFwiLCBCRUZPUkVfU0NSSVBUXzQpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTY3JpcHQ0ID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlRcIiwgQkVGT1JFX1NDUklQVF81KTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTY3JpcHQ1ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX1NDUklQVDtcblx0fVxuXHR0aGlzLl9zdGF0ZSA9IElOX1RBR19OQU1FO1xuXHR0aGlzLl9pbmRleC0tOyAvL2NvbnN1bWUgdGhlIHRva2VuIGFnYWluXG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0MSA9IGlmRWxzZVN0YXRlKFwiUlwiLCBBRlRFUl9TQ1JJUFRfMiwgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0MiA9IGlmRWxzZVN0YXRlKFwiSVwiLCBBRlRFUl9TQ1JJUFRfMywgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0MyA9IGlmRWxzZVN0YXRlKFwiUFwiLCBBRlRFUl9TQ1JJUFRfNCwgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0NCA9IGlmRWxzZVN0YXRlKFwiVFwiLCBBRlRFUl9TQ1JJUFRfNSwgVEVYVCk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJTY3JpcHQ1ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX05PTkU7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DTE9TSU5HX1RBR19OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4IC0gNjtcblx0XHR0aGlzLl9pbmRleC0tOyAvL3JlY29uc3VtZSB0aGUgdG9rZW5cblx0fVxuXHRlbHNlIHRoaXMuX3N0YXRlID0gVEVYVDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU3R5bGUxID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIllcIiwgQkVGT1JFX1NUWUxFXzIpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTdHlsZTIgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiTFwiLCBCRUZPUkVfU1RZTEVfMyk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVN0eWxlMyA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJFXCIsIEJFRk9SRV9TVFlMRV80KTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTdHlsZTQgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSl7XG5cdFx0dGhpcy5fc3BlY2lhbCA9IFNQRUNJQUxfU1RZTEU7XG5cdH1cblx0dGhpcy5fc3RhdGUgPSBJTl9UQUdfTkFNRTtcblx0dGhpcy5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclN0eWxlMSA9IGlmRWxzZVN0YXRlKFwiWVwiLCBBRlRFUl9TVFlMRV8yLCBURVhUKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJTdHlsZTIgPSBpZkVsc2VTdGF0ZShcIkxcIiwgQUZURVJfU1RZTEVfMywgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU3R5bGUzID0gaWZFbHNlU3RhdGUoXCJFXCIsIEFGVEVSX1NUWUxFXzQsIFRFWFQpO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU3R5bGU0ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX05PTkU7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DTE9TSU5HX1RBR19OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4IC0gNTtcblx0XHR0aGlzLl9pbmRleC0tOyAvL3JlY29uc3VtZSB0aGUgdG9rZW5cblx0fVxuXHRlbHNlIHRoaXMuX3N0YXRlID0gVEVYVDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlRW50aXR5ID0gaWZFbHNlU3RhdGUoXCIjXCIsIEJFRk9SRV9OVU1FUklDX0VOVElUWSwgSU5fTkFNRURfRU5USVRZKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlTnVtZXJpY0VudGl0eSA9IGlmRWxzZVN0YXRlKFwiWFwiLCBJTl9IRVhfRU5USVRZLCBJTl9OVU1FUklDX0VOVElUWSk7XG5cbi8vZm9yIGVudGl0aWVzIHRlcm1pbmF0ZWQgd2l0aCBhIHNlbWljb2xvblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2VOYW1lZEVudGl0eVN0cmljdCA9IGZ1bmN0aW9uKCl7XG5cdC8vb2Zmc2V0ID0gMVxuXHRpZih0aGlzLl9zZWN0aW9uU3RhcnQgKyAxIDwgdGhpcy5faW5kZXgpe1xuXHRcdHZhciBlbnRpdHkgPSB0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCArIDEsIHRoaXMuX2luZGV4KSxcblx0XHQgICAgbWFwID0gdGhpcy5feG1sTW9kZSA/IHhtbE1hcCA6IGVudGl0eU1hcDtcblxuXHRcdGlmKG1hcC5oYXNPd25Qcm9wZXJ0eShlbnRpdHkpKXtcblx0XHRcdHRoaXMuX2VtaXRQYXJ0aWFsKG1hcFtlbnRpdHldKTtcblx0XHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0XHR9XG5cdH1cbn07XG5cblxuLy9wYXJzZXMgbGVnYWN5IGVudGl0aWVzICh3aXRob3V0IHRyYWlsaW5nIHNlbWljb2xvbilcblRva2VuaXplci5wcm90b3R5cGUuX3BhcnNlTGVnYWN5RW50aXR5ID0gZnVuY3Rpb24oKXtcblx0dmFyIHN0YXJ0ID0gdGhpcy5fc2VjdGlvblN0YXJ0ICsgMSxcblx0ICAgIGxpbWl0ID0gdGhpcy5faW5kZXggLSBzdGFydDtcblxuXHRpZihsaW1pdCA+IDYpIGxpbWl0ID0gNjsgLy90aGUgbWF4IGxlbmd0aCBvZiBsZWdhY3kgZW50aXRpZXMgaXMgNlxuXG5cdHdoaWxlKGxpbWl0ID49IDIpeyAvL3RoZSBtaW4gbGVuZ3RoIG9mIGxlZ2FjeSBlbnRpdGllcyBpcyAyXG5cdFx0dmFyIGVudGl0eSA9IHRoaXMuX2J1ZmZlci5zdWJzdHIoc3RhcnQsIGxpbWl0KTtcblxuXHRcdGlmKGxlZ2FjeU1hcC5oYXNPd25Qcm9wZXJ0eShlbnRpdHkpKXtcblx0XHRcdHRoaXMuX2VtaXRQYXJ0aWFsKGxlZ2FjeU1hcFtlbnRpdHldKTtcblx0XHRcdHRoaXMuX3NlY3Rpb25TdGFydCArPSBsaW1pdCArIDE7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbWl0LS07XG5cdFx0fVxuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluTmFtZWRFbnRpdHkgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI7XCIpe1xuXHRcdHRoaXMuX3BhcnNlTmFtZWRFbnRpdHlTdHJpY3QoKTtcblx0XHRpZih0aGlzLl9zZWN0aW9uU3RhcnQgKyAxIDwgdGhpcy5faW5kZXggJiYgIXRoaXMuX3htbE1vZGUpe1xuXHRcdFx0dGhpcy5fcGFyc2VMZWdhY3lFbnRpdHkoKTtcblx0XHR9XG5cdFx0dGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cdH0gZWxzZSBpZigoYyA8IFwiYVwiIHx8IGMgPiBcInpcIikgJiYgKGMgPCBcIkFcIiB8fCBjID4gXCJaXCIpICYmIChjIDwgXCIwXCIgfHwgYyA+IFwiOVwiKSl7XG5cdFx0aWYodGhpcy5feG1sTW9kZSk7XG5cdFx0ZWxzZSBpZih0aGlzLl9zZWN0aW9uU3RhcnQgKyAxID09PSB0aGlzLl9pbmRleCk7XG5cdFx0ZWxzZSBpZih0aGlzLl9iYXNlU3RhdGUgIT09IFRFWFQpe1xuXHRcdFx0aWYoYyAhPT0gXCI9XCIpe1xuXHRcdFx0XHR0aGlzLl9wYXJzZU5hbWVkRW50aXR5U3RyaWN0KCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cdFx0dGhpcy5faW5kZXgtLTtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZGVjb2RlTnVtZXJpY0VudGl0eSA9IGZ1bmN0aW9uKG9mZnNldCwgYmFzZSl7XG5cdHZhciBzZWN0aW9uU3RhcnQgPSB0aGlzLl9zZWN0aW9uU3RhcnQgKyBvZmZzZXQ7XG5cblx0aWYoc2VjdGlvblN0YXJ0ICE9PSB0aGlzLl9pbmRleCl7XG5cdFx0Ly9wYXJzZSBlbnRpdHlcblx0XHR2YXIgZW50aXR5ID0gdGhpcy5fYnVmZmVyLnN1YnN0cmluZyhzZWN0aW9uU3RhcnQsIHRoaXMuX2luZGV4KTtcblx0XHR2YXIgcGFyc2VkID0gcGFyc2VJbnQoZW50aXR5LCBiYXNlKTtcblxuXHRcdHRoaXMuX2VtaXRQYXJ0aWFsKGRlY29kZUNvZGVQb2ludChwYXJzZWQpKTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQtLTtcblx0fVxuXG5cdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbk51bWVyaWNFbnRpdHkgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI7XCIpe1xuXHRcdHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwgMTApO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCsrO1xuXHR9IGVsc2UgaWYoYyA8IFwiMFwiIHx8IGMgPiBcIjlcIil7XG5cdFx0aWYoIXRoaXMuX3htbE1vZGUpe1xuXHRcdFx0dGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgyLCAxMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdH1cblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluSGV4RW50aXR5ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiO1wiKXtcblx0XHR0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2KTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQrKztcblx0fSBlbHNlIGlmKChjIDwgXCJhXCIgfHwgYyA+IFwiZlwiKSAmJiAoYyA8IFwiQVwiIHx8IGMgPiBcIkZcIikgJiYgKGMgPCBcIjBcIiB8fCBjID4gXCI5XCIpKXtcblx0XHRpZighdGhpcy5feG1sTW9kZSl7XG5cdFx0XHR0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cdFx0fVxuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKXtcblx0aWYodGhpcy5fc2VjdGlvblN0YXJ0IDwgMCl7XG5cdFx0dGhpcy5fYnVmZmVyID0gXCJcIjtcblx0XHR0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG5cdFx0dGhpcy5faW5kZXggPSAwO1xuXHR9IGVsc2UgaWYodGhpcy5fcnVubmluZyl7XG5cdFx0aWYodGhpcy5fc3RhdGUgPT09IFRFWFQpe1xuXHRcdFx0aWYodGhpcy5fc2VjdGlvblN0YXJ0ICE9PSB0aGlzLl9pbmRleCl7XG5cdFx0XHRcdHRoaXMuX2Nicy5vbnRleHQodGhpcy5fYnVmZmVyLnN1YnN0cih0aGlzLl9zZWN0aW9uU3RhcnQpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2J1ZmZlciA9IFwiXCI7XG5cdFx0XHR0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG5cdFx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3NlY3Rpb25TdGFydCA9PT0gdGhpcy5faW5kZXgpe1xuXHRcdFx0Ly90aGUgc2VjdGlvbiBqdXN0IHN0YXJ0ZWRcblx0XHRcdHRoaXMuX2J1ZmZlciA9IFwiXCI7XG5cdFx0XHR0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG5cdFx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vcmVtb3ZlIGV2ZXJ5dGhpbmcgdW5uZWNlc3Nhcnlcblx0XHRcdHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5zdWJzdHIodGhpcy5fc2VjdGlvblN0YXJ0KTtcblx0XHRcdHRoaXMuX2luZGV4IC09IHRoaXMuX3NlY3Rpb25TdGFydDtcblx0XHRcdHRoaXMuX2J1ZmZlck9mZnNldCArPSB0aGlzLl9zZWN0aW9uU3RhcnQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gMDtcblx0fVxufTtcblxuLy9UT0RPIG1ha2UgZXZlbnRzIGNvbmRpdGlvbmFsXG5Ub2tlbml6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmspe1xuXHRpZih0aGlzLl9lbmRlZCkgdGhpcy5fY2JzLm9uZXJyb3IoRXJyb3IoXCIud3JpdGUoKSBhZnRlciBkb25lIVwiKSk7XG5cblx0dGhpcy5fYnVmZmVyICs9IGNodW5rO1xuXHR0aGlzLl9wYXJzZSgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbigpe1xuXHR3aGlsZSh0aGlzLl9pbmRleCA8IHRoaXMuX2J1ZmZlci5sZW5ndGggJiYgdGhpcy5fcnVubmluZyl7XG5cdFx0dmFyIGMgPSB0aGlzLl9idWZmZXIuY2hhckF0KHRoaXMuX2luZGV4KTtcblx0XHRpZih0aGlzLl9zdGF0ZSA9PT0gVEVYVCkge1xuXHRcdFx0dGhpcy5fc3RhdGVUZXh0KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1RBR19OQU1FKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlVGFnTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX1RBR19OQU1FKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUluVGFnTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DTE9TSU5HX1RBR19OQU1FKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ2xvc2VpbmdUYWdOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQ0xPU0lOR19UQUdfTkFNRSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluQ2xvc2VpbmdUYWdOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfQ0xPU0lOR19UQUdfTkFNRSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyQ2xvc2VpbmdUYWdOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fU0VMRl9DTE9TSU5HX1RBRyl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluU2VsZkNsb3NpbmdUYWcoYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqXHRhdHRyaWJ1dGVzXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQVRUUklCVVRFX05BTUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQVRUUklCVVRFX05BTUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZU5hbWUoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9BVFRSSUJVVEVfTkFNRSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9BVFRSSUJVVEVfVkFMVUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0FUVFJJQlVURV9WQUxVRV9EUSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluQXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZXMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9BVFRSSUJVVEVfVkFMVUVfU1Epe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQVRUUklCVVRFX1ZBTFVFX05RKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0Klx0ZGVjbGFyYXRpb25zXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfREVDTEFSQVRJT04pe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0RFQ0xBUkFUSU9OKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5EZWNsYXJhdGlvbihjKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCpcdHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9QUk9DRVNTSU5HX0lOU1RSVUNUSU9OKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqXHRjb21tZW50c1xuXHRcdCovXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0NPTU1FTlQpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVDb21tZW50KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQ09NTUVOVCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluQ29tbWVudChjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX0NPTU1FTlRfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyQ29tbWVudDEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9DT01NRU5UXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckNvbW1lbnQyKGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0Klx0Y2RhdGFcblx0XHQqL1xuXHRcdGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DREFUQV8xKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ2RhdGExKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0NEQVRBXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVDZGF0YTIoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQ0RBVEFfMyl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZUNkYXRhMyhjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DREFUQV80KXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ2RhdGE0KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0NEQVRBXzUpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVDZGF0YTUoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQ0RBVEFfNil7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZUNkYXRhNihjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0NEQVRBKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5DZGF0YShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX0NEQVRBXzEpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckNkYXRhMShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX0NEQVRBXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckNkYXRhMihjKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCogc3BlY2lhbCB0YWdzXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1BFQ0lBTCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVNwZWNpYWwoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1BFQ0lBTF9FTkQpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTcGVjaWFsRW5kKGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0KiBzY3JpcHRcblx0XHQqL1xuXHRcdGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9TQ1JJUFRfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVNjcmlwdDEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU0NSSVBUXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTY3JpcHQyKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NDUklQVF8zKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlU2NyaXB0MyhjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9TQ1JJUFRfNCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVNjcmlwdDQoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU0NSSVBUXzUpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTY3JpcHQ1KGMpO1xuXHRcdH1cblxuXHRcdGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX1NDUklQVF8xKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTY3JpcHQxKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU0NSSVBUXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlclNjcmlwdDIoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TQ1JJUFRfMyl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyU2NyaXB0MyhjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX1NDUklQVF80KXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTY3JpcHQ0KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU0NSSVBUXzUpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlclNjcmlwdDUoYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqIHN0eWxlXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1RZTEVfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVN0eWxlMShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9TVFlMRV8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlU3R5bGUyKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NUWUxFXzMpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTdHlsZTMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1RZTEVfNCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVN0eWxlNChjKTtcblx0XHR9XG5cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TVFlMRV8xKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TVFlMRV8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTIoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TVFlMRV8zKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TVFlMRV80KXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTQoYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqIGVudGl0aWVzXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfRU5USVRZKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlRW50aXR5KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX05VTUVSSUNfRU5USVRZKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlTnVtZXJpY0VudGl0eShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX05BTUVEX0VOVElUWSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluTmFtZWRFbnRpdHkoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9OVU1FUklDX0VOVElUWSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluTnVtZXJpY0VudGl0eShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0hFWF9FTlRJVFkpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkhleEVudGl0eShjKTtcblx0XHR9XG5cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwidW5rbm93biBfc3RhdGVcIiksIHRoaXMuX3N0YXRlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9pbmRleCsrO1xuXHR9XG5cblx0dGhpcy5fY2xlYW51cCgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbn07XG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG5cdGlmKHRoaXMuX2luZGV4IDwgdGhpcy5fYnVmZmVyLmxlbmd0aCl7XG5cdFx0dGhpcy5fcGFyc2UoKTtcblx0fVxuXHRpZih0aGlzLl9lbmRlZCl7XG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmspe1xuXHRpZih0aGlzLl9lbmRlZCkgdGhpcy5fY2JzLm9uZXJyb3IoRXJyb3IoXCIuZW5kKCkgYWZ0ZXIgZG9uZSFcIikpO1xuXHRpZihjaHVuaykgdGhpcy53cml0ZShjaHVuayk7XG5cblx0dGhpcy5fZW5kZWQgPSB0cnVlO1xuXG5cdGlmKHRoaXMuX3J1bm5pbmcpIHRoaXMuX2ZpbmlzaCgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24oKXtcblx0Ly9pZiB0aGVyZSBpcyByZW1haW5pbmcgZGF0YSwgZW1pdCBpdCBpbiBhIHJlYXNvbmFibGUgd2F5XG5cdGlmKHRoaXMuX3NlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KXtcblx0XHR0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTtcblx0fVxuXG5cdHRoaXMuX2Nicy5vbmVuZCgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faGFuZGxlVHJhaWxpbmdEYXRhID0gZnVuY3Rpb24oKXtcblx0dmFyIGRhdGEgPSB0aGlzLl9idWZmZXIuc3Vic3RyKHRoaXMuX3NlY3Rpb25TdGFydCk7XG5cblx0aWYodGhpcy5fc3RhdGUgPT09IElOX0NEQVRBIHx8IHRoaXMuX3N0YXRlID09PSBBRlRFUl9DREFUQV8xIHx8IHRoaXMuX3N0YXRlID09PSBBRlRFUl9DREFUQV8yKXtcblx0XHR0aGlzLl9jYnMub25jZGF0YShkYXRhKTtcblx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9DT01NRU5UIHx8IHRoaXMuX3N0YXRlID09PSBBRlRFUl9DT01NRU5UXzEgfHwgdGhpcy5fc3RhdGUgPT09IEFGVEVSX0NPTU1FTlRfMil7XG5cdFx0dGhpcy5fY2JzLm9uY29tbWVudChkYXRhKTtcblx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9OQU1FRF9FTlRJVFkgJiYgIXRoaXMuX3htbE1vZGUpe1xuXHRcdHRoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7XG5cdFx0aWYodGhpcy5fc2VjdGlvblN0YXJ0IDwgdGhpcy5faW5kZXgpe1xuXHRcdFx0dGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cdFx0XHR0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTtcblx0XHR9XG5cdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fTlVNRVJJQ19FTlRJVFkgJiYgIXRoaXMuX3htbE1vZGUpe1xuXHRcdHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwgMTApO1xuXHRcdGlmKHRoaXMuX3NlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KXtcblx0XHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdFx0dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0hFWF9FTlRJVFkgJiYgIXRoaXMuX3htbE1vZGUpe1xuXHRcdHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMywgMTYpO1xuXHRcdGlmKHRoaXMuX3NlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KXtcblx0XHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdFx0dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYoXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX1RBR19OQU1FICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IEJFRk9SRV9BVFRSSUJVVEVfTkFNRSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBCRUZPUkVfQVRUUklCVVRFX1ZBTFVFICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IEFGVEVSX0FUVFJJQlVURV9OQU1FICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX0FUVFJJQlVURV9OQU1FICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX0FUVFJJQlVURV9WQUxVRV9TUSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBJTl9BVFRSSUJVVEVfVkFMVUVfRFEgJiZcblx0XHR0aGlzLl9zdGF0ZSAhPT0gSU5fQVRUUklCVVRFX1ZBTFVFX05RICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX0NMT1NJTkdfVEFHX05BTUVcblx0KXtcblx0XHR0aGlzLl9jYnMub250ZXh0KGRhdGEpO1xuXHR9XG5cdC8vZWxzZSwgaWdub3JlIHJlbWFpbmluZyBkYXRhXG5cdC8vVE9ETyBhZGQgYSB3YXkgdG8gcmVtb3ZlIGN1cnJlbnQgdGFnXG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcblx0VG9rZW5pemVyLmNhbGwodGhpcywge3htbE1vZGU6IHRoaXMuX3htbE1vZGUsIGRlY29kZUVudGl0aWVzOiB0aGlzLl9kZWNvZGVFbnRpdGllc30sIHRoaXMuX2Nicyk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldEFic29sdXRlSW5kZXggPSBmdW5jdGlvbigpe1xuXHRyZXR1cm4gdGhpcy5fYnVmZmVyT2Zmc2V0ICsgdGhpcy5faW5kZXg7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRTZWN0aW9uID0gZnVuY3Rpb24oKXtcblx0cmV0dXJuIHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcodGhpcy5fc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9lbWl0VG9rZW4gPSBmdW5jdGlvbihuYW1lKXtcblx0dGhpcy5fY2JzW25hbWVdKHRoaXMuX2dldFNlY3Rpb24oKSk7XG5cdHRoaXMuX3NlY3Rpb25TdGFydCA9IC0xO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZW1pdFBhcnRpYWwgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdGlmKHRoaXMuX2Jhc2VTdGF0ZSAhPT0gVEVYVCl7XG5cdFx0dGhpcy5fY2JzLm9uYXR0cmliZGF0YSh2YWx1ZSk7IC8vVE9ETyBpbXBsZW1lbnQgdGhlIG5ldyBldmVudFxuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX2Nicy5vbnRleHQodmFsdWUpO1xuXHR9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9odG1scGFyc2VyMkAzLjkuMkBodG1scGFyc2VyMi9saWIvVG9rZW5pemVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlY29kZU1hcCA9IHJlcXVpcmUoXCIuLi9tYXBzL2RlY29kZS5qc29uXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZUNvZGVQb2ludDtcblxuLy8gbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9oZS9ibG9iL21hc3Rlci9zcmMvaGUuanMjTDk0LUwxMTlcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludChjb2RlUG9pbnQpe1xuXG5cdGlmKChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGKXtcblx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdH1cblxuXHRpZihjb2RlUG9pbnQgaW4gZGVjb2RlTWFwKXtcblx0XHRjb2RlUG9pbnQgPSBkZWNvZGVNYXBbY29kZVBvaW50XTtcblx0fVxuXG5cdHZhciBvdXRwdXQgPSBcIlwiO1xuXG5cdGlmKGNvZGVQb2ludCA+IDB4RkZGRil7XG5cdFx0Y29kZVBvaW50IC09IDB4MTAwMDA7XG5cdFx0b3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcblx0fVxuXG5cdG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2VudGl0aWVzQDEuMS4xQGVudGl0aWVzL2xpYi9kZWNvZGVfY29kZXBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCIwXCI6NjU1MzMsXCIxMjhcIjo4MzY0LFwiMTMwXCI6ODIxOCxcIjEzMVwiOjQwMixcIjEzMlwiOjgyMjIsXCIxMzNcIjo4MjMwLFwiMTM0XCI6ODIyNCxcIjEzNVwiOjgyMjUsXCIxMzZcIjo3MTAsXCIxMzdcIjo4MjQwLFwiMTM4XCI6MzUyLFwiMTM5XCI6ODI0OSxcIjE0MFwiOjMzOCxcIjE0MlwiOjM4MSxcIjE0NVwiOjgyMTYsXCIxNDZcIjo4MjE3LFwiMTQ3XCI6ODIyMCxcIjE0OFwiOjgyMjEsXCIxNDlcIjo4MjI2LFwiMTUwXCI6ODIxMSxcIjE1MVwiOjgyMTIsXCIxNTJcIjo3MzIsXCIxNTNcIjo4NDgyLFwiMTU0XCI6MzUzLFwiMTU1XCI6ODI1MCxcIjE1NlwiOjMzOSxcIjE1OFwiOjM4MixcIjE1OVwiOjM3Nn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2VudGl0aWVzQDEuMS4xQGVudGl0aWVzL21hcHMvZGVjb2RlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIkFhY3V0ZVwiOlwiw4FcIixcImFhY3V0ZVwiOlwiw6FcIixcIkFicmV2ZVwiOlwixIJcIixcImFicmV2ZVwiOlwixINcIixcImFjXCI6XCLiiL5cIixcImFjZFwiOlwi4oi/XCIsXCJhY0VcIjpcIuKIvsyzXCIsXCJBY2lyY1wiOlwiw4JcIixcImFjaXJjXCI6XCLDolwiLFwiYWN1dGVcIjpcIsK0XCIsXCJBY3lcIjpcItCQXCIsXCJhY3lcIjpcItCwXCIsXCJBRWxpZ1wiOlwiw4ZcIixcImFlbGlnXCI6XCLDplwiLFwiYWZcIjpcIuKBoVwiLFwiQWZyXCI6XCLwnZSEXCIsXCJhZnJcIjpcIvCdlJ5cIixcIkFncmF2ZVwiOlwiw4BcIixcImFncmF2ZVwiOlwiw6BcIixcImFsZWZzeW1cIjpcIuKEtVwiLFwiYWxlcGhcIjpcIuKEtVwiLFwiQWxwaGFcIjpcIs6RXCIsXCJhbHBoYVwiOlwizrFcIixcIkFtYWNyXCI6XCLEgFwiLFwiYW1hY3JcIjpcIsSBXCIsXCJhbWFsZ1wiOlwi4qi/XCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiYW5kYW5kXCI6XCLiqZVcIixcIkFuZFwiOlwi4qmTXCIsXCJhbmRcIjpcIuKIp1wiLFwiYW5kZFwiOlwi4qmcXCIsXCJhbmRzbG9wZVwiOlwi4qmYXCIsXCJhbmR2XCI6XCLiqZpcIixcImFuZ1wiOlwi4oigXCIsXCJhbmdlXCI6XCLipqRcIixcImFuZ2xlXCI6XCLiiKBcIixcImFuZ21zZGFhXCI6XCLipqhcIixcImFuZ21zZGFiXCI6XCLipqlcIixcImFuZ21zZGFjXCI6XCLipqpcIixcImFuZ21zZGFkXCI6XCLipqtcIixcImFuZ21zZGFlXCI6XCLipqxcIixcImFuZ21zZGFmXCI6XCLipq1cIixcImFuZ21zZGFnXCI6XCLipq5cIixcImFuZ21zZGFoXCI6XCLipq9cIixcImFuZ21zZFwiOlwi4oihXCIsXCJhbmdydFwiOlwi4oifXCIsXCJhbmdydHZiXCI6XCLiir5cIixcImFuZ3J0dmJkXCI6XCLipp1cIixcImFuZ3NwaFwiOlwi4oiiXCIsXCJhbmdzdFwiOlwiw4VcIixcImFuZ3phcnJcIjpcIuKNvFwiLFwiQW9nb25cIjpcIsSEXCIsXCJhb2dvblwiOlwixIVcIixcIkFvcGZcIjpcIvCdlLhcIixcImFvcGZcIjpcIvCdlZJcIixcImFwYWNpclwiOlwi4qmvXCIsXCJhcFwiOlwi4omIXCIsXCJhcEVcIjpcIuKpsFwiLFwiYXBlXCI6XCLiiYpcIixcImFwaWRcIjpcIuKJi1wiLFwiYXBvc1wiOlwiJ1wiLFwiQXBwbHlGdW5jdGlvblwiOlwi4oGhXCIsXCJhcHByb3hcIjpcIuKJiFwiLFwiYXBwcm94ZXFcIjpcIuKJilwiLFwiQXJpbmdcIjpcIsOFXCIsXCJhcmluZ1wiOlwiw6VcIixcIkFzY3JcIjpcIvCdkpxcIixcImFzY3JcIjpcIvCdkrZcIixcIkFzc2lnblwiOlwi4omUXCIsXCJhc3RcIjpcIipcIixcImFzeW1wXCI6XCLiiYhcIixcImFzeW1wZXFcIjpcIuKJjVwiLFwiQXRpbGRlXCI6XCLDg1wiLFwiYXRpbGRlXCI6XCLDo1wiLFwiQXVtbFwiOlwiw4RcIixcImF1bWxcIjpcIsOkXCIsXCJhd2NvbmludFwiOlwi4oizXCIsXCJhd2ludFwiOlwi4qiRXCIsXCJiYWNrY29uZ1wiOlwi4omMXCIsXCJiYWNrZXBzaWxvblwiOlwiz7ZcIixcImJhY2twcmltZVwiOlwi4oC1XCIsXCJiYWNrc2ltXCI6XCLiiL1cIixcImJhY2tzaW1lcVwiOlwi4ouNXCIsXCJCYWNrc2xhc2hcIjpcIuKIllwiLFwiQmFydlwiOlwi4qunXCIsXCJiYXJ2ZWVcIjpcIuKKvVwiLFwiYmFyd2VkXCI6XCLijIVcIixcIkJhcndlZFwiOlwi4oyGXCIsXCJiYXJ3ZWRnZVwiOlwi4oyFXCIsXCJiYnJrXCI6XCLijrVcIixcImJicmt0YnJrXCI6XCLijrZcIixcImJjb25nXCI6XCLiiYxcIixcIkJjeVwiOlwi0JFcIixcImJjeVwiOlwi0LFcIixcImJkcXVvXCI6XCLigJ5cIixcImJlY2F1c1wiOlwi4oi1XCIsXCJiZWNhdXNlXCI6XCLiiLVcIixcIkJlY2F1c2VcIjpcIuKItVwiLFwiYmVtcHR5dlwiOlwi4qawXCIsXCJiZXBzaVwiOlwiz7ZcIixcImJlcm5vdVwiOlwi4oSsXCIsXCJCZXJub3VsbGlzXCI6XCLihKxcIixcIkJldGFcIjpcIs6SXCIsXCJiZXRhXCI6XCLOslwiLFwiYmV0aFwiOlwi4oS2XCIsXCJiZXR3ZWVuXCI6XCLiiaxcIixcIkJmclwiOlwi8J2UhVwiLFwiYmZyXCI6XCLwnZSfXCIsXCJiaWdjYXBcIjpcIuKLglwiLFwiYmlnY2lyY1wiOlwi4pevXCIsXCJiaWdjdXBcIjpcIuKLg1wiLFwiYmlnb2RvdFwiOlwi4qiAXCIsXCJiaWdvcGx1c1wiOlwi4qiBXCIsXCJiaWdvdGltZXNcIjpcIuKoglwiLFwiYmlnc3FjdXBcIjpcIuKohlwiLFwiYmlnc3RhclwiOlwi4piFXCIsXCJiaWd0cmlhbmdsZWRvd25cIjpcIuKWvVwiLFwiYmlndHJpYW5nbGV1cFwiOlwi4pazXCIsXCJiaWd1cGx1c1wiOlwi4qiEXCIsXCJiaWd2ZWVcIjpcIuKLgVwiLFwiYmlnd2VkZ2VcIjpcIuKLgFwiLFwiYmthcm93XCI6XCLipI1cIixcImJsYWNrbG96ZW5nZVwiOlwi4qerXCIsXCJibGFja3NxdWFyZVwiOlwi4paqXCIsXCJibGFja3RyaWFuZ2xlXCI6XCLilrRcIixcImJsYWNrdHJpYW5nbGVkb3duXCI6XCLilr5cIixcImJsYWNrdHJpYW5nbGVsZWZ0XCI6XCLil4JcIixcImJsYWNrdHJpYW5nbGVyaWdodFwiOlwi4pa4XCIsXCJibGFua1wiOlwi4pCjXCIsXCJibGsxMlwiOlwi4paSXCIsXCJibGsxNFwiOlwi4paRXCIsXCJibGszNFwiOlwi4paTXCIsXCJibG9ja1wiOlwi4paIXCIsXCJibmVcIjpcIj3ig6VcIixcImJuZXF1aXZcIjpcIuKJoeKDpVwiLFwiYk5vdFwiOlwi4qutXCIsXCJibm90XCI6XCLijJBcIixcIkJvcGZcIjpcIvCdlLlcIixcImJvcGZcIjpcIvCdlZNcIixcImJvdFwiOlwi4oqlXCIsXCJib3R0b21cIjpcIuKKpVwiLFwiYm93dGllXCI6XCLii4hcIixcImJveGJveFwiOlwi4qeJXCIsXCJib3hkbFwiOlwi4pSQXCIsXCJib3hkTFwiOlwi4pWVXCIsXCJib3hEbFwiOlwi4pWWXCIsXCJib3hETFwiOlwi4pWXXCIsXCJib3hkclwiOlwi4pSMXCIsXCJib3hkUlwiOlwi4pWSXCIsXCJib3hEclwiOlwi4pWTXCIsXCJib3hEUlwiOlwi4pWUXCIsXCJib3hoXCI6XCLilIBcIixcImJveEhcIjpcIuKVkFwiLFwiYm94aGRcIjpcIuKUrFwiLFwiYm94SGRcIjpcIuKVpFwiLFwiYm94aERcIjpcIuKVpVwiLFwiYm94SERcIjpcIuKVplwiLFwiYm94aHVcIjpcIuKUtFwiLFwiYm94SHVcIjpcIuKVp1wiLFwiYm94aFVcIjpcIuKVqFwiLFwiYm94SFVcIjpcIuKVqVwiLFwiYm94bWludXNcIjpcIuKKn1wiLFwiYm94cGx1c1wiOlwi4oqeXCIsXCJib3h0aW1lc1wiOlwi4oqgXCIsXCJib3h1bFwiOlwi4pSYXCIsXCJib3h1TFwiOlwi4pWbXCIsXCJib3hVbFwiOlwi4pWcXCIsXCJib3hVTFwiOlwi4pWdXCIsXCJib3h1clwiOlwi4pSUXCIsXCJib3h1UlwiOlwi4pWYXCIsXCJib3hVclwiOlwi4pWZXCIsXCJib3hVUlwiOlwi4pWaXCIsXCJib3h2XCI6XCLilIJcIixcImJveFZcIjpcIuKVkVwiLFwiYm94dmhcIjpcIuKUvFwiLFwiYm94dkhcIjpcIuKVqlwiLFwiYm94VmhcIjpcIuKVq1wiLFwiYm94VkhcIjpcIuKVrFwiLFwiYm94dmxcIjpcIuKUpFwiLFwiYm94dkxcIjpcIuKVoVwiLFwiYm94VmxcIjpcIuKVolwiLFwiYm94VkxcIjpcIuKVo1wiLFwiYm94dnJcIjpcIuKUnFwiLFwiYm94dlJcIjpcIuKVnlwiLFwiYm94VnJcIjpcIuKVn1wiLFwiYm94VlJcIjpcIuKVoFwiLFwiYnByaW1lXCI6XCLigLVcIixcImJyZXZlXCI6XCLLmFwiLFwiQnJldmVcIjpcIsuYXCIsXCJicnZiYXJcIjpcIsKmXCIsXCJic2NyXCI6XCLwnZK3XCIsXCJCc2NyXCI6XCLihKxcIixcImJzZW1pXCI6XCLigY9cIixcImJzaW1cIjpcIuKIvVwiLFwiYnNpbWVcIjpcIuKLjVwiLFwiYnNvbGJcIjpcIuKnhVwiLFwiYnNvbFwiOlwiXFxcXFwiLFwiYnNvbGhzdWJcIjpcIuKfiFwiLFwiYnVsbFwiOlwi4oCiXCIsXCJidWxsZXRcIjpcIuKAolwiLFwiYnVtcFwiOlwi4omOXCIsXCJidW1wRVwiOlwi4qquXCIsXCJidW1wZVwiOlwi4omPXCIsXCJCdW1wZXFcIjpcIuKJjlwiLFwiYnVtcGVxXCI6XCLiiY9cIixcIkNhY3V0ZVwiOlwixIZcIixcImNhY3V0ZVwiOlwixIdcIixcImNhcGFuZFwiOlwi4qmEXCIsXCJjYXBicmN1cFwiOlwi4qmJXCIsXCJjYXBjYXBcIjpcIuKpi1wiLFwiY2FwXCI6XCLiiKlcIixcIkNhcFwiOlwi4ouSXCIsXCJjYXBjdXBcIjpcIuKph1wiLFwiY2FwZG90XCI6XCLiqYBcIixcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6XCLihYVcIixcImNhcHNcIjpcIuKIqe+4gFwiLFwiY2FyZXRcIjpcIuKBgVwiLFwiY2Fyb25cIjpcIsuHXCIsXCJDYXlsZXlzXCI6XCLihK1cIixcImNjYXBzXCI6XCLiqY1cIixcIkNjYXJvblwiOlwixIxcIixcImNjYXJvblwiOlwixI1cIixcIkNjZWRpbFwiOlwiw4dcIixcImNjZWRpbFwiOlwiw6dcIixcIkNjaXJjXCI6XCLEiFwiLFwiY2NpcmNcIjpcIsSJXCIsXCJDY29uaW50XCI6XCLiiLBcIixcImNjdXBzXCI6XCLiqYxcIixcImNjdXBzc21cIjpcIuKpkFwiLFwiQ2RvdFwiOlwixIpcIixcImNkb3RcIjpcIsSLXCIsXCJjZWRpbFwiOlwiwrhcIixcIkNlZGlsbGFcIjpcIsK4XCIsXCJjZW1wdHl2XCI6XCLiprJcIixcImNlbnRcIjpcIsKiXCIsXCJjZW50ZXJkb3RcIjpcIsK3XCIsXCJDZW50ZXJEb3RcIjpcIsK3XCIsXCJjZnJcIjpcIvCdlKBcIixcIkNmclwiOlwi4oStXCIsXCJDSGN5XCI6XCLQp1wiLFwiY2hjeVwiOlwi0YdcIixcImNoZWNrXCI6XCLinJNcIixcImNoZWNrbWFya1wiOlwi4pyTXCIsXCJDaGlcIjpcIs6nXCIsXCJjaGlcIjpcIs+HXCIsXCJjaXJjXCI6XCLLhlwiLFwiY2lyY2VxXCI6XCLiiZdcIixcImNpcmNsZWFycm93bGVmdFwiOlwi4oa6XCIsXCJjaXJjbGVhcnJvd3JpZ2h0XCI6XCLihrtcIixcImNpcmNsZWRhc3RcIjpcIuKKm1wiLFwiY2lyY2xlZGNpcmNcIjpcIuKKmlwiLFwiY2lyY2xlZGRhc2hcIjpcIuKKnVwiLFwiQ2lyY2xlRG90XCI6XCLiiplcIixcImNpcmNsZWRSXCI6XCLCrlwiLFwiY2lyY2xlZFNcIjpcIuKTiFwiLFwiQ2lyY2xlTWludXNcIjpcIuKKllwiLFwiQ2lyY2xlUGx1c1wiOlwi4oqVXCIsXCJDaXJjbGVUaW1lc1wiOlwi4oqXXCIsXCJjaXJcIjpcIuKXi1wiLFwiY2lyRVwiOlwi4qeDXCIsXCJjaXJlXCI6XCLiiZdcIixcImNpcmZuaW50XCI6XCLiqJBcIixcImNpcm1pZFwiOlwi4quvXCIsXCJjaXJzY2lyXCI6XCLip4JcIixcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiyXCIsXCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnVwiLFwiQ2xvc2VDdXJseVF1b3RlXCI6XCLigJlcIixcImNsdWJzXCI6XCLimaNcIixcImNsdWJzdWl0XCI6XCLimaNcIixcImNvbG9uXCI6XCI6XCIsXCJDb2xvblwiOlwi4oi3XCIsXCJDb2xvbmVcIjpcIuKptFwiLFwiY29sb25lXCI6XCLiiZRcIixcImNvbG9uZXFcIjpcIuKJlFwiLFwiY29tbWFcIjpcIixcIixcImNvbW1hdFwiOlwiQFwiLFwiY29tcFwiOlwi4oiBXCIsXCJjb21wZm5cIjpcIuKImFwiLFwiY29tcGxlbWVudFwiOlwi4oiBXCIsXCJjb21wbGV4ZXNcIjpcIuKEglwiLFwiY29uZ1wiOlwi4omFXCIsXCJjb25nZG90XCI6XCLiqa1cIixcIkNvbmdydWVudFwiOlwi4omhXCIsXCJjb25pbnRcIjpcIuKIrlwiLFwiQ29uaW50XCI6XCLiiK9cIixcIkNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiuXCIsXCJjb3BmXCI6XCLwnZWUXCIsXCJDb3BmXCI6XCLihIJcIixcImNvcHJvZFwiOlwi4oiQXCIsXCJDb3Byb2R1Y3RcIjpcIuKIkFwiLFwiY29weVwiOlwiwqlcIixcIkNPUFlcIjpcIsKpXCIsXCJjb3B5c3JcIjpcIuKEl1wiLFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oizXCIsXCJjcmFyclwiOlwi4oa1XCIsXCJjcm9zc1wiOlwi4pyXXCIsXCJDcm9zc1wiOlwi4qivXCIsXCJDc2NyXCI6XCLwnZKeXCIsXCJjc2NyXCI6XCLwnZK4XCIsXCJjc3ViXCI6XCLiq49cIixcImNzdWJlXCI6XCLiq5FcIixcImNzdXBcIjpcIuKrkFwiLFwiY3N1cGVcIjpcIuKrklwiLFwiY3Rkb3RcIjpcIuKLr1wiLFwiY3VkYXJybFwiOlwi4qS4XCIsXCJjdWRhcnJyXCI6XCLipLVcIixcImN1ZXByXCI6XCLii55cIixcImN1ZXNjXCI6XCLii59cIixcImN1bGFyclwiOlwi4oa2XCIsXCJjdWxhcnJwXCI6XCLipL1cIixcImN1cGJyY2FwXCI6XCLiqYhcIixcImN1cGNhcFwiOlwi4qmGXCIsXCJDdXBDYXBcIjpcIuKJjVwiLFwiY3VwXCI6XCLiiKpcIixcIkN1cFwiOlwi4ouTXCIsXCJjdXBjdXBcIjpcIuKpilwiLFwiY3VwZG90XCI6XCLiio1cIixcImN1cG9yXCI6XCLiqYVcIixcImN1cHNcIjpcIuKIqu+4gFwiLFwiY3VyYXJyXCI6XCLihrdcIixcImN1cmFycm1cIjpcIuKkvFwiLFwiY3VybHllcXByZWNcIjpcIuKLnlwiLFwiY3VybHllcXN1Y2NcIjpcIuKLn1wiLFwiY3VybHl2ZWVcIjpcIuKLjlwiLFwiY3VybHl3ZWRnZVwiOlwi4ouPXCIsXCJjdXJyZW5cIjpcIsKkXCIsXCJjdXJ2ZWFycm93bGVmdFwiOlwi4oa2XCIsXCJjdXJ2ZWFycm93cmlnaHRcIjpcIuKGt1wiLFwiY3V2ZWVcIjpcIuKLjlwiLFwiY3V3ZWRcIjpcIuKLj1wiLFwiY3djb25pbnRcIjpcIuKIslwiLFwiY3dpbnRcIjpcIuKIsVwiLFwiY3lsY3R5XCI6XCLijK1cIixcImRhZ2dlclwiOlwi4oCgXCIsXCJEYWdnZXJcIjpcIuKAoVwiLFwiZGFsZXRoXCI6XCLihLhcIixcImRhcnJcIjpcIuKGk1wiLFwiRGFyclwiOlwi4oahXCIsXCJkQXJyXCI6XCLih5NcIixcImRhc2hcIjpcIuKAkFwiLFwiRGFzaHZcIjpcIuKrpFwiLFwiZGFzaHZcIjpcIuKKo1wiLFwiZGJrYXJvd1wiOlwi4qSPXCIsXCJkYmxhY1wiOlwiy51cIixcIkRjYXJvblwiOlwixI5cIixcImRjYXJvblwiOlwixI9cIixcIkRjeVwiOlwi0JRcIixcImRjeVwiOlwi0LRcIixcImRkYWdnZXJcIjpcIuKAoVwiLFwiZGRhcnJcIjpcIuKHilwiLFwiRERcIjpcIuKFhVwiLFwiZGRcIjpcIuKFhlwiLFwiRERvdHJhaGRcIjpcIuKkkVwiLFwiZGRvdHNlcVwiOlwi4qm3XCIsXCJkZWdcIjpcIsKwXCIsXCJEZWxcIjpcIuKIh1wiLFwiRGVsdGFcIjpcIs6UXCIsXCJkZWx0YVwiOlwizrRcIixcImRlbXB0eXZcIjpcIuKmsVwiLFwiZGZpc2h0XCI6XCLipb9cIixcIkRmclwiOlwi8J2Uh1wiLFwiZGZyXCI6XCLwnZShXCIsXCJkSGFyXCI6XCLipaVcIixcImRoYXJsXCI6XCLih4NcIixcImRoYXJyXCI6XCLih4JcIixcIkRpYWNyaXRpY2FsQWN1dGVcIjpcIsK0XCIsXCJEaWFjcml0aWNhbERvdFwiOlwiy5lcIixcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjpcIsudXCIsXCJEaWFjcml0aWNhbEdyYXZlXCI6XCJgXCIsXCJEaWFjcml0aWNhbFRpbGRlXCI6XCLLnFwiLFwiZGlhbVwiOlwi4ouEXCIsXCJkaWFtb25kXCI6XCLii4RcIixcIkRpYW1vbmRcIjpcIuKLhFwiLFwiZGlhbW9uZHN1aXRcIjpcIuKZplwiLFwiZGlhbXNcIjpcIuKZplwiLFwiZGllXCI6XCLCqFwiLFwiRGlmZmVyZW50aWFsRFwiOlwi4oWGXCIsXCJkaWdhbW1hXCI6XCLPnVwiLFwiZGlzaW5cIjpcIuKLslwiLFwiZGl2XCI6XCLDt1wiLFwiZGl2aWRlXCI6XCLDt1wiLFwiZGl2aWRlb250aW1lc1wiOlwi4ouHXCIsXCJkaXZvbnhcIjpcIuKLh1wiLFwiREpjeVwiOlwi0IJcIixcImRqY3lcIjpcItGSXCIsXCJkbGNvcm5cIjpcIuKMnlwiLFwiZGxjcm9wXCI6XCLijI1cIixcImRvbGxhclwiOlwiJFwiLFwiRG9wZlwiOlwi8J2Uu1wiLFwiZG9wZlwiOlwi8J2VlVwiLFwiRG90XCI6XCLCqFwiLFwiZG90XCI6XCLLmVwiLFwiRG90RG90XCI6XCLig5xcIixcImRvdGVxXCI6XCLiiZBcIixcImRvdGVxZG90XCI6XCLiiZFcIixcIkRvdEVxdWFsXCI6XCLiiZBcIixcImRvdG1pbnVzXCI6XCLiiLhcIixcImRvdHBsdXNcIjpcIuKIlFwiLFwiZG90c3F1YXJlXCI6XCLiiqFcIixcImRvdWJsZWJhcndlZGdlXCI6XCLijIZcIixcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oivXCIsXCJEb3VibGVEb3RcIjpcIsKoXCIsXCJEb3VibGVEb3duQXJyb3dcIjpcIuKHk1wiLFwiRG91YmxlTGVmdEFycm93XCI6XCLih5BcIixcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6XCLih5RcIixcIkRvdWJsZUxlZnRUZWVcIjpcIuKrpFwiLFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOlwi4p+4XCIsXCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKfulwiLFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjpcIuKfuVwiLFwiRG91YmxlUmlnaHRBcnJvd1wiOlwi4oeSXCIsXCJEb3VibGVSaWdodFRlZVwiOlwi4oqoXCIsXCJEb3VibGVVcEFycm93XCI6XCLih5FcIixcIkRvdWJsZVVwRG93bkFycm93XCI6XCLih5VcIixcIkRvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKVcIixcIkRvd25BcnJvd0JhclwiOlwi4qSTXCIsXCJkb3duYXJyb3dcIjpcIuKGk1wiLFwiRG93bkFycm93XCI6XCLihpNcIixcIkRvd25hcnJvd1wiOlwi4oeTXCIsXCJEb3duQXJyb3dVcEFycm93XCI6XCLih7VcIixcIkRvd25CcmV2ZVwiOlwizJFcIixcImRvd25kb3duYXJyb3dzXCI6XCLih4pcIixcImRvd25oYXJwb29ubGVmdFwiOlwi4oeDXCIsXCJkb3duaGFycG9vbnJpZ2h0XCI6XCLih4JcIixcIkRvd25MZWZ0UmlnaHRWZWN0b3JcIjpcIuKlkFwiLFwiRG93bkxlZnRUZWVWZWN0b3JcIjpcIuKlnlwiLFwiRG93bkxlZnRWZWN0b3JCYXJcIjpcIuKlllwiLFwiRG93bkxlZnRWZWN0b3JcIjpcIuKGvVwiLFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6XCLipZ9cIixcIkRvd25SaWdodFZlY3RvckJhclwiOlwi4qWXXCIsXCJEb3duUmlnaHRWZWN0b3JcIjpcIuKHgVwiLFwiRG93blRlZUFycm93XCI6XCLihqdcIixcIkRvd25UZWVcIjpcIuKKpFwiLFwiZHJia2Fyb3dcIjpcIuKkkFwiLFwiZHJjb3JuXCI6XCLijJ9cIixcImRyY3JvcFwiOlwi4oyMXCIsXCJEc2NyXCI6XCLwnZKfXCIsXCJkc2NyXCI6XCLwnZK5XCIsXCJEU2N5XCI6XCLQhVwiLFwiZHNjeVwiOlwi0ZVcIixcImRzb2xcIjpcIuKntlwiLFwiRHN0cm9rXCI6XCLEkFwiLFwiZHN0cm9rXCI6XCLEkVwiLFwiZHRkb3RcIjpcIuKLsVwiLFwiZHRyaVwiOlwi4pa/XCIsXCJkdHJpZlwiOlwi4pa+XCIsXCJkdWFyclwiOlwi4oe1XCIsXCJkdWhhclwiOlwi4qWvXCIsXCJkd2FuZ2xlXCI6XCLipqZcIixcIkRaY3lcIjpcItCPXCIsXCJkemN5XCI6XCLRn1wiLFwiZHppZ3JhcnJcIjpcIuKfv1wiLFwiRWFjdXRlXCI6XCLDiVwiLFwiZWFjdXRlXCI6XCLDqVwiLFwiZWFzdGVyXCI6XCLiqa5cIixcIkVjYXJvblwiOlwixJpcIixcImVjYXJvblwiOlwixJtcIixcIkVjaXJjXCI6XCLDilwiLFwiZWNpcmNcIjpcIsOqXCIsXCJlY2lyXCI6XCLiiZZcIixcImVjb2xvblwiOlwi4omVXCIsXCJFY3lcIjpcItCtXCIsXCJlY3lcIjpcItGNXCIsXCJlRERvdFwiOlwi4qm3XCIsXCJFZG90XCI6XCLEllwiLFwiZWRvdFwiOlwixJdcIixcImVEb3RcIjpcIuKJkVwiLFwiZWVcIjpcIuKFh1wiLFwiZWZEb3RcIjpcIuKJklwiLFwiRWZyXCI6XCLwnZSIXCIsXCJlZnJcIjpcIvCdlKJcIixcImVnXCI6XCLiqppcIixcIkVncmF2ZVwiOlwiw4hcIixcImVncmF2ZVwiOlwiw6hcIixcImVnc1wiOlwi4qqWXCIsXCJlZ3Nkb3RcIjpcIuKqmFwiLFwiZWxcIjpcIuKqmVwiLFwiRWxlbWVudFwiOlwi4oiIXCIsXCJlbGludGVyc1wiOlwi4o+nXCIsXCJlbGxcIjpcIuKEk1wiLFwiZWxzXCI6XCLiqpVcIixcImVsc2RvdFwiOlwi4qqXXCIsXCJFbWFjclwiOlwixJJcIixcImVtYWNyXCI6XCLEk1wiLFwiZW1wdHlcIjpcIuKIhVwiLFwiZW1wdHlzZXRcIjpcIuKIhVwiLFwiRW1wdHlTbWFsbFNxdWFyZVwiOlwi4pe7XCIsXCJlbXB0eXZcIjpcIuKIhVwiLFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjpcIuKWq1wiLFwiZW1zcDEzXCI6XCLigIRcIixcImVtc3AxNFwiOlwi4oCFXCIsXCJlbXNwXCI6XCLigINcIixcIkVOR1wiOlwixYpcIixcImVuZ1wiOlwixYtcIixcImVuc3BcIjpcIuKAglwiLFwiRW9nb25cIjpcIsSYXCIsXCJlb2dvblwiOlwixJlcIixcIkVvcGZcIjpcIvCdlLxcIixcImVvcGZcIjpcIvCdlZZcIixcImVwYXJcIjpcIuKLlVwiLFwiZXBhcnNsXCI6XCLip6NcIixcImVwbHVzXCI6XCLiqbFcIixcImVwc2lcIjpcIs61XCIsXCJFcHNpbG9uXCI6XCLOlVwiLFwiZXBzaWxvblwiOlwizrVcIixcImVwc2l2XCI6XCLPtVwiLFwiZXFjaXJjXCI6XCLiiZZcIixcImVxY29sb25cIjpcIuKJlVwiLFwiZXFzaW1cIjpcIuKJglwiLFwiZXFzbGFudGd0clwiOlwi4qqWXCIsXCJlcXNsYW50bGVzc1wiOlwi4qqVXCIsXCJFcXVhbFwiOlwi4qm1XCIsXCJlcXVhbHNcIjpcIj1cIixcIkVxdWFsVGlsZGVcIjpcIuKJglwiLFwiZXF1ZXN0XCI6XCLiiZ9cIixcIkVxdWlsaWJyaXVtXCI6XCLih4xcIixcImVxdWl2XCI6XCLiiaFcIixcImVxdWl2RERcIjpcIuKpuFwiLFwiZXF2cGFyc2xcIjpcIuKnpVwiLFwiZXJhcnJcIjpcIuKlsVwiLFwiZXJEb3RcIjpcIuKJk1wiLFwiZXNjclwiOlwi4oSvXCIsXCJFc2NyXCI6XCLihLBcIixcImVzZG90XCI6XCLiiZBcIixcIkVzaW1cIjpcIuKps1wiLFwiZXNpbVwiOlwi4omCXCIsXCJFdGFcIjpcIs6XXCIsXCJldGFcIjpcIs63XCIsXCJFVEhcIjpcIsOQXCIsXCJldGhcIjpcIsOwXCIsXCJFdW1sXCI6XCLDi1wiLFwiZXVtbFwiOlwiw6tcIixcImV1cm9cIjpcIuKCrFwiLFwiZXhjbFwiOlwiIVwiLFwiZXhpc3RcIjpcIuKIg1wiLFwiRXhpc3RzXCI6XCLiiINcIixcImV4cGVjdGF0aW9uXCI6XCLihLBcIixcImV4cG9uZW50aWFsZVwiOlwi4oWHXCIsXCJFeHBvbmVudGlhbEVcIjpcIuKFh1wiLFwiZmFsbGluZ2RvdHNlcVwiOlwi4omSXCIsXCJGY3lcIjpcItCkXCIsXCJmY3lcIjpcItGEXCIsXCJmZW1hbGVcIjpcIuKZgFwiLFwiZmZpbGlnXCI6XCLvrINcIixcImZmbGlnXCI6XCLvrIBcIixcImZmbGxpZ1wiOlwi76yEXCIsXCJGZnJcIjpcIvCdlIlcIixcImZmclwiOlwi8J2Uo1wiLFwiZmlsaWdcIjpcIu+sgVwiLFwiRmlsbGVkU21hbGxTcXVhcmVcIjpcIuKXvFwiLFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6XCLilqpcIixcImZqbGlnXCI6XCJmalwiLFwiZmxhdFwiOlwi4pmtXCIsXCJmbGxpZ1wiOlwi76yCXCIsXCJmbHRuc1wiOlwi4paxXCIsXCJmbm9mXCI6XCLGklwiLFwiRm9wZlwiOlwi8J2UvVwiLFwiZm9wZlwiOlwi8J2Vl1wiLFwiZm9yYWxsXCI6XCLiiIBcIixcIkZvckFsbFwiOlwi4oiAXCIsXCJmb3JrXCI6XCLii5RcIixcImZvcmt2XCI6XCLiq5lcIixcIkZvdXJpZXJ0cmZcIjpcIuKEsVwiLFwiZnBhcnRpbnRcIjpcIuKojVwiLFwiZnJhYzEyXCI6XCLCvVwiLFwiZnJhYzEzXCI6XCLihZNcIixcImZyYWMxNFwiOlwiwrxcIixcImZyYWMxNVwiOlwi4oWVXCIsXCJmcmFjMTZcIjpcIuKFmVwiLFwiZnJhYzE4XCI6XCLihZtcIixcImZyYWMyM1wiOlwi4oWUXCIsXCJmcmFjMjVcIjpcIuKFllwiLFwiZnJhYzM0XCI6XCLCvlwiLFwiZnJhYzM1XCI6XCLihZdcIixcImZyYWMzOFwiOlwi4oWcXCIsXCJmcmFjNDVcIjpcIuKFmFwiLFwiZnJhYzU2XCI6XCLihZpcIixcImZyYWM1OFwiOlwi4oWdXCIsXCJmcmFjNzhcIjpcIuKFnlwiLFwiZnJhc2xcIjpcIuKBhFwiLFwiZnJvd25cIjpcIuKMolwiLFwiZnNjclwiOlwi8J2Su1wiLFwiRnNjclwiOlwi4oSxXCIsXCJnYWN1dGVcIjpcIse1XCIsXCJHYW1tYVwiOlwizpNcIixcImdhbW1hXCI6XCLOs1wiLFwiR2FtbWFkXCI6XCLPnFwiLFwiZ2FtbWFkXCI6XCLPnVwiLFwiZ2FwXCI6XCLiqoZcIixcIkdicmV2ZVwiOlwixJ5cIixcImdicmV2ZVwiOlwixJ9cIixcIkdjZWRpbFwiOlwixKJcIixcIkdjaXJjXCI6XCLEnFwiLFwiZ2NpcmNcIjpcIsSdXCIsXCJHY3lcIjpcItCTXCIsXCJnY3lcIjpcItCzXCIsXCJHZG90XCI6XCLEoFwiLFwiZ2RvdFwiOlwixKFcIixcImdlXCI6XCLiiaVcIixcImdFXCI6XCLiiadcIixcImdFbFwiOlwi4qqMXCIsXCJnZWxcIjpcIuKLm1wiLFwiZ2VxXCI6XCLiiaVcIixcImdlcXFcIjpcIuKJp1wiLFwiZ2Vxc2xhbnRcIjpcIuKpvlwiLFwiZ2VzY2NcIjpcIuKqqVwiLFwiZ2VzXCI6XCLiqb5cIixcImdlc2RvdFwiOlwi4qqAXCIsXCJnZXNkb3RvXCI6XCLiqoJcIixcImdlc2RvdG9sXCI6XCLiqoRcIixcImdlc2xcIjpcIuKLm++4gFwiLFwiZ2VzbGVzXCI6XCLiqpRcIixcIkdmclwiOlwi8J2UilwiLFwiZ2ZyXCI6XCLwnZSkXCIsXCJnZ1wiOlwi4omrXCIsXCJHZ1wiOlwi4ouZXCIsXCJnZ2dcIjpcIuKLmVwiLFwiZ2ltZWxcIjpcIuKEt1wiLFwiR0pjeVwiOlwi0INcIixcImdqY3lcIjpcItGTXCIsXCJnbGFcIjpcIuKqpVwiLFwiZ2xcIjpcIuKJt1wiLFwiZ2xFXCI6XCLiqpJcIixcImdsalwiOlwi4qqkXCIsXCJnbmFwXCI6XCLiqopcIixcImduYXBwcm94XCI6XCLiqopcIixcImduZVwiOlwi4qqIXCIsXCJnbkVcIjpcIuKJqVwiLFwiZ25lcVwiOlwi4qqIXCIsXCJnbmVxcVwiOlwi4ompXCIsXCJnbnNpbVwiOlwi4ounXCIsXCJHb3BmXCI6XCLwnZS+XCIsXCJnb3BmXCI6XCLwnZWYXCIsXCJncmF2ZVwiOlwiYFwiLFwiR3JlYXRlckVxdWFsXCI6XCLiiaVcIixcIkdyZWF0ZXJFcXVhbExlc3NcIjpcIuKLm1wiLFwiR3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnXCIsXCJHcmVhdGVyR3JlYXRlclwiOlwi4qqiXCIsXCJHcmVhdGVyTGVzc1wiOlwi4om3XCIsXCJHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+XCIsXCJHcmVhdGVyVGlsZGVcIjpcIuKJs1wiLFwiR3NjclwiOlwi8J2SolwiLFwiZ3NjclwiOlwi4oSKXCIsXCJnc2ltXCI6XCLiibNcIixcImdzaW1lXCI6XCLiqo5cIixcImdzaW1sXCI6XCLiqpBcIixcImd0Y2NcIjpcIuKqp1wiLFwiZ3RjaXJcIjpcIuKpulwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJHdFwiOlwi4omrXCIsXCJndGRvdFwiOlwi4ouXXCIsXCJndGxQYXJcIjpcIuKmlVwiLFwiZ3RxdWVzdFwiOlwi4qm8XCIsXCJndHJhcHByb3hcIjpcIuKqhlwiLFwiZ3RyYXJyXCI6XCLipbhcIixcImd0cmRvdFwiOlwi4ouXXCIsXCJndHJlcWxlc3NcIjpcIuKLm1wiLFwiZ3RyZXFxbGVzc1wiOlwi4qqMXCIsXCJndHJsZXNzXCI6XCLiibdcIixcImd0cnNpbVwiOlwi4omzXCIsXCJndmVydG5lcXFcIjpcIuKJqe+4gFwiLFwiZ3ZuRVwiOlwi4omp77iAXCIsXCJIYWNla1wiOlwiy4dcIixcImhhaXJzcFwiOlwi4oCKXCIsXCJoYWxmXCI6XCLCvVwiLFwiaGFtaWx0XCI6XCLihItcIixcIkhBUkRjeVwiOlwi0KpcIixcImhhcmRjeVwiOlwi0YpcIixcImhhcnJjaXJcIjpcIuKliFwiLFwiaGFyclwiOlwi4oaUXCIsXCJoQXJyXCI6XCLih5RcIixcImhhcnJ3XCI6XCLihq1cIixcIkhhdFwiOlwiXlwiLFwiaGJhclwiOlwi4oSPXCIsXCJIY2lyY1wiOlwixKRcIixcImhjaXJjXCI6XCLEpVwiLFwiaGVhcnRzXCI6XCLimaVcIixcImhlYXJ0c3VpdFwiOlwi4pmlXCIsXCJoZWxsaXBcIjpcIuKAplwiLFwiaGVyY29uXCI6XCLiirlcIixcImhmclwiOlwi8J2UpVwiLFwiSGZyXCI6XCLihIxcIixcIkhpbGJlcnRTcGFjZVwiOlwi4oSLXCIsXCJoa3NlYXJvd1wiOlwi4qSlXCIsXCJoa3N3YXJvd1wiOlwi4qSmXCIsXCJob2FyclwiOlwi4oe/XCIsXCJob210aHRcIjpcIuKIu1wiLFwiaG9va2xlZnRhcnJvd1wiOlwi4oapXCIsXCJob29rcmlnaHRhcnJvd1wiOlwi4oaqXCIsXCJob3BmXCI6XCLwnZWZXCIsXCJIb3BmXCI6XCLihI1cIixcImhvcmJhclwiOlwi4oCVXCIsXCJIb3Jpem9udGFsTGluZVwiOlwi4pSAXCIsXCJoc2NyXCI6XCLwnZK9XCIsXCJIc2NyXCI6XCLihItcIixcImhzbGFzaFwiOlwi4oSPXCIsXCJIc3Ryb2tcIjpcIsSmXCIsXCJoc3Ryb2tcIjpcIsSnXCIsXCJIdW1wRG93bkh1bXBcIjpcIuKJjlwiLFwiSHVtcEVxdWFsXCI6XCLiiY9cIixcImh5YnVsbFwiOlwi4oGDXCIsXCJoeXBoZW5cIjpcIuKAkFwiLFwiSWFjdXRlXCI6XCLDjVwiLFwiaWFjdXRlXCI6XCLDrVwiLFwiaWNcIjpcIuKBo1wiLFwiSWNpcmNcIjpcIsOOXCIsXCJpY2lyY1wiOlwiw65cIixcIkljeVwiOlwi0JhcIixcImljeVwiOlwi0LhcIixcIklkb3RcIjpcIsSwXCIsXCJJRWN5XCI6XCLQlVwiLFwiaWVjeVwiOlwi0LVcIixcImlleGNsXCI6XCLCoVwiLFwiaWZmXCI6XCLih5RcIixcImlmclwiOlwi8J2UplwiLFwiSWZyXCI6XCLihJFcIixcIklncmF2ZVwiOlwiw4xcIixcImlncmF2ZVwiOlwiw6xcIixcImlpXCI6XCLihYhcIixcImlpaWludFwiOlwi4qiMXCIsXCJpaWludFwiOlwi4oitXCIsXCJpaW5maW5cIjpcIuKnnFwiLFwiaWlvdGFcIjpcIuKEqVwiLFwiSUpsaWdcIjpcIsSyXCIsXCJpamxpZ1wiOlwixLNcIixcIkltYWNyXCI6XCLEqlwiLFwiaW1hY3JcIjpcIsSrXCIsXCJpbWFnZVwiOlwi4oSRXCIsXCJJbWFnaW5hcnlJXCI6XCLihYhcIixcImltYWdsaW5lXCI6XCLihJBcIixcImltYWdwYXJ0XCI6XCLihJFcIixcImltYXRoXCI6XCLEsVwiLFwiSW1cIjpcIuKEkVwiLFwiaW1vZlwiOlwi4oq3XCIsXCJpbXBlZFwiOlwixrVcIixcIkltcGxpZXNcIjpcIuKHklwiLFwiaW5jYXJlXCI6XCLihIVcIixcImluXCI6XCLiiIhcIixcImluZmluXCI6XCLiiJ5cIixcImluZmludGllXCI6XCLip51cIixcImlub2RvdFwiOlwixLFcIixcImludGNhbFwiOlwi4oq6XCIsXCJpbnRcIjpcIuKIq1wiLFwiSW50XCI6XCLiiKxcIixcImludGVnZXJzXCI6XCLihKRcIixcIkludGVncmFsXCI6XCLiiKtcIixcImludGVyY2FsXCI6XCLiirpcIixcIkludGVyc2VjdGlvblwiOlwi4ouCXCIsXCJpbnRsYXJoa1wiOlwi4qiXXCIsXCJpbnRwcm9kXCI6XCLiqLxcIixcIkludmlzaWJsZUNvbW1hXCI6XCLigaNcIixcIkludmlzaWJsZVRpbWVzXCI6XCLigaJcIixcIklPY3lcIjpcItCBXCIsXCJpb2N5XCI6XCLRkVwiLFwiSW9nb25cIjpcIsSuXCIsXCJpb2dvblwiOlwixK9cIixcIklvcGZcIjpcIvCdlYBcIixcImlvcGZcIjpcIvCdlZpcIixcIklvdGFcIjpcIs6ZXCIsXCJpb3RhXCI6XCLOuVwiLFwiaXByb2RcIjpcIuKovFwiLFwiaXF1ZXN0XCI6XCLCv1wiLFwiaXNjclwiOlwi8J2SvlwiLFwiSXNjclwiOlwi4oSQXCIsXCJpc2luXCI6XCLiiIhcIixcImlzaW5kb3RcIjpcIuKLtVwiLFwiaXNpbkVcIjpcIuKLuVwiLFwiaXNpbnNcIjpcIuKLtFwiLFwiaXNpbnN2XCI6XCLii7NcIixcImlzaW52XCI6XCLiiIhcIixcIml0XCI6XCLigaJcIixcIkl0aWxkZVwiOlwixKhcIixcIml0aWxkZVwiOlwixKlcIixcIkl1a2N5XCI6XCLQhlwiLFwiaXVrY3lcIjpcItGWXCIsXCJJdW1sXCI6XCLDj1wiLFwiaXVtbFwiOlwiw69cIixcIkpjaXJjXCI6XCLEtFwiLFwiamNpcmNcIjpcIsS1XCIsXCJKY3lcIjpcItCZXCIsXCJqY3lcIjpcItC5XCIsXCJKZnJcIjpcIvCdlI1cIixcImpmclwiOlwi8J2Up1wiLFwiam1hdGhcIjpcIsi3XCIsXCJKb3BmXCI6XCLwnZWBXCIsXCJqb3BmXCI6XCLwnZWbXCIsXCJKc2NyXCI6XCLwnZKlXCIsXCJqc2NyXCI6XCLwnZK/XCIsXCJKc2VyY3lcIjpcItCIXCIsXCJqc2VyY3lcIjpcItGYXCIsXCJKdWtjeVwiOlwi0IRcIixcImp1a2N5XCI6XCLRlFwiLFwiS2FwcGFcIjpcIs6aXCIsXCJrYXBwYVwiOlwizrpcIixcImthcHBhdlwiOlwiz7BcIixcIktjZWRpbFwiOlwixLZcIixcImtjZWRpbFwiOlwixLdcIixcIktjeVwiOlwi0JpcIixcImtjeVwiOlwi0LpcIixcIktmclwiOlwi8J2UjlwiLFwia2ZyXCI6XCLwnZSoXCIsXCJrZ3JlZW5cIjpcIsS4XCIsXCJLSGN5XCI6XCLQpVwiLFwia2hjeVwiOlwi0YVcIixcIktKY3lcIjpcItCMXCIsXCJramN5XCI6XCLRnFwiLFwiS29wZlwiOlwi8J2VglwiLFwia29wZlwiOlwi8J2VnFwiLFwiS3NjclwiOlwi8J2SplwiLFwia3NjclwiOlwi8J2TgFwiLFwibEFhcnJcIjpcIuKHmlwiLFwiTGFjdXRlXCI6XCLEuVwiLFwibGFjdXRlXCI6XCLEulwiLFwibGFlbXB0eXZcIjpcIuKmtFwiLFwibGFncmFuXCI6XCLihJJcIixcIkxhbWJkYVwiOlwizptcIixcImxhbWJkYVwiOlwizrtcIixcImxhbmdcIjpcIuKfqFwiLFwiTGFuZ1wiOlwi4p+qXCIsXCJsYW5nZFwiOlwi4qaRXCIsXCJsYW5nbGVcIjpcIuKfqFwiLFwibGFwXCI6XCLiqoVcIixcIkxhcGxhY2V0cmZcIjpcIuKEklwiLFwibGFxdW9cIjpcIsKrXCIsXCJsYXJyYlwiOlwi4oekXCIsXCJsYXJyYmZzXCI6XCLipJ9cIixcImxhcnJcIjpcIuKGkFwiLFwiTGFyclwiOlwi4oaeXCIsXCJsQXJyXCI6XCLih5BcIixcImxhcnJmc1wiOlwi4qSdXCIsXCJsYXJyaGtcIjpcIuKGqVwiLFwibGFycmxwXCI6XCLihqtcIixcImxhcnJwbFwiOlwi4qS5XCIsXCJsYXJyc2ltXCI6XCLipbNcIixcImxhcnJ0bFwiOlwi4oaiXCIsXCJsYXRhaWxcIjpcIuKkmVwiLFwibEF0YWlsXCI6XCLipJtcIixcImxhdFwiOlwi4qqrXCIsXCJsYXRlXCI6XCLiqq1cIixcImxhdGVzXCI6XCLiqq3vuIBcIixcImxiYXJyXCI6XCLipIxcIixcImxCYXJyXCI6XCLipI5cIixcImxiYnJrXCI6XCLinbJcIixcImxicmFjZVwiOlwie1wiLFwibGJyYWNrXCI6XCJbXCIsXCJsYnJrZVwiOlwi4qaLXCIsXCJsYnJrc2xkXCI6XCLipo9cIixcImxicmtzbHVcIjpcIuKmjVwiLFwiTGNhcm9uXCI6XCLEvVwiLFwibGNhcm9uXCI6XCLEvlwiLFwiTGNlZGlsXCI6XCLEu1wiLFwibGNlZGlsXCI6XCLEvFwiLFwibGNlaWxcIjpcIuKMiFwiLFwibGN1YlwiOlwie1wiLFwiTGN5XCI6XCLQm1wiLFwibGN5XCI6XCLQu1wiLFwibGRjYVwiOlwi4qS2XCIsXCJsZHF1b1wiOlwi4oCcXCIsXCJsZHF1b3JcIjpcIuKAnlwiLFwibGRyZGhhclwiOlwi4qWnXCIsXCJsZHJ1c2hhclwiOlwi4qWLXCIsXCJsZHNoXCI6XCLihrJcIixcImxlXCI6XCLiiaRcIixcImxFXCI6XCLiiaZcIixcIkxlZnRBbmdsZUJyYWNrZXRcIjpcIuKfqFwiLFwiTGVmdEFycm93QmFyXCI6XCLih6RcIixcImxlZnRhcnJvd1wiOlwi4oaQXCIsXCJMZWZ0QXJyb3dcIjpcIuKGkFwiLFwiTGVmdGFycm93XCI6XCLih5BcIixcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjpcIuKHhlwiLFwibGVmdGFycm93dGFpbFwiOlwi4oaiXCIsXCJMZWZ0Q2VpbGluZ1wiOlwi4oyIXCIsXCJMZWZ0RG91YmxlQnJhY2tldFwiOlwi4p+mXCIsXCJMZWZ0RG93blRlZVZlY3RvclwiOlwi4qWhXCIsXCJMZWZ0RG93blZlY3RvckJhclwiOlwi4qWZXCIsXCJMZWZ0RG93blZlY3RvclwiOlwi4oeDXCIsXCJMZWZ0Rmxvb3JcIjpcIuKMilwiLFwibGVmdGhhcnBvb25kb3duXCI6XCLihr1cIixcImxlZnRoYXJwb29udXBcIjpcIuKGvFwiLFwibGVmdGxlZnRhcnJvd3NcIjpcIuKHh1wiLFwibGVmdHJpZ2h0YXJyb3dcIjpcIuKGlFwiLFwiTGVmdFJpZ2h0QXJyb3dcIjpcIuKGlFwiLFwiTGVmdHJpZ2h0YXJyb3dcIjpcIuKHlFwiLFwibGVmdHJpZ2h0YXJyb3dzXCI6XCLih4ZcIixcImxlZnRyaWdodGhhcnBvb25zXCI6XCLih4tcIixcImxlZnRyaWdodHNxdWlnYXJyb3dcIjpcIuKGrVwiLFwiTGVmdFJpZ2h0VmVjdG9yXCI6XCLipY5cIixcIkxlZnRUZWVBcnJvd1wiOlwi4oakXCIsXCJMZWZ0VGVlXCI6XCLiiqNcIixcIkxlZnRUZWVWZWN0b3JcIjpcIuKlmlwiLFwibGVmdHRocmVldGltZXNcIjpcIuKLi1wiLFwiTGVmdFRyaWFuZ2xlQmFyXCI6XCLip49cIixcIkxlZnRUcmlhbmdsZVwiOlwi4oqyXCIsXCJMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4oq0XCIsXCJMZWZ0VXBEb3duVmVjdG9yXCI6XCLipZFcIixcIkxlZnRVcFRlZVZlY3RvclwiOlwi4qWgXCIsXCJMZWZ0VXBWZWN0b3JCYXJcIjpcIuKlmFwiLFwiTGVmdFVwVmVjdG9yXCI6XCLihr9cIixcIkxlZnRWZWN0b3JCYXJcIjpcIuKlklwiLFwiTGVmdFZlY3RvclwiOlwi4oa8XCIsXCJsRWdcIjpcIuKqi1wiLFwibGVnXCI6XCLii5pcIixcImxlcVwiOlwi4omkXCIsXCJsZXFxXCI6XCLiiaZcIixcImxlcXNsYW50XCI6XCLiqb1cIixcImxlc2NjXCI6XCLiqqhcIixcImxlc1wiOlwi4qm9XCIsXCJsZXNkb3RcIjpcIuKpv1wiLFwibGVzZG90b1wiOlwi4qqBXCIsXCJsZXNkb3RvclwiOlwi4qqDXCIsXCJsZXNnXCI6XCLii5rvuIBcIixcImxlc2dlc1wiOlwi4qqTXCIsXCJsZXNzYXBwcm94XCI6XCLiqoVcIixcImxlc3Nkb3RcIjpcIuKLllwiLFwibGVzc2VxZ3RyXCI6XCLii5pcIixcImxlc3NlcXFndHJcIjpcIuKqi1wiLFwiTGVzc0VxdWFsR3JlYXRlclwiOlwi4ouaXCIsXCJMZXNzRnVsbEVxdWFsXCI6XCLiiaZcIixcIkxlc3NHcmVhdGVyXCI6XCLiibZcIixcImxlc3NndHJcIjpcIuKJtlwiLFwiTGVzc0xlc3NcIjpcIuKqoVwiLFwibGVzc3NpbVwiOlwi4omyXCIsXCJMZXNzU2xhbnRFcXVhbFwiOlwi4qm9XCIsXCJMZXNzVGlsZGVcIjpcIuKJslwiLFwibGZpc2h0XCI6XCLipbxcIixcImxmbG9vclwiOlwi4oyKXCIsXCJMZnJcIjpcIvCdlI9cIixcImxmclwiOlwi8J2UqVwiLFwibGdcIjpcIuKJtlwiLFwibGdFXCI6XCLiqpFcIixcImxIYXJcIjpcIuKlolwiLFwibGhhcmRcIjpcIuKGvVwiLFwibGhhcnVcIjpcIuKGvFwiLFwibGhhcnVsXCI6XCLipapcIixcImxoYmxrXCI6XCLiloRcIixcIkxKY3lcIjpcItCJXCIsXCJsamN5XCI6XCLRmVwiLFwibGxhcnJcIjpcIuKHh1wiLFwibGxcIjpcIuKJqlwiLFwiTGxcIjpcIuKLmFwiLFwibGxjb3JuZXJcIjpcIuKMnlwiLFwiTGxlZnRhcnJvd1wiOlwi4oeaXCIsXCJsbGhhcmRcIjpcIuKlq1wiLFwibGx0cmlcIjpcIuKXulwiLFwiTG1pZG90XCI6XCLEv1wiLFwibG1pZG90XCI6XCLFgFwiLFwibG1vdXN0YWNoZVwiOlwi4o6wXCIsXCJsbW91c3RcIjpcIuKOsFwiLFwibG5hcFwiOlwi4qqJXCIsXCJsbmFwcHJveFwiOlwi4qqJXCIsXCJsbmVcIjpcIuKqh1wiLFwibG5FXCI6XCLiiahcIixcImxuZXFcIjpcIuKqh1wiLFwibG5lcXFcIjpcIuKJqFwiLFwibG5zaW1cIjpcIuKLplwiLFwibG9hbmdcIjpcIuKfrFwiLFwibG9hcnJcIjpcIuKHvVwiLFwibG9icmtcIjpcIuKfplwiLFwibG9uZ2xlZnRhcnJvd1wiOlwi4p+1XCIsXCJMb25nTGVmdEFycm93XCI6XCLin7VcIixcIkxvbmdsZWZ0YXJyb3dcIjpcIuKfuFwiLFwibG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7dcIixcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwi4p+3XCIsXCJMb25nbGVmdHJpZ2h0YXJyb3dcIjpcIuKfulwiLFwibG9uZ21hcHN0b1wiOlwi4p+8XCIsXCJsb25ncmlnaHRhcnJvd1wiOlwi4p+2XCIsXCJMb25nUmlnaHRBcnJvd1wiOlwi4p+2XCIsXCJMb25ncmlnaHRhcnJvd1wiOlwi4p+5XCIsXCJsb29wYXJyb3dsZWZ0XCI6XCLihqtcIixcImxvb3BhcnJvd3JpZ2h0XCI6XCLihqxcIixcImxvcGFyXCI6XCLipoVcIixcIkxvcGZcIjpcIvCdlYNcIixcImxvcGZcIjpcIvCdlZ1cIixcImxvcGx1c1wiOlwi4qitXCIsXCJsb3RpbWVzXCI6XCLiqLRcIixcImxvd2FzdFwiOlwi4oiXXCIsXCJsb3diYXJcIjpcIl9cIixcIkxvd2VyTGVmdEFycm93XCI6XCLihplcIixcIkxvd2VyUmlnaHRBcnJvd1wiOlwi4oaYXCIsXCJsb3pcIjpcIuKXilwiLFwibG96ZW5nZVwiOlwi4peKXCIsXCJsb3pmXCI6XCLip6tcIixcImxwYXJcIjpcIihcIixcImxwYXJsdFwiOlwi4qaTXCIsXCJscmFyclwiOlwi4oeGXCIsXCJscmNvcm5lclwiOlwi4oyfXCIsXCJscmhhclwiOlwi4oeLXCIsXCJscmhhcmRcIjpcIuKlrVwiLFwibHJtXCI6XCLigI5cIixcImxydHJpXCI6XCLiir9cIixcImxzYXF1b1wiOlwi4oC5XCIsXCJsc2NyXCI6XCLwnZOBXCIsXCJMc2NyXCI6XCLihJJcIixcImxzaFwiOlwi4oawXCIsXCJMc2hcIjpcIuKGsFwiLFwibHNpbVwiOlwi4omyXCIsXCJsc2ltZVwiOlwi4qqNXCIsXCJsc2ltZ1wiOlwi4qqPXCIsXCJsc3FiXCI6XCJbXCIsXCJsc3F1b1wiOlwi4oCYXCIsXCJsc3F1b3JcIjpcIuKAmlwiLFwiTHN0cm9rXCI6XCLFgVwiLFwibHN0cm9rXCI6XCLFglwiLFwibHRjY1wiOlwi4qqmXCIsXCJsdGNpclwiOlwi4qm5XCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIkx0XCI6XCLiiapcIixcImx0ZG90XCI6XCLii5ZcIixcImx0aHJlZVwiOlwi4ouLXCIsXCJsdGltZXNcIjpcIuKLiVwiLFwibHRsYXJyXCI6XCLipbZcIixcImx0cXVlc3RcIjpcIuKpu1wiLFwibHRyaVwiOlwi4peDXCIsXCJsdHJpZVwiOlwi4oq0XCIsXCJsdHJpZlwiOlwi4peCXCIsXCJsdHJQYXJcIjpcIuKmllwiLFwibHVyZHNoYXJcIjpcIuKlilwiLFwibHVydWhhclwiOlwi4qWmXCIsXCJsdmVydG5lcXFcIjpcIuKJqO+4gFwiLFwibHZuRVwiOlwi4omo77iAXCIsXCJtYWNyXCI6XCLCr1wiLFwibWFsZVwiOlwi4pmCXCIsXCJtYWx0XCI6XCLinKBcIixcIm1hbHRlc2VcIjpcIuKcoFwiLFwiTWFwXCI6XCLipIVcIixcIm1hcFwiOlwi4oamXCIsXCJtYXBzdG9cIjpcIuKGplwiLFwibWFwc3RvZG93blwiOlwi4oanXCIsXCJtYXBzdG9sZWZ0XCI6XCLihqRcIixcIm1hcHN0b3VwXCI6XCLihqVcIixcIm1hcmtlclwiOlwi4pauXCIsXCJtY29tbWFcIjpcIuKoqVwiLFwiTWN5XCI6XCLQnFwiLFwibWN5XCI6XCLQvFwiLFwibWRhc2hcIjpcIuKAlFwiLFwibUREb3RcIjpcIuKIulwiLFwibWVhc3VyZWRhbmdsZVwiOlwi4oihXCIsXCJNZWRpdW1TcGFjZVwiOlwi4oGfXCIsXCJNZWxsaW50cmZcIjpcIuKEs1wiLFwiTWZyXCI6XCLwnZSQXCIsXCJtZnJcIjpcIvCdlKpcIixcIm1ob1wiOlwi4oSnXCIsXCJtaWNyb1wiOlwiwrVcIixcIm1pZGFzdFwiOlwiKlwiLFwibWlkY2lyXCI6XCLiq7BcIixcIm1pZFwiOlwi4oijXCIsXCJtaWRkb3RcIjpcIsK3XCIsXCJtaW51c2JcIjpcIuKKn1wiLFwibWludXNcIjpcIuKIklwiLFwibWludXNkXCI6XCLiiLhcIixcIm1pbnVzZHVcIjpcIuKoqlwiLFwiTWludXNQbHVzXCI6XCLiiJNcIixcIm1sY3BcIjpcIuKrm1wiLFwibWxkclwiOlwi4oCmXCIsXCJtbnBsdXNcIjpcIuKIk1wiLFwibW9kZWxzXCI6XCLiiqdcIixcIk1vcGZcIjpcIvCdlYRcIixcIm1vcGZcIjpcIvCdlZ5cIixcIm1wXCI6XCLiiJNcIixcIm1zY3JcIjpcIvCdk4JcIixcIk1zY3JcIjpcIuKEs1wiLFwibXN0cG9zXCI6XCLiiL5cIixcIk11XCI6XCLOnFwiLFwibXVcIjpcIs68XCIsXCJtdWx0aW1hcFwiOlwi4oq4XCIsXCJtdW1hcFwiOlwi4oq4XCIsXCJuYWJsYVwiOlwi4oiHXCIsXCJOYWN1dGVcIjpcIsWDXCIsXCJuYWN1dGVcIjpcIsWEXCIsXCJuYW5nXCI6XCLiiKDig5JcIixcIm5hcFwiOlwi4omJXCIsXCJuYXBFXCI6XCLiqbDMuFwiLFwibmFwaWRcIjpcIuKJi8y4XCIsXCJuYXBvc1wiOlwixYlcIixcIm5hcHByb3hcIjpcIuKJiVwiLFwibmF0dXJhbFwiOlwi4pmuXCIsXCJuYXR1cmFsc1wiOlwi4oSVXCIsXCJuYXR1clwiOlwi4pmuXCIsXCJuYnNwXCI6XCLCoFwiLFwibmJ1bXBcIjpcIuKJjsy4XCIsXCJuYnVtcGVcIjpcIuKJj8y4XCIsXCJuY2FwXCI6XCLiqYNcIixcIk5jYXJvblwiOlwixYdcIixcIm5jYXJvblwiOlwixYhcIixcIk5jZWRpbFwiOlwixYVcIixcIm5jZWRpbFwiOlwixYZcIixcIm5jb25nXCI6XCLiiYdcIixcIm5jb25nZG90XCI6XCLiqa3MuFwiLFwibmN1cFwiOlwi4qmCXCIsXCJOY3lcIjpcItCdXCIsXCJuY3lcIjpcItC9XCIsXCJuZGFzaFwiOlwi4oCTXCIsXCJuZWFyaGtcIjpcIuKkpFwiLFwibmVhcnJcIjpcIuKGl1wiLFwibmVBcnJcIjpcIuKHl1wiLFwibmVhcnJvd1wiOlwi4oaXXCIsXCJuZVwiOlwi4omgXCIsXCJuZWRvdFwiOlwi4omQzLhcIixcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpblNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJuZXF1aXZcIjpcIuKJolwiLFwibmVzZWFyXCI6XCLipKhcIixcIm5lc2ltXCI6XCLiiYLMuFwiLFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKJq1wiLFwiTmVzdGVkTGVzc0xlc3NcIjpcIuKJqlwiLFwiTmV3TGluZVwiOlwiXFxuXCIsXCJuZXhpc3RcIjpcIuKIhFwiLFwibmV4aXN0c1wiOlwi4oiEXCIsXCJOZnJcIjpcIvCdlJFcIixcIm5mclwiOlwi8J2Uq1wiLFwibmdFXCI6XCLiiafMuFwiLFwibmdlXCI6XCLiibFcIixcIm5nZXFcIjpcIuKJsVwiLFwibmdlcXFcIjpcIuKJp8y4XCIsXCJuZ2Vxc2xhbnRcIjpcIuKpvsy4XCIsXCJuZ2VzXCI6XCLiqb7MuFwiLFwibkdnXCI6XCLii5nMuFwiLFwibmdzaW1cIjpcIuKJtVwiLFwibkd0XCI6XCLiiavig5JcIixcIm5ndFwiOlwi4omvXCIsXCJuZ3RyXCI6XCLiia9cIixcIm5HdHZcIjpcIuKJq8y4XCIsXCJuaGFyclwiOlwi4oauXCIsXCJuaEFyclwiOlwi4oeOXCIsXCJuaHBhclwiOlwi4quyXCIsXCJuaVwiOlwi4oiLXCIsXCJuaXNcIjpcIuKLvFwiLFwibmlzZFwiOlwi4ou6XCIsXCJuaXZcIjpcIuKIi1wiLFwiTkpjeVwiOlwi0IpcIixcIm5qY3lcIjpcItGaXCIsXCJubGFyclwiOlwi4oaaXCIsXCJubEFyclwiOlwi4oeNXCIsXCJubGRyXCI6XCLigKVcIixcIm5sRVwiOlwi4ommzLhcIixcIm5sZVwiOlwi4omwXCIsXCJubGVmdGFycm93XCI6XCLihppcIixcIm5MZWZ0YXJyb3dcIjpcIuKHjVwiLFwibmxlZnRyaWdodGFycm93XCI6XCLihq5cIixcIm5MZWZ0cmlnaHRhcnJvd1wiOlwi4oeOXCIsXCJubGVxXCI6XCLiibBcIixcIm5sZXFxXCI6XCLiiabMuFwiLFwibmxlcXNsYW50XCI6XCLiqb3MuFwiLFwibmxlc1wiOlwi4qm9zLhcIixcIm5sZXNzXCI6XCLiia5cIixcIm5MbFwiOlwi4ouYzLhcIixcIm5sc2ltXCI6XCLiibRcIixcIm5MdFwiOlwi4omq4oOSXCIsXCJubHRcIjpcIuKJrlwiLFwibmx0cmlcIjpcIuKLqlwiLFwibmx0cmllXCI6XCLii6xcIixcIm5MdHZcIjpcIuKJqsy4XCIsXCJubWlkXCI6XCLiiKRcIixcIk5vQnJlYWtcIjpcIuKBoFwiLFwiTm9uQnJlYWtpbmdTcGFjZVwiOlwiwqBcIixcIm5vcGZcIjpcIvCdlZ9cIixcIk5vcGZcIjpcIuKElVwiLFwiTm90XCI6XCLiq6xcIixcIm5vdFwiOlwiwqxcIixcIk5vdENvbmdydWVudFwiOlwi4omiXCIsXCJOb3RDdXBDYXBcIjpcIuKJrVwiLFwiTm90RG91YmxlVmVydGljYWxCYXJcIjpcIuKIplwiLFwiTm90RWxlbWVudFwiOlwi4oiJXCIsXCJOb3RFcXVhbFwiOlwi4omgXCIsXCJOb3RFcXVhbFRpbGRlXCI6XCLiiYLMuFwiLFwiTm90RXhpc3RzXCI6XCLiiIRcIixcIk5vdEdyZWF0ZXJcIjpcIuKJr1wiLFwiTm90R3JlYXRlckVxdWFsXCI6XCLiibFcIixcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjpcIuKJp8y4XCIsXCJOb3RHcmVhdGVyR3JlYXRlclwiOlwi4omrzLhcIixcIk5vdEdyZWF0ZXJMZXNzXCI6XCLiiblcIixcIk5vdEdyZWF0ZXJTbGFudEVxdWFsXCI6XCLiqb7MuFwiLFwiTm90R3JlYXRlclRpbGRlXCI6XCLiibVcIixcIk5vdEh1bXBEb3duSHVtcFwiOlwi4omOzLhcIixcIk5vdEh1bXBFcXVhbFwiOlwi4omPzLhcIixcIm5vdGluXCI6XCLiiIlcIixcIm5vdGluZG90XCI6XCLii7XMuFwiLFwibm90aW5FXCI6XCLii7nMuFwiLFwibm90aW52YVwiOlwi4oiJXCIsXCJub3RpbnZiXCI6XCLii7dcIixcIm5vdGludmNcIjpcIuKLtlwiLFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6XCLip4/MuFwiLFwiTm90TGVmdFRyaWFuZ2xlXCI6XCLii6pcIixcIk5vdExlZnRUcmlhbmdsZUVxdWFsXCI6XCLii6xcIixcIk5vdExlc3NcIjpcIuKJrlwiLFwiTm90TGVzc0VxdWFsXCI6XCLiibBcIixcIk5vdExlc3NHcmVhdGVyXCI6XCLiibhcIixcIk5vdExlc3NMZXNzXCI6XCLiiarMuFwiLFwiTm90TGVzc1NsYW50RXF1YWxcIjpcIuKpvcy4XCIsXCJOb3RMZXNzVGlsZGVcIjpcIuKJtFwiLFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKqosy4XCIsXCJOb3ROZXN0ZWRMZXNzTGVzc1wiOlwi4qqhzLhcIixcIm5vdG5pXCI6XCLiiIxcIixcIm5vdG5pdmFcIjpcIuKIjFwiLFwibm90bml2YlwiOlwi4ou+XCIsXCJub3RuaXZjXCI6XCLii71cIixcIk5vdFByZWNlZGVzXCI6XCLiioBcIixcIk5vdFByZWNlZGVzRXF1YWxcIjpcIuKqr8y4XCIsXCJOb3RQcmVjZWRlc1NsYW50RXF1YWxcIjpcIuKLoFwiLFwiTm90UmV2ZXJzZUVsZW1lbnRcIjpcIuKIjFwiLFwiTm90UmlnaHRUcmlhbmdsZUJhclwiOlwi4qeQzLhcIixcIk5vdFJpZ2h0VHJpYW5nbGVcIjpcIuKLq1wiLFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6XCLii61cIixcIk5vdFNxdWFyZVN1YnNldFwiOlwi4oqPzLhcIixcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6XCLii6JcIixcIk5vdFNxdWFyZVN1cGVyc2V0XCI6XCLiipDMuFwiLFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwi4oujXCIsXCJOb3RTdWJzZXRcIjpcIuKKguKDklwiLFwiTm90U3Vic2V0RXF1YWxcIjpcIuKKiFwiLFwiTm90U3VjY2VlZHNcIjpcIuKKgVwiLFwiTm90U3VjY2VlZHNFcXVhbFwiOlwi4qqwzLhcIixcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwi4ouhXCIsXCJOb3RTdWNjZWVkc1RpbGRlXCI6XCLiib/MuFwiLFwiTm90U3VwZXJzZXRcIjpcIuKKg+KDklwiLFwiTm90U3VwZXJzZXRFcXVhbFwiOlwi4oqJXCIsXCJOb3RUaWxkZVwiOlwi4omBXCIsXCJOb3RUaWxkZUVxdWFsXCI6XCLiiYRcIixcIk5vdFRpbGRlRnVsbEVxdWFsXCI6XCLiiYdcIixcIk5vdFRpbGRlVGlsZGVcIjpcIuKJiVwiLFwiTm90VmVydGljYWxCYXJcIjpcIuKIpFwiLFwibnBhcmFsbGVsXCI6XCLiiKZcIixcIm5wYXJcIjpcIuKIplwiLFwibnBhcnNsXCI6XCLiq73ig6VcIixcIm5wYXJ0XCI6XCLiiILMuFwiLFwibnBvbGludFwiOlwi4qiUXCIsXCJucHJcIjpcIuKKgFwiLFwibnByY3VlXCI6XCLii6BcIixcIm5wcmVjXCI6XCLiioBcIixcIm5wcmVjZXFcIjpcIuKqr8y4XCIsXCJucHJlXCI6XCLiqq/MuFwiLFwibnJhcnJjXCI6XCLipLPMuFwiLFwibnJhcnJcIjpcIuKGm1wiLFwibnJBcnJcIjpcIuKHj1wiLFwibnJhcnJ3XCI6XCLihp3MuFwiLFwibnJpZ2h0YXJyb3dcIjpcIuKGm1wiLFwiblJpZ2h0YXJyb3dcIjpcIuKHj1wiLFwibnJ0cmlcIjpcIuKLq1wiLFwibnJ0cmllXCI6XCLii61cIixcIm5zY1wiOlwi4oqBXCIsXCJuc2NjdWVcIjpcIuKLoVwiLFwibnNjZVwiOlwi4qqwzLhcIixcIk5zY3JcIjpcIvCdkqlcIixcIm5zY3JcIjpcIvCdk4NcIixcIm5zaG9ydG1pZFwiOlwi4oikXCIsXCJuc2hvcnRwYXJhbGxlbFwiOlwi4oimXCIsXCJuc2ltXCI6XCLiiYFcIixcIm5zaW1lXCI6XCLiiYRcIixcIm5zaW1lcVwiOlwi4omEXCIsXCJuc21pZFwiOlwi4oikXCIsXCJuc3BhclwiOlwi4oimXCIsXCJuc3FzdWJlXCI6XCLii6JcIixcIm5zcXN1cGVcIjpcIuKLo1wiLFwibnN1YlwiOlwi4oqEXCIsXCJuc3ViRVwiOlwi4quFzLhcIixcIm5zdWJlXCI6XCLiiohcIixcIm5zdWJzZXRcIjpcIuKKguKDklwiLFwibnN1YnNldGVxXCI6XCLiiohcIixcIm5zdWJzZXRlcXFcIjpcIuKrhcy4XCIsXCJuc3VjY1wiOlwi4oqBXCIsXCJuc3VjY2VxXCI6XCLiqrDMuFwiLFwibnN1cFwiOlwi4oqFXCIsXCJuc3VwRVwiOlwi4quGzLhcIixcIm5zdXBlXCI6XCLiiolcIixcIm5zdXBzZXRcIjpcIuKKg+KDklwiLFwibnN1cHNldGVxXCI6XCLiiolcIixcIm5zdXBzZXRlcXFcIjpcIuKrhsy4XCIsXCJudGdsXCI6XCLiiblcIixcIk50aWxkZVwiOlwiw5FcIixcIm50aWxkZVwiOlwiw7FcIixcIm50bGdcIjpcIuKJuFwiLFwibnRyaWFuZ2xlbGVmdFwiOlwi4ouqXCIsXCJudHJpYW5nbGVsZWZ0ZXFcIjpcIuKLrFwiLFwibnRyaWFuZ2xlcmlnaHRcIjpcIuKLq1wiLFwibnRyaWFuZ2xlcmlnaHRlcVwiOlwi4outXCIsXCJOdVwiOlwizp1cIixcIm51XCI6XCLOvVwiLFwibnVtXCI6XCIjXCIsXCJudW1lcm9cIjpcIuKEllwiLFwibnVtc3BcIjpcIuKAh1wiLFwibnZhcFwiOlwi4omN4oOSXCIsXCJudmRhc2hcIjpcIuKKrFwiLFwibnZEYXNoXCI6XCLiiq1cIixcIm5WZGFzaFwiOlwi4oquXCIsXCJuVkRhc2hcIjpcIuKKr1wiLFwibnZnZVwiOlwi4oml4oOSXCIsXCJudmd0XCI6XCI+4oOSXCIsXCJudkhhcnJcIjpcIuKkhFwiLFwibnZpbmZpblwiOlwi4qeeXCIsXCJudmxBcnJcIjpcIuKkglwiLFwibnZsZVwiOlwi4omk4oOSXCIsXCJudmx0XCI6XCI84oOSXCIsXCJudmx0cmllXCI6XCLiirTig5JcIixcIm52ckFyclwiOlwi4qSDXCIsXCJudnJ0cmllXCI6XCLiirXig5JcIixcIm52c2ltXCI6XCLiiLzig5JcIixcIm53YXJoa1wiOlwi4qSjXCIsXCJud2FyclwiOlwi4oaWXCIsXCJud0FyclwiOlwi4oeWXCIsXCJud2Fycm93XCI6XCLihpZcIixcIm53bmVhclwiOlwi4qSnXCIsXCJPYWN1dGVcIjpcIsOTXCIsXCJvYWN1dGVcIjpcIsOzXCIsXCJvYXN0XCI6XCLiiptcIixcIk9jaXJjXCI6XCLDlFwiLFwib2NpcmNcIjpcIsO0XCIsXCJvY2lyXCI6XCLiippcIixcIk9jeVwiOlwi0J5cIixcIm9jeVwiOlwi0L5cIixcIm9kYXNoXCI6XCLiip1cIixcIk9kYmxhY1wiOlwixZBcIixcIm9kYmxhY1wiOlwixZFcIixcIm9kaXZcIjpcIuKouFwiLFwib2RvdFwiOlwi4oqZXCIsXCJvZHNvbGRcIjpcIuKmvFwiLFwiT0VsaWdcIjpcIsWSXCIsXCJvZWxpZ1wiOlwixZNcIixcIm9mY2lyXCI6XCLipr9cIixcIk9mclwiOlwi8J2UklwiLFwib2ZyXCI6XCLwnZSsXCIsXCJvZ29uXCI6XCLLm1wiLFwiT2dyYXZlXCI6XCLDklwiLFwib2dyYXZlXCI6XCLDslwiLFwib2d0XCI6XCLip4FcIixcIm9oYmFyXCI6XCLiprVcIixcIm9obVwiOlwizqlcIixcIm9pbnRcIjpcIuKIrlwiLFwib2xhcnJcIjpcIuKGulwiLFwib2xjaXJcIjpcIuKmvlwiLFwib2xjcm9zc1wiOlwi4qa7XCIsXCJvbGluZVwiOlwi4oC+XCIsXCJvbHRcIjpcIuKngFwiLFwiT21hY3JcIjpcIsWMXCIsXCJvbWFjclwiOlwixY1cIixcIk9tZWdhXCI6XCLOqVwiLFwib21lZ2FcIjpcIs+JXCIsXCJPbWljcm9uXCI6XCLOn1wiLFwib21pY3JvblwiOlwizr9cIixcIm9taWRcIjpcIuKmtlwiLFwib21pbnVzXCI6XCLiipZcIixcIk9vcGZcIjpcIvCdlYZcIixcIm9vcGZcIjpcIvCdlaBcIixcIm9wYXJcIjpcIuKmt1wiLFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnFwiLFwiT3BlbkN1cmx5UXVvdGVcIjpcIuKAmFwiLFwib3BlcnBcIjpcIuKmuVwiLFwib3BsdXNcIjpcIuKKlVwiLFwib3JhcnJcIjpcIuKGu1wiLFwiT3JcIjpcIuKplFwiLFwib3JcIjpcIuKIqFwiLFwib3JkXCI6XCLiqZ1cIixcIm9yZGVyXCI6XCLihLRcIixcIm9yZGVyb2ZcIjpcIuKEtFwiLFwib3JkZlwiOlwiwqpcIixcIm9yZG1cIjpcIsK6XCIsXCJvcmlnb2ZcIjpcIuKKtlwiLFwib3JvclwiOlwi4qmWXCIsXCJvcnNsb3BlXCI6XCLiqZdcIixcIm9ydlwiOlwi4qmbXCIsXCJvU1wiOlwi4pOIXCIsXCJPc2NyXCI6XCLwnZKqXCIsXCJvc2NyXCI6XCLihLRcIixcIk9zbGFzaFwiOlwiw5hcIixcIm9zbGFzaFwiOlwiw7hcIixcIm9zb2xcIjpcIuKKmFwiLFwiT3RpbGRlXCI6XCLDlVwiLFwib3RpbGRlXCI6XCLDtVwiLFwib3RpbWVzYXNcIjpcIuKotlwiLFwiT3RpbWVzXCI6XCLiqLdcIixcIm90aW1lc1wiOlwi4oqXXCIsXCJPdW1sXCI6XCLDllwiLFwib3VtbFwiOlwiw7ZcIixcIm92YmFyXCI6XCLijL1cIixcIk92ZXJCYXJcIjpcIuKAvlwiLFwiT3ZlckJyYWNlXCI6XCLij55cIixcIk92ZXJCcmFja2V0XCI6XCLijrRcIixcIk92ZXJQYXJlbnRoZXNpc1wiOlwi4o+cXCIsXCJwYXJhXCI6XCLCtlwiLFwicGFyYWxsZWxcIjpcIuKIpVwiLFwicGFyXCI6XCLiiKVcIixcInBhcnNpbVwiOlwi4quzXCIsXCJwYXJzbFwiOlwi4qu9XCIsXCJwYXJ0XCI6XCLiiIJcIixcIlBhcnRpYWxEXCI6XCLiiIJcIixcIlBjeVwiOlwi0J9cIixcInBjeVwiOlwi0L9cIixcInBlcmNudFwiOlwiJVwiLFwicGVyaW9kXCI6XCIuXCIsXCJwZXJtaWxcIjpcIuKAsFwiLFwicGVycFwiOlwi4oqlXCIsXCJwZXJ0ZW5rXCI6XCLigLFcIixcIlBmclwiOlwi8J2Uk1wiLFwicGZyXCI6XCLwnZStXCIsXCJQaGlcIjpcIs6mXCIsXCJwaGlcIjpcIs+GXCIsXCJwaGl2XCI6XCLPlVwiLFwicGhtbWF0XCI6XCLihLNcIixcInBob25lXCI6XCLimI5cIixcIlBpXCI6XCLOoFwiLFwicGlcIjpcIs+AXCIsXCJwaXRjaGZvcmtcIjpcIuKLlFwiLFwicGl2XCI6XCLPllwiLFwicGxhbmNrXCI6XCLihI9cIixcInBsYW5ja2hcIjpcIuKEjlwiLFwicGxhbmt2XCI6XCLihI9cIixcInBsdXNhY2lyXCI6XCLiqKNcIixcInBsdXNiXCI6XCLiip5cIixcInBsdXNjaXJcIjpcIuKoolwiLFwicGx1c1wiOlwiK1wiLFwicGx1c2RvXCI6XCLiiJRcIixcInBsdXNkdVwiOlwi4qilXCIsXCJwbHVzZVwiOlwi4qmyXCIsXCJQbHVzTWludXNcIjpcIsKxXCIsXCJwbHVzbW5cIjpcIsKxXCIsXCJwbHVzc2ltXCI6XCLiqKZcIixcInBsdXN0d29cIjpcIuKop1wiLFwicG1cIjpcIsKxXCIsXCJQb2luY2FyZXBsYW5lXCI6XCLihIxcIixcInBvaW50aW50XCI6XCLiqJVcIixcInBvcGZcIjpcIvCdlaFcIixcIlBvcGZcIjpcIuKEmVwiLFwicG91bmRcIjpcIsKjXCIsXCJwcmFwXCI6XCLiqrdcIixcIlByXCI6XCLiqrtcIixcInByXCI6XCLiibpcIixcInByY3VlXCI6XCLiibxcIixcInByZWNhcHByb3hcIjpcIuKqt1wiLFwicHJlY1wiOlwi4om6XCIsXCJwcmVjY3VybHllcVwiOlwi4om8XCIsXCJQcmVjZWRlc1wiOlwi4om6XCIsXCJQcmVjZWRlc0VxdWFsXCI6XCLiqq9cIixcIlByZWNlZGVzU2xhbnRFcXVhbFwiOlwi4om8XCIsXCJQcmVjZWRlc1RpbGRlXCI6XCLiib5cIixcInByZWNlcVwiOlwi4qqvXCIsXCJwcmVjbmFwcHJveFwiOlwi4qq5XCIsXCJwcmVjbmVxcVwiOlwi4qq1XCIsXCJwcmVjbnNpbVwiOlwi4ouoXCIsXCJwcmVcIjpcIuKqr1wiLFwicHJFXCI6XCLiqrNcIixcInByZWNzaW1cIjpcIuKJvlwiLFwicHJpbWVcIjpcIuKAslwiLFwiUHJpbWVcIjpcIuKAs1wiLFwicHJpbWVzXCI6XCLihJlcIixcInBybmFwXCI6XCLiqrlcIixcInBybkVcIjpcIuKqtVwiLFwicHJuc2ltXCI6XCLii6hcIixcInByb2RcIjpcIuKIj1wiLFwiUHJvZHVjdFwiOlwi4oiPXCIsXCJwcm9mYWxhclwiOlwi4oyuXCIsXCJwcm9mbGluZVwiOlwi4oySXCIsXCJwcm9mc3VyZlwiOlwi4oyTXCIsXCJwcm9wXCI6XCLiiJ1cIixcIlByb3BvcnRpb25hbFwiOlwi4oidXCIsXCJQcm9wb3J0aW9uXCI6XCLiiLdcIixcInByb3B0b1wiOlwi4oidXCIsXCJwcnNpbVwiOlwi4om+XCIsXCJwcnVyZWxcIjpcIuKKsFwiLFwiUHNjclwiOlwi8J2Sq1wiLFwicHNjclwiOlwi8J2ThVwiLFwiUHNpXCI6XCLOqFwiLFwicHNpXCI6XCLPiFwiLFwicHVuY3NwXCI6XCLigIhcIixcIlFmclwiOlwi8J2UlFwiLFwicWZyXCI6XCLwnZSuXCIsXCJxaW50XCI6XCLiqIxcIixcInFvcGZcIjpcIvCdlaJcIixcIlFvcGZcIjpcIuKEmlwiLFwicXByaW1lXCI6XCLigZdcIixcIlFzY3JcIjpcIvCdkqxcIixcInFzY3JcIjpcIvCdk4ZcIixcInF1YXRlcm5pb25zXCI6XCLihI1cIixcInF1YXRpbnRcIjpcIuKollwiLFwicXVlc3RcIjpcIj9cIixcInF1ZXN0ZXFcIjpcIuKJn1wiLFwicXVvdFwiOlwiXFxcIlwiLFwiUVVPVFwiOlwiXFxcIlwiLFwickFhcnJcIjpcIuKHm1wiLFwicmFjZVwiOlwi4oi9zLFcIixcIlJhY3V0ZVwiOlwixZRcIixcInJhY3V0ZVwiOlwixZVcIixcInJhZGljXCI6XCLiiJpcIixcInJhZW1wdHl2XCI6XCLiprNcIixcInJhbmdcIjpcIuKfqVwiLFwiUmFuZ1wiOlwi4p+rXCIsXCJyYW5nZFwiOlwi4qaSXCIsXCJyYW5nZVwiOlwi4qalXCIsXCJyYW5nbGVcIjpcIuKfqVwiLFwicmFxdW9cIjpcIsK7XCIsXCJyYXJyYXBcIjpcIuKltVwiLFwicmFycmJcIjpcIuKHpVwiLFwicmFycmJmc1wiOlwi4qSgXCIsXCJyYXJyY1wiOlwi4qSzXCIsXCJyYXJyXCI6XCLihpJcIixcIlJhcnJcIjpcIuKGoFwiLFwickFyclwiOlwi4oeSXCIsXCJyYXJyZnNcIjpcIuKknlwiLFwicmFycmhrXCI6XCLihqpcIixcInJhcnJscFwiOlwi4oasXCIsXCJyYXJycGxcIjpcIuKlhVwiLFwicmFycnNpbVwiOlwi4qW0XCIsXCJSYXJydGxcIjpcIuKkllwiLFwicmFycnRsXCI6XCLihqNcIixcInJhcnJ3XCI6XCLihp1cIixcInJhdGFpbFwiOlwi4qSaXCIsXCJyQXRhaWxcIjpcIuKknFwiLFwicmF0aW9cIjpcIuKItlwiLFwicmF0aW9uYWxzXCI6XCLihJpcIixcInJiYXJyXCI6XCLipI1cIixcInJCYXJyXCI6XCLipI9cIixcIlJCYXJyXCI6XCLipJBcIixcInJiYnJrXCI6XCLinbNcIixcInJicmFjZVwiOlwifVwiLFwicmJyYWNrXCI6XCJdXCIsXCJyYnJrZVwiOlwi4qaMXCIsXCJyYnJrc2xkXCI6XCLipo5cIixcInJicmtzbHVcIjpcIuKmkFwiLFwiUmNhcm9uXCI6XCLFmFwiLFwicmNhcm9uXCI6XCLFmVwiLFwiUmNlZGlsXCI6XCLFllwiLFwicmNlZGlsXCI6XCLFl1wiLFwicmNlaWxcIjpcIuKMiVwiLFwicmN1YlwiOlwifVwiLFwiUmN5XCI6XCLQoFwiLFwicmN5XCI6XCLRgFwiLFwicmRjYVwiOlwi4qS3XCIsXCJyZGxkaGFyXCI6XCLipalcIixcInJkcXVvXCI6XCLigJ1cIixcInJkcXVvclwiOlwi4oCdXCIsXCJyZHNoXCI6XCLihrNcIixcInJlYWxcIjpcIuKEnFwiLFwicmVhbGluZVwiOlwi4oSbXCIsXCJyZWFscGFydFwiOlwi4oScXCIsXCJyZWFsc1wiOlwi4oSdXCIsXCJSZVwiOlwi4oScXCIsXCJyZWN0XCI6XCLilq1cIixcInJlZ1wiOlwiwq5cIixcIlJFR1wiOlwiwq5cIixcIlJldmVyc2VFbGVtZW50XCI6XCLiiItcIixcIlJldmVyc2VFcXVpbGlicml1bVwiOlwi4oeLXCIsXCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOlwi4qWvXCIsXCJyZmlzaHRcIjpcIuKlvVwiLFwicmZsb29yXCI6XCLijItcIixcInJmclwiOlwi8J2Ur1wiLFwiUmZyXCI6XCLihJxcIixcInJIYXJcIjpcIuKlpFwiLFwicmhhcmRcIjpcIuKHgVwiLFwicmhhcnVcIjpcIuKHgFwiLFwicmhhcnVsXCI6XCLipaxcIixcIlJob1wiOlwizqFcIixcInJob1wiOlwiz4FcIixcInJob3ZcIjpcIs+xXCIsXCJSaWdodEFuZ2xlQnJhY2tldFwiOlwi4p+pXCIsXCJSaWdodEFycm93QmFyXCI6XCLih6VcIixcInJpZ2h0YXJyb3dcIjpcIuKGklwiLFwiUmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJSaWdodGFycm93XCI6XCLih5JcIixcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjpcIuKHhFwiLFwicmlnaHRhcnJvd3RhaWxcIjpcIuKGo1wiLFwiUmlnaHRDZWlsaW5nXCI6XCLijIlcIixcIlJpZ2h0RG91YmxlQnJhY2tldFwiOlwi4p+nXCIsXCJSaWdodERvd25UZWVWZWN0b3JcIjpcIuKlnVwiLFwiUmlnaHREb3duVmVjdG9yQmFyXCI6XCLipZVcIixcIlJpZ2h0RG93blZlY3RvclwiOlwi4oeCXCIsXCJSaWdodEZsb29yXCI6XCLijItcIixcInJpZ2h0aGFycG9vbmRvd25cIjpcIuKHgVwiLFwicmlnaHRoYXJwb29udXBcIjpcIuKHgFwiLFwicmlnaHRsZWZ0YXJyb3dzXCI6XCLih4RcIixcInJpZ2h0bGVmdGhhcnBvb25zXCI6XCLih4xcIixcInJpZ2h0cmlnaHRhcnJvd3NcIjpcIuKHiVwiLFwicmlnaHRzcXVpZ2Fycm93XCI6XCLihp1cIixcIlJpZ2h0VGVlQXJyb3dcIjpcIuKGplwiLFwiUmlnaHRUZWVcIjpcIuKKolwiLFwiUmlnaHRUZWVWZWN0b3JcIjpcIuKlm1wiLFwicmlnaHR0aHJlZXRpbWVzXCI6XCLii4xcIixcIlJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkFwiLFwiUmlnaHRUcmlhbmdsZVwiOlwi4oqzXCIsXCJSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKKtVwiLFwiUmlnaHRVcERvd25WZWN0b3JcIjpcIuKlj1wiLFwiUmlnaHRVcFRlZVZlY3RvclwiOlwi4qWcXCIsXCJSaWdodFVwVmVjdG9yQmFyXCI6XCLipZRcIixcIlJpZ2h0VXBWZWN0b3JcIjpcIuKGvlwiLFwiUmlnaHRWZWN0b3JCYXJcIjpcIuKlk1wiLFwiUmlnaHRWZWN0b3JcIjpcIuKHgFwiLFwicmluZ1wiOlwiy5pcIixcInJpc2luZ2RvdHNlcVwiOlwi4omTXCIsXCJybGFyclwiOlwi4oeEXCIsXCJybGhhclwiOlwi4oeMXCIsXCJybG1cIjpcIuKAj1wiLFwicm1vdXN0YWNoZVwiOlwi4o6xXCIsXCJybW91c3RcIjpcIuKOsVwiLFwicm5taWRcIjpcIuKrrlwiLFwicm9hbmdcIjpcIuKfrVwiLFwicm9hcnJcIjpcIuKHvlwiLFwicm9icmtcIjpcIuKfp1wiLFwicm9wYXJcIjpcIuKmhlwiLFwicm9wZlwiOlwi8J2Vo1wiLFwiUm9wZlwiOlwi4oSdXCIsXCJyb3BsdXNcIjpcIuKorlwiLFwicm90aW1lc1wiOlwi4qi1XCIsXCJSb3VuZEltcGxpZXNcIjpcIuKlsFwiLFwicnBhclwiOlwiKVwiLFwicnBhcmd0XCI6XCLippRcIixcInJwcG9saW50XCI6XCLiqJJcIixcInJyYXJyXCI6XCLih4lcIixcIlJyaWdodGFycm93XCI6XCLih5tcIixcInJzYXF1b1wiOlwi4oC6XCIsXCJyc2NyXCI6XCLwnZOHXCIsXCJSc2NyXCI6XCLihJtcIixcInJzaFwiOlwi4oaxXCIsXCJSc2hcIjpcIuKGsVwiLFwicnNxYlwiOlwiXVwiLFwicnNxdW9cIjpcIuKAmVwiLFwicnNxdW9yXCI6XCLigJlcIixcInJ0aHJlZVwiOlwi4ouMXCIsXCJydGltZXNcIjpcIuKLilwiLFwicnRyaVwiOlwi4pa5XCIsXCJydHJpZVwiOlwi4oq1XCIsXCJydHJpZlwiOlwi4pa4XCIsXCJydHJpbHRyaVwiOlwi4qeOXCIsXCJSdWxlRGVsYXllZFwiOlwi4qe0XCIsXCJydWx1aGFyXCI6XCLipahcIixcInJ4XCI6XCLihJ5cIixcIlNhY3V0ZVwiOlwixZpcIixcInNhY3V0ZVwiOlwixZtcIixcInNicXVvXCI6XCLigJpcIixcInNjYXBcIjpcIuKquFwiLFwiU2Nhcm9uXCI6XCLFoFwiLFwic2Nhcm9uXCI6XCLFoVwiLFwiU2NcIjpcIuKqvFwiLFwic2NcIjpcIuKJu1wiLFwic2NjdWVcIjpcIuKJvVwiLFwic2NlXCI6XCLiqrBcIixcInNjRVwiOlwi4qq0XCIsXCJTY2VkaWxcIjpcIsWeXCIsXCJzY2VkaWxcIjpcIsWfXCIsXCJTY2lyY1wiOlwixZxcIixcInNjaXJjXCI6XCLFnVwiLFwic2NuYXBcIjpcIuKqulwiLFwic2NuRVwiOlwi4qq2XCIsXCJzY25zaW1cIjpcIuKLqVwiLFwic2Nwb2xpbnRcIjpcIuKok1wiLFwic2NzaW1cIjpcIuKJv1wiLFwiU2N5XCI6XCLQoVwiLFwic2N5XCI6XCLRgVwiLFwic2RvdGJcIjpcIuKKoVwiLFwic2RvdFwiOlwi4ouFXCIsXCJzZG90ZVwiOlwi4qmmXCIsXCJzZWFyaGtcIjpcIuKkpVwiLFwic2VhcnJcIjpcIuKGmFwiLFwic2VBcnJcIjpcIuKHmFwiLFwic2VhcnJvd1wiOlwi4oaYXCIsXCJzZWN0XCI6XCLCp1wiLFwic2VtaVwiOlwiO1wiLFwic2Vzd2FyXCI6XCLipKlcIixcInNldG1pbnVzXCI6XCLiiJZcIixcInNldG1uXCI6XCLiiJZcIixcInNleHRcIjpcIuKctlwiLFwiU2ZyXCI6XCLwnZSWXCIsXCJzZnJcIjpcIvCdlLBcIixcInNmcm93blwiOlwi4oyiXCIsXCJzaGFycFwiOlwi4pmvXCIsXCJTSENIY3lcIjpcItCpXCIsXCJzaGNoY3lcIjpcItGJXCIsXCJTSGN5XCI6XCLQqFwiLFwic2hjeVwiOlwi0YhcIixcIlNob3J0RG93bkFycm93XCI6XCLihpNcIixcIlNob3J0TGVmdEFycm93XCI6XCLihpBcIixcInNob3J0bWlkXCI6XCLiiKNcIixcInNob3J0cGFyYWxsZWxcIjpcIuKIpVwiLFwiU2hvcnRSaWdodEFycm93XCI6XCLihpJcIixcIlNob3J0VXBBcnJvd1wiOlwi4oaRXCIsXCJzaHlcIjpcIsKtXCIsXCJTaWdtYVwiOlwizqNcIixcInNpZ21hXCI6XCLPg1wiLFwic2lnbWFmXCI6XCLPglwiLFwic2lnbWF2XCI6XCLPglwiLFwic2ltXCI6XCLiiLxcIixcInNpbWRvdFwiOlwi4qmqXCIsXCJzaW1lXCI6XCLiiYNcIixcInNpbWVxXCI6XCLiiYNcIixcInNpbWdcIjpcIuKqnlwiLFwic2ltZ0VcIjpcIuKqoFwiLFwic2ltbFwiOlwi4qqdXCIsXCJzaW1sRVwiOlwi4qqfXCIsXCJzaW1uZVwiOlwi4omGXCIsXCJzaW1wbHVzXCI6XCLiqKRcIixcInNpbXJhcnJcIjpcIuKlslwiLFwic2xhcnJcIjpcIuKGkFwiLFwiU21hbGxDaXJjbGVcIjpcIuKImFwiLFwic21hbGxzZXRtaW51c1wiOlwi4oiWXCIsXCJzbWFzaHBcIjpcIuKos1wiLFwic21lcGFyc2xcIjpcIuKnpFwiLFwic21pZFwiOlwi4oijXCIsXCJzbWlsZVwiOlwi4oyjXCIsXCJzbXRcIjpcIuKqqlwiLFwic210ZVwiOlwi4qqsXCIsXCJzbXRlc1wiOlwi4qqs77iAXCIsXCJTT0ZUY3lcIjpcItCsXCIsXCJzb2Z0Y3lcIjpcItGMXCIsXCJzb2xiYXJcIjpcIuKMv1wiLFwic29sYlwiOlwi4qeEXCIsXCJzb2xcIjpcIi9cIixcIlNvcGZcIjpcIvCdlYpcIixcInNvcGZcIjpcIvCdlaRcIixcInNwYWRlc1wiOlwi4pmgXCIsXCJzcGFkZXN1aXRcIjpcIuKZoFwiLFwic3BhclwiOlwi4oilXCIsXCJzcWNhcFwiOlwi4oqTXCIsXCJzcWNhcHNcIjpcIuKKk++4gFwiLFwic3FjdXBcIjpcIuKKlFwiLFwic3FjdXBzXCI6XCLiipTvuIBcIixcIlNxcnRcIjpcIuKImlwiLFwic3FzdWJcIjpcIuKKj1wiLFwic3FzdWJlXCI6XCLiipFcIixcInNxc3Vic2V0XCI6XCLiio9cIixcInNxc3Vic2V0ZXFcIjpcIuKKkVwiLFwic3FzdXBcIjpcIuKKkFwiLFwic3FzdXBlXCI6XCLiipJcIixcInNxc3Vwc2V0XCI6XCLiipBcIixcInNxc3Vwc2V0ZXFcIjpcIuKKklwiLFwic3F1YXJlXCI6XCLilqFcIixcIlNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVJbnRlcnNlY3Rpb25cIjpcIuKKk1wiLFwiU3F1YXJlU3Vic2V0XCI6XCLiio9cIixcIlNxdWFyZVN1YnNldEVxdWFsXCI6XCLiipFcIixcIlNxdWFyZVN1cGVyc2V0XCI6XCLiipBcIixcIlNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKKklwiLFwiU3F1YXJlVW5pb25cIjpcIuKKlFwiLFwic3F1YXJmXCI6XCLilqpcIixcInNxdVwiOlwi4pahXCIsXCJzcXVmXCI6XCLilqpcIixcInNyYXJyXCI6XCLihpJcIixcIlNzY3JcIjpcIvCdkq5cIixcInNzY3JcIjpcIvCdk4hcIixcInNzZXRtblwiOlwi4oiWXCIsXCJzc21pbGVcIjpcIuKMo1wiLFwic3N0YXJmXCI6XCLii4ZcIixcIlN0YXJcIjpcIuKLhlwiLFwic3RhclwiOlwi4piGXCIsXCJzdGFyZlwiOlwi4piFXCIsXCJzdHJhaWdodGVwc2lsb25cIjpcIs+1XCIsXCJzdHJhaWdodHBoaVwiOlwiz5VcIixcInN0cm5zXCI6XCLCr1wiLFwic3ViXCI6XCLiioJcIixcIlN1YlwiOlwi4ouQXCIsXCJzdWJkb3RcIjpcIuKqvVwiLFwic3ViRVwiOlwi4quFXCIsXCJzdWJlXCI6XCLiioZcIixcInN1YmVkb3RcIjpcIuKrg1wiLFwic3VibXVsdFwiOlwi4quBXCIsXCJzdWJuRVwiOlwi4quLXCIsXCJzdWJuZVwiOlwi4oqKXCIsXCJzdWJwbHVzXCI6XCLiqr9cIixcInN1YnJhcnJcIjpcIuKluVwiLFwic3Vic2V0XCI6XCLiioJcIixcIlN1YnNldFwiOlwi4ouQXCIsXCJzdWJzZXRlcVwiOlwi4oqGXCIsXCJzdWJzZXRlcXFcIjpcIuKrhVwiLFwiU3Vic2V0RXF1YWxcIjpcIuKKhlwiLFwic3Vic2V0bmVxXCI6XCLiiopcIixcInN1YnNldG5lcXFcIjpcIuKri1wiLFwic3Vic2ltXCI6XCLiq4dcIixcInN1YnN1YlwiOlwi4quVXCIsXCJzdWJzdXBcIjpcIuKrk1wiLFwic3VjY2FwcHJveFwiOlwi4qq4XCIsXCJzdWNjXCI6XCLiibtcIixcInN1Y2NjdXJseWVxXCI6XCLiib1cIixcIlN1Y2NlZWRzXCI6XCLiibtcIixcIlN1Y2NlZWRzRXF1YWxcIjpcIuKqsFwiLFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6XCLiib1cIixcIlN1Y2NlZWRzVGlsZGVcIjpcIuKJv1wiLFwic3VjY2VxXCI6XCLiqrBcIixcInN1Y2NuYXBwcm94XCI6XCLiqrpcIixcInN1Y2NuZXFxXCI6XCLiqrZcIixcInN1Y2Nuc2ltXCI6XCLii6lcIixcInN1Y2NzaW1cIjpcIuKJv1wiLFwiU3VjaFRoYXRcIjpcIuKIi1wiLFwic3VtXCI6XCLiiJFcIixcIlN1bVwiOlwi4oiRXCIsXCJzdW5nXCI6XCLimapcIixcInN1cDFcIjpcIsK5XCIsXCJzdXAyXCI6XCLCslwiLFwic3VwM1wiOlwiwrNcIixcInN1cFwiOlwi4oqDXCIsXCJTdXBcIjpcIuKLkVwiLFwic3VwZG90XCI6XCLiqr5cIixcInN1cGRzdWJcIjpcIuKrmFwiLFwic3VwRVwiOlwi4quGXCIsXCJzdXBlXCI6XCLiiodcIixcInN1cGVkb3RcIjpcIuKrhFwiLFwiU3VwZXJzZXRcIjpcIuKKg1wiLFwiU3VwZXJzZXRFcXVhbFwiOlwi4oqHXCIsXCJzdXBoc29sXCI6XCLin4lcIixcInN1cGhzdWJcIjpcIuKrl1wiLFwic3VwbGFyclwiOlwi4qW7XCIsXCJzdXBtdWx0XCI6XCLiq4JcIixcInN1cG5FXCI6XCLiq4xcIixcInN1cG5lXCI6XCLiiotcIixcInN1cHBsdXNcIjpcIuKrgFwiLFwic3Vwc2V0XCI6XCLiioNcIixcIlN1cHNldFwiOlwi4ouRXCIsXCJzdXBzZXRlcVwiOlwi4oqHXCIsXCJzdXBzZXRlcXFcIjpcIuKrhlwiLFwic3Vwc2V0bmVxXCI6XCLiiotcIixcInN1cHNldG5lcXFcIjpcIuKrjFwiLFwic3Vwc2ltXCI6XCLiq4hcIixcInN1cHN1YlwiOlwi4quUXCIsXCJzdXBzdXBcIjpcIuKrllwiLFwic3dhcmhrXCI6XCLipKZcIixcInN3YXJyXCI6XCLihplcIixcInN3QXJyXCI6XCLih5lcIixcInN3YXJyb3dcIjpcIuKGmVwiLFwic3dud2FyXCI6XCLipKpcIixcInN6bGlnXCI6XCLDn1wiLFwiVGFiXCI6XCJcXHRcIixcInRhcmdldFwiOlwi4oyWXCIsXCJUYXVcIjpcIs6kXCIsXCJ0YXVcIjpcIs+EXCIsXCJ0YnJrXCI6XCLijrRcIixcIlRjYXJvblwiOlwixaRcIixcInRjYXJvblwiOlwixaVcIixcIlRjZWRpbFwiOlwixaJcIixcInRjZWRpbFwiOlwixaNcIixcIlRjeVwiOlwi0KJcIixcInRjeVwiOlwi0YJcIixcInRkb3RcIjpcIuKDm1wiLFwidGVscmVjXCI6XCLijJVcIixcIlRmclwiOlwi8J2Ul1wiLFwidGZyXCI6XCLwnZSxXCIsXCJ0aGVyZTRcIjpcIuKItFwiLFwidGhlcmVmb3JlXCI6XCLiiLRcIixcIlRoZXJlZm9yZVwiOlwi4oi0XCIsXCJUaGV0YVwiOlwizphcIixcInRoZXRhXCI6XCLOuFwiLFwidGhldGFzeW1cIjpcIs+RXCIsXCJ0aGV0YXZcIjpcIs+RXCIsXCJ0aGlja2FwcHJveFwiOlwi4omIXCIsXCJ0aGlja3NpbVwiOlwi4oi8XCIsXCJUaGlja1NwYWNlXCI6XCLigZ/igIpcIixcIlRoaW5TcGFjZVwiOlwi4oCJXCIsXCJ0aGluc3BcIjpcIuKAiVwiLFwidGhrYXBcIjpcIuKJiFwiLFwidGhrc2ltXCI6XCLiiLxcIixcIlRIT1JOXCI6XCLDnlwiLFwidGhvcm5cIjpcIsO+XCIsXCJ0aWxkZVwiOlwiy5xcIixcIlRpbGRlXCI6XCLiiLxcIixcIlRpbGRlRXF1YWxcIjpcIuKJg1wiLFwiVGlsZGVGdWxsRXF1YWxcIjpcIuKJhVwiLFwiVGlsZGVUaWxkZVwiOlwi4omIXCIsXCJ0aW1lc2JhclwiOlwi4qixXCIsXCJ0aW1lc2JcIjpcIuKKoFwiLFwidGltZXNcIjpcIsOXXCIsXCJ0aW1lc2RcIjpcIuKosFwiLFwidGludFwiOlwi4oitXCIsXCJ0b2VhXCI6XCLipKhcIixcInRvcGJvdFwiOlwi4oy2XCIsXCJ0b3BjaXJcIjpcIuKrsVwiLFwidG9wXCI6XCLiiqRcIixcIlRvcGZcIjpcIvCdlYtcIixcInRvcGZcIjpcIvCdlaVcIixcInRvcGZvcmtcIjpcIuKrmlwiLFwidG9zYVwiOlwi4qSpXCIsXCJ0cHJpbWVcIjpcIuKAtFwiLFwidHJhZGVcIjpcIuKEolwiLFwiVFJBREVcIjpcIuKEolwiLFwidHJpYW5nbGVcIjpcIuKWtVwiLFwidHJpYW5nbGVkb3duXCI6XCLilr9cIixcInRyaWFuZ2xlbGVmdFwiOlwi4peDXCIsXCJ0cmlhbmdsZWxlZnRlcVwiOlwi4oq0XCIsXCJ0cmlhbmdsZXFcIjpcIuKJnFwiLFwidHJpYW5nbGVyaWdodFwiOlwi4pa5XCIsXCJ0cmlhbmdsZXJpZ2h0ZXFcIjpcIuKKtVwiLFwidHJpZG90XCI6XCLil6xcIixcInRyaWVcIjpcIuKJnFwiLFwidHJpbWludXNcIjpcIuKoulwiLFwiVHJpcGxlRG90XCI6XCLig5tcIixcInRyaXBsdXNcIjpcIuKouVwiLFwidHJpc2JcIjpcIuKnjVwiLFwidHJpdGltZVwiOlwi4qi7XCIsXCJ0cnBleml1bVwiOlwi4o+iXCIsXCJUc2NyXCI6XCLwnZKvXCIsXCJ0c2NyXCI6XCLwnZOJXCIsXCJUU2N5XCI6XCLQplwiLFwidHNjeVwiOlwi0YZcIixcIlRTSGN5XCI6XCLQi1wiLFwidHNoY3lcIjpcItGbXCIsXCJUc3Ryb2tcIjpcIsWmXCIsXCJ0c3Ryb2tcIjpcIsWnXCIsXCJ0d2l4dFwiOlwi4omsXCIsXCJ0d29oZWFkbGVmdGFycm93XCI6XCLihp5cIixcInR3b2hlYWRyaWdodGFycm93XCI6XCLihqBcIixcIlVhY3V0ZVwiOlwiw5pcIixcInVhY3V0ZVwiOlwiw7pcIixcInVhcnJcIjpcIuKGkVwiLFwiVWFyclwiOlwi4oafXCIsXCJ1QXJyXCI6XCLih5FcIixcIlVhcnJvY2lyXCI6XCLipYlcIixcIlVicmN5XCI6XCLQjlwiLFwidWJyY3lcIjpcItGeXCIsXCJVYnJldmVcIjpcIsWsXCIsXCJ1YnJldmVcIjpcIsWtXCIsXCJVY2lyY1wiOlwiw5tcIixcInVjaXJjXCI6XCLDu1wiLFwiVWN5XCI6XCLQo1wiLFwidWN5XCI6XCLRg1wiLFwidWRhcnJcIjpcIuKHhVwiLFwiVWRibGFjXCI6XCLFsFwiLFwidWRibGFjXCI6XCLFsVwiLFwidWRoYXJcIjpcIuKlrlwiLFwidWZpc2h0XCI6XCLipb5cIixcIlVmclwiOlwi8J2UmFwiLFwidWZyXCI6XCLwnZSyXCIsXCJVZ3JhdmVcIjpcIsOZXCIsXCJ1Z3JhdmVcIjpcIsO5XCIsXCJ1SGFyXCI6XCLipaNcIixcInVoYXJsXCI6XCLihr9cIixcInVoYXJyXCI6XCLihr5cIixcInVoYmxrXCI6XCLiloBcIixcInVsY29yblwiOlwi4oycXCIsXCJ1bGNvcm5lclwiOlwi4oycXCIsXCJ1bGNyb3BcIjpcIuKMj1wiLFwidWx0cmlcIjpcIuKXuFwiLFwiVW1hY3JcIjpcIsWqXCIsXCJ1bWFjclwiOlwixatcIixcInVtbFwiOlwiwqhcIixcIlVuZGVyQmFyXCI6XCJfXCIsXCJVbmRlckJyYWNlXCI6XCLij59cIixcIlVuZGVyQnJhY2tldFwiOlwi4o61XCIsXCJVbmRlclBhcmVudGhlc2lzXCI6XCLij51cIixcIlVuaW9uXCI6XCLii4NcIixcIlVuaW9uUGx1c1wiOlwi4oqOXCIsXCJVb2dvblwiOlwixbJcIixcInVvZ29uXCI6XCLFs1wiLFwiVW9wZlwiOlwi8J2VjFwiLFwidW9wZlwiOlwi8J2VplwiLFwiVXBBcnJvd0JhclwiOlwi4qSSXCIsXCJ1cGFycm93XCI6XCLihpFcIixcIlVwQXJyb3dcIjpcIuKGkVwiLFwiVXBhcnJvd1wiOlwi4oeRXCIsXCJVcEFycm93RG93bkFycm93XCI6XCLih4VcIixcInVwZG93bmFycm93XCI6XCLihpVcIixcIlVwRG93bkFycm93XCI6XCLihpVcIixcIlVwZG93bmFycm93XCI6XCLih5VcIixcIlVwRXF1aWxpYnJpdW1cIjpcIuKlrlwiLFwidXBoYXJwb29ubGVmdFwiOlwi4oa/XCIsXCJ1cGhhcnBvb25yaWdodFwiOlwi4oa+XCIsXCJ1cGx1c1wiOlwi4oqOXCIsXCJVcHBlckxlZnRBcnJvd1wiOlwi4oaWXCIsXCJVcHBlclJpZ2h0QXJyb3dcIjpcIuKGl1wiLFwidXBzaVwiOlwiz4VcIixcIlVwc2lcIjpcIs+SXCIsXCJ1cHNpaFwiOlwiz5JcIixcIlVwc2lsb25cIjpcIs6lXCIsXCJ1cHNpbG9uXCI6XCLPhVwiLFwiVXBUZWVBcnJvd1wiOlwi4oalXCIsXCJVcFRlZVwiOlwi4oqlXCIsXCJ1cHVwYXJyb3dzXCI6XCLih4hcIixcInVyY29yblwiOlwi4oydXCIsXCJ1cmNvcm5lclwiOlwi4oydXCIsXCJ1cmNyb3BcIjpcIuKMjlwiLFwiVXJpbmdcIjpcIsWuXCIsXCJ1cmluZ1wiOlwixa9cIixcInVydHJpXCI6XCLil7lcIixcIlVzY3JcIjpcIvCdkrBcIixcInVzY3JcIjpcIvCdk4pcIixcInV0ZG90XCI6XCLii7BcIixcIlV0aWxkZVwiOlwixahcIixcInV0aWxkZVwiOlwixalcIixcInV0cmlcIjpcIuKWtVwiLFwidXRyaWZcIjpcIuKWtFwiLFwidXVhcnJcIjpcIuKHiFwiLFwiVXVtbFwiOlwiw5xcIixcInV1bWxcIjpcIsO8XCIsXCJ1d2FuZ2xlXCI6XCLipqdcIixcInZhbmdydFwiOlwi4qacXCIsXCJ2YXJlcHNpbG9uXCI6XCLPtVwiLFwidmFya2FwcGFcIjpcIs+wXCIsXCJ2YXJub3RoaW5nXCI6XCLiiIVcIixcInZhcnBoaVwiOlwiz5VcIixcInZhcnBpXCI6XCLPllwiLFwidmFycHJvcHRvXCI6XCLiiJ1cIixcInZhcnJcIjpcIuKGlVwiLFwidkFyclwiOlwi4oeVXCIsXCJ2YXJyaG9cIjpcIs+xXCIsXCJ2YXJzaWdtYVwiOlwiz4JcIixcInZhcnN1YnNldG5lcVwiOlwi4oqK77iAXCIsXCJ2YXJzdWJzZXRuZXFxXCI6XCLiq4vvuIBcIixcInZhcnN1cHNldG5lcVwiOlwi4oqL77iAXCIsXCJ2YXJzdXBzZXRuZXFxXCI6XCLiq4zvuIBcIixcInZhcnRoZXRhXCI6XCLPkVwiLFwidmFydHJpYW5nbGVsZWZ0XCI6XCLiirJcIixcInZhcnRyaWFuZ2xlcmlnaHRcIjpcIuKKs1wiLFwidkJhclwiOlwi4quoXCIsXCJWYmFyXCI6XCLiq6tcIixcInZCYXJ2XCI6XCLiq6lcIixcIlZjeVwiOlwi0JJcIixcInZjeVwiOlwi0LJcIixcInZkYXNoXCI6XCLiiqJcIixcInZEYXNoXCI6XCLiiqhcIixcIlZkYXNoXCI6XCLiiqlcIixcIlZEYXNoXCI6XCLiiqtcIixcIlZkYXNobFwiOlwi4qumXCIsXCJ2ZWViYXJcIjpcIuKKu1wiLFwidmVlXCI6XCLiiKhcIixcIlZlZVwiOlwi4ouBXCIsXCJ2ZWVlcVwiOlwi4omaXCIsXCJ2ZWxsaXBcIjpcIuKLrlwiLFwidmVyYmFyXCI6XCJ8XCIsXCJWZXJiYXJcIjpcIuKAllwiLFwidmVydFwiOlwifFwiLFwiVmVydFwiOlwi4oCWXCIsXCJWZXJ0aWNhbEJhclwiOlwi4oijXCIsXCJWZXJ0aWNhbExpbmVcIjpcInxcIixcIlZlcnRpY2FsU2VwYXJhdG9yXCI6XCLinZhcIixcIlZlcnRpY2FsVGlsZGVcIjpcIuKJgFwiLFwiVmVyeVRoaW5TcGFjZVwiOlwi4oCKXCIsXCJWZnJcIjpcIvCdlJlcIixcInZmclwiOlwi8J2Us1wiLFwidmx0cmlcIjpcIuKKslwiLFwidm5zdWJcIjpcIuKKguKDklwiLFwidm5zdXBcIjpcIuKKg+KDklwiLFwiVm9wZlwiOlwi8J2VjVwiLFwidm9wZlwiOlwi8J2Vp1wiLFwidnByb3BcIjpcIuKInVwiLFwidnJ0cmlcIjpcIuKKs1wiLFwiVnNjclwiOlwi8J2SsVwiLFwidnNjclwiOlwi8J2Ti1wiLFwidnN1Ym5FXCI6XCLiq4vvuIBcIixcInZzdWJuZVwiOlwi4oqK77iAXCIsXCJ2c3VwbkVcIjpcIuKrjO+4gFwiLFwidnN1cG5lXCI6XCLiiovvuIBcIixcIlZ2ZGFzaFwiOlwi4oqqXCIsXCJ2emlnemFnXCI6XCLipppcIixcIldjaXJjXCI6XCLFtFwiLFwid2NpcmNcIjpcIsW1XCIsXCJ3ZWRiYXJcIjpcIuKpn1wiLFwid2VkZ2VcIjpcIuKIp1wiLFwiV2VkZ2VcIjpcIuKLgFwiLFwid2VkZ2VxXCI6XCLiiZlcIixcIndlaWVycFwiOlwi4oSYXCIsXCJXZnJcIjpcIvCdlJpcIixcIndmclwiOlwi8J2UtFwiLFwiV29wZlwiOlwi8J2VjlwiLFwid29wZlwiOlwi8J2VqFwiLFwid3BcIjpcIuKEmFwiLFwid3JcIjpcIuKJgFwiLFwid3JlYXRoXCI6XCLiiYBcIixcIldzY3JcIjpcIvCdkrJcIixcIndzY3JcIjpcIvCdk4xcIixcInhjYXBcIjpcIuKLglwiLFwieGNpcmNcIjpcIuKXr1wiLFwieGN1cFwiOlwi4ouDXCIsXCJ4ZHRyaVwiOlwi4pa9XCIsXCJYZnJcIjpcIvCdlJtcIixcInhmclwiOlwi8J2UtVwiLFwieGhhcnJcIjpcIuKft1wiLFwieGhBcnJcIjpcIuKfulwiLFwiWGlcIjpcIs6eXCIsXCJ4aVwiOlwizr5cIixcInhsYXJyXCI6XCLin7VcIixcInhsQXJyXCI6XCLin7hcIixcInhtYXBcIjpcIuKfvFwiLFwieG5pc1wiOlwi4ou7XCIsXCJ4b2RvdFwiOlwi4qiAXCIsXCJYb3BmXCI6XCLwnZWPXCIsXCJ4b3BmXCI6XCLwnZWpXCIsXCJ4b3BsdXNcIjpcIuKogVwiLFwieG90aW1lXCI6XCLiqIJcIixcInhyYXJyXCI6XCLin7ZcIixcInhyQXJyXCI6XCLin7lcIixcIlhzY3JcIjpcIvCdkrNcIixcInhzY3JcIjpcIvCdk41cIixcInhzcWN1cFwiOlwi4qiGXCIsXCJ4dXBsdXNcIjpcIuKohFwiLFwieHV0cmlcIjpcIuKWs1wiLFwieHZlZVwiOlwi4ouBXCIsXCJ4d2VkZ2VcIjpcIuKLgFwiLFwiWWFjdXRlXCI6XCLDnVwiLFwieWFjdXRlXCI6XCLDvVwiLFwiWUFjeVwiOlwi0K9cIixcInlhY3lcIjpcItGPXCIsXCJZY2lyY1wiOlwixbZcIixcInljaXJjXCI6XCLFt1wiLFwiWWN5XCI6XCLQq1wiLFwieWN5XCI6XCLRi1wiLFwieWVuXCI6XCLCpVwiLFwiWWZyXCI6XCLwnZScXCIsXCJ5ZnJcIjpcIvCdlLZcIixcIllJY3lcIjpcItCHXCIsXCJ5aWN5XCI6XCLRl1wiLFwiWW9wZlwiOlwi8J2VkFwiLFwieW9wZlwiOlwi8J2VqlwiLFwiWXNjclwiOlwi8J2StFwiLFwieXNjclwiOlwi8J2TjlwiLFwiWVVjeVwiOlwi0K5cIixcInl1Y3lcIjpcItGOXCIsXCJ5dW1sXCI6XCLDv1wiLFwiWXVtbFwiOlwixbhcIixcIlphY3V0ZVwiOlwixblcIixcInphY3V0ZVwiOlwixbpcIixcIlpjYXJvblwiOlwixb1cIixcInpjYXJvblwiOlwixb5cIixcIlpjeVwiOlwi0JdcIixcInpjeVwiOlwi0LdcIixcIlpkb3RcIjpcIsW7XCIsXCJ6ZG90XCI6XCLFvFwiLFwiemVldHJmXCI6XCLihKhcIixcIlplcm9XaWR0aFNwYWNlXCI6XCLigItcIixcIlpldGFcIjpcIs6WXCIsXCJ6ZXRhXCI6XCLOtlwiLFwiemZyXCI6XCLwnZS3XCIsXCJaZnJcIjpcIuKEqFwiLFwiWkhjeVwiOlwi0JZcIixcInpoY3lcIjpcItC2XCIsXCJ6aWdyYXJyXCI6XCLih51cIixcInpvcGZcIjpcIvCdlatcIixcIlpvcGZcIjpcIuKEpFwiLFwiWnNjclwiOlwi8J2StVwiLFwienNjclwiOlwi8J2Tj1wiLFwiendqXCI6XCLigI1cIixcInp3bmpcIjpcIuKAjFwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fZW50aXRpZXNAMS4xLjFAZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJBYWN1dGVcIjpcIsOBXCIsXCJhYWN1dGVcIjpcIsOhXCIsXCJBY2lyY1wiOlwiw4JcIixcImFjaXJjXCI6XCLDolwiLFwiYWN1dGVcIjpcIsK0XCIsXCJBRWxpZ1wiOlwiw4ZcIixcImFlbGlnXCI6XCLDplwiLFwiQWdyYXZlXCI6XCLDgFwiLFwiYWdyYXZlXCI6XCLDoFwiLFwiYW1wXCI6XCImXCIsXCJBTVBcIjpcIiZcIixcIkFyaW5nXCI6XCLDhVwiLFwiYXJpbmdcIjpcIsOlXCIsXCJBdGlsZGVcIjpcIsODXCIsXCJhdGlsZGVcIjpcIsOjXCIsXCJBdW1sXCI6XCLDhFwiLFwiYXVtbFwiOlwiw6RcIixcImJydmJhclwiOlwiwqZcIixcIkNjZWRpbFwiOlwiw4dcIixcImNjZWRpbFwiOlwiw6dcIixcImNlZGlsXCI6XCLCuFwiLFwiY2VudFwiOlwiwqJcIixcImNvcHlcIjpcIsKpXCIsXCJDT1BZXCI6XCLCqVwiLFwiY3VycmVuXCI6XCLCpFwiLFwiZGVnXCI6XCLCsFwiLFwiZGl2aWRlXCI6XCLDt1wiLFwiRWFjdXRlXCI6XCLDiVwiLFwiZWFjdXRlXCI6XCLDqVwiLFwiRWNpcmNcIjpcIsOKXCIsXCJlY2lyY1wiOlwiw6pcIixcIkVncmF2ZVwiOlwiw4hcIixcImVncmF2ZVwiOlwiw6hcIixcIkVUSFwiOlwiw5BcIixcImV0aFwiOlwiw7BcIixcIkV1bWxcIjpcIsOLXCIsXCJldW1sXCI6XCLDq1wiLFwiZnJhYzEyXCI6XCLCvVwiLFwiZnJhYzE0XCI6XCLCvFwiLFwiZnJhYzM0XCI6XCLCvlwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJJYWN1dGVcIjpcIsONXCIsXCJpYWN1dGVcIjpcIsOtXCIsXCJJY2lyY1wiOlwiw45cIixcImljaXJjXCI6XCLDrlwiLFwiaWV4Y2xcIjpcIsKhXCIsXCJJZ3JhdmVcIjpcIsOMXCIsXCJpZ3JhdmVcIjpcIsOsXCIsXCJpcXVlc3RcIjpcIsK/XCIsXCJJdW1sXCI6XCLDj1wiLFwiaXVtbFwiOlwiw69cIixcImxhcXVvXCI6XCLCq1wiLFwibHRcIjpcIjxcIixcIkxUXCI6XCI8XCIsXCJtYWNyXCI6XCLCr1wiLFwibWljcm9cIjpcIsK1XCIsXCJtaWRkb3RcIjpcIsK3XCIsXCJuYnNwXCI6XCLCoFwiLFwibm90XCI6XCLCrFwiLFwiTnRpbGRlXCI6XCLDkVwiLFwibnRpbGRlXCI6XCLDsVwiLFwiT2FjdXRlXCI6XCLDk1wiLFwib2FjdXRlXCI6XCLDs1wiLFwiT2NpcmNcIjpcIsOUXCIsXCJvY2lyY1wiOlwiw7RcIixcIk9ncmF2ZVwiOlwiw5JcIixcIm9ncmF2ZVwiOlwiw7JcIixcIm9yZGZcIjpcIsKqXCIsXCJvcmRtXCI6XCLCulwiLFwiT3NsYXNoXCI6XCLDmFwiLFwib3NsYXNoXCI6XCLDuFwiLFwiT3RpbGRlXCI6XCLDlVwiLFwib3RpbGRlXCI6XCLDtVwiLFwiT3VtbFwiOlwiw5ZcIixcIm91bWxcIjpcIsO2XCIsXCJwYXJhXCI6XCLCtlwiLFwicGx1c21uXCI6XCLCsVwiLFwicG91bmRcIjpcIsKjXCIsXCJxdW90XCI6XCJcXFwiXCIsXCJRVU9UXCI6XCJcXFwiXCIsXCJyYXF1b1wiOlwiwrtcIixcInJlZ1wiOlwiwq5cIixcIlJFR1wiOlwiwq5cIixcInNlY3RcIjpcIsKnXCIsXCJzaHlcIjpcIsKtXCIsXCJzdXAxXCI6XCLCuVwiLFwic3VwMlwiOlwiwrJcIixcInN1cDNcIjpcIsKzXCIsXCJzemxpZ1wiOlwiw59cIixcIlRIT1JOXCI6XCLDnlwiLFwidGhvcm5cIjpcIsO+XCIsXCJ0aW1lc1wiOlwiw5dcIixcIlVhY3V0ZVwiOlwiw5pcIixcInVhY3V0ZVwiOlwiw7pcIixcIlVjaXJjXCI6XCLDm1wiLFwidWNpcmNcIjpcIsO7XCIsXCJVZ3JhdmVcIjpcIsOZXCIsXCJ1Z3JhdmVcIjpcIsO5XCIsXCJ1bWxcIjpcIsKoXCIsXCJVdW1sXCI6XCLDnFwiLFwidXVtbFwiOlwiw7xcIixcIllhY3V0ZVwiOlwiw51cIixcInlhY3V0ZVwiOlwiw71cIixcInllblwiOlwiwqVcIixcInl1bWxcIjpcIsO/XCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9lbnRpdGllc0AxLjEuMUBlbnRpdGllcy9tYXBzL2xlZ2FjeS5qc29uXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJhbXBcIjpcIiZcIixcImFwb3NcIjpcIidcIixcImd0XCI6XCI+XCIsXCJsdFwiOlwiPFwiLFwicXVvdFwiOlwiXFxcIlwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fZW50aXRpZXNAMS4xLjFAZW50aXRpZXMvbWFwcy94bWwuanNvblxuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInRyeSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuICBpZiAodHlwZW9mIHV0aWwuaW5oZXJpdHMgIT09ICdmdW5jdGlvbicpIHRocm93ICcnO1xuICBtb2R1bGUuZXhwb3J0cyA9IHV0aWwuaW5oZXJpdHM7XG59IGNhdGNoIChlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbmhlcml0c19icm93c2VyLmpzJyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2luaGVyaXRzQDIuMC4zQGluaGVyaXRzL2luaGVyaXRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2luaGVyaXRzQDIuMC4zQGluaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJldmVudHNcIlxuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9pc2FycmF5QDEuMC4wQGlzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJylcbnZhciBhcGkgPSByZXF1aXJlKCcuL2FwaS5qcycpXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdwb3N0aHRtbC1wYXJzZXInKVxudmFyIHJlbmRlciA9IHJlcXVpcmUoJ3Bvc3RodG1sLXJlbmRlcicpXG5cbi8qKlxuICogQGF1dGhvciBJdmFuIFZvaXNjaGV2IChAdm9pc2NoZXYpLFxuICogICAgICAgICBBbnRvbiBXaW5vZ3JhZG92IChAYXdpbm9ncmFkb3YpLFxuICogICAgICAgICBBbGV4ZWogWWFyb3NoZXZpY2ggKEB6eHFmb3gpLFxuICogICAgICAgICBWYXNpbGl5IChAWWV0aS1vcilcbiAqXG4gKiBAcmVxdWlyZXMgYXBpXG4gKiBAcmVxdWlyZXMgcG9zdGh0bWwtcGFyc2VyXG4gKiBAcmVxdWlyZXMgcG9zdGh0bWwtcmVuZGVyXG4gKlxuICogQGNvbnN0cnVjdG9yIFBvc3RIVE1MXG4gKiBAcGFyYW0ge0FycmF5fSBwbHVnaW5zIC0gQW4gYXJyYXkgb2YgUG9zdEhUTUwgcGx1Z2luc1xuICovXG5mdW5jdGlvbiBQb3N0SFRNTCAocGx1Z2lucykge1xuLyoqXG4gKiBQb3N0SFRNTCBJbnN0YW5jZVxuICpcbiAqIEBwcm9wIHBsdWdpbnNcbiAqIEBwcm9wIG9wdGlvbnNcbiAqL1xuICB0aGlzLnZlcnNpb24gPSBwa2cudmVyc2lvblxuICB0aGlzLm5hbWUgPSBwa2cubmFtZVxuICB0aGlzLnBsdWdpbnMgPSB0eXBlb2YgcGx1Z2lucyA9PT0gJ2Z1bmN0aW9uJyA/IFtwbHVnaW5zXSA6IHBsdWdpbnMgfHwgW11cbn1cblxuLyoqXG4gKiBAcmVxdWlyZXMgcG9zdGh0bWwtcGFyc2VyXG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gaHRtbCAtIElucHV0IChIVE1MKVxuICogQHJldHVybnMge0FycmF5fSAgdHJlZSAtIFBvc3RIVE1MVHJlZSAoSlNPTilcbiAqL1xuUG9zdEhUTUwucGFyc2VyID0gcGFyc2VyXG4vKipcbiAqIEByZXF1aXJlcyBwb3N0aHRtbC1yZW5kZXJcbiAqXG4gKiBAcGFyYW0gICB7QXJyYXl9ICB0cmVlIC0gUG9zdEhUTUxUcmVlIChKU09OKVxuICogQHJldHVybnMge1N0cmluZ30gaHRtbCAtIEhUTUxcbiAqL1xuUG9zdEhUTUwucmVuZGVyID0gcmVuZGVyXG5cbi8qKlxuKiBAdGhpcyBwb3N0aHRtbFxuKiBAcGFyYW0gICB7RnVuY3Rpb259IHBsdWdpbiAtIEEgUG9zdEhUTUwgcGx1Z2luXG4qIEByZXR1cm5zIHtDb25zdHJ1Y3Rvcn0gLSB0aGlzKFBvc3RIVE1MKVxuKlxuKiAqKlVzYWdlKipcbiogYGBganNcbiogcGgudXNlKCh0cmVlKSA9PiB7IHRhZzogJ2RpdicsIGNvbnRlbnQ6IHRyZWUgfSlcbiogICAucHJvY2VzcygnPGh0bWw+Li48L2h0bWw+Jywge30pXG4qICAgLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0KSlcbiogYGBgXG4qL1xuUG9zdEhUTUwucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgW10ucHVzaC5hcHBseSh0aGlzLnBsdWdpbnMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBAcGFyYW0gICB7U3RyaW5nfSBodG1sIC0gSW5wdXQgKEhUTUwpXG4gKiBAcGFyYW0gICB7P09iamVjdH0gb3B0aW9ucyAtIFBvc3RIVE1MIE9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3Q8e2h0bWw6IFN0cmluZywgdHJlZTogUG9zdEhUTUxUcmVlfT59IC0gU3luYyBNb2RlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7aHRtbDogU3RyaW5nLCB0cmVlOiBQb3N0SFRNTFRyZWV9Pn0gLSBBc3luYyBNb2RlIChkZWZhdWx0KVxuICpcbiAqICoqVXNhZ2UqKlxuICpcbiAqICoqU3luYyoqXG4gKiBgYGBqc1xuICogcGgucHJvY2VzcygnPGh0bWw+Li48L2h0bWw+JywgeyBzeW5jOiB0cnVlIH0pLmh0bWxcbiAqIGBgYFxuICpcbiAqICoqQXN5bmMqKlxuICogYGBganNcbiAqIHBoLnByb2Nlc3MoJzxodG1sPi4uPC9odG1sPicsIHt9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdCkpXG4gKiBgYGBcbiAqL1xuUG9zdEhUTUwucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAodHJlZSwgb3B0aW9ucykge1xuICAvKipcbiAgICogIyMgUG9zdEhUTUwgT3B0aW9uc1xuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcCB7P0Jvb2xlYW59IG9wdGlvbnMuc3luYyAtIGVuYWJsZXMgc3luYyBtb2RlLCBwbHVnaW5zIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksIHRocm93cyBhbiBlcnJvciB3aGVuIHVzZWQgd2l0aCBhc3luYyBwbHVnaW5zXG4gICAqIEBwcm9wIHs/RnVuY3Rpb259IG9wdGlvbnMucGFyc2VyIC0gdXNlIGN1c3RvbSBwYXJzZXIsIHJlcGxhY2VzIGRlZmF1bHQgKHBvc3RodG1sLXBhcnNlcilcbiAgICogQHByb3Agez9GdW5jdGlvbn0gb3B0aW9ucy5yZW5kZXIgLSB1c2UgY3VzdG9tIHJlbmRlciwgcmVwbGFjZXMgZGVmYXVsdCAocG9zdGh0bWwtcmVuZGVyKVxuICAgKiBAcHJvcCB7P0Jvb2xlYW59IG9wdGlvbnMuc2tpcFBhcnNlIC0gZGlzYWJsZSBwYXJzaW5nXG4gICAqL1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChvcHRpb25zLnBhcnNlcikgcGFyc2VyID0gb3B0aW9ucy5wYXJzZXJcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSByZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuXG4gIHRyZWUgPSBvcHRpb25zLnNraXBQYXJzZVxuICAgID8gdHJlZSB8fCBbXVxuICAgIDogcGFyc2VyKHRyZWUsIG9wdGlvbnMpXG5cbiAgdHJlZS5vcHRpb25zID0gb3B0aW9uc1xuICB0cmVlLnByb2Nlc3NvciA9IHRoaXNcblxuICAvLyBzeW5jIG1vZGVcbiAgaWYgKG9wdGlvbnMuc3luYyA9PT0gdHJ1ZSkge1xuICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIGFwaSh0cmVlKVxuXG4gICAgICB2YXIgcmVzdWx0XG5cbiAgICAgIGlmIChwbHVnaW4ubGVuZ3RoID09PSAyIHx8IGlzUHJvbWlzZShyZXN1bHQgPSBwbHVnaW4odHJlZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ2Fu4oCZdCBwcm9jZXNzIGNvbnRlbnRzIGluIHN5bmMgbW9kZSBiZWNhdXNlIG9mIGFzeW5jIHBsdWdpbjogJyArIHBsdWdpbi5uYW1lXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiB0aGUgcHJldmlvdXMgdHJlZSB1bmxlc3MgcmVzdWx0IGlzIGZ1bGZpbGxlZFxuICAgICAgdHJlZSA9IHJlc3VsdCB8fCB0cmVlXG4gICAgfSlcblxuICAgIHJldHVybiBsYXp5UmVzdWx0KHJlbmRlciwgdHJlZSlcbiAgfVxuXG4gIC8vIGFzeW5jIG1vZGVcbiAgdmFyIGkgPSAwXG5cbiAgdmFyIG5leHQgPSBmdW5jdGlvbiAocmVzdWx0LCBjYikge1xuICAgIC8vIGFsbCBwbHVnaW5zIGNhbGxlZFxuICAgIGlmICh0aGlzLnBsdWdpbnMubGVuZ3RoIDw9IGkpIHtcbiAgICAgIGNiKG51bGwsIHJlc3VsdClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGxpdHRsZSBoZWxwZXIgdG8gZ28gdG8gdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgZnVuY3Rpb24gX25leHQgKHJlcykge1xuICAgICAgcmV0dXJuIG5leHQocmVzIHx8IHJlc3VsdCwgY2IpXG4gICAgfVxuXG4gICAgLy8gKHJlKWV4dGVuZCB0aGUgb2JqZWN0XG4gICAgYXBpKHJlc3VsdClcblxuICAgIC8vIGNhbGwgbmV4dFxuICAgIHZhciBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbaSsrXVxuXG4gICAgaWYgKHBsdWdpbi5sZW5ndGggPT09IDIpIHtcbiAgICAgIHBsdWdpbihyZXN1bHQsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICBfbmV4dChyZXMpXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gc3luYyBhbmQgcHJvbWlzZWQgcGx1Z2luc1xuICAgIHZhciBlcnIgPSBudWxsXG5cbiAgICB2YXIgcmVzID0gdHJ5Q2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBsdWdpbihyZXN1bHQpXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGVyciA9IGVcbiAgICAgIHJldHVybiBlXG4gICAgfSlcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLnRoZW4oX25leHQpLmNhdGNoKGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgX25leHQocmVzKVxuICB9LmJpbmQodGhpcylcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIG5leHQodHJlZSwgZnVuY3Rpb24gKGVyciwgdHJlZSkge1xuICAgICAgaWYgKGVycikgcmVqZWN0KGVycilcbiAgICAgIGVsc2UgcmVzb2x2ZShsYXp5UmVzdWx0KHJlbmRlciwgdHJlZSkpXG4gICAgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBAZXhwb3J0cyBwb3N0aHRtbFxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBwbHVnaW5zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcG9zdGh0bWxcbiAqXG4gKiAqKlVzYWdlKipcbiAqIGBgYGpzXG4gKiBpbXBvcnQgcG9zdGh0bWwgZnJvbSAncG9zdGh0bWwnXG4gKiBpbXBvcnQgcGx1Z2luIGZyb20gJ3Bvc3RodG1sLXBsdWdpbidcbiAqXG4gKiBjb25zdCBwaCA9IHBvc3RodG1sKFsgcGx1Z2luKCkgXSlcbiAqIGBgYFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwbHVnaW5zKSB7XG4gIHJldHVybiBuZXcgUG9zdEhUTUwocGx1Z2lucylcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcGFyYW1ldGVyIGlzIGEgUHJvbWlzZSAob3IgdGhlbmFibGUpIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAgIHsqfSBwcm9taXNlIC0gVGFyZ2V0IGB7fWAgdG8gdGVzdFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSAocHJvbWlzZSkge1xuICByZXR1cm4gISFwcm9taXNlICYmIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbidcbn1cblxuLyoqXG4gKiBTaW1wbGUgdHJ5L2NhdGNoIGhlbHBlciwgaWYgZXhpc3RzLCByZXR1cm5zIHJlc3VsdFxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICAge0Z1bmN0aW9ufSB0cnlGbiAtIHRyeSBibG9ja1xuICogQHBhcmFtICAge0Z1bmN0aW9ufSBjYXRjaEZuIC0gY2F0Y2ggYmxvY2tcbiAqIEByZXR1cm5zIHs/Kn1cbiAqL1xuZnVuY3Rpb24gdHJ5Q2F0Y2ggKHRyeUZuLCBjYXRjaEZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRyeUZuKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2F0Y2hGbihlcnIpXG4gIH1cbn1cblxuIC8qKlxuICogV3JhcHMgdGhlIFBvc3RIVE1MVHJlZSB3aXRoaW4gYW4gb2JqZWN0IHVzaW5nIGEgZ2V0dGVyIHRvIHJlbmRlciBIVE1MIG9uIGRlbWFuZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcmVuZGVyXG4gKiBAcGFyYW0gICB7QXJyYXl9ICAgIHRyZWVcbiAqIEByZXR1cm5zIHtPYmplY3Q8e2h0bWw6IFN0cmluZywgdHJlZTogQXJyYXl9Pn1cbiAqL1xuZnVuY3Rpb24gbGF6eVJlc3VsdCAocmVuZGVyLCB0cmVlKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0IGh0bWwgKCkge1xuICAgICAgcmV0dXJuIHJlbmRlcih0cmVlLCB0cmVlLm9wdGlvbnMpXG4gICAgfSxcbiAgICB0cmVlOiB0cmVlLFxuICAgIG1lc3NhZ2VzOiB0cmVlLm1lc3NhZ2VzXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fcG9zdGh0bWxAMC4xMS4yQHBvc3RodG1sL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wibmFtZVwiOlwicG9zdGh0bWxcIixcInZlcnNpb25cIjpcIjAuMTEuMlwiLFwiZGVzY3JpcHRpb25cIjpcIkhUTUwvWE1MIHByb2Nlc3NvclwiLFwia2V5d29yZHNcIjpbXCJodG1sXCIsXCJ4bWxcIixcInBvc3Rwcm9jY2Vzc29yXCIsXCJwYXJzZXJcIixcInRyYW5zZm9ybVwiLFwidHJhbnNmb3JtYXRpb25zXCIsXCJtYW5pcHVsYXRpb25cIixcInByZXByb2Nlc3NvclwiLFwicHJvY2Vzc29yXCJdLFwibWFpblwiOlwibGliXCIsXCJmaWxlc1wiOltcImxpYlwiXSxcImVuZ2luZXNcIjp7XCJub2RlXCI6XCI+PTAuMTAuMFwifSxcImRlcGVuZGVuY2llc1wiOntcInBvc3RodG1sLXBhcnNlclwiOlwiXjAuMy4zXCIsXCJwb3N0aHRtbC1yZW5kZXJcIjpcIl4xLjEuMFwifSxcImRldkRlcGVuZGVuY2llc1wiOntcImNoYWlcIjpcIl4zLjAuMFwiLFwiY2hhaS1hcy1wcm9taXNlZFwiOlwiXjYuMC4wXCIsXCJjaGFpLXN1YnNldFwiOlwiXjEuMS4wXCIsXCJlczYtcHJvbWlzZVwiOlwiXjQuMC41XCIsXCJpc3RhbmJ1bFwiOlwiXjAuNC4yXCIsXCJqc2RvYy10by1tYXJrZG93blwiOlwiXjMuMC4wXCIsXCJtb2NoYVwiOlwiXjMuNC4wXCIsXCJtdmVyc2lvblwiOlwiXjEuMTAuMFwiLFwib2JqZWN0LmFzc2lnblwiOlwiXjQuMC4zXCIsXCJzdGFuZGFyZFwiOlwiXjEwLjAuMlwiLFwic3RhbmRhcmQtdmVyc2lvblwiOlwiXjQuMi4wXCJ9LFwic2NyaXB0c1wiOntcImxpbnRcIjpcInN0YW5kYXJkXCIsXCJ0ZXN0XCI6XCJucG0gcnVuIGxpbnQgJiYgbW9jaGEgLVIgZG90ICYmIG5wbSBydW4gY292ZXJcIixcImNsZWFuXCI6XCJybSAtcmYgY292ZXJhZ2UganNkb2MtYXBpXCIsXCJjb3ZlclwiOlwiaXN0YW5idWwgY292ZXIgLS1yZXBvcnQgdGV4dCAtLXJlcG9ydCBodG1sIC0tcmVwb3J0IGxjb3Ygbm9kZV9tb2R1bGVzL21vY2hhL2Jpbi9fbW9jaGEgLS0gLVIgdGFwXCIsXCJkb2NzOmFwaVwiOlwianNkb2MybWQgbGliL2FwaS5qcyA+IGRvY3MvYXBpLm1kXCIsXCJkb2NzOmNvcmVcIjpcImpzZG9jMm1kIGxpYi9pbmRleC5qcyA+IGRvY3MvY29yZS5tZFwiLFwicmVsZWFzZVwiOlwic3RhbmRhcmQtdmVyc2lvblwifSxcImF1dGhvclwiOlwiQW50b24gV2lub2dyYWRvdiA8d2lub2dyYWRvdmFhQGdtYWlsLmNvbT5cIixcImNvbnRyaWJ1dG9yc1wiOlt7XCJuYW1lXCI6XCJJdmFuIFZvaXNjaGV2XCIsXCJlbWFpbFwiOlwidm9pc2NoZXYuaXZhbkB5YS5ydVwifSx7XCJuYW1lXCI6XCJBbnRvbiBXaW5vZ3JhZG92XCIsXCJlbWFpbFwiOlwid2lub2dyYWRvdmFhQGdtYWlsLmNvbVwifSx7XCJuYW1lXCI6XCJBbGV4ZWogWWFyb3NoZXZpY2hcIixcImVtYWlsXCI6XCJ6eHFmb3hAZ21haWwuY29tXCJ9XSxcImhvbWVwYWdlXCI6XCJodHRwczovL2dpdGh1Yi5jb20vcG9zdGh0bWwvcG9zdGh0bWxcIixcInJlcG9zaXRvcnlcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0aHRtbC9wb3N0aHRtbC5naXRcIixcImJ1Z3NcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0aHRtbC9wb3N0aHRtbC9pc3N1ZXNcIixcImxpY2Vuc2VcIjpcIk1JVFwiLFwiX2Zyb21cIjpcInBvc3RodG1sQDAuMTEuMlwiLFwiX3Jlc29sdmVkXCI6XCJodHRwOi8vcmVnaXN0cnkubnBtLnRhb2Jhby5vcmcvcG9zdGh0bWwvZG93bmxvYWQvcG9zdGh0bWwtMC4xMS4yLnRnelwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fcG9zdGh0bWxAMC4xMS4yQHBvc3RodG1sL3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBhcnNlciA9IHJlcXVpcmUoJ2h0bWxwYXJzZXIyL2xpYi9QYXJzZXInKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZiNTUvaHRtbHBhcnNlcjIvd2lraS9QYXJzZXItb3B0aW9uc1xuICovXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7bG93ZXJDYXNlVGFnczogZmFsc2UsIGxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiBmYWxzZX07XG5cbnZhciBkZWZhdWx0RGlyZWN0aXZlcyA9IFt7bmFtZTogJyFkb2N0eXBlJywgc3RhcnQ6ICc8JywgZW5kOiAnPid9XTtcblxuLyoqXG4gKiBQYXJzZSBodG1sIHRvIFBvc3RIVE1MVHJlZVxuICogQHBhcmFtICB7U3RyaW5nfSBodG1sXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPWRlZmF1bHRPcHRpb25zXVxuICogQHJldHVybiB7UG9zdEhUTUxUcmVlfVxuICovXG5mdW5jdGlvbiBwb3N0SFRNTFBhcnNlcihodG1sLCBvcHRpb25zKSB7XG4gICAgdmFyIGJ1ZkFycmF5ID0gW10sXG4gICAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgIGJ1ZkFycmF5Lmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VyRGlyZWN0aXZlKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBbXS5jb25jYXQoZGVmYXVsdERpcmVjdGl2ZXMsIG9wdGlvbnMuZGlyZWN0aXZlcyB8fCBbXSk7XG4gICAgICAgIHZhciBsYXN0ID0gYnVmQXJyYXkubGFzdCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IGRpcmVjdGl2ZXNbaV07XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlVGV4dCA9IGRpcmVjdGl2ZS5zdGFydCArIGRhdGEgKyBkaXJlY3RpdmUuZW5kO1xuXG4gICAgICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpID09PSBkaXJlY3RpdmUubmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZGlyZWN0aXZlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXN0LmNvbnRlbnQgfHwgKGxhc3QuY29udGVudCA9IFtdKTtcbiAgICAgICAgICAgICAgICBsYXN0LmNvbnRlbnQucHVzaChkaXJlY3RpdmVUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFycmlidXRlcyhhdHRycykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gYXR0cnNba2V5XS5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJyk7XG4gICAgICAgICAgICBvYmplY3RBc3NpZ24ocmVzdWx0LCBvYmopO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHtcbiAgICAgICAgb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb246IHBhcnNlckRpcmVjdGl2ZSxcbiAgICAgICAgb25jb21tZW50OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9ICc8IS0tJyArIGRhdGEgKyAnLS0+JyxcbiAgICAgICAgICAgICAgICBsYXN0ID0gYnVmQXJyYXkubGFzdCgpO1xuXG4gICAgICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0LmNvbnRlbnQgfHwgKGxhc3QuY29udGVudCA9IFtdKTtcbiAgICAgICAgICAgIGxhc3QuY29udGVudC5wdXNoKGNvbW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbm9wZW50YWc6IGZ1bmN0aW9uKHRhZywgYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSB7IHRhZzogdGFnIH07XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnVmLmF0dHJzID0gbm9ybWFsaXplQXJyaWJ1dGVzKGF0dHJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmQXJyYXkucHVzaChidWYpO1xuICAgICAgICB9LFxuICAgICAgICBvbmNsb3NldGFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBidWZBcnJheS5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKCFidWZBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goYnVmKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXN0ID0gYnVmQXJyYXkubGFzdCgpO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhc3QuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBsYXN0LmNvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdC5jb250ZW50LnB1c2goYnVmKTtcbiAgICAgICAgfSxcbiAgICAgICAgb250ZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGJ1ZkFycmF5Lmxhc3QoKTtcbiAgICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3QuY29udGVudCB8fCAobGFzdC5jb250ZW50ID0gW10pO1xuICAgICAgICAgICAgbGFzdC5jb250ZW50LnB1c2godGV4dCk7XG4gICAgICAgIH1cbiAgICB9LCBvcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zKTtcblxuICAgIHBhcnNlci53cml0ZShodG1sKTtcbiAgICBwYXJzZXIuZW5kKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcGFyc2VyV3JhcHBlcigpIHtcbiAgICB2YXIgb3B0aW9uO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VyKGh0bWwpIHtcbiAgICAgICAgdmFyIG9wdCA9IG9iamVjdEFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9uKTtcbiAgICAgICAgcmV0dXJuIHBvc3RIVE1MUGFyc2VyKGh0bWwsIG9wdCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNPYmplY3QoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBvcHRpb24gPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgfVxuXG4gICAgb3B0aW9uID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiBwYXJzZXIoYXJndW1lbnRzWzBdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZXJXcmFwcGVyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHREaXJlY3RpdmVzID0gZGVmYXVsdERpcmVjdGl2ZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3Bvc3RodG1sLXBhcnNlckAwLjMuM0Bwb3N0aHRtbC1wYXJzZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge1BhZ2V9IGZyb20gXCIuL1BhZ2VcIlxyXG5pbXBvcnQge2VuY3J5cHRDb2RlfSBmcm9tIFwiLi4vY29tbW9uL2VuY3J5cHRcIjtcclxuaW1wb3J0IHtwcm9ncmFtfSBmcm9tIFwiLi4vY29tbW9uL2FzdFF1ZXJ5XCI7XHJcbmltcG9ydCAqIGFzIHBvc3RodG1sIGZyb20gJ3Bvc3RodG1sJ1xyXG5pbXBvcnQgKiBhcyBwYXJzZXIgZnJvbSAncG9zdGh0bWwtcGFyc2VyJ1xyXG5pbXBvcnQgKiBhcyByZW5kZXIgZnJvbSAncG9zdGh0bWwtcmVuZGVyJ1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnXHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJ1xyXG5sZXQgd2FsayA9IHJlcXVpcmUoJ3Bvc3RodG1sL2xpYi9hcGknKS53YWxrXHJcbmxldCBtYXRjaCA9IHJlcXVpcmUoJ3Bvc3RodG1sL2xpYi9hcGknKS5tYXRjaFxyXG5pbXBvcnQgeyBlbnRyaWVzIH0gZnJvbSAnLi4vY29tbW9uL1Rvb2xzJztcclxuaW1wb3J0IHtjb25maWd9IGZyb20gXCIuLi9jb21tb24vY29uZlwiXHJcblxyXG5jb25zb2xlLmxvZyhjb25maWcpXHJcbi8vaW1wb3J0IHtyZWFkLHdyaXRlRmlsZX0gZnJvbSBcIi4uL2NvbW1vbi9Ub29sc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEh0bWxQYWdlIGV4dGVuZHMgIFBhZ2V7XHJcblxyXG4gICAgXHJcbiAgICBwcml2YXRlIHNjcmlwdHM6QXJyYXk8c3RyaW5nPjtcclxuICAgIHByaXZhdGUgc3R5bGVzOkFycmF5PHN0cmluZz47XHJcbiAgICBwcml2YXRlIGNvbnRlbnQ6c3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBmcm9tRGlyOnN0cmluZztcclxuICAgIHByaXZhdGUgSnNPdXRQYXRoOnN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihmcm9tOnN0cmluZyx0bzpzdHJpbmcsSnNPdXRQYXRoOnN0cmluZyl7XHJcbiAgICAgICAgc3VwZXIoZnJvbSx0byk7XHJcblxyXG4gICAgICAgIHRoaXMuZnJvbURpciA9IHBhdGguZGlybmFtZShmcm9tKTtcclxuICAgICAgICB0aGlzLkpzT3V0UGF0aCA9IEpzT3V0UGF0aDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmVhZCggSU46c3RyaW5nKTpzdHJpbmd7XHJcblxyXG4gICAgICAgIGxldCB0ZXh0ID0gc3VwZXIucmVhZChJTik7XHJcbiAgICAgICAgaWYoSU4uZW5kc1dpdGgoXCJjb25maWcuanNcIikpeyAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCB0cmVlID0gcHJvZ3JhbSh0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgb2YgT2JqZWN0LmtleXMoY29uZmlnKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHYgPSBjb25maWdba107XHJcbiAgICAgICAgICAgICAgICB0cmVlLnNldFZhcmlhYmxlKGssdilcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgdGV4dCA9IHRyZWUuZ2VuZXJhdG9yKCk7XHJcblxyXG4gICAgICAgICAgICAvL3RyZWUuc2V0VmFyaWFibGUoKVxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBwYXJzZUh0bWwoKXtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMucmVhZCh0aGlzLmZyb20pO1xyXG4gICAgICAgICAgICBsZXQgYXN0ID0gIHBhcnNlcih0aGlzLmNvbnRlbnQpO1xyXG5cclxuICAgICAgICAgICAgYXN0ID10aGlzLnBhcnNlSHRtbFNjcmlwdChhc3QpIDtcclxuXHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgID0gIHJlbmRlcihhc3QpXHJcblxyXG5cclxuICAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcGFyc2VIdG1sU2NyaXB0KGFzdCl7XHJcbiAgICAgICAgLy9sZXQgYXN0ID0gIHBhcnNlcih0aGlzLmNvbnRlbnQpO1xyXG5cclxuICAgICAgICBsZXQgbGlua3MgPVtdO1xyXG4gICAgICAgIGxldCBhc3QxID0gbWF0Y2guY2FsbChhc3QsIFt7IHRhZzogJ3NjcmlwdCcgfV0sICAobm9kZSk9PiB7XHJcbiAgICAgICAgICAgIGxldCByb290ID0gdGhpcy5mcm9tRGlyO1xyXG4gICAgICAgICAgICBpZihub2RlICYmbm9kZS50YWcgPT0gXCJzY3JpcHRcIiAmJiBub2RlLmF0dHJzICYmIG5vZGUuYXR0cnMuc3JjKXtcclxuICAgICAgICAgICAgICAgIGxldCBwID0gcGF0aC5yZXNvbHZlKHJvb3Qsbm9kZS5hdHRycy5zcmMpXHJcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRhZzpmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6XCJcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zY3JpcHRzID0gbGlua3M7XHJcblxyXG5cclxuICAgICAgICBsZXQgdHQxID0gbWF0Y2guY2FsbChhc3QxLCBbeyB0YWc6ICdoZWFkJyB9XSwgIChub2RlKT0+IHtcclxuICAgICAgICAgICAgbGV0IHNjcmlwdF9wYXRoID0gcGF0aC5yZWxhdGl2ZSggIHBhdGguZGlybmFtZSh0aGlzLnRvKSAsdGhpcy5Kc091dFBhdGgpO1xyXG4gICAgICAgICAgICB2YXIgc2NyaXB0X25vZGUgPXsgdGFnOiAnc2NyaXB0JywgYXR0cnM6IHsgc3JjOiBzY3JpcHRfcGF0aCB9IH07XHJcbiAgICAgICAgICAgIGlmKG5vZGUgJiYgbm9kZS50YWcgPT0gXCJoZWFkXCIpe1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50LnB1c2goc2NyaXB0X25vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHR0MVxyXG4gICAgfVxyXG5cclxuICAgIG1lcmdlU2NyaXB0KCl7XHJcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xyXG5cclxuICAgICAgICB0aGlzLnNjcmlwdHMuZm9yRWFjaCgobGluayk9PntcclxuICAgICAgICAgICAgdGV4dCArPVwiO1wiKyB0aGlzLnJlYWQobGluaylcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgb3BlcmF0ZSgpe1xyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdGhpcy5wYXJzZUh0bWwoKTtcclxuICAgICAgICB0aGlzLndyaXRlRmlsZSh0aGlzLmNvbnRlbnQsdGhpcy50byk7XHJcbiAgICAgICAgbGV0IHR4dCA9dGhpcy5tZXJnZVNjcmlwdCgpO1xyXG5cclxuICAgICAgICBsZXQgcDpQcm9taXNlPGFueT4gPSBlbmNyeXB0Q29kZSh0eHQpO1xyXG4gICAgICAgIHAudGhlbiggKGRhdGEpPT57XHJcblxyXG4gICAgICAgICAgICB0aGlzLndyaXRlRmlsZShkYXRhLHRoaXMuSnNPdXRQYXRoKTtcclxuXHJcbiAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgIH0gKS5jYXRjaCgoZSk9PntcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLliqDlr4YtLS0tLT5cIixlKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuICBcclxuXHJcblxyXG5cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2pvL0h0bWxQYWdlLnRzIiwiaW1wb3J0ICogYXMgYmFieWxvbiBmcm9tICdiYWJ5bG9uJztcclxuaW1wb3J0IHRyYXZlcnNlIGZyb20gXCJiYWJlbC10cmF2ZXJzZVwiO1xyXG5pbXBvcnQgZ2VuZXJhdG9yIGZyb20gXCJiYWJlbC1nZW5lcmF0b3JcIjtcclxudmFyIHR5cGVzID0gcmVxdWlyZSgnYmFiZWwtdHlwZXMnKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcHJvZ3JhbShqcyl7XHJcbiAgICByZXR1cm4gbmV3IGpzUGFyc2VyKGpzKTtcclxufSBcclxuXHJcblxyXG5jbGFzcyBqc1BhcnNlcntcclxuXHJcbiAgICBwcml2YXRlIGFzdDtcclxuICAgIHByaXZhdGUgS21hcDpvYmplY3QgPSBuZXcgT2JqZWN0KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29kZSl7XHJcblxyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdGhpcy5wcm9ncmFtKGNvZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb2dyYW0oY29kZSl7XHJcbiAgICAgICAgdGhpcy5hc3QgPSBiYWJ5bG9uLnBhcnNlKGNvZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFZhcmlhYmxlKGssdil7XHJcbiAgICAgICAgdGhpcy5LbWFwW2tdID0gdjtcclxuICAgIH1cclxuXHJcbiAgICB0cmF2ZXJzZSgpe1xyXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgICAgICB0cmF2ZXJzZSh0aGlzLmFzdCwge1xyXG4gICAgICAgICAgICBlbnRlcihwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9KCBwYXRoLm5vZGUgYXMgYW55KTtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5wYXJlbnRQYXRoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudE5vZGUgPSAocGF0aC5wYXJlbnRQYXRoLm5vZGUgYXMgYW55KSA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkICA9IHBhcmVudE5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluaXQgID0gcGFyZW50Tm9kZS5pbml0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgucGFyZW50UGF0aC5pc1ZhcmlhYmxlRGVjbGFyYXRvcih7IGluaXQ6IG5vZGUgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcGF0aC5pc0xpdGVyYWwoKSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcGFyZW50Tm9kZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgdHlwZXMuaXNJZGVudGlmaWVyKGlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLkttYXBbaWQubmFtZV0gXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCB2ID0gc2VsZi5LbWFwW2lkLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vZGUgLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZW5lcmF0b3IoKXtcclxuXHJcbiAgICAgICAgdGhpcy50cmF2ZXJzZSgpXHJcblxyXG4gICAgICAgIHJldHVybiBnZW5lcmF0b3IodGhpcy5hc3QpLmNvZGU7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59XHJcblxyXG5cclxuXHJcbi8vIGxldCBjb2RlMSA9IGdlbmVyYXRvcihhc3QpO1xyXG5cclxuXHJcbi8vIGNvbnNvbGUubG9nKGNvZGUxKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL2FzdFF1ZXJ5LnRzIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXQgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktc3ltYm9sc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5rZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpO1xudmFyICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7IHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnkgfSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvZm9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2Zvci5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sWydmb3InXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2Zvci5qc1xuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2tleXMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5leHBvcnRzLmlzQmluZGluZyA9IGlzQmluZGluZztcbmV4cG9ydHMuaXNSZWZlcmVuY2VkID0gaXNSZWZlcmVuY2VkO1xuZXhwb3J0cy5pc1ZhbGlkSWRlbnRpZmllciA9IGlzVmFsaWRJZGVudGlmaWVyO1xuZXhwb3J0cy5pc0xldCA9IGlzTGV0O1xuZXhwb3J0cy5pc0Jsb2NrU2NvcGVkID0gaXNCbG9ja1Njb3BlZDtcbmV4cG9ydHMuaXNWYXIgPSBpc1ZhcjtcbmV4cG9ydHMuaXNTcGVjaWZpZXJEZWZhdWx0ID0gaXNTcGVjaWZpZXJEZWZhdWx0O1xuZXhwb3J0cy5pc1Njb3BlID0gaXNTY29wZTtcbmV4cG9ydHMuaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZTtcbmV4cG9ydHMuaXNOb2Rlc0VxdWl2YWxlbnQgPSBpc05vZGVzRXF1aXZhbGVudDtcblxudmFyIF9yZXRyaWV2ZXJzID0gcmVxdWlyZShcIi4vcmV0cmlldmVyc1wiKTtcblxudmFyIF9lc3V0aWxzID0gcmVxdWlyZShcImVzdXRpbHNcIik7XG5cbnZhciBfZXN1dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lc3V0aWxzKTtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuXG52YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbmRleCk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0JpbmRpbmcobm9kZSwgcGFyZW50KSB7XG4gIHZhciBrZXlzID0gX3JldHJpZXZlcnMuZ2V0QmluZGluZ0lkZW50aWZpZXJzLmtleXNbcGFyZW50LnR5cGVdO1xuICBpZiAoa2V5cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsID0gcGFyZW50W2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGlmICh2YWwuaW5kZXhPZihub2RlKSA+PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWwgPT09IG5vZGUpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNSZWZlcmVuY2VkKG5vZGUsIHBhcmVudCkge1xuICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgY2FzZSBcIkJpbmRFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gcGFyZW50Lm9iamVjdCA9PT0gbm9kZSB8fCBwYXJlbnQuY2FsbGVlID09PSBub2RlO1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSAmJiBwYXJlbnQuY29tcHV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5vYmplY3QgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIFwiTWV0YVByb3BlcnR5XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICAgIGlmIChwYXJlbnQua2V5ID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuY29tcHV0ZWQ7XG4gICAgICB9XG5cbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6XG4gICAgICByZXR1cm4gcGFyZW50LmlkICE9PSBub2RlO1xuXG4gICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBwYXJlbnQucGFyYW1zLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcik7Oykge1xuICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJhbSA9IF9yZWY7XG5cbiAgICAgICAgaWYgKHBhcmFtID09PSBub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnQuaWQgIT09IG5vZGU7XG5cbiAgICBjYXNlIFwiRXhwb3J0U3BlY2lmaWVyXCI6XG4gICAgICBpZiAocGFyZW50LnNvdXJjZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyZW50LmxvY2FsID09PSBub2RlO1xuICAgICAgfVxuXG4gICAgY2FzZSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiSlNYQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gcGFyZW50Lm5hbWUgIT09IG5vZGU7XG5cbiAgICBjYXNlIFwiQ2xhc3NQcm9wZXJ0eVwiOlxuICAgICAgaWYgKHBhcmVudC5rZXkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jb21wdXRlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQudmFsdWUgPT09IG5vZGU7XG4gICAgICB9XG5cbiAgICBjYXNlIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiSW1wb3J0U3BlY2lmaWVyXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQuaWQgIT09IG5vZGU7XG5cbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgICByZXR1cm4gcGFyZW50LmtleSA9PT0gbm9kZSAmJiBwYXJlbnQuY29tcHV0ZWQ7XG5cbiAgICBjYXNlIFwiTGFiZWxlZFN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgICByZXR1cm4gcGFyZW50LnBhcmFtICE9PSBub2RlO1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQucmlnaHQgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHJldHVybiBwYXJlbnQucmlnaHQgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkSWRlbnRpZmllcihuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBfZXN1dGlsczIuZGVmYXVsdC5rZXl3b3JkLmlzUmVzZXJ2ZWRXb3JkRVM2KG5hbWUsIHRydWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiYXdhaXRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gX2VzdXRpbHMyLmRlZmF1bHQua2V5d29yZC5pc0lkZW50aWZpZXJOYW1lRVM2KG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGV0KG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpICYmIChub2RlLmtpbmQgIT09IFwidmFyXCIgfHwgbm9kZVtfY29uc3RhbnRzLkJMT0NLX1NDT1BFRF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNCbG9ja1Njb3BlZChub2RlKSB7XG4gIHJldHVybiB0LmlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKSB8fCB0LmlzQ2xhc3NEZWNsYXJhdGlvbihub2RlKSB8fCB0LmlzTGV0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBpc1Zhcihub2RlKSB7XG4gIHJldHVybiB0LmlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlLCB7IGtpbmQ6IFwidmFyXCIgfSkgJiYgIW5vZGVbX2NvbnN0YW50cy5CTE9DS19TQ09QRURfU1lNQk9MXTtcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWZpZXJEZWZhdWx0KHNwZWNpZmllcikge1xuICByZXR1cm4gdC5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIoc3BlY2lmaWVyKSB8fCB0LmlzSWRlbnRpZmllcihzcGVjaWZpZXIuaW1wb3J0ZWQgfHwgc3BlY2lmaWVyLmV4cG9ydGVkLCB7IG5hbWU6IFwiZGVmYXVsdFwiIH0pO1xufVxuXG5mdW5jdGlvbiBpc1Njb3BlKG5vZGUsIHBhcmVudCkge1xuICBpZiAodC5pc0Jsb2NrU3RhdGVtZW50KG5vZGUpICYmIHQuaXNGdW5jdGlvbihwYXJlbnQsIHsgYm9keTogbm9kZSB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0LmlzU2NvcGFibGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzSW1tdXRhYmxlKG5vZGUpIHtcbiAgaWYgKHQuaXNUeXBlKG5vZGUudHlwZSwgXCJJbW11dGFibGVcIikpIHJldHVybiB0cnVlO1xuXG4gIGlmICh0LmlzSWRlbnRpZmllcihub2RlKSkge1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc05vZGVzRXF1aXZhbGVudChhLCBiKSB7XG4gIGlmICgodHlwZW9mIGEgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGEpKSAhPT0gXCJvYmplY3RcIiB8fCAodHlwZW9mIGEgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGEpKSAhPT0gXCJvYmplY3RcIiB8fCBhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZmllbGRzID0gKDAsIF9rZXlzMi5kZWZhdWx0KSh0Lk5PREVfRklFTERTW2EudHlwZV0gfHwgYS50eXBlKTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZmllbGRzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjIpOzspIHtcbiAgICB2YXIgX3JlZjI7XG5cbiAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBmaWVsZCA9IF9yZWYyO1xuXG4gICAgaWYgKCgwLCBfdHlwZW9mMy5kZWZhdWx0KShhW2ZpZWxkXSkgIT09ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShiW2ZpZWxkXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhW2ZpZWxkXSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShiW2ZpZWxkXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGFbZmllbGRdLmxlbmd0aCAhPT0gYltmaWVsZF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhW2ZpZWxkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTm9kZXNFcXVpdmFsZW50KGFbZmllbGRdW2ldLCBiW2ZpZWxkXVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghaXNOb2Rlc0VxdWl2YWxlbnQoYVtmaWVsZF0sIGJbZmllbGRdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzL2xpYi92YWxpZGF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgJ0FTIElTJ1xuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGlzRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdDb25kaXRpb25hbEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ05ld0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGlvblN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdEb1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvckluU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdXaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRW1wdHlTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdGb3JJblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnTGFiZWxlZFN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdSZXR1cm5TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnU3dpdGNoU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1Rocm93U3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1RyeVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1dpdGhTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NvdXJjZUVsZW1lbnQobm9kZSkge1xuICAgICAgcmV0dXJuIGlzU3RhdGVtZW50KG5vZGUpIHx8IG5vZGUgIT0gbnVsbCAmJiBub2RlLnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFpbGluZ1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29uc2VxdWVudDtcblxuICAgICAgICBjYXNlICdMYWJlbGVkU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdXaGlsZVN0YXRlbWVudCc6XG4gICAgICAgIGNhc2UgJ1dpdGhTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgY3VycmVudDtcblxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbm9kZS5jb25zZXF1ZW50O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlID09IG51bGwpICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSB0cmFpbGluZ1N0YXRlbWVudChjdXJyZW50KTtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0V4cHJlc3Npb246IGlzRXhwcmVzc2lvbixcbiAgICAgICAgaXNTdGF0ZW1lbnQ6IGlzU3RhdGVtZW50LFxuICAgICAgICBpc0l0ZXJhdGlvblN0YXRlbWVudDogaXNJdGVyYXRpb25TdGF0ZW1lbnQsXG4gICAgICAgIGlzU291cmNlRWxlbWVudDogaXNTb3VyY2VFbGVtZW50LFxuICAgICAgICBpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQ6IGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudCxcblxuICAgICAgICB0cmFpbGluZ1N0YXRlbWVudDogdHJhaWxpbmdTdGF0ZW1lbnRcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2VzdXRpbHNAMi4wLjJAZXN1dGlscy9saWIvYXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBjb2RlID0gcmVxdWlyZSgnLi9jb2RlJyk7XG5cbiAgICBmdW5jdGlvbiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmRFUzYoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICBjYXNlICdpbXBsZW1lbnRzJzpcbiAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgICAgY2FzZSAncGFja2FnZSc6XG4gICAgICAgIGNhc2UgJ3ByaXZhdGUnOlxuICAgICAgICBjYXNlICdwcm90ZWN0ZWQnOlxuICAgICAgICBjYXNlICdwdWJsaWMnOlxuICAgICAgICBjYXNlICdzdGF0aWMnOlxuICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0tleXdvcmRFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICAvLyB5aWVsZCBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMga2V5d29yZCB1bmRlciBub24tc3RyaWN0IG1vZGUuXG4gICAgICAgIGlmICghc3RyaWN0ICYmIGlkID09PSAneWllbGQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0tleXdvcmRFUzYoaWQsIHN0cmljdCkge1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZEVTNihpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHwgKGlkID09PSAndHJ5Jyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkRVM1KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnbnVsbCcgfHwgaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJyB8fCBpc0tleXdvcmRFUzUoaWQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmRFUzYoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdudWxsJyB8fCBpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnIHx8IGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Jlc3RyaWN0ZWRXb3JkKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ2V2YWwnIHx8IGlkID09PSAnYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lRVM1KGlkKSB7XG4gICAgICAgIHZhciBpLCBpeiwgY2g7XG5cbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICghY29kZS5pc0lkZW50aWZpZXJTdGFydEVTNShjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDEsIGl6ID0gaWQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY2ggPSBpZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKCFjb2RlLmlzSWRlbnRpZmllclBhcnRFUzUoY2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZVV0ZjE2KGxlYWQsIHRyYWlsKSB7XG4gICAgICAgIHJldHVybiAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWVFUzYoaWQpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjaCwgbG93Q2gsIGNoZWNrO1xuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgY2hlY2sgPSBjb2RlLmlzSWRlbnRpZmllclN0YXJ0RVM2O1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGlkLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGNoID0gaWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgweEQ4MDAgPD0gY2ggJiYgY2ggPD0gMHhEQkZGKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIGlmIChpID49IGl6KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIGxvd0NoID0gaWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoISgweERDMDAgPD0gbG93Q2ggJiYgbG93Q2ggPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoID0gZGVjb2RlVXRmMTYoY2gsIGxvd0NoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2hlY2soY2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2sgPSBjb2RlLmlzSWRlbnRpZmllclBhcnRFUzY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyRVM1KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRpZmllck5hbWVFUzUoaWQpICYmICFpc1Jlc2VydmVkV29yZEVTNShpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJFUzYoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaXNJZGVudGlmaWVyTmFtZUVTNihpZCkgJiYgIWlzUmVzZXJ2ZWRXb3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0tleXdvcmRFUzU6IGlzS2V5d29yZEVTNSxcbiAgICAgICAgaXNLZXl3b3JkRVM2OiBpc0tleXdvcmRFUzYsXG4gICAgICAgIGlzUmVzZXJ2ZWRXb3JkRVM1OiBpc1Jlc2VydmVkV29yZEVTNSxcbiAgICAgICAgaXNSZXNlcnZlZFdvcmRFUzY6IGlzUmVzZXJ2ZWRXb3JkRVM2LFxuICAgICAgICBpc1Jlc3RyaWN0ZWRXb3JkOiBpc1Jlc3RyaWN0ZWRXb3JkLFxuICAgICAgICBpc0lkZW50aWZpZXJOYW1lRVM1OiBpc0lkZW50aWZpZXJOYW1lRVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJOYW1lRVM2OiBpc0lkZW50aWZpZXJOYW1lRVM2LFxuICAgICAgICBpc0lkZW50aWZpZXJFUzU6IGlzSWRlbnRpZmllckVTNSxcbiAgICAgICAgaXNJZGVudGlmaWVyRVM2OiBpc0lkZW50aWZpZXJFUzZcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2VzdXRpbHNAMi4wLjJAZXN1dGlscy9saWIva2V5d29yZC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX21heFNhZmVJbnRlZ2VyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9udW1iZXIvbWF4LXNhZmUtaW50ZWdlclwiKTtcblxudmFyIF9tYXhTYWZlSW50ZWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXhTYWZlSW50ZWdlcik7XG5cbnZhciBfc3RyaW5naWZ5ID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeVwiKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5leHBvcnRzLnRvQ29tcHV0ZWRLZXkgPSB0b0NvbXB1dGVkS2V5O1xuZXhwb3J0cy50b1NlcXVlbmNlRXhwcmVzc2lvbiA9IHRvU2VxdWVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy50b0tleUFsaWFzID0gdG9LZXlBbGlhcztcbmV4cG9ydHMudG9JZGVudGlmaWVyID0gdG9JZGVudGlmaWVyO1xuZXhwb3J0cy50b0JpbmRpbmdJZGVudGlmaWVyTmFtZSA9IHRvQmluZGluZ0lkZW50aWZpZXJOYW1lO1xuZXhwb3J0cy50b1N0YXRlbWVudCA9IHRvU3RhdGVtZW50O1xuZXhwb3J0cy50b0V4cHJlc3Npb24gPSB0b0V4cHJlc3Npb247XG5leHBvcnRzLnRvQmxvY2sgPSB0b0Jsb2NrO1xuZXhwb3J0cy52YWx1ZVRvTm9kZSA9IHZhbHVlVG9Ob2RlO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIik7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9pc1JlZ0V4cCA9IHJlcXVpcmUoXCJsb2Rhc2gvaXNSZWdFeHBcIik7XG5cbnZhciBfaXNSZWdFeHAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNSZWdFeHApO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2luZGV4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9Db21wdXRlZEtleShub2RlKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vZGUua2V5IHx8IG5vZGUucHJvcGVydHk7XG5cbiAgaWYgKCFub2RlLmNvbXB1dGVkKSB7XG4gICAgaWYgKHQuaXNJZGVudGlmaWVyKGtleSkpIGtleSA9IHQuc3RyaW5nTGl0ZXJhbChrZXkubmFtZSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cblxuZnVuY3Rpb24gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhub2Rlcywgc2NvcGUsIGRlY2xhcnMpIHtcbiAgdmFyIGV4cHJzID0gW107XG4gIHZhciBlbnN1cmVMYXN0VW5kZWZpbmVkID0gdHJ1ZTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IgPSBub2RlcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gX3JlZjtcblxuICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSBmYWxzZTtcblxuICAgIGlmICh0LmlzRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlKTtcbiAgICB9IGVsc2UgaWYgKHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICBleHBycy5wdXNoKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgfSBlbHNlIGlmICh0LmlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJ2YXJcIikgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gbm9kZS5kZWNsYXJhdGlvbnMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMik7Oykge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWNsYXIgPSBfcmVmMjtcblxuICAgICAgICB2YXIgYmluZGluZ3MgPSB0LmdldEJpbmRpbmdJZGVudGlmaWVycyhkZWNsYXIpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYmluZGluZ3MpIHtcbiAgICAgICAgICBkZWNsYXJzLnB1c2goe1xuICAgICAgICAgICAga2luZDogbm9kZS5raW5kLFxuICAgICAgICAgICAgaWQ6IGJpbmRpbmdzW2tleV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWNsYXIuaW5pdCkge1xuICAgICAgICAgIGV4cHJzLnB1c2godC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbGFyLmlkLCBkZWNsYXIuaW5pdCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodC5pc0lmU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICB2YXIgY29uc2VxdWVudCA9IG5vZGUuY29uc2VxdWVudCA/IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMoW25vZGUuY29uc2VxdWVudF0sIHNjb3BlLCBkZWNsYXJzKSA6IHNjb3BlLmJ1aWxkVW5kZWZpbmVkTm9kZSgpO1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlID8gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhbbm9kZS5hbHRlcm5hdGVdLCBzY29wZSwgZGVjbGFycykgOiBzY29wZS5idWlsZFVuZGVmaW5lZE5vZGUoKTtcbiAgICAgIGlmICghY29uc2VxdWVudCB8fCAhYWx0ZXJuYXRlKSByZXR1cm47XG5cbiAgICAgIGV4cHJzLnB1c2godC5jb25kaXRpb25hbEV4cHJlc3Npb24obm9kZS50ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcbiAgICB9IGVsc2UgaWYgKHQuaXNCbG9ja1N0YXRlbWVudChub2RlKSkge1xuICAgICAgdmFyIGJvZHkgPSBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKG5vZGUuYm9keSwgc2NvcGUsIGRlY2xhcnMpO1xuICAgICAgaWYgKCFib2R5KSByZXR1cm47XG5cbiAgICAgIGV4cHJzLnB1c2goYm9keSk7XG4gICAgfSBlbHNlIGlmICh0LmlzRW1wdHlTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuc3VyZUxhc3RVbmRlZmluZWQpIHtcbiAgICBleHBycy5wdXNoKHNjb3BlLmJ1aWxkVW5kZWZpbmVkTm9kZSgpKTtcbiAgfVxuXG4gIGlmIChleHBycy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZXhwcnNbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHQuc2VxdWVuY2VFeHByZXNzaW9uKGV4cHJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1NlcXVlbmNlRXhwcmVzc2lvbihub2Rlcywgc2NvcGUpIHtcbiAgaWYgKCFub2RlcyB8fCAhbm9kZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGRlY2xhcnMgPSBbXTtcbiAgdmFyIHJlc3VsdCA9IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMobm9kZXMsIHNjb3BlLCBkZWNsYXJzKTtcbiAgaWYgKCFyZXN1bHQpIHJldHVybjtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IzID0gZGVjbGFycywgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IzKTs7KSB7XG4gICAgdmFyIF9yZWYzO1xuXG4gICAgaWYgKF9pc0FycmF5Mykge1xuICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaTMgPSBfaXRlcmF0b3IzLm5leHQoKTtcbiAgICAgIGlmIChfaTMuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVjbGFyID0gX3JlZjM7XG5cbiAgICBzY29wZS5wdXNoKGRlY2xhcik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB0b0tleUFsaWFzKG5vZGUpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9kZS5rZXk7XG5cbiAgdmFyIGFsaWFzID0gdm9pZCAwO1xuXG4gIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy5pbmNyZW1lbnQoKSArIFwiXCI7XG4gIH0gZWxzZSBpZiAodC5pc0lkZW50aWZpZXIoa2V5KSkge1xuICAgIGFsaWFzID0ga2V5Lm5hbWU7XG4gIH0gZWxzZSBpZiAodC5pc1N0cmluZ0xpdGVyYWwoa2V5KSkge1xuICAgIGFsaWFzID0gKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKGtleS52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgYWxpYXMgPSAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkodC5yZW1vdmVQcm9wZXJ0aWVzRGVlcCh0LmNsb25lRGVlcChrZXkpKSk7XG4gIH1cblxuICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgIGFsaWFzID0gXCJbXCIgKyBhbGlhcyArIFwiXVwiO1xuICB9XG5cbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgYWxpYXMgPSBcInN0YXRpYzpcIiArIGFsaWFzO1xuICB9XG5cbiAgcmV0dXJuIGFsaWFzO1xufVxuXG50b0tleUFsaWFzLnVpZCA9IDA7XG5cbnRvS2V5QWxpYXMuaW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodG9LZXlBbGlhcy51aWQgPj0gX21heFNhZmVJbnRlZ2VyMi5kZWZhdWx0KSB7XG4gICAgcmV0dXJuIHRvS2V5QWxpYXMudWlkID0gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy51aWQrKztcbiAgfVxufTtcblxuZnVuY3Rpb24gdG9JZGVudGlmaWVyKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUgKyBcIlwiO1xuXG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05JF9dL2csIFwiLVwiKTtcblxuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eWy0wLTldKy8sIFwiXCIpO1xuXG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1stXFxzXSsoLik/L2csIGZ1bmN0aW9uIChtYXRjaCwgYykge1xuICAgIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIjtcbiAgfSk7XG5cbiAgaWYgKCF0LmlzVmFsaWRJZGVudGlmaWVyKG5hbWUpKSB7XG4gICAgbmFtZSA9IFwiX1wiICsgbmFtZTtcbiAgfVxuXG4gIHJldHVybiBuYW1lIHx8IFwiX1wiO1xufVxuXG5mdW5jdGlvbiB0b0JpbmRpbmdJZGVudGlmaWVyTmFtZShuYW1lKSB7XG4gIG5hbWUgPSB0b0lkZW50aWZpZXIobmFtZSk7XG4gIGlmIChuYW1lID09PSBcImV2YWxcIiB8fCBuYW1lID09PSBcImFyZ3VtZW50c1wiKSBuYW1lID0gXCJfXCIgKyBuYW1lO1xuICByZXR1cm4gbmFtZTtcbn1cblxuZnVuY3Rpb24gdG9TdGF0ZW1lbnQobm9kZSwgaWdub3JlKSB7XG4gIGlmICh0LmlzU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgbXVzdEhhdmVJZCA9IGZhbHNlO1xuICB2YXIgbmV3VHlwZSA9IHZvaWQgMDtcblxuICBpZiAodC5pc0NsYXNzKG5vZGUpKSB7XG4gICAgbXVzdEhhdmVJZCA9IHRydWU7XG4gICAgbmV3VHlwZSA9IFwiQ2xhc3NEZWNsYXJhdGlvblwiO1xuICB9IGVsc2UgaWYgKHQuaXNGdW5jdGlvbihub2RlKSkge1xuICAgIG11c3RIYXZlSWQgPSB0cnVlO1xuICAgIG5ld1R5cGUgPSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjtcbiAgfSBlbHNlIGlmICh0LmlzQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gdC5leHByZXNzaW9uU3RhdGVtZW50KG5vZGUpO1xuICB9XG5cbiAgaWYgKG11c3RIYXZlSWQgJiYgIW5vZGUuaWQpIHtcbiAgICBuZXdUeXBlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIW5ld1R5cGUpIHtcbiAgICBpZiAoaWdub3JlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCB0dXJuIFwiICsgbm9kZS50eXBlICsgXCIgdG8gYSBzdGF0ZW1lbnRcIik7XG4gICAgfVxuICB9XG5cbiAgbm9kZS50eXBlID0gbmV3VHlwZTtcblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gdG9FeHByZXNzaW9uKG5vZGUpIHtcbiAgaWYgKHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgbm9kZSA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgfVxuXG4gIGlmICh0LmlzRXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaWYgKHQuaXNDbGFzcyhub2RlKSkge1xuICAgIG5vZGUudHlwZSA9IFwiQ2xhc3NFeHByZXNzaW9uXCI7XG4gIH0gZWxzZSBpZiAodC5pc0Z1bmN0aW9uKG5vZGUpKSB7XG4gICAgbm9kZS50eXBlID0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIjtcbiAgfVxuXG4gIGlmICghdC5pc0V4cHJlc3Npb24obm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdHVybiBcIiArIG5vZGUudHlwZSArIFwiIHRvIGFuIGV4cHJlc3Npb25cIik7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gdG9CbG9jayhub2RlLCBwYXJlbnQpIHtcbiAgaWYgKHQuaXNCbG9ja1N0YXRlbWVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaWYgKHQuaXNFbXB0eVN0YXRlbWVudChub2RlKSkge1xuICAgIG5vZGUgPSBbXTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGlmICghdC5pc1N0YXRlbWVudChub2RlKSkge1xuICAgICAgaWYgKHQuaXNGdW5jdGlvbihwYXJlbnQpKSB7XG4gICAgICAgIG5vZGUgPSB0LnJldHVyblN0YXRlbWVudChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSB0LmV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IFtub2RlXTtcbiAgfVxuXG4gIHJldHVybiB0LmJsb2NrU3RhdGVtZW50KG5vZGUpO1xufVxuXG5mdW5jdGlvbiB2YWx1ZVRvTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0LmlkZW50aWZpZXIoXCJ1bmRlZmluZWRcIik7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHQuYm9vbGVhbkxpdGVyYWwodmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHQubnVsbExpdGVyYWwoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdC5zdHJpbmdMaXRlcmFsKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdC5udW1lcmljTGl0ZXJhbCh2YWx1ZSk7XG4gIH1cblxuICBpZiAoKDAsIF9pc1JlZ0V4cDIuZGVmYXVsdCkodmFsdWUpKSB7XG4gICAgdmFyIHBhdHRlcm4gPSB2YWx1ZS5zb3VyY2U7XG4gICAgdmFyIGZsYWdzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaCgvXFwvKFthLXpdK3wpJC8pWzFdO1xuICAgIHJldHVybiB0LnJlZ0V4cExpdGVyYWwocGF0dGVybiwgZmxhZ3MpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHQuYXJyYXlFeHByZXNzaW9uKHZhbHVlLm1hcCh0LnZhbHVlVG9Ob2RlKSk7XG4gIH1cblxuICBpZiAoKDAsIF9pc1BsYWluT2JqZWN0Mi5kZWZhdWx0KSh2YWx1ZSkpIHtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHZhciBub2RlS2V5ID0gdm9pZCAwO1xuICAgICAgaWYgKHQuaXNWYWxpZElkZW50aWZpZXIoa2V5KSkge1xuICAgICAgICBub2RlS2V5ID0gdC5pZGVudGlmaWVyKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlS2V5ID0gdC5zdHJpbmdMaXRlcmFsKGtleSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5wdXNoKHQub2JqZWN0UHJvcGVydHkobm9kZUtleSwgdC52YWx1ZVRvTm9kZSh2YWx1ZVtrZXldKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdC5vYmplY3RFeHByZXNzaW9uKHByb3BzKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcImRvbid0IGtub3cgaG93IHRvIHR1cm4gdGhpcyB2YWx1ZSBpbnRvIGEgbm9kZVwiKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlcy9saWIvY29udmVydGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvbWF4LXNhZmUtaW50ZWdlclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL251bWJlci9tYXgtc2FmZS1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbm1vZHVsZS5leHBvcnRzID0gMHgxZmZmZmZmZmZmZmZmZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL21heC1zYWZlLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmYgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19nZXRSYXdUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDIzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VJc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1JlZ0V4cCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1JlZ0V4cDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaXNSZWdFeHAuanNcbi8vIG1vZHVsZSBpZCA9IDIzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzUmVnRXhwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUlzUmVnRXhwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb24gPSBjcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5yZW1vdmVUeXBlRHVwbGljYXRlcyA9IHJlbW92ZVR5cGVEdXBsaWNhdGVzO1xuZXhwb3J0cy5jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YgPSBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2Y7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaW5kZXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uKHR5cGVzKSB7XG4gIHZhciBmbGF0dGVuZWQgPSByZW1vdmVUeXBlRHVwbGljYXRlcyh0eXBlcyk7XG5cbiAgaWYgKGZsYXR0ZW5lZC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0LnVuaW9uVHlwZUFubm90YXRpb24oZmxhdHRlbmVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUeXBlRHVwbGljYXRlcyhub2Rlcykge1xuICB2YXIgZ2VuZXJpY3MgPSB7fTtcbiAgdmFyIGJhc2VzID0ge307XG5cbiAgdmFyIHR5cGVHcm91cHMgPSBbXTtcblxuICB2YXIgdHlwZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoIW5vZGUpIGNvbnRpbnVlO1xuXG4gICAgaWYgKHR5cGVzLmluZGV4T2Yobm9kZSkgPj0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNBbnlUeXBlQW5ub3RhdGlvbihub2RlKSkge1xuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG5cbiAgICBpZiAodC5pc0Zsb3dCYXNlQW5ub3RhdGlvbihub2RlKSkge1xuICAgICAgYmFzZXNbbm9kZS50eXBlXSA9IG5vZGU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodC5pc1VuaW9uVHlwZUFubm90YXRpb24obm9kZSkpIHtcbiAgICAgIGlmICh0eXBlR3JvdXBzLmluZGV4T2Yobm9kZS50eXBlcykgPCAwKSB7XG4gICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KG5vZGUudHlwZXMpO1xuICAgICAgICB0eXBlR3JvdXBzLnB1c2gobm9kZS50eXBlcyk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodC5pc0dlbmVyaWNUeXBlQW5ub3RhdGlvbihub2RlKSkge1xuICAgICAgdmFyIG5hbWUgPSBub2RlLmlkLm5hbWU7XG5cbiAgICAgIGlmIChnZW5lcmljc1tuYW1lXSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBnZW5lcmljc1tuYW1lXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcyA9IHJlbW92ZVR5cGVEdXBsaWNhdGVzKGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcy5jb25jYXQobm9kZS50eXBlUGFyYW1ldGVycy5wYXJhbXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RpbmcgPSBub2RlLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmljc1tuYW1lXSA9IG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGVzLnB1c2gobm9kZSk7XG4gIH1cblxuICBmb3IgKHZhciB0eXBlIGluIGJhc2VzKSB7XG4gICAgdHlwZXMucHVzaChiYXNlc1t0eXBlXSk7XG4gIH1cblxuICBmb3IgKHZhciBfbmFtZSBpbiBnZW5lcmljcykge1xuICAgIHR5cGVzLnB1c2goZ2VuZXJpY3NbX25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdC5zdHJpbmdUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdC5udW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdC52b2lkVHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0LmJvb2xlYW5UeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0LmdlbmVyaWNUeXBlQW5ub3RhdGlvbih0LmlkZW50aWZpZXIoXCJGdW5jdGlvblwiKSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB0LmdlbmVyaWNUeXBlQW5ub3RhdGlvbih0LmlkZW50aWZpZXIoXCJPYmplY3RcIikpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3ltYm9sXCIpIHtcbiAgICByZXR1cm4gdC5nZW5lcmljVHlwZUFubm90YXRpb24odC5pZGVudGlmaWVyKFwiU3ltYm9sXCIpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGVvZiB2YWx1ZVwiKTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzL2xpYi9mbG93LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0Zhc3Rwcm9wZXJ0aWVzKG8pIHtcblx0ZnVuY3Rpb24gU3ViKCkge31cblx0U3ViLnByb3RvdHlwZSA9IG87XG5cdHZhciByZWNlaXZlciA9IG5ldyBTdWIoKTsgLy8gY3JlYXRlIGFuIGluc3RhbmNlXG5cdGZ1bmN0aW9uIGljKCkgeyByZXR1cm4gdHlwZW9mIHJlY2VpdmVyLmZvbzsgfSAvLyBwZXJmb3JtIGFjY2Vzc1xuXHRpYygpOyBcblx0aWMoKTtcblx0cmV0dXJuIG87XG5cdGV2YWwoXCJvXCIgKyBvKTsgLy8gZW5zdXJlIG5vIGRlYWQgY29kZSBlbGltaW5hdGlvblxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl90by1mYXN0LXByb3BlcnRpZXNAMS4wLjNAdG8tZmFzdC1wcm9wZXJ0aWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlQXNzaWduSW4gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduSW4nKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgY29weVN5bWJvbHMgPSByZXF1aXJlKCcuL19jb3B5U3ltYm9scycpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksXG4gICAgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVCeVRhZycpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc01hcCA9IHJlcXVpcmUoJy4vaXNNYXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1NldCA9IHJlcXVpcmUoJy4vaXNTZXQnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUNsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbGlzdENhY2hlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19saXN0Q2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDI0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19saXN0Q2FjaGVTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDI0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX3N0YWNrQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19zdGFja0RlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX3N0YWNrR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX3N0YWNrSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19zdGFja1NldC5qc1xuLy8gbW9kdWxlIGlkID0gMjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlSXNOYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2lzTWFza2VkLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2NvcmVKc0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDI1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2dldFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbWFwQ2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMjU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fSGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9faGFzaENsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9faGFzaERlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19oYXNoR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2hhc2hIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19oYXNoU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDI2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9faXNLZXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX21hcENhY2hlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19tYXBDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19tYXBDYWNoZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gMjY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19hcnJheUVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZVRpbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDI3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9zdHViRmFsc2UuanNcbi8vIG1vZHVsZSBpZCA9IDI3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Jhc2VLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbmF0aXZlS2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlQXNzaWduSW4uanNcbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlS2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbmF0aXZlS2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19jbG9uZUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2NvcHlBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2NvcHlTeW1ib2xzLmpzXG4vLyBtb2R1bGUgaWQgPSAyODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYXJyYXlGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzXG4vLyBtb2R1bGUgaWQgPSAyODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2dldEFsbEtleXNJbi5qc1xuLy8gbW9kdWxlIGlkID0gMjgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19EYXRhVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19Qcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX1dlYWtNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDI4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9faW5pdENsb25lQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9faW5pdENsb25lQnlUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDI4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fY2xvbmVEYXRhVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19jbG9uZVJlZ0V4cC5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fY2xvbmVTeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDI5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Jhc2VDcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzTWFwID0gcmVxdWlyZSgnLi9fYmFzZUlzTWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9pc01hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlSXNNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9pc1NldC5qc1xuLy8gbW9kdWxlIGlkID0gMjk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlSXNTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDI5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVVuaXEgPSByZXF1aXJlKCcuL19iYXNlVW5pcScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAqIGluIHRoZSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pcShbMiwgMSwgMl0pO1xuICogLy8gPT4gWzIsIDFdXG4gKi9cbmZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvdW5pcS5qc1xuLy8gbW9kdWxlIGlkID0gMjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpLFxuICAgIGNyZWF0ZVNldCA9IHJlcXVpcmUoJy4vX2NyZWF0ZVNldCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgfVxuICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgfVxuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuaXE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlVW5pcS5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fc2V0Q2FjaGVBZGQuanNcbi8vIG1vZHVsZSBpZCA9IDMwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19zZXRDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2FycmF5SW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDMwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Jhc2VJc05hTi5qc1xuLy8gbW9kdWxlIGlkID0gMzA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fc3RyaWN0SW5kZXhPZi5qc1xuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBub29wID0gcmVxdWlyZSgnLi9ub29wJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19jcmVhdGVTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDMwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL25vb3AuanNcbi8vIG1vZHVsZSBpZCA9IDMwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcIi4vaW5kZXhcIik7XG5cbnJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbnJlcXVpcmUoXCIuL2VzMjAxNVwiKTtcblxucmVxdWlyZShcIi4vZmxvd1wiKTtcblxucmVxdWlyZShcIi4vanN4XCIpO1xuXG5yZXF1aXJlKFwiLi9taXNjXCIpO1xuXG5yZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXMvbGliL2RlZmluaXRpb25zL2luaXQuanNcbi8vIG1vZHVsZSBpZCA9IDMwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaW5kZXgpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5cbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG5cbnZhciBfaW5kZXgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5kZXgyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJBcnJheUV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXgyLmFzc2VydEVhY2gpKCgwLCBfaW5kZXgyLmFzc2VydE5vZGVPclZhbHVlVHlwZSkoXCJudWxsXCIsIFwiRXhwcmVzc2lvblwiLCBcIlNwcmVhZEVsZW1lbnRcIikpKSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJlbGVtZW50c1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBvcGVyYXRvcjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIkJpbmFyeUV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiBfaW5kZXgyLmFzc2VydE9uZU9mLmFwcGx5KHVuZGVmaW5lZCwgX2NvbnN0YW50cy5CSU5BUllfT1BFUkFUT1JTKVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJCaW5hcnlcIiwgXCJFeHByZXNzaW9uXCJdXG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJEaXJlY3RpdmVcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJEaXJlY3RpdmVMaXRlcmFsXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJEaXJlY3RpdmVMaXRlcmFsXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiQmxvY2tTdGF0ZW1lbnRcIiwge1xuICBidWlsZGVyOiBbXCJib2R5XCIsIFwiZGlyZWN0aXZlc1wiXSxcbiAgdmlzaXRvcjogW1wiZGlyZWN0aXZlc1wiLCBcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGRpcmVjdGl2ZXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5jaGFpbikoKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4Mi5hc3NlcnRFYWNoKSgoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJEaXJlY3RpdmVcIikpKSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuY2hhaW4pKCgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF9pbmRleDIuYXNzZXJ0RWFjaCkoKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpKSlcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJCbG9ja1wiLCBcIlN0YXRlbWVudFwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiQnJlYWtTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiQ2FsbEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIl0sXG4gIGZpZWxkczoge1xuICAgIGNhbGxlZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGFyZ3VtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXgyLmFzc2VydEVhY2gpKCgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIpKSlcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIkNhdGNoQ2xhdXNlXCIsIHtcbiAgdmlzaXRvcjogW1wicGFyYW1cIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIl1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIsIFwiYWx0ZXJuYXRlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgY29uc2VxdWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGFsdGVybmF0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJDb25kaXRpb25hbFwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiQ29udGludWVTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIkRvV2hpbGVTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiLCBcIldoaWxlXCIsIFwiU2NvcGFibGVcIl1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIkVtcHR5U3RhdGVtZW50XCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdXG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkV4cHJlc3Npb25XcmFwcGVyXCJdXG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJGaWxlXCIsIHtcbiAgYnVpbGRlcjogW1wicHJvZ3JhbVwiLCBcImNvbW1lbnRzXCIsIFwidG9rZW5zXCJdLFxuICB2aXNpdG9yOiBbXCJwcm9ncmFtXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcm9ncmFtOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiUHJvZ3JhbVwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiRm9ySW5TdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIlN0YXRlbWVudFwiLCBcIkZvclwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiLCBcIkZvclhTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiTFZhbFwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJGb3JTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJpbml0XCIsIFwidGVzdFwiLCBcInVwZGF0ZVwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpbml0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZ2VuZXJhdG9yXCIsIFwiYXN5bmNcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcInJldHVyblR5cGVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBwYXJhbXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5jaGFpbikoKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4Mi5hc3NlcnRFYWNoKSgoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpKSlcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgZ2VuZXJhdG9yOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH0sXG4gICAgYXN5bmM6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIlN0YXRlbWVudFwiLCBcIlB1cmVpc2hcIiwgXCJEZWNsYXJhdGlvblwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgcGFyYW1zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuY2hhaW4pKCgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF9pbmRleDIuYXNzZXJ0RWFjaCkoKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiTFZhbFwiKSkpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGdlbmVyYXRvcjoge1xuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIilcbiAgICB9LFxuICAgIGFzeW5jOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiSWRlbnRpZmllclwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTFZhbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghdC5pc1ZhbGlkSWRlbnRpZmllcih2YWwpKSB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXgyLmFzc2VydEVhY2gpKCgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJJZlN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIsIFwiYWx0ZXJuYXRlXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJDb25kaXRpb25hbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGNvbnNlcXVlbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGFsdGVybmF0ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJMYWJlbGVkU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGFiZWxcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxhYmVsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiU3RyaW5nTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiTnVtZXJpY0xpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZGVwcmVjYXRlZEFsaWFzOiBcIk51bWJlckxpdGVyYWxcIixcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwibnVtYmVyXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIk51bGxMaXRlcmFsXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJCb29sZWFuTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIlJlZ0V4cExpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJwYXR0ZXJuXCIsIFwiZmxhZ3NcIl0sXG4gIGRlcHJlY2F0ZWRBbGlhczogXCJSZWdleExpdGVyYWxcIixcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkxpdGVyYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhdHRlcm46IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfSxcbiAgICBmbGFnczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksXG4gICAgICBkZWZhdWx0OiBcIlwiXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJMb2dpY2FsRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkJpbmFyeVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogX2luZGV4Mi5hc3NlcnRPbmVPZi5hcHBseSh1bmRlZmluZWQsIF9jb25zdGFudHMuTE9HSUNBTF9PUEVSQVRPUlMpXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIiwgXCJjb21wdXRlZFwiXSxcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJMVmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBwcm9wZXJ0eToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIHZhciBleHBlY3RlZFR5cGUgPSBub2RlLmNvbXB1dGVkID8gXCJFeHByZXNzaW9uXCIgOiBcIklkZW50aWZpZXJcIjtcbiAgICAgICAgKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKGV4cGVjdGVkVHlwZSkobm9kZSwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJOZXdFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBhcmd1bWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5jaGFpbikoKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4Mi5hc3NlcnRFYWNoKSgoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiU3ByZWFkRWxlbWVudFwiKSkpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJQcm9ncmFtXCIsIHtcbiAgdmlzaXRvcjogW1wiZGlyZWN0aXZlc1wiLCBcImJvZHlcIl0sXG4gIGJ1aWxkZXI6IFtcImJvZHlcIiwgXCJkaXJlY3RpdmVzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuY2hhaW4pKCgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF9pbmRleDIuYXNzZXJ0RWFjaCkoKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRGlyZWN0aXZlXCIpKSksXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXgyLmFzc2VydEVhY2gpKCgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKSkpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCIsIFwiQmxvY2tcIiwgXCJGdW5jdGlvblBhcmVudFwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiT2JqZWN0RXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5jaGFpbikoKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4Mi5hc3NlcnRFYWNoKSgoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJPYmplY3RNZXRob2RcIiwgXCJPYmplY3RQcm9wZXJ0eVwiLCBcIlNwcmVhZFByb3BlcnR5XCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIk9iamVjdE1ldGhvZFwiLCB7XG4gIGJ1aWxkZXI6IFtcImtpbmRcIiwgXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiY29tcHV0ZWRcIl0sXG4gIGZpZWxkczoge1xuICAgIGtpbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5jaGFpbikoKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSwgKDAsIF9pbmRleDIuYXNzZXJ0T25lT2YpKFwibWV0aG9kXCIsIFwiZ2V0XCIsIFwic2V0XCIpKSxcbiAgICAgIGRlZmF1bHQ6IFwibWV0aG9kXCJcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAga2V5OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBub2RlLmNvbXB1dGVkID8gW1wiRXhwcmVzc2lvblwiXSA6IFtcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIl07XG4gICAgICAgIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUuYXBwbHkodW5kZWZpbmVkLCBleHBlY3RlZFR5cGVzKShub2RlLCBrZXksIHZhbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuY2hhaW4pKCgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF9pbmRleDIuYXNzZXJ0RWFjaCkoKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSlcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgZ2VuZXJhdG9yOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH0sXG4gICAgYXN5bmM6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZGVjb3JhdG9yc1wiLCBcInJldHVyblR5cGVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgYWxpYXNlczogW1wiVXNlcldoaXRlc3BhY2FibGVcIiwgXCJGdW5jdGlvblwiLCBcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIk1ldGhvZFwiLCBcIk9iamVjdE1lbWJlclwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiT2JqZWN0UHJvcGVydHlcIiwge1xuICBidWlsZGVyOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcImNvbXB1dGVkXCIsIFwic2hvcnRoYW5kXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IG5vZGUuY29tcHV0ZWQgPyBbXCJFeHByZXNzaW9uXCJdIDogW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiXTtcbiAgICAgICAgX2luZGV4Mi5hc3NlcnROb2RlVHlwZS5hcHBseSh1bmRlZmluZWQsIGV4cGVjdGVkVHlwZXMpKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlBhdHRlcm5cIiwgXCJSZXN0RWxlbWVudFwiKVxuICAgIH0sXG4gICAgc2hvcnRoYW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXgyLmFzc2VydEVhY2gpKCgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInZhbHVlXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYWxpYXNlczogW1wiVXNlcldoaXRlc3BhY2FibGVcIiwgXCJQcm9wZXJ0eVwiLCBcIk9iamVjdE1lbWJlclwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiUmVzdEVsZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJMVmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkxWYWxcIilcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5jaGFpbikoKDAsIF9pbmRleDIuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4Mi5hc3NlcnRFYWNoKSgoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiUmV0dXJuU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXgyLmFzc2VydEVhY2gpKCgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIikpKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiU3dpdGNoQ2FzZVwiLCB7XG4gIHZpc2l0b3I6IFtcInRlc3RcIiwgXCJjb25zZXF1ZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBjb25zZXF1ZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuY2hhaW4pKCgwLCBfaW5kZXgyLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF9pbmRleDIuYXNzZXJ0RWFjaCkoKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIlN3aXRjaFN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImRpc2NyaW1pbmFudFwiLCBcImNhc2VzXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIlNjb3BhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXNjcmltaW5hbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjYXNlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXgyLmFzc2VydEVhY2gpKCgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIlN3aXRjaENhc2VcIikpKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiVGhpc0V4cHJlc3Npb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJUaHJvd1N0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJUZXJtaW5hdG9ybGVzc1wiLCBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiVHJ5U3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYmxvY2tcIiwgXCJoYW5kbGVyXCIsIFwiZmluYWxpemVyXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgaGFuZGxlcjoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBoYW5kbGVyOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgZmluYWxpemVyOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiVW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJlZml4OiB7XG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogX2luZGV4Mi5hc3NlcnRPbmVPZi5hcHBseSh1bmRlZmluZWQsIF9jb25zdGFudHMuVU5BUllfT1BFUkFUT1JTKVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlVuYXJ5TGlrZVwiLCBcIkV4cHJlc3Npb25cIl1cbn0pO1xuXG4oMCwgX2luZGV4My5kZWZhdWx0KShcIlVwZGF0ZUV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImFyZ3VtZW50XCIsIFwicHJlZml4XCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcmVmaXg6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogX2luZGV4Mi5hc3NlcnRPbmVPZi5hcHBseSh1bmRlZmluZWQsIF9jb25zdGFudHMuVVBEQVRFX09QRVJBVE9SUylcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wia2luZFwiLCBcImRlY2xhcmF0aW9uc1wiXSxcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25zXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAga2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpLCAoMCwgX2luZGV4Mi5hc3NlcnRPbmVPZikoXCJ2YXJcIiwgXCJsZXRcIiwgXCJjb25zdFwiKSlcbiAgICB9LFxuICAgIGRlY2xhcmF0aW9uczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmNoYWluKSgoMCwgX2luZGV4Mi5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXgyLmFzc2VydEVhY2gpKCgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSkpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDMuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiTFZhbFwiKVxuICAgIH0sXG4gICAgaW5pdDoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleDIuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiV2hpbGVTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCIsIFwiV2hpbGVcIiwgXCJTY29wYWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiLCBcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgzLmRlZmF1bHQpKFwiV2l0aFN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0OiB7XG4gICAgICBvYmplY3Q6ICgwLCBfaW5kZXgyLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4Mi5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiLCBcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXMvbGliL2RlZmluaXRpb25zL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuXG52YXIgX2luZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luZGV4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJBc3NpZ25tZW50UGF0dGVyblwiLCB7XG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgYWxpYXNlczogW1wiUGF0dGVyblwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5jaGFpbikoKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXguYXNzZXJ0RWFjaCkoKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiQXJyYXlQYXR0ZXJuXCIsIHtcbiAgdmlzaXRvcjogW1wiZWxlbWVudHNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiUGF0dGVyblwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGVsZW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5jaGFpbikoKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXguYXNzZXJ0RWFjaCkoKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUGF0dGVyblwiLCBcIlJlc3RFbGVtZW50XCIpKSlcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmNoYWluKSgoMCwgX2luZGV4LmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF9pbmRleC5hc3NlcnRFYWNoKSgoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJhc3luY1wiXSxcbiAgdmlzaXRvcjogW1wicGFyYW1zXCIsIFwiYm9keVwiLCBcInJldHVyblR5cGVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJGdW5jdGlvblwiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIiwgXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5jaGFpbikoKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXguYXNzZXJ0RWFjaCkoKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpKSlcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIsIFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYXN5bmM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkNsYXNzQm9keVwiLCB7XG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmNoYWluKSgoMCwgX2luZGV4LmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF9pbmRleC5hc3NlcnRFYWNoKSgoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkNsYXNzTWV0aG9kXCIsIFwiQ2xhc3NQcm9wZXJ0eVwiKSkpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJDbGFzc0RlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJzdXBlckNsYXNzXCIsIFwiYm9keVwiLCBcImRlY29yYXRvcnNcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiYm9keVwiLCBcInN1cGVyQ2xhc3NcIiwgXCJtaXhpbnNcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVyVHlwZVBhcmFtZXRlcnNcIiwgXCJpbXBsZW1lbnRzXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJDbGFzc1wiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiUHVyZWlzaFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkNsYXNzQm9keVwiKVxuICAgIH0sXG4gICAgc3VwZXJDbGFzczoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5jaGFpbikoKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXguYXNzZXJ0RWFjaCkoKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiQ2xhc3NFeHByZXNzaW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiQ2xhc3NEZWNsYXJhdGlvblwiLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkNsYXNzXCIsIFwiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkNsYXNzQm9keVwiKVxuICAgIH0sXG4gICAgc3VwZXJDbGFzczoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5jaGFpbikoKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXguYXNzZXJ0RWFjaCkoKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJzb3VyY2VcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiTW9kdWxlRGVjbGFyYXRpb25cIiwgXCJFeHBvcnREZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgc291cmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJNb2R1bGVEZWNsYXJhdGlvblwiLCBcIkV4cG9ydERlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIkNsYXNzRGVjbGFyYXRpb25cIiwgXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25cIiwgXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIk1vZHVsZURlY2xhcmF0aW9uXCIsIFwiRXhwb3J0RGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJEZWNsYXJhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBzcGVjaWZpZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5jaGFpbikoKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXguYXNzZXJ0RWFjaCkoKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHBvcnRTcGVjaWZpZXJcIikpKVxuICAgIH0sXG4gICAgc291cmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkV4cG9ydFNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImxvY2FsXCIsIFwiZXhwb3J0ZWRcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgbG9jYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGV4cG9ydGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJGb3JPZlN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCIsIFwiRm9yWFN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBcIkxWYWxcIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkltcG9ydERlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wic3BlY2lmaWVyc1wiLCBcInNvdXJjZVwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJNb2R1bGVEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgc3BlY2lmaWVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguY2hhaW4pKCgwLCBfaW5kZXguYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4LmFzc2VydEVhY2gpKCgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSW1wb3J0U3BlY2lmaWVyXCIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSkpXG4gICAgfSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsb2NhbFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsb2NhbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wibG9jYWxcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgbG9jYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkltcG9ydFNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImxvY2FsXCIsIFwiaW1wb3J0ZWRcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgbG9jYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGltcG9ydGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBpbXBvcnRLaW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnRPbmVPZikobnVsbCwgXCJ0eXBlXCIsIFwidHlwZW9mXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJNZXRhUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJtZXRhXCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG1ldGE6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJDbGFzc01ldGhvZFwiLCB7XG4gIGFsaWFzZXM6IFtcIkZ1bmN0aW9uXCIsIFwiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiTWV0aG9kXCJdLFxuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImNvbXB1dGVkXCIsIFwic3RhdGljXCJdLFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZGVjb3JhdG9yc1wiLCBcInJldHVyblR5cGVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAga2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguY2hhaW4pKCgwLCBfaW5kZXguYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSwgKDAsIF9pbmRleC5hc3NlcnRPbmVPZikoXCJnZXRcIiwgXCJzZXRcIiwgXCJtZXRob2RcIiwgXCJjb25zdHJ1Y3RvclwiKSksXG4gICAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH0sXG4gICAgc3RhdGljOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfSxcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IG5vZGUuY29tcHV0ZWQgPyBbXCJFeHByZXNzaW9uXCJdIDogW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiXTtcbiAgICAgICAgX2luZGV4LmFzc2VydE5vZGVUeXBlLmFwcGx5KHVuZGVmaW5lZCwgZXhwZWN0ZWRUeXBlcykobm9kZSwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFyYW1zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5jaGFpbikoKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXguYXNzZXJ0RWFjaCkoKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpKSlcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfSxcbiAgICBnZW5lcmF0b3I6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIilcbiAgICB9LFxuICAgIGFzeW5jOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJPYmplY3RQYXR0ZXJuXCIsIHtcbiAgdmlzaXRvcjogW1wicHJvcGVydGllc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJQYXR0ZXJuXCIsIFwiTFZhbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguY2hhaW4pKCgwLCBfaW5kZXguYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4LmFzc2VydEVhY2gpKCgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiUmVzdFByb3BlcnR5XCIsIFwiUHJvcGVydHlcIikpKVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguY2hhaW4pKCgwLCBfaW5kZXguYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4LmFzc2VydEVhY2gpKCgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlNwcmVhZEVsZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiVW5hcnlMaWtlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiU3VwZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0YWdcIiwgXCJxdWFzaVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGFnOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBxdWFzaToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiVGVtcGxhdGVMaXRlcmFsXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJUZW1wbGF0ZUVsZW1lbnRcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiLCBcInRhaWxcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7fSxcbiAgICB0YWlsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJUZW1wbGF0ZUxpdGVyYWxcIiwge1xuICB2aXNpdG9yOiBbXCJxdWFzaXNcIiwgXCJleHByZXNzaW9uc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkxpdGVyYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIHF1YXNpczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguY2hhaW4pKCgwLCBfaW5kZXguYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4LmFzc2VydEVhY2gpKCgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiVGVtcGxhdGVFbGVtZW50XCIpKSlcbiAgICB9LFxuICAgIGV4cHJlc3Npb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5jaGFpbikoKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfaW5kZXguYXNzZXJ0RWFjaCkoKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIllpZWxkRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImFyZ3VtZW50XCIsIFwiZGVsZWdhdGVcIl0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiVGVybWluYXRvcmxlc3NcIl0sXG4gIGZpZWxkczoge1xuICAgIGRlbGVnYXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlcy9saWIvZGVmaW5pdGlvbnMvZXMyMDE1LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiQW55VHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZWxlbWVudFR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiQ2xhc3NJbXBsZW1lbnRzXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiQ2xhc3NQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInZhbHVlXCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBidWlsZGVyOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiLCBcImNvbXB1dGVkXCJdLFxuICBhbGlhc2VzOiBbXCJQcm9wZXJ0eVwiXSxcbiAgZmllbGRzOiB7XG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkRlY2xhcmVDbGFzc1wiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJleHRlbmRzXCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJEZWNsYXJlRnVuY3Rpb25cIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJEZWNsYXJlSW50ZXJmYWNlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImV4dGVuZHNcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkRlY2xhcmVNb2R1bGVcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJEZWNsYXJlVHlwZUFsaWFzXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkRlY2xhcmVPcGFxdWVUeXBlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVydHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJEZWNsYXJlVmFyaWFibGVcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRXhpc3RlbnRpYWxUeXBlUGFyYW1cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCJdXG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbXNcIiwgXCJyZXN0XCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRnVuY3Rpb25UeXBlUGFyYW1cIiwge1xuICB2aXNpdG9yOiBbXCJuYW1lXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkludGVyZmFjZUV4dGVuZHNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJleHRlbmRzXCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiTnVtZXJpY0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiU3RyaW5nVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJUaGlzVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlR5cGVBbGlhc1wiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJyaWdodFwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJPcGFxdWVUeXBlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImltcGx0eXBlXCIsIFwic3VwZXJ0eXBlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlR5cGVDYXN0RXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkV4cHJlc3Npb25XcmFwcGVyXCIsIFwiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiVHlwZVBhcmFtZXRlclwiLCB7XG4gIHZpc2l0b3I6IFtcImJvdW5kXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJwYXJhbXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicGFyYW1zXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIiwgXCJpbmRleGVyc1wiLCBcImNhbGxQcm9wZXJ0aWVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJVc2VyV2hpdGVzcGFjYWJsZVwiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiT2JqZWN0VHlwZUluZGV4ZXJcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcImtleVwiLCBcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIk9iamVjdFR5cGVQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJxdWFsaWZpY2F0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHt9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge31cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzL2xpYi9kZWZpbml0aW9ucy9mbG93LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiSlNYQXR0cmlidXRlXCIsIHtcbiAgdmlzaXRvcjogW1wibmFtZVwiLCBcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIiwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYRWxlbWVudFwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJKU1hDbG9zaW5nRWxlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiLCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkpTWEVsZW1lbnRcIiwge1xuICBidWlsZGVyOiBbXCJvcGVuaW5nRWxlbWVudFwiLCBcImNsb3NpbmdFbGVtZW50XCIsIFwiY2hpbGRyZW5cIiwgXCJzZWxmQ2xvc2luZ1wiXSxcbiAgdmlzaXRvcjogW1wib3BlbmluZ0VsZW1lbnRcIiwgXCJjaGlsZHJlblwiLCBcImNsb3NpbmdFbGVtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvcGVuaW5nRWxlbWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYT3BlbmluZ0VsZW1lbnRcIilcbiAgICB9LFxuICAgIGNsb3NpbmdFbGVtZW50OiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkpTWENsb3NpbmdFbGVtZW50XCIpXG4gICAgfSxcbiAgICBjaGlsZHJlbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguY2hhaW4pKCgwLCBfaW5kZXguYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4LmFzc2VydEVhY2gpKCgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYVGV4dFwiLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiwgXCJKU1hTcHJlYWRDaGlsZFwiLCBcIkpTWEVsZW1lbnRcIikpKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHtcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiRXhwcmVzc2lvblwiXVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiSlNYU3ByZWFkQ2hpbGRcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkpTWElkZW50aWZpZXJcIiwge1xuICBidWlsZGVyOiBbXCJuYW1lXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBcIkpTWElkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJKU1hOYW1lc3BhY2VkTmFtZVwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVzcGFjZVwiLCBcIm5hbWVcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZXNwYWNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJKU1hPcGVuaW5nRWxlbWVudFwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIiwgXCJhdHRyaWJ1dGVzXCIsIFwic2VsZkNsb3NpbmdcIl0sXG4gIHZpc2l0b3I6IFtcIm5hbWVcIiwgXCJhdHRyaWJ1dGVzXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIiwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBzZWxmQ2xvc2luZzoge1xuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH0sXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguY2hhaW4pKCgwLCBfaW5kZXguYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX2luZGV4LmFzc2VydEVhY2gpKCgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYQXR0cmlidXRlXCIsIFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJKU1hUZXh0XCIsIHtcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdLFxuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHlwZXNANi4yNi4wQGJhYmVsLXR5cGVzL2xpYi9kZWZpbml0aW9ucy9qc3guanNcbi8vIG1vZHVsZSBpZCA9IDMxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuXG52YXIgX2luZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luZGV4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJOb29wXCIsIHtcbiAgdmlzaXRvcjogW11cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkV4cHJlc3Npb25XcmFwcGVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlcy9saWIvZGVmaW5pdGlvbnMvbWlzYy5qc1xuLy8gbW9kdWxlIGlkID0gMzE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG5cbnZhciBfaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5kZXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkF3YWl0RXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImFyZ3VtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlRlcm1pbmF0b3JsZXNzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRm9yQXdhaXRTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIlN0YXRlbWVudFwiLCBcIkZvclwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiLCBcIkZvclhTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJMVmFsXCIpXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJCaW5kRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcImNhbGxlZVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7fVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiSW1wb3J0XCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRGVjb3JhdG9yXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRG9FeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJleHBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfaW5kZXguYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG5cbigwLCBfaW5kZXgyLmRlZmF1bHQpKFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwb3J0ZWRcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwb3J0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX2luZGV4LmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuXG4oMCwgX2luZGV4Mi5kZWZhdWx0KShcIlJlc3RQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJVbmFyeUxpa2VcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpXG4gICAgfVxuICB9XG59KTtcblxuKDAsIF9pbmRleDIuZGVmYXVsdCkoXCJTcHJlYWRQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJVbmFyeUxpa2VcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF9pbmRleC5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXR5cGVzQDYuMjYuMEBiYWJlbC10eXBlcy9saWIvZGVmaW5pdGlvbnMvZXhwZXJpbWVudGFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzUmVhY3RDb21wb25lbnQgPSB1bmRlZmluZWQ7XG5leHBvcnRzLmlzQ29tcGF0VGFnID0gaXNDb21wYXRUYWc7XG5leHBvcnRzLmJ1aWxkQ2hpbGRyZW4gPSBidWlsZENoaWxkcmVuO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2luZGV4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxudmFyIGlzUmVhY3RDb21wb25lbnQgPSBleHBvcnRzLmlzUmVhY3RDb21wb25lbnQgPSB0LmJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uKFwiUmVhY3QuQ29tcG9uZW50XCIpO1xuXG5mdW5jdGlvbiBpc0NvbXBhdFRhZyh0YWdOYW1lKSB7XG4gIHJldHVybiAhIXRhZ05hbWUgJiYgL15bYS16XXxcXC0vLnRlc3QodGFnTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZChjaGlsZCwgYXJncykge1xuICB2YXIgbGluZXMgPSBjaGlsZC52YWx1ZS5zcGxpdCgvXFxyXFxufFxcbnxcXHIvKTtcblxuICB2YXIgbGFzdE5vbkVtcHR5TGluZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaW5lc1tpXS5tYXRjaCgvW14gXFx0XS8pKSB7XG4gICAgICBsYXN0Tm9uRW1wdHlMaW5lID0gaTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyID0gXCJcIjtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGluZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tfaV07XG5cbiAgICB2YXIgaXNGaXJzdExpbmUgPSBfaSA9PT0gMDtcbiAgICB2YXIgaXNMYXN0TGluZSA9IF9pID09PSBsaW5lcy5sZW5ndGggLSAxO1xuICAgIHZhciBpc0xhc3ROb25FbXB0eUxpbmUgPSBfaSA9PT0gbGFzdE5vbkVtcHR5TGluZTtcblxuICAgIHZhciB0cmltbWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXFx0L2csIFwiIFwiKTtcblxuICAgIGlmICghaXNGaXJzdExpbmUpIHtcbiAgICAgIHRyaW1tZWRMaW5lID0gdHJpbW1lZExpbmUucmVwbGFjZSgvXlsgXSsvLCBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTGFzdExpbmUpIHtcbiAgICAgIHRyaW1tZWRMaW5lID0gdHJpbW1lZExpbmUucmVwbGFjZSgvWyBdKyQvLCBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAodHJpbW1lZExpbmUpIHtcbiAgICAgIGlmICghaXNMYXN0Tm9uRW1wdHlMaW5lKSB7XG4gICAgICAgIHRyaW1tZWRMaW5lICs9IFwiIFwiO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gdHJpbW1lZExpbmU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cikgYXJncy5wdXNoKHQuc3RyaW5nTGl0ZXJhbChzdHIpKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDaGlsZHJlbihub2RlKSB7XG4gIHZhciBlbGVtcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cbiAgICBpZiAodC5pc0pTWFRleHQoY2hpbGQpKSB7XG4gICAgICBjbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQoY2hpbGQsIGVsZW1zKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0LmlzSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihjaGlsZCkpIGNoaWxkID0gY2hpbGQuZXhwcmVzc2lvbjtcbiAgICBpZiAodC5pc0pTWEVtcHR5RXhwcmVzc2lvbihjaGlsZCkpIGNvbnRpbnVlO1xuXG4gICAgZWxlbXMucHVzaChjaGlsZCk7XG4gIH1cblxuICByZXR1cm4gZWxlbXM7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10eXBlc0A2LjI2LjBAYmFiZWwtdHlwZXMvbGliL3JlYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9kZWJ1Z0AyLjYuOUBkZWJ1Zy9zcmMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2RlYnVnQDIuNi45QGRlYnVnL3NyYy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9tc0AyLjAuMEBtcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgLy8gY2FtZWwtY2FzZVxuICB2YXIgcHJvcCA9IGtleVxuICAgIC5zdWJzdHJpbmcoNilcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKC9fKFthLXpdKS9nLCBmdW5jdGlvbiAoXywgaykgeyByZXR1cm4gay50b1VwcGVyQ2FzZSgpIH0pO1xuXG4gIC8vIGNvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuICB2YXIgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcbiAgaWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gdHJ1ZTtcbiAgZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IGZhbHNlO1xuICBlbHNlIGlmICh2YWwgPT09ICdudWxsJykgdmFsID0gbnVsbDtcbiAgZWxzZSB2YWwgPSBOdW1iZXIodmFsKTtcblxuICBvYmpbcHJvcF0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogVGhlIGZpbGUgZGVzY3JpcHRvciB0byB3cml0ZSB0aGUgYGRlYnVnKClgIGNhbGxzIHRvLlxuICogU2V0IHRoZSBgREVCVUdfRkRgIGVudiB2YXJpYWJsZSB0byBvdmVycmlkZSB3aXRoIGFub3RoZXIgdmFsdWUuIGkuZS46XG4gKlxuICogICAkIERFQlVHX0ZEPTMgbm9kZSBzY3JpcHQuanMgMz5kZWJ1Zy5sb2dcbiAqL1xuXG52YXIgZmQgPSBwYXJzZUludChwcm9jZXNzLmVudi5ERUJVR19GRCwgMTApIHx8IDI7XG5cbmlmICgxICE9PSBmZCAmJiAyICE9PSBmZCkge1xuICB1dGlsLmRlcHJlY2F0ZShmdW5jdGlvbigpe30sICdleGNlcHQgZm9yIHN0ZGVycigyKSBhbmQgc3Rkb3V0KDEpLCBhbnkgb3RoZXIgdXNhZ2Ugb2YgREVCVUdfRkQgaXMgZGVwcmVjYXRlZC4gT3ZlcnJpZGUgZGVidWcubG9nIGlmIHlvdSB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBsb2cgZnVuY3Rpb24gKGh0dHBzOi8vZ2l0LmlvL2RlYnVnX2ZkKScpKClcbn1cblxudmFyIHN0cmVhbSA9IDEgPT09IGZkID8gcHJvY2Vzcy5zdGRvdXQgOlxuICAgICAgICAgICAgIDIgPT09IGZkID8gcHJvY2Vzcy5zdGRlcnIgOlxuICAgICAgICAgICAgIGNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0oZmQpO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzXG4gICAgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKVxuICAgIDogdHR5LmlzYXR0eShmZCk7XG59XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG4gICAgLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKVxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2U7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBwcmVmaXggPSAnICBcXHUwMDFiWzMnICsgYyArICc7MW0nICsgbmFtZSArICcgJyArICdcXHUwMDFiWzBtJztcblxuICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcbiAgICBhcmdzLnB1c2goJ1xcdTAwMWJbMycgKyBjICsgJ20rJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFiWzBtJyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKVxuICAgICAgKyAnICcgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcbiAgfVxufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0KClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBgc3RyZWFtYC5cbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcbiAgICAvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogQ29waWVkIGZyb20gYG5vZGUvc3JjL25vZGUuanNgLlxuICpcbiAqIFhYWDogSXQncyBsYW1lIHRoYXQgbm9kZSBkb2Vzbid0IGV4cG9zZSB0aGlzIEFQSSBvdXQtb2YtdGhlLWJveC4gSXQgYWxzb1xuICogcmVsaWVzIG9uIHRoZSB1bmRvY3VtZW50ZWQgYHR0eV93cmFwLmd1ZXNzSGFuZGxlVHlwZSgpYCB3aGljaCBpcyBhbHNvIGxhbWUuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbSAoZmQpIHtcbiAgdmFyIHN0cmVhbTtcbiAgdmFyIHR0eV93cmFwID0gcHJvY2Vzcy5iaW5kaW5nKCd0dHlfd3JhcCcpO1xuXG4gIC8vIE5vdGUgc3RyZWFtLl90eXBlIGlzIHVzZWQgZm9yIHRlc3QtbW9kdWxlLWxvYWQtbGlzdC5qc1xuXG4gIHN3aXRjaCAodHR5X3dyYXAuZ3Vlc3NIYW5kbGVUeXBlKGZkKSkge1xuICAgIGNhc2UgJ1RUWSc6XG4gICAgICBzdHJlYW0gPSBuZXcgdHR5LldyaXRlU3RyZWFtKGZkKTtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICd0dHknO1xuXG4gICAgICAvLyBIYWNrIHRvIGhhdmUgc3RyZWFtIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIGFsaXZlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcyNlxuICAgICAgaWYgKHN0cmVhbS5faGFuZGxlICYmIHN0cmVhbS5faGFuZGxlLnVucmVmKSB7XG4gICAgICAgIHN0cmVhbS5faGFuZGxlLnVucmVmKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0ZJTEUnOlxuICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgIHN0cmVhbSA9IG5ldyBmcy5TeW5jV3JpdGVTdHJlYW0oZmQsIHsgYXV0b0Nsb3NlOiBmYWxzZSB9KTtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICdmcyc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BJUEUnOlxuICAgIGNhc2UgJ1RDUCc6XG4gICAgICB2YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG4gICAgICBzdHJlYW0gPSBuZXcgbmV0LlNvY2tldCh7XG4gICAgICAgIGZkOiBmZCxcbiAgICAgICAgcmVhZGFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZJWE1FIFNob3VsZCBwcm9iYWJseSBoYXZlIGFuIG9wdGlvbiBpbiBuZXQuU29ja2V0IHRvIGNyZWF0ZSBhXG4gICAgICAvLyBzdHJlYW0gZnJvbSBhbiBleGlzdGluZyBmZCB3aGljaCBpcyB3cml0YWJsZSBvbmx5LiBCdXQgZm9yIG5vd1xuICAgICAgLy8gd2UnbGwganVzdCBhZGQgdGhpcyBoYWNrIGFuZCBzZXQgdGhlIGByZWFkYWJsZWAgbWVtYmVyIHRvIGZhbHNlLlxuICAgICAgLy8gVGVzdDogLi9ub2RlIHRlc3QvZml4dHVyZXMvZWNoby5qcyA8IC9ldGMvcGFzc3dkXG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZWFkID0gbnVsbDtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICdwaXBlJztcblxuICAgICAgLy8gRklYTUUgSGFjayB0byBoYXZlIHN0cmVhbSBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBhbGl2ZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MjZcbiAgICAgIGlmIChzdHJlYW0uX2hhbmRsZSAmJiBzdHJlYW0uX2hhbmRsZS51bnJlZikge1xuICAgICAgICBzdHJlYW0uX2hhbmRsZS51bnJlZigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gUHJvYmFibHkgYW4gZXJyb3Igb24gaW4gdXZfZ3Vlc3NfaGFuZGxlKClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW1wbGVtZW50IG1lLiBVbmtub3duIHN0cmVhbSBmaWxlIHR5cGUhJyk7XG4gIH1cblxuICAvLyBGb3Igc3VwcG9ydGluZyBsZWdhY3kgQVBJIHdlIHB1dCB0aGUgRkQgaGVyZS5cbiAgc3RyZWFtLmZkID0gZmQ7XG5cbiAgc3RyZWFtLl9pc1N0ZGlvID0gdHJ1ZTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQgKGRlYnVnKSB7XG4gIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBwcm9jZXNzLmVudi5ERUJVR2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2RlYnVnQDIuNi45QGRlYnVnL3NyYy9ub2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHR5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHR5XCJcbi8vIG1vZHVsZSBpZCA9IDMyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJuZXRcIlxuLy8gbW9kdWxlIGlkID0gMzIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIE5PREVfRU5WID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAoTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9pbnZhcmlhbnRAMi4yLjJAaW52YXJpYW50L2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gMzIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduSW5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIEJhcigpIHtcbiAqICAgdGhpcy5jID0gMztcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMzI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fY3JlYXRlQXNzaWduZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fb3ZlclJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDMyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19hcHBseS5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19zZXRUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9jb25zdGFudC5qc1xuLy8gbW9kdWxlIGlkID0gMzMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX3Nob3J0T3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLk1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuLy8gbW9kdWxlIGlkID0gMzM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDMzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qc1xuLy8gbW9kdWxlIGlkID0gMzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDMzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAub2YuanNcbi8vIG1vZHVsZSBpZCA9IDM0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcubWFwLmZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDM0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2lzU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvdG9GaW5pdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvdG9OdW1iZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvdmFsdWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVZhbHVlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Jhc2VWYWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gIGRvIHtcbiAgICBpZiAobiAlIDIpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgfVxuICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgaWYgKG4pIHtcbiAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgfVxuICB9IHdoaWxlIChuKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXBlYXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlUmVwZWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZVRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2JpbmRpbmcgPSByZXF1aXJlKFwiLi4vYmluZGluZ1wiKTtcblxudmFyIF9iaW5kaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRpbmcpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcmVuYW1lVmlzaXRvciA9IHtcbiAgUmVmZXJlbmNlZElkZW50aWZpZXI6IGZ1bmN0aW9uIFJlZmVyZW5jZWRJZGVudGlmaWVyKF9yZWYsIHN0YXRlKSB7XG4gICAgdmFyIG5vZGUgPSBfcmVmLm5vZGU7XG5cbiAgICBpZiAobm9kZS5uYW1lID09PSBzdGF0ZS5vbGROYW1lKSB7XG4gICAgICBub2RlLm5hbWUgPSBzdGF0ZS5uZXdOYW1lO1xuICAgIH1cbiAgfSxcbiAgU2NvcGU6IGZ1bmN0aW9uIFNjb3BlKHBhdGgsIHN0YXRlKSB7XG4gICAgaWYgKCFwYXRoLnNjb3BlLmJpbmRpbmdJZGVudGlmaWVyRXF1YWxzKHN0YXRlLm9sZE5hbWUsIHN0YXRlLmJpbmRpbmcuaWRlbnRpZmllcikpIHtcbiAgICAgIHBhdGguc2tpcCgpO1xuICAgIH1cbiAgfSxcbiAgXCJBc3NpZ25tZW50RXhwcmVzc2lvbnxEZWNsYXJhdGlvblwiOiBmdW5jdGlvbiBBc3NpZ25tZW50RXhwcmVzc2lvbkRlY2xhcmF0aW9uKHBhdGgsIHN0YXRlKSB7XG4gICAgdmFyIGlkcyA9IHBhdGguZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMoKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gaWRzKSB7XG4gICAgICBpZiAobmFtZSA9PT0gc3RhdGUub2xkTmFtZSkgaWRzW25hbWVdLm5hbWUgPSBzdGF0ZS5uZXdOYW1lO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlbmFtZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlbmFtZXIoYmluZGluZywgb2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFJlbmFtZXIpO1xuXG4gICAgdGhpcy5uZXdOYW1lID0gbmV3TmFtZTtcbiAgICB0aGlzLm9sZE5hbWUgPSBvbGROYW1lO1xuICAgIHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG4gIH1cblxuICBSZW5hbWVyLnByb3RvdHlwZS5tYXliZUNvbnZlcnRGcm9tRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiBtYXliZUNvbnZlcnRGcm9tRXhwb3J0RGVjbGFyYXRpb24ocGFyZW50RGVjbGFyKSB7XG4gICAgdmFyIGV4cG9ydERlY2xhciA9IHBhcmVudERlY2xhci5wYXJlbnRQYXRoLmlzRXhwb3J0RGVjbGFyYXRpb24oKSAmJiBwYXJlbnREZWNsYXIucGFyZW50UGF0aDtcbiAgICBpZiAoIWV4cG9ydERlY2xhcikgcmV0dXJuO1xuXG4gICAgdmFyIGlzRGVmYXVsdCA9IGV4cG9ydERlY2xhci5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbigpO1xuXG4gICAgaWYgKGlzRGVmYXVsdCAmJiAocGFyZW50RGVjbGFyLmlzRnVuY3Rpb25EZWNsYXJhdGlvbigpIHx8IHBhcmVudERlY2xhci5pc0NsYXNzRGVjbGFyYXRpb24oKSkgJiYgIXBhcmVudERlY2xhci5ub2RlLmlkKSB7XG4gICAgICBwYXJlbnREZWNsYXIubm9kZS5pZCA9IHBhcmVudERlY2xhci5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJkZWZhdWx0XCIpO1xuICAgIH1cblxuICAgIHZhciBiaW5kaW5nSWRlbnRpZmllcnMgPSBwYXJlbnREZWNsYXIuZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMoKTtcbiAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBiaW5kaW5nSWRlbnRpZmllcnMpIHtcbiAgICAgIHZhciBsb2NhbE5hbWUgPSBuYW1lID09PSB0aGlzLm9sZE5hbWUgPyB0aGlzLm5ld05hbWUgOiBuYW1lO1xuICAgICAgdmFyIGV4cG9ydGVkTmFtZSA9IGlzRGVmYXVsdCA/IFwiZGVmYXVsdFwiIDogbmFtZTtcbiAgICAgIHNwZWNpZmllcnMucHVzaCh0LmV4cG9ydFNwZWNpZmllcih0LmlkZW50aWZpZXIobG9jYWxOYW1lKSwgdC5pZGVudGlmaWVyKGV4cG9ydGVkTmFtZSkpKTtcbiAgICB9XG5cbiAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgIHZhciBhbGlhc0RlY2xhciA9IHQuZXhwb3J0TmFtZWREZWNsYXJhdGlvbihudWxsLCBzcGVjaWZpZXJzKTtcblxuICAgICAgaWYgKHBhcmVudERlY2xhci5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBhbGlhc0RlY2xhci5fYmxvY2tIb2lzdCA9IDM7XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydERlY2xhci5pbnNlcnRBZnRlcihhbGlhc0RlY2xhcik7XG4gICAgICBleHBvcnREZWNsYXIucmVwbGFjZVdpdGgocGFyZW50RGVjbGFyLm5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBSZW5hbWVyLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiByZW5hbWUoYmxvY2spIHtcbiAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZyxcbiAgICAgICAgb2xkTmFtZSA9IHRoaXMub2xkTmFtZSxcbiAgICAgICAgbmV3TmFtZSA9IHRoaXMubmV3TmFtZTtcbiAgICB2YXIgc2NvcGUgPSBiaW5kaW5nLnNjb3BlLFxuICAgICAgICBwYXRoID0gYmluZGluZy5wYXRoO1xuXG5cbiAgICB2YXIgcGFyZW50RGVjbGFyID0gcGF0aC5maW5kKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5pc0RlY2xhcmF0aW9uKCkgfHwgcGF0aC5pc0Z1bmN0aW9uRXhwcmVzc2lvbigpO1xuICAgIH0pO1xuICAgIGlmIChwYXJlbnREZWNsYXIpIHtcbiAgICAgIHRoaXMubWF5YmVDb252ZXJ0RnJvbUV4cG9ydERlY2xhcmF0aW9uKHBhcmVudERlY2xhcik7XG4gICAgfVxuXG4gICAgc2NvcGUudHJhdmVyc2UoYmxvY2sgfHwgc2NvcGUuYmxvY2ssIHJlbmFtZVZpc2l0b3IsIHRoaXMpO1xuXG4gICAgaWYgKCFibG9jaykge1xuICAgICAgc2NvcGUucmVtb3ZlT3duQmluZGluZyhvbGROYW1lKTtcbiAgICAgIHNjb3BlLmJpbmRpbmdzW25ld05hbWVdID0gYmluZGluZztcbiAgICAgIHRoaXMuYmluZGluZy5pZGVudGlmaWVyLm5hbWUgPSBuZXdOYW1lO1xuICAgIH1cblxuICAgIGlmIChiaW5kaW5nLnR5cGUgPT09IFwiaG9pc3RlZFwiKSB7fVxuICB9O1xuXG4gIHJldHVybiBSZW5hbWVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZW5hbWVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvc2NvcGUvbGliL3JlbmFtZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgbGVuZ3RoID0gMTtcbiAgfVxuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2RlZmF1bHRzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2dsb2JhbHMuanNvbicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9nbG9iYWxzQDkuMTguMEBnbG9iYWxzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJidWlsdGluXCI6e1wiQXJyYXlcIjpmYWxzZSxcIkFycmF5QnVmZmVyXCI6ZmFsc2UsXCJCb29sZWFuXCI6ZmFsc2UsXCJjb25zdHJ1Y3RvclwiOmZhbHNlLFwiRGF0YVZpZXdcIjpmYWxzZSxcIkRhdGVcIjpmYWxzZSxcImRlY29kZVVSSVwiOmZhbHNlLFwiZGVjb2RlVVJJQ29tcG9uZW50XCI6ZmFsc2UsXCJlbmNvZGVVUklcIjpmYWxzZSxcImVuY29kZVVSSUNvbXBvbmVudFwiOmZhbHNlLFwiRXJyb3JcIjpmYWxzZSxcImVzY2FwZVwiOmZhbHNlLFwiZXZhbFwiOmZhbHNlLFwiRXZhbEVycm9yXCI6ZmFsc2UsXCJGbG9hdDMyQXJyYXlcIjpmYWxzZSxcIkZsb2F0NjRBcnJheVwiOmZhbHNlLFwiRnVuY3Rpb25cIjpmYWxzZSxcImhhc093blByb3BlcnR5XCI6ZmFsc2UsXCJJbmZpbml0eVwiOmZhbHNlLFwiSW50MTZBcnJheVwiOmZhbHNlLFwiSW50MzJBcnJheVwiOmZhbHNlLFwiSW50OEFycmF5XCI6ZmFsc2UsXCJpc0Zpbml0ZVwiOmZhbHNlLFwiaXNOYU5cIjpmYWxzZSxcImlzUHJvdG90eXBlT2ZcIjpmYWxzZSxcIkpTT05cIjpmYWxzZSxcIk1hcFwiOmZhbHNlLFwiTWF0aFwiOmZhbHNlLFwiTmFOXCI6ZmFsc2UsXCJOdW1iZXJcIjpmYWxzZSxcIk9iamVjdFwiOmZhbHNlLFwicGFyc2VGbG9hdFwiOmZhbHNlLFwicGFyc2VJbnRcIjpmYWxzZSxcIlByb21pc2VcIjpmYWxzZSxcInByb3BlcnR5SXNFbnVtZXJhYmxlXCI6ZmFsc2UsXCJQcm94eVwiOmZhbHNlLFwiUmFuZ2VFcnJvclwiOmZhbHNlLFwiUmVmZXJlbmNlRXJyb3JcIjpmYWxzZSxcIlJlZmxlY3RcIjpmYWxzZSxcIlJlZ0V4cFwiOmZhbHNlLFwiU2V0XCI6ZmFsc2UsXCJTdHJpbmdcIjpmYWxzZSxcIlN5bWJvbFwiOmZhbHNlLFwiU3ludGF4RXJyb3JcIjpmYWxzZSxcIlN5c3RlbVwiOmZhbHNlLFwidG9Mb2NhbGVTdHJpbmdcIjpmYWxzZSxcInRvU3RyaW5nXCI6ZmFsc2UsXCJUeXBlRXJyb3JcIjpmYWxzZSxcIlVpbnQxNkFycmF5XCI6ZmFsc2UsXCJVaW50MzJBcnJheVwiOmZhbHNlLFwiVWludDhBcnJheVwiOmZhbHNlLFwiVWludDhDbGFtcGVkQXJyYXlcIjpmYWxzZSxcInVuZGVmaW5lZFwiOmZhbHNlLFwidW5lc2NhcGVcIjpmYWxzZSxcIlVSSUVycm9yXCI6ZmFsc2UsXCJ2YWx1ZU9mXCI6ZmFsc2UsXCJXZWFrTWFwXCI6ZmFsc2UsXCJXZWFrU2V0XCI6ZmFsc2V9LFwiZXM1XCI6e1wiQXJyYXlcIjpmYWxzZSxcIkJvb2xlYW5cIjpmYWxzZSxcImNvbnN0cnVjdG9yXCI6ZmFsc2UsXCJEYXRlXCI6ZmFsc2UsXCJkZWNvZGVVUklcIjpmYWxzZSxcImRlY29kZVVSSUNvbXBvbmVudFwiOmZhbHNlLFwiZW5jb2RlVVJJXCI6ZmFsc2UsXCJlbmNvZGVVUklDb21wb25lbnRcIjpmYWxzZSxcIkVycm9yXCI6ZmFsc2UsXCJlc2NhcGVcIjpmYWxzZSxcImV2YWxcIjpmYWxzZSxcIkV2YWxFcnJvclwiOmZhbHNlLFwiRnVuY3Rpb25cIjpmYWxzZSxcImhhc093blByb3BlcnR5XCI6ZmFsc2UsXCJJbmZpbml0eVwiOmZhbHNlLFwiaXNGaW5pdGVcIjpmYWxzZSxcImlzTmFOXCI6ZmFsc2UsXCJpc1Byb3RvdHlwZU9mXCI6ZmFsc2UsXCJKU09OXCI6ZmFsc2UsXCJNYXRoXCI6ZmFsc2UsXCJOYU5cIjpmYWxzZSxcIk51bWJlclwiOmZhbHNlLFwiT2JqZWN0XCI6ZmFsc2UsXCJwYXJzZUZsb2F0XCI6ZmFsc2UsXCJwYXJzZUludFwiOmZhbHNlLFwicHJvcGVydHlJc0VudW1lcmFibGVcIjpmYWxzZSxcIlJhbmdlRXJyb3JcIjpmYWxzZSxcIlJlZmVyZW5jZUVycm9yXCI6ZmFsc2UsXCJSZWdFeHBcIjpmYWxzZSxcIlN0cmluZ1wiOmZhbHNlLFwiU3ludGF4RXJyb3JcIjpmYWxzZSxcInRvTG9jYWxlU3RyaW5nXCI6ZmFsc2UsXCJ0b1N0cmluZ1wiOmZhbHNlLFwiVHlwZUVycm9yXCI6ZmFsc2UsXCJ1bmRlZmluZWRcIjpmYWxzZSxcInVuZXNjYXBlXCI6ZmFsc2UsXCJVUklFcnJvclwiOmZhbHNlLFwidmFsdWVPZlwiOmZhbHNlfSxcImVzNlwiOntcIkFycmF5XCI6ZmFsc2UsXCJBcnJheUJ1ZmZlclwiOmZhbHNlLFwiQm9vbGVhblwiOmZhbHNlLFwiY29uc3RydWN0b3JcIjpmYWxzZSxcIkRhdGFWaWV3XCI6ZmFsc2UsXCJEYXRlXCI6ZmFsc2UsXCJkZWNvZGVVUklcIjpmYWxzZSxcImRlY29kZVVSSUNvbXBvbmVudFwiOmZhbHNlLFwiZW5jb2RlVVJJXCI6ZmFsc2UsXCJlbmNvZGVVUklDb21wb25lbnRcIjpmYWxzZSxcIkVycm9yXCI6ZmFsc2UsXCJlc2NhcGVcIjpmYWxzZSxcImV2YWxcIjpmYWxzZSxcIkV2YWxFcnJvclwiOmZhbHNlLFwiRmxvYXQzMkFycmF5XCI6ZmFsc2UsXCJGbG9hdDY0QXJyYXlcIjpmYWxzZSxcIkZ1bmN0aW9uXCI6ZmFsc2UsXCJoYXNPd25Qcm9wZXJ0eVwiOmZhbHNlLFwiSW5maW5pdHlcIjpmYWxzZSxcIkludDE2QXJyYXlcIjpmYWxzZSxcIkludDMyQXJyYXlcIjpmYWxzZSxcIkludDhBcnJheVwiOmZhbHNlLFwiaXNGaW5pdGVcIjpmYWxzZSxcImlzTmFOXCI6ZmFsc2UsXCJpc1Byb3RvdHlwZU9mXCI6ZmFsc2UsXCJKU09OXCI6ZmFsc2UsXCJNYXBcIjpmYWxzZSxcIk1hdGhcIjpmYWxzZSxcIk5hTlwiOmZhbHNlLFwiTnVtYmVyXCI6ZmFsc2UsXCJPYmplY3RcIjpmYWxzZSxcInBhcnNlRmxvYXRcIjpmYWxzZSxcInBhcnNlSW50XCI6ZmFsc2UsXCJQcm9taXNlXCI6ZmFsc2UsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiOmZhbHNlLFwiUHJveHlcIjpmYWxzZSxcIlJhbmdlRXJyb3JcIjpmYWxzZSxcIlJlZmVyZW5jZUVycm9yXCI6ZmFsc2UsXCJSZWZsZWN0XCI6ZmFsc2UsXCJSZWdFeHBcIjpmYWxzZSxcIlNldFwiOmZhbHNlLFwiU3RyaW5nXCI6ZmFsc2UsXCJTeW1ib2xcIjpmYWxzZSxcIlN5bnRheEVycm9yXCI6ZmFsc2UsXCJTeXN0ZW1cIjpmYWxzZSxcInRvTG9jYWxlU3RyaW5nXCI6ZmFsc2UsXCJ0b1N0cmluZ1wiOmZhbHNlLFwiVHlwZUVycm9yXCI6ZmFsc2UsXCJVaW50MTZBcnJheVwiOmZhbHNlLFwiVWludDMyQXJyYXlcIjpmYWxzZSxcIlVpbnQ4QXJyYXlcIjpmYWxzZSxcIlVpbnQ4Q2xhbXBlZEFycmF5XCI6ZmFsc2UsXCJ1bmRlZmluZWRcIjpmYWxzZSxcInVuZXNjYXBlXCI6ZmFsc2UsXCJVUklFcnJvclwiOmZhbHNlLFwidmFsdWVPZlwiOmZhbHNlLFwiV2Vha01hcFwiOmZhbHNlLFwiV2Vha1NldFwiOmZhbHNlfSxcImJyb3dzZXJcIjp7XCJhZGRFdmVudExpc3RlbmVyXCI6ZmFsc2UsXCJhbGVydFwiOmZhbHNlLFwiQW5hbHlzZXJOb2RlXCI6ZmFsc2UsXCJBbmltYXRpb25cIjpmYWxzZSxcIkFuaW1hdGlvbkVmZmVjdFJlYWRPbmx5XCI6ZmFsc2UsXCJBbmltYXRpb25FZmZlY3RUaW1pbmdcIjpmYWxzZSxcIkFuaW1hdGlvbkVmZmVjdFRpbWluZ1JlYWRPbmx5XCI6ZmFsc2UsXCJBbmltYXRpb25FdmVudFwiOmZhbHNlLFwiQW5pbWF0aW9uUGxheWJhY2tFdmVudFwiOmZhbHNlLFwiQW5pbWF0aW9uVGltZWxpbmVcIjpmYWxzZSxcImFwcGxpY2F0aW9uQ2FjaGVcIjpmYWxzZSxcIkFwcGxpY2F0aW9uQ2FjaGVcIjpmYWxzZSxcIkFwcGxpY2F0aW9uQ2FjaGVFcnJvckV2ZW50XCI6ZmFsc2UsXCJhdG9iXCI6ZmFsc2UsXCJBdHRyXCI6ZmFsc2UsXCJBdWRpb1wiOmZhbHNlLFwiQXVkaW9CdWZmZXJcIjpmYWxzZSxcIkF1ZGlvQnVmZmVyU291cmNlTm9kZVwiOmZhbHNlLFwiQXVkaW9Db250ZXh0XCI6ZmFsc2UsXCJBdWRpb0Rlc3RpbmF0aW9uTm9kZVwiOmZhbHNlLFwiQXVkaW9MaXN0ZW5lclwiOmZhbHNlLFwiQXVkaW9Ob2RlXCI6ZmFsc2UsXCJBdWRpb1BhcmFtXCI6ZmFsc2UsXCJBdWRpb1Byb2Nlc3NpbmdFdmVudFwiOmZhbHNlLFwiQXV0b2NvbXBsZXRlRXJyb3JFdmVudFwiOmZhbHNlLFwiQmFyUHJvcFwiOmZhbHNlLFwiQmF0dGVyeU1hbmFnZXJcIjpmYWxzZSxcIkJlZm9yZVVubG9hZEV2ZW50XCI6ZmFsc2UsXCJCaXF1YWRGaWx0ZXJOb2RlXCI6ZmFsc2UsXCJCbG9iXCI6ZmFsc2UsXCJibHVyXCI6ZmFsc2UsXCJidG9hXCI6ZmFsc2UsXCJDYWNoZVwiOmZhbHNlLFwiY2FjaGVzXCI6ZmFsc2UsXCJDYWNoZVN0b3JhZ2VcIjpmYWxzZSxcImNhbmNlbEFuaW1hdGlvbkZyYW1lXCI6ZmFsc2UsXCJjYW5jZWxJZGxlQ2FsbGJhY2tcIjpmYWxzZSxcIkNhbnZhc0dyYWRpZW50XCI6ZmFsc2UsXCJDYW52YXNQYXR0ZXJuXCI6ZmFsc2UsXCJDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcIjpmYWxzZSxcIkNEQVRBU2VjdGlvblwiOmZhbHNlLFwiQ2hhbm5lbE1lcmdlck5vZGVcIjpmYWxzZSxcIkNoYW5uZWxTcGxpdHRlck5vZGVcIjpmYWxzZSxcIkNoYXJhY3RlckRhdGFcIjpmYWxzZSxcImNsZWFySW50ZXJ2YWxcIjpmYWxzZSxcImNsZWFyVGltZW91dFwiOmZhbHNlLFwiY2xpZW50SW5mb3JtYXRpb25cIjpmYWxzZSxcIkNsaWVudFJlY3RcIjpmYWxzZSxcIkNsaWVudFJlY3RMaXN0XCI6ZmFsc2UsXCJDbGlwYm9hcmRFdmVudFwiOmZhbHNlLFwiY2xvc2VcIjpmYWxzZSxcImNsb3NlZFwiOmZhbHNlLFwiQ2xvc2VFdmVudFwiOmZhbHNlLFwiQ29tbWVudFwiOmZhbHNlLFwiQ29tcG9zaXRpb25FdmVudFwiOmZhbHNlLFwiY29uZmlybVwiOmZhbHNlLFwiY29uc29sZVwiOmZhbHNlLFwiQ29udm9sdmVyTm9kZVwiOmZhbHNlLFwiY3JlYXRlSW1hZ2VCaXRtYXBcIjpmYWxzZSxcIkNyZWRlbnRpYWxcIjpmYWxzZSxcIkNyZWRlbnRpYWxzQ29udGFpbmVyXCI6ZmFsc2UsXCJjcnlwdG9cIjpmYWxzZSxcIkNyeXB0b1wiOmZhbHNlLFwiQ3J5cHRvS2V5XCI6ZmFsc2UsXCJDU1NcIjpmYWxzZSxcIkNTU0FuaW1hdGlvblwiOmZhbHNlLFwiQ1NTRm9udEZhY2VSdWxlXCI6ZmFsc2UsXCJDU1NJbXBvcnRSdWxlXCI6ZmFsc2UsXCJDU1NLZXlmcmFtZVJ1bGVcIjpmYWxzZSxcIkNTU0tleWZyYW1lc1J1bGVcIjpmYWxzZSxcIkNTU01lZGlhUnVsZVwiOmZhbHNlLFwiQ1NTUGFnZVJ1bGVcIjpmYWxzZSxcIkNTU1J1bGVcIjpmYWxzZSxcIkNTU1J1bGVMaXN0XCI6ZmFsc2UsXCJDU1NTdHlsZURlY2xhcmF0aW9uXCI6ZmFsc2UsXCJDU1NTdHlsZVJ1bGVcIjpmYWxzZSxcIkNTU1N0eWxlU2hlZXRcIjpmYWxzZSxcIkNTU1N1cHBvcnRzUnVsZVwiOmZhbHNlLFwiQ1NTVHJhbnNpdGlvblwiOmZhbHNlLFwiQ1NTVW5rbm93blJ1bGVcIjpmYWxzZSxcIkNTU1ZpZXdwb3J0UnVsZVwiOmZhbHNlLFwiY3VzdG9tRWxlbWVudHNcIjpmYWxzZSxcIkN1c3RvbUV2ZW50XCI6ZmFsc2UsXCJEYXRhVHJhbnNmZXJcIjpmYWxzZSxcIkRhdGFUcmFuc2Zlckl0ZW1cIjpmYWxzZSxcIkRhdGFUcmFuc2Zlckl0ZW1MaXN0XCI6ZmFsc2UsXCJEZWJ1Z1wiOmZhbHNlLFwiZGVmYXVsdFN0YXR1c1wiOmZhbHNlLFwiZGVmYXVsdHN0YXR1c1wiOmZhbHNlLFwiRGVsYXlOb2RlXCI6ZmFsc2UsXCJEZXZpY2VNb3Rpb25FdmVudFwiOmZhbHNlLFwiRGV2aWNlT3JpZW50YXRpb25FdmVudFwiOmZhbHNlLFwiZGV2aWNlUGl4ZWxSYXRpb1wiOmZhbHNlLFwiZGlzcGF0Y2hFdmVudFwiOmZhbHNlLFwiZG9jdW1lbnRcIjpmYWxzZSxcIkRvY3VtZW50XCI6ZmFsc2UsXCJEb2N1bWVudEZyYWdtZW50XCI6ZmFsc2UsXCJEb2N1bWVudFRpbWVsaW5lXCI6ZmFsc2UsXCJEb2N1bWVudFR5cGVcIjpmYWxzZSxcIkRPTUVycm9yXCI6ZmFsc2UsXCJET01FeGNlcHRpb25cIjpmYWxzZSxcIkRPTUltcGxlbWVudGF0aW9uXCI6ZmFsc2UsXCJET01QYXJzZXJcIjpmYWxzZSxcIkRPTVNldHRhYmxlVG9rZW5MaXN0XCI6ZmFsc2UsXCJET01TdHJpbmdMaXN0XCI6ZmFsc2UsXCJET01TdHJpbmdNYXBcIjpmYWxzZSxcIkRPTVRva2VuTGlzdFwiOmZhbHNlLFwiRHJhZ0V2ZW50XCI6ZmFsc2UsXCJEeW5hbWljc0NvbXByZXNzb3JOb2RlXCI6ZmFsc2UsXCJFbGVtZW50XCI6ZmFsc2UsXCJFbGVtZW50VGltZUNvbnRyb2xcIjpmYWxzZSxcIkVycm9yRXZlbnRcIjpmYWxzZSxcImV2ZW50XCI6ZmFsc2UsXCJFdmVudFwiOmZhbHNlLFwiRXZlbnRTb3VyY2VcIjpmYWxzZSxcIkV2ZW50VGFyZ2V0XCI6ZmFsc2UsXCJleHRlcm5hbFwiOmZhbHNlLFwiRmVkZXJhdGVkQ3JlZGVudGlhbFwiOmZhbHNlLFwiZmV0Y2hcIjpmYWxzZSxcIkZpbGVcIjpmYWxzZSxcIkZpbGVFcnJvclwiOmZhbHNlLFwiRmlsZUxpc3RcIjpmYWxzZSxcIkZpbGVSZWFkZXJcIjpmYWxzZSxcImZpbmRcIjpmYWxzZSxcImZvY3VzXCI6ZmFsc2UsXCJGb2N1c0V2ZW50XCI6ZmFsc2UsXCJGb250RmFjZVwiOmZhbHNlLFwiRm9ybURhdGFcIjpmYWxzZSxcImZyYW1lRWxlbWVudFwiOmZhbHNlLFwiZnJhbWVzXCI6ZmFsc2UsXCJHYWluTm9kZVwiOmZhbHNlLFwiR2FtZXBhZFwiOmZhbHNlLFwiR2FtZXBhZEJ1dHRvblwiOmZhbHNlLFwiR2FtZXBhZEV2ZW50XCI6ZmFsc2UsXCJnZXRDb21wdXRlZFN0eWxlXCI6ZmFsc2UsXCJnZXRTZWxlY3Rpb25cIjpmYWxzZSxcIkhhc2hDaGFuZ2VFdmVudFwiOmZhbHNlLFwiSGVhZGVyc1wiOmZhbHNlLFwiaGlzdG9yeVwiOmZhbHNlLFwiSGlzdG9yeVwiOmZhbHNlLFwiSFRNTEFsbENvbGxlY3Rpb25cIjpmYWxzZSxcIkhUTUxBbmNob3JFbGVtZW50XCI6ZmFsc2UsXCJIVE1MQXBwbGV0RWxlbWVudFwiOmZhbHNlLFwiSFRNTEFyZWFFbGVtZW50XCI6ZmFsc2UsXCJIVE1MQXVkaW9FbGVtZW50XCI6ZmFsc2UsXCJIVE1MQmFzZUVsZW1lbnRcIjpmYWxzZSxcIkhUTUxCbG9ja3F1b3RlRWxlbWVudFwiOmZhbHNlLFwiSFRNTEJvZHlFbGVtZW50XCI6ZmFsc2UsXCJIVE1MQlJFbGVtZW50XCI6ZmFsc2UsXCJIVE1MQnV0dG9uRWxlbWVudFwiOmZhbHNlLFwiSFRNTENhbnZhc0VsZW1lbnRcIjpmYWxzZSxcIkhUTUxDb2xsZWN0aW9uXCI6ZmFsc2UsXCJIVE1MQ29udGVudEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxEYXRhTGlzdEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxEZXRhaWxzRWxlbWVudFwiOmZhbHNlLFwiSFRNTERpYWxvZ0VsZW1lbnRcIjpmYWxzZSxcIkhUTUxEaXJlY3RvcnlFbGVtZW50XCI6ZmFsc2UsXCJIVE1MRGl2RWxlbWVudFwiOmZhbHNlLFwiSFRNTERMaXN0RWxlbWVudFwiOmZhbHNlLFwiSFRNTERvY3VtZW50XCI6ZmFsc2UsXCJIVE1MRWxlbWVudFwiOmZhbHNlLFwiSFRNTEVtYmVkRWxlbWVudFwiOmZhbHNlLFwiSFRNTEZpZWxkU2V0RWxlbWVudFwiOmZhbHNlLFwiSFRNTEZvbnRFbGVtZW50XCI6ZmFsc2UsXCJIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvblwiOmZhbHNlLFwiSFRNTEZvcm1FbGVtZW50XCI6ZmFsc2UsXCJIVE1MRnJhbWVFbGVtZW50XCI6ZmFsc2UsXCJIVE1MRnJhbWVTZXRFbGVtZW50XCI6ZmFsc2UsXCJIVE1MSGVhZEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxIZWFkaW5nRWxlbWVudFwiOmZhbHNlLFwiSFRNTEhSRWxlbWVudFwiOmZhbHNlLFwiSFRNTEh0bWxFbGVtZW50XCI6ZmFsc2UsXCJIVE1MSUZyYW1lRWxlbWVudFwiOmZhbHNlLFwiSFRNTEltYWdlRWxlbWVudFwiOmZhbHNlLFwiSFRNTElucHV0RWxlbWVudFwiOmZhbHNlLFwiSFRNTElzSW5kZXhFbGVtZW50XCI6ZmFsc2UsXCJIVE1MS2V5Z2VuRWxlbWVudFwiOmZhbHNlLFwiSFRNTExhYmVsRWxlbWVudFwiOmZhbHNlLFwiSFRNTExheWVyRWxlbWVudFwiOmZhbHNlLFwiSFRNTExlZ2VuZEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxMSUVsZW1lbnRcIjpmYWxzZSxcIkhUTUxMaW5rRWxlbWVudFwiOmZhbHNlLFwiSFRNTE1hcEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxNYXJxdWVlRWxlbWVudFwiOmZhbHNlLFwiSFRNTE1lZGlhRWxlbWVudFwiOmZhbHNlLFwiSFRNTE1lbnVFbGVtZW50XCI6ZmFsc2UsXCJIVE1MTWV0YUVsZW1lbnRcIjpmYWxzZSxcIkhUTUxNZXRlckVsZW1lbnRcIjpmYWxzZSxcIkhUTUxNb2RFbGVtZW50XCI6ZmFsc2UsXCJIVE1MT2JqZWN0RWxlbWVudFwiOmZhbHNlLFwiSFRNTE9MaXN0RWxlbWVudFwiOmZhbHNlLFwiSFRNTE9wdEdyb3VwRWxlbWVudFwiOmZhbHNlLFwiSFRNTE9wdGlvbkVsZW1lbnRcIjpmYWxzZSxcIkhUTUxPcHRpb25zQ29sbGVjdGlvblwiOmZhbHNlLFwiSFRNTE91dHB1dEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxQYXJhZ3JhcGhFbGVtZW50XCI6ZmFsc2UsXCJIVE1MUGFyYW1FbGVtZW50XCI6ZmFsc2UsXCJIVE1MUGljdHVyZUVsZW1lbnRcIjpmYWxzZSxcIkhUTUxQcmVFbGVtZW50XCI6ZmFsc2UsXCJIVE1MUHJvZ3Jlc3NFbGVtZW50XCI6ZmFsc2UsXCJIVE1MUXVvdGVFbGVtZW50XCI6ZmFsc2UsXCJIVE1MU2NyaXB0RWxlbWVudFwiOmZhbHNlLFwiSFRNTFNlbGVjdEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxTaGFkb3dFbGVtZW50XCI6ZmFsc2UsXCJIVE1MU291cmNlRWxlbWVudFwiOmZhbHNlLFwiSFRNTFNwYW5FbGVtZW50XCI6ZmFsc2UsXCJIVE1MU3R5bGVFbGVtZW50XCI6ZmFsc2UsXCJIVE1MVGFibGVDYXB0aW9uRWxlbWVudFwiOmZhbHNlLFwiSFRNTFRhYmxlQ2VsbEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxUYWJsZUNvbEVsZW1lbnRcIjpmYWxzZSxcIkhUTUxUYWJsZUVsZW1lbnRcIjpmYWxzZSxcIkhUTUxUYWJsZVJvd0VsZW1lbnRcIjpmYWxzZSxcIkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50XCI6ZmFsc2UsXCJIVE1MVGVtcGxhdGVFbGVtZW50XCI6ZmFsc2UsXCJIVE1MVGV4dEFyZWFFbGVtZW50XCI6ZmFsc2UsXCJIVE1MVGl0bGVFbGVtZW50XCI6ZmFsc2UsXCJIVE1MVHJhY2tFbGVtZW50XCI6ZmFsc2UsXCJIVE1MVUxpc3RFbGVtZW50XCI6ZmFsc2UsXCJIVE1MVW5rbm93bkVsZW1lbnRcIjpmYWxzZSxcIkhUTUxWaWRlb0VsZW1lbnRcIjpmYWxzZSxcIklEQkN1cnNvclwiOmZhbHNlLFwiSURCQ3Vyc29yV2l0aFZhbHVlXCI6ZmFsc2UsXCJJREJEYXRhYmFzZVwiOmZhbHNlLFwiSURCRW52aXJvbm1lbnRcIjpmYWxzZSxcIklEQkZhY3RvcnlcIjpmYWxzZSxcIklEQkluZGV4XCI6ZmFsc2UsXCJJREJLZXlSYW5nZVwiOmZhbHNlLFwiSURCT2JqZWN0U3RvcmVcIjpmYWxzZSxcIklEQk9wZW5EQlJlcXVlc3RcIjpmYWxzZSxcIklEQlJlcXVlc3RcIjpmYWxzZSxcIklEQlRyYW5zYWN0aW9uXCI6ZmFsc2UsXCJJREJWZXJzaW9uQ2hhbmdlRXZlbnRcIjpmYWxzZSxcIkltYWdlXCI6ZmFsc2UsXCJJbWFnZUJpdG1hcFwiOmZhbHNlLFwiSW1hZ2VEYXRhXCI6ZmFsc2UsXCJpbmRleGVkREJcIjpmYWxzZSxcImlubmVySGVpZ2h0XCI6ZmFsc2UsXCJpbm5lcldpZHRoXCI6ZmFsc2UsXCJJbnB1dEV2ZW50XCI6ZmFsc2UsXCJJbnB1dE1ldGhvZENvbnRleHRcIjpmYWxzZSxcIkludGVyc2VjdGlvbk9ic2VydmVyXCI6ZmFsc2UsXCJJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5XCI6ZmFsc2UsXCJJbnRsXCI6ZmFsc2UsXCJLZXlib2FyZEV2ZW50XCI6ZmFsc2UsXCJLZXlmcmFtZUVmZmVjdFwiOmZhbHNlLFwiS2V5ZnJhbWVFZmZlY3RSZWFkT25seVwiOmZhbHNlLFwibGVuZ3RoXCI6ZmFsc2UsXCJsb2NhbFN0b3JhZ2VcIjpmYWxzZSxcImxvY2F0aW9uXCI6ZmFsc2UsXCJMb2NhdGlvblwiOmZhbHNlLFwibG9jYXRpb25iYXJcIjpmYWxzZSxcIm1hdGNoTWVkaWFcIjpmYWxzZSxcIk1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZVwiOmZhbHNlLFwiTWVkaWFFbmNyeXB0ZWRFdmVudFwiOmZhbHNlLFwiTWVkaWFFcnJvclwiOmZhbHNlLFwiTWVkaWFLZXlFcnJvclwiOmZhbHNlLFwiTWVkaWFLZXlFdmVudFwiOmZhbHNlLFwiTWVkaWFLZXlNZXNzYWdlRXZlbnRcIjpmYWxzZSxcIk1lZGlhS2V5c1wiOmZhbHNlLFwiTWVkaWFLZXlTZXNzaW9uXCI6ZmFsc2UsXCJNZWRpYUtleVN0YXR1c01hcFwiOmZhbHNlLFwiTWVkaWFLZXlTeXN0ZW1BY2Nlc3NcIjpmYWxzZSxcIk1lZGlhTGlzdFwiOmZhbHNlLFwiTWVkaWFRdWVyeUxpc3RcIjpmYWxzZSxcIk1lZGlhUXVlcnlMaXN0RXZlbnRcIjpmYWxzZSxcIk1lZGlhU291cmNlXCI6ZmFsc2UsXCJNZWRpYVJlY29yZGVyXCI6ZmFsc2UsXCJNZWRpYVN0cmVhbVwiOmZhbHNlLFwiTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZVwiOmZhbHNlLFwiTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVcIjpmYWxzZSxcIk1lZGlhU3RyZWFtRXZlbnRcIjpmYWxzZSxcIk1lZGlhU3RyZWFtVHJhY2tcIjpmYWxzZSxcIm1lbnViYXJcIjpmYWxzZSxcIk1lc3NhZ2VDaGFubmVsXCI6ZmFsc2UsXCJNZXNzYWdlRXZlbnRcIjpmYWxzZSxcIk1lc3NhZ2VQb3J0XCI6ZmFsc2UsXCJNSURJQWNjZXNzXCI6ZmFsc2UsXCJNSURJQ29ubmVjdGlvbkV2ZW50XCI6ZmFsc2UsXCJNSURJSW5wdXRcIjpmYWxzZSxcIk1JRElJbnB1dE1hcFwiOmZhbHNlLFwiTUlESU1lc3NhZ2VFdmVudFwiOmZhbHNlLFwiTUlESU91dHB1dFwiOmZhbHNlLFwiTUlESU91dHB1dE1hcFwiOmZhbHNlLFwiTUlESVBvcnRcIjpmYWxzZSxcIk1pbWVUeXBlXCI6ZmFsc2UsXCJNaW1lVHlwZUFycmF5XCI6ZmFsc2UsXCJNb3VzZUV2ZW50XCI6ZmFsc2UsXCJtb3ZlQnlcIjpmYWxzZSxcIm1vdmVUb1wiOmZhbHNlLFwiTXV0YXRpb25FdmVudFwiOmZhbHNlLFwiTXV0YXRpb25PYnNlcnZlclwiOmZhbHNlLFwiTXV0YXRpb25SZWNvcmRcIjpmYWxzZSxcIm5hbWVcIjpmYWxzZSxcIk5hbWVkTm9kZU1hcFwiOmZhbHNlLFwibmF2aWdhdG9yXCI6ZmFsc2UsXCJOYXZpZ2F0b3JcIjpmYWxzZSxcIk5vZGVcIjpmYWxzZSxcIk5vZGVGaWx0ZXJcIjpmYWxzZSxcIk5vZGVJdGVyYXRvclwiOmZhbHNlLFwiTm9kZUxpc3RcIjpmYWxzZSxcIk5vdGlmaWNhdGlvblwiOmZhbHNlLFwiT2ZmbGluZUF1ZGlvQ29tcGxldGlvbkV2ZW50XCI6ZmFsc2UsXCJPZmZsaW5lQXVkaW9Db250ZXh0XCI6ZmFsc2UsXCJvZmZzY3JlZW5CdWZmZXJpbmdcIjpmYWxzZSxcIm9uYmVmb3JldW5sb2FkXCI6dHJ1ZSxcIm9uYmx1clwiOnRydWUsXCJvbmVycm9yXCI6dHJ1ZSxcIm9uZm9jdXNcIjp0cnVlLFwib25sb2FkXCI6dHJ1ZSxcIm9ucmVzaXplXCI6dHJ1ZSxcIm9udW5sb2FkXCI6dHJ1ZSxcIm9wZW5cIjpmYWxzZSxcIm9wZW5EYXRhYmFzZVwiOmZhbHNlLFwib3BlbmVyXCI6ZmFsc2UsXCJvcGVyYVwiOmZhbHNlLFwiT3B0aW9uXCI6ZmFsc2UsXCJPc2NpbGxhdG9yTm9kZVwiOmZhbHNlLFwib3V0ZXJIZWlnaHRcIjpmYWxzZSxcIm91dGVyV2lkdGhcIjpmYWxzZSxcIlBhZ2VUcmFuc2l0aW9uRXZlbnRcIjpmYWxzZSxcInBhZ2VYT2Zmc2V0XCI6ZmFsc2UsXCJwYWdlWU9mZnNldFwiOmZhbHNlLFwicGFyZW50XCI6ZmFsc2UsXCJQYXNzd29yZENyZWRlbnRpYWxcIjpmYWxzZSxcIlBhdGgyRFwiOmZhbHNlLFwicGVyZm9ybWFuY2VcIjpmYWxzZSxcIlBlcmZvcm1hbmNlXCI6ZmFsc2UsXCJQZXJmb3JtYW5jZUVudHJ5XCI6ZmFsc2UsXCJQZXJmb3JtYW5jZU1hcmtcIjpmYWxzZSxcIlBlcmZvcm1hbmNlTWVhc3VyZVwiOmZhbHNlLFwiUGVyZm9ybWFuY2VOYXZpZ2F0aW9uXCI6ZmFsc2UsXCJQZXJmb3JtYW5jZVJlc291cmNlVGltaW5nXCI6ZmFsc2UsXCJQZXJmb3JtYW5jZVRpbWluZ1wiOmZhbHNlLFwiUGVyaW9kaWNXYXZlXCI6ZmFsc2UsXCJQZXJtaXNzaW9uc1wiOmZhbHNlLFwiUGVybWlzc2lvblN0YXR1c1wiOmZhbHNlLFwicGVyc29uYWxiYXJcIjpmYWxzZSxcIlBsdWdpblwiOmZhbHNlLFwiUGx1Z2luQXJyYXlcIjpmYWxzZSxcIlBvcFN0YXRlRXZlbnRcIjpmYWxzZSxcInBvc3RNZXNzYWdlXCI6ZmFsc2UsXCJwcmludFwiOmZhbHNlLFwiUHJvY2Vzc2luZ0luc3RydWN0aW9uXCI6ZmFsc2UsXCJQcm9ncmVzc0V2ZW50XCI6ZmFsc2UsXCJQcm9taXNlUmVqZWN0aW9uRXZlbnRcIjpmYWxzZSxcInByb21wdFwiOmZhbHNlLFwiUHVzaE1hbmFnZXJcIjpmYWxzZSxcIlB1c2hTdWJzY3JpcHRpb25cIjpmYWxzZSxcIlJhZGlvTm9kZUxpc3RcIjpmYWxzZSxcIlJhbmdlXCI6ZmFsc2UsXCJSZWFkYWJsZUJ5dGVTdHJlYW1cIjpmYWxzZSxcIlJlYWRhYmxlU3RyZWFtXCI6ZmFsc2UsXCJyZW1vdmVFdmVudExpc3RlbmVyXCI6ZmFsc2UsXCJSZXF1ZXN0XCI6ZmFsc2UsXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIjpmYWxzZSxcInJlcXVlc3RJZGxlQ2FsbGJhY2tcIjpmYWxzZSxcInJlc2l6ZUJ5XCI6ZmFsc2UsXCJyZXNpemVUb1wiOmZhbHNlLFwiUmVzcG9uc2VcIjpmYWxzZSxcIlJUQ0ljZUNhbmRpZGF0ZVwiOmZhbHNlLFwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uXCI6ZmFsc2UsXCJSVENQZWVyQ29ubmVjdGlvblwiOmZhbHNlLFwic2NyZWVuXCI6ZmFsc2UsXCJTY3JlZW5cIjpmYWxzZSxcInNjcmVlbkxlZnRcIjpmYWxzZSxcIlNjcmVlbk9yaWVudGF0aW9uXCI6ZmFsc2UsXCJzY3JlZW5Ub3BcIjpmYWxzZSxcInNjcmVlblhcIjpmYWxzZSxcInNjcmVlbllcIjpmYWxzZSxcIlNjcmlwdFByb2Nlc3Nvck5vZGVcIjpmYWxzZSxcInNjcm9sbFwiOmZhbHNlLFwic2Nyb2xsYmFyc1wiOmZhbHNlLFwic2Nyb2xsQnlcIjpmYWxzZSxcInNjcm9sbFRvXCI6ZmFsc2UsXCJzY3JvbGxYXCI6ZmFsc2UsXCJzY3JvbGxZXCI6ZmFsc2UsXCJTZWN1cml0eVBvbGljeVZpb2xhdGlvbkV2ZW50XCI6ZmFsc2UsXCJTZWxlY3Rpb25cIjpmYWxzZSxcInNlbGZcIjpmYWxzZSxcIlNlcnZpY2VXb3JrZXJcIjpmYWxzZSxcIlNlcnZpY2VXb3JrZXJDb250YWluZXJcIjpmYWxzZSxcIlNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb25cIjpmYWxzZSxcInNlc3Npb25TdG9yYWdlXCI6ZmFsc2UsXCJzZXRJbnRlcnZhbFwiOmZhbHNlLFwic2V0VGltZW91dFwiOmZhbHNlLFwiU2hhZG93Um9vdFwiOmZhbHNlLFwiU2hhcmVkS2V5ZnJhbWVMaXN0XCI6ZmFsc2UsXCJTaGFyZWRXb3JrZXJcIjpmYWxzZSxcInNob3dNb2RhbERpYWxvZ1wiOmZhbHNlLFwiU2l0ZUJvdW5kQ3JlZGVudGlhbFwiOmZhbHNlLFwic3BlZWNoU3ludGhlc2lzXCI6ZmFsc2UsXCJTcGVlY2hTeW50aGVzaXNFdmVudFwiOmZhbHNlLFwiU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlXCI6ZmFsc2UsXCJzdGF0dXNcIjpmYWxzZSxcInN0YXR1c2JhclwiOmZhbHNlLFwic3RvcFwiOmZhbHNlLFwiU3RvcmFnZVwiOmZhbHNlLFwiU3RvcmFnZUV2ZW50XCI6ZmFsc2UsXCJzdHlsZU1lZGlhXCI6ZmFsc2UsXCJTdHlsZVNoZWV0XCI6ZmFsc2UsXCJTdHlsZVNoZWV0TGlzdFwiOmZhbHNlLFwiU3VidGxlQ3J5cHRvXCI6ZmFsc2UsXCJTVkdBRWxlbWVudFwiOmZhbHNlLFwiU1ZHQWx0R2x5cGhEZWZFbGVtZW50XCI6ZmFsc2UsXCJTVkdBbHRHbHlwaEVsZW1lbnRcIjpmYWxzZSxcIlNWR0FsdEdseXBoSXRlbUVsZW1lbnRcIjpmYWxzZSxcIlNWR0FuZ2xlXCI6ZmFsc2UsXCJTVkdBbmltYXRlQ29sb3JFbGVtZW50XCI6ZmFsc2UsXCJTVkdBbmltYXRlZEFuZ2xlXCI6ZmFsc2UsXCJTVkdBbmltYXRlZEJvb2xlYW5cIjpmYWxzZSxcIlNWR0FuaW1hdGVkRW51bWVyYXRpb25cIjpmYWxzZSxcIlNWR0FuaW1hdGVkSW50ZWdlclwiOmZhbHNlLFwiU1ZHQW5pbWF0ZWRMZW5ndGhcIjpmYWxzZSxcIlNWR0FuaW1hdGVkTGVuZ3RoTGlzdFwiOmZhbHNlLFwiU1ZHQW5pbWF0ZWROdW1iZXJcIjpmYWxzZSxcIlNWR0FuaW1hdGVkTnVtYmVyTGlzdFwiOmZhbHNlLFwiU1ZHQW5pbWF0ZWRQYXRoRGF0YVwiOmZhbHNlLFwiU1ZHQW5pbWF0ZWRQb2ludHNcIjpmYWxzZSxcIlNWR0FuaW1hdGVkUHJlc2VydmVBc3BlY3RSYXRpb1wiOmZhbHNlLFwiU1ZHQW5pbWF0ZWRSZWN0XCI6ZmFsc2UsXCJTVkdBbmltYXRlZFN0cmluZ1wiOmZhbHNlLFwiU1ZHQW5pbWF0ZWRUcmFuc2Zvcm1MaXN0XCI6ZmFsc2UsXCJTVkdBbmltYXRlRWxlbWVudFwiOmZhbHNlLFwiU1ZHQW5pbWF0ZU1vdGlvbkVsZW1lbnRcIjpmYWxzZSxcIlNWR0FuaW1hdGVUcmFuc2Zvcm1FbGVtZW50XCI6ZmFsc2UsXCJTVkdBbmltYXRpb25FbGVtZW50XCI6ZmFsc2UsXCJTVkdDaXJjbGVFbGVtZW50XCI6ZmFsc2UsXCJTVkdDbGlwUGF0aEVsZW1lbnRcIjpmYWxzZSxcIlNWR0NvbG9yXCI6ZmFsc2UsXCJTVkdDb2xvclByb2ZpbGVFbGVtZW50XCI6ZmFsc2UsXCJTVkdDb2xvclByb2ZpbGVSdWxlXCI6ZmFsc2UsXCJTVkdDb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9uRWxlbWVudFwiOmZhbHNlLFwiU1ZHQ1NTUnVsZVwiOmZhbHNlLFwiU1ZHQ3Vyc29yRWxlbWVudFwiOmZhbHNlLFwiU1ZHRGVmc0VsZW1lbnRcIjpmYWxzZSxcIlNWR0Rlc2NFbGVtZW50XCI6ZmFsc2UsXCJTVkdEaXNjYXJkRWxlbWVudFwiOmZhbHNlLFwiU1ZHRG9jdW1lbnRcIjpmYWxzZSxcIlNWR0VsZW1lbnRcIjpmYWxzZSxcIlNWR0VsZW1lbnRJbnN0YW5jZVwiOmZhbHNlLFwiU1ZHRWxlbWVudEluc3RhbmNlTGlzdFwiOmZhbHNlLFwiU1ZHRWxsaXBzZUVsZW1lbnRcIjpmYWxzZSxcIlNWR0V2ZW50XCI6ZmFsc2UsXCJTVkdFeHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6ZmFsc2UsXCJTVkdGRUJsZW5kRWxlbWVudFwiOmZhbHNlLFwiU1ZHRkVDb2xvck1hdHJpeEVsZW1lbnRcIjpmYWxzZSxcIlNWR0ZFQ29tcG9uZW50VHJhbnNmZXJFbGVtZW50XCI6ZmFsc2UsXCJTVkdGRUNvbXBvc2l0ZUVsZW1lbnRcIjpmYWxzZSxcIlNWR0ZFQ29udm9sdmVNYXRyaXhFbGVtZW50XCI6ZmFsc2UsXCJTVkdGRURpZmZ1c2VMaWdodGluZ0VsZW1lbnRcIjpmYWxzZSxcIlNWR0ZFRGlzcGxhY2VtZW50TWFwRWxlbWVudFwiOmZhbHNlLFwiU1ZHRkVEaXN0YW50TGlnaHRFbGVtZW50XCI6ZmFsc2UsXCJTVkdGRURyb3BTaGFkb3dFbGVtZW50XCI6ZmFsc2UsXCJTVkdGRUZsb29kRWxlbWVudFwiOmZhbHNlLFwiU1ZHRkVGdW5jQUVsZW1lbnRcIjpmYWxzZSxcIlNWR0ZFRnVuY0JFbGVtZW50XCI6ZmFsc2UsXCJTVkdGRUZ1bmNHRWxlbWVudFwiOmZhbHNlLFwiU1ZHRkVGdW5jUkVsZW1lbnRcIjpmYWxzZSxcIlNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudFwiOmZhbHNlLFwiU1ZHRkVJbWFnZUVsZW1lbnRcIjpmYWxzZSxcIlNWR0ZFTWVyZ2VFbGVtZW50XCI6ZmFsc2UsXCJTVkdGRU1lcmdlTm9kZUVsZW1lbnRcIjpmYWxzZSxcIlNWR0ZFTW9ycGhvbG9neUVsZW1lbnRcIjpmYWxzZSxcIlNWR0ZFT2Zmc2V0RWxlbWVudFwiOmZhbHNlLFwiU1ZHRkVQb2ludExpZ2h0RWxlbWVudFwiOmZhbHNlLFwiU1ZHRkVTcGVjdWxhckxpZ2h0aW5nRWxlbWVudFwiOmZhbHNlLFwiU1ZHRkVTcG90TGlnaHRFbGVtZW50XCI6ZmFsc2UsXCJTVkdGRVRpbGVFbGVtZW50XCI6ZmFsc2UsXCJTVkdGRVR1cmJ1bGVuY2VFbGVtZW50XCI6ZmFsc2UsXCJTVkdGaWx0ZXJFbGVtZW50XCI6ZmFsc2UsXCJTVkdGaWx0ZXJQcmltaXRpdmVTdGFuZGFyZEF0dHJpYnV0ZXNcIjpmYWxzZSxcIlNWR0ZpdFRvVmlld0JveFwiOmZhbHNlLFwiU1ZHRm9udEVsZW1lbnRcIjpmYWxzZSxcIlNWR0ZvbnRGYWNlRWxlbWVudFwiOmZhbHNlLFwiU1ZHRm9udEZhY2VGb3JtYXRFbGVtZW50XCI6ZmFsc2UsXCJTVkdGb250RmFjZU5hbWVFbGVtZW50XCI6ZmFsc2UsXCJTVkdGb250RmFjZVNyY0VsZW1lbnRcIjpmYWxzZSxcIlNWR0ZvbnRGYWNlVXJpRWxlbWVudFwiOmZhbHNlLFwiU1ZHRm9yZWlnbk9iamVjdEVsZW1lbnRcIjpmYWxzZSxcIlNWR0dFbGVtZW50XCI6ZmFsc2UsXCJTVkdHZW9tZXRyeUVsZW1lbnRcIjpmYWxzZSxcIlNWR0dseXBoRWxlbWVudFwiOmZhbHNlLFwiU1ZHR2x5cGhSZWZFbGVtZW50XCI6ZmFsc2UsXCJTVkdHcmFkaWVudEVsZW1lbnRcIjpmYWxzZSxcIlNWR0dyYXBoaWNzRWxlbWVudFwiOmZhbHNlLFwiU1ZHSEtlcm5FbGVtZW50XCI6ZmFsc2UsXCJTVkdJQ0NDb2xvclwiOmZhbHNlLFwiU1ZHSW1hZ2VFbGVtZW50XCI6ZmFsc2UsXCJTVkdMYW5nU3BhY2VcIjpmYWxzZSxcIlNWR0xlbmd0aFwiOmZhbHNlLFwiU1ZHTGVuZ3RoTGlzdFwiOmZhbHNlLFwiU1ZHTGluZWFyR3JhZGllbnRFbGVtZW50XCI6ZmFsc2UsXCJTVkdMaW5lRWxlbWVudFwiOmZhbHNlLFwiU1ZHTG9jYXRhYmxlXCI6ZmFsc2UsXCJTVkdNYXJrZXJFbGVtZW50XCI6ZmFsc2UsXCJTVkdNYXNrRWxlbWVudFwiOmZhbHNlLFwiU1ZHTWF0cml4XCI6ZmFsc2UsXCJTVkdNZXRhZGF0YUVsZW1lbnRcIjpmYWxzZSxcIlNWR01pc3NpbmdHbHlwaEVsZW1lbnRcIjpmYWxzZSxcIlNWR01QYXRoRWxlbWVudFwiOmZhbHNlLFwiU1ZHTnVtYmVyXCI6ZmFsc2UsXCJTVkdOdW1iZXJMaXN0XCI6ZmFsc2UsXCJTVkdQYWludFwiOmZhbHNlLFwiU1ZHUGF0aEVsZW1lbnRcIjpmYWxzZSxcIlNWR1BhdGhTZWdcIjpmYWxzZSxcIlNWR1BhdGhTZWdBcmNBYnNcIjpmYWxzZSxcIlNWR1BhdGhTZWdBcmNSZWxcIjpmYWxzZSxcIlNWR1BhdGhTZWdDbG9zZVBhdGhcIjpmYWxzZSxcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnNcIjpmYWxzZSxcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWxcIjpmYWxzZSxcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnNcIjpmYWxzZSxcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhSZWxcIjpmYWxzZSxcIlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzXCI6ZmFsc2UsXCJTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbFwiOmZhbHNlLFwiU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnNcIjpmYWxzZSxcIlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsXCI6ZmFsc2UsXCJTVkdQYXRoU2VnTGluZXRvQWJzXCI6ZmFsc2UsXCJTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFic1wiOmZhbHNlLFwiU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWxcIjpmYWxzZSxcIlNWR1BhdGhTZWdMaW5ldG9SZWxcIjpmYWxzZSxcIlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFic1wiOmZhbHNlLFwiU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsUmVsXCI6ZmFsc2UsXCJTVkdQYXRoU2VnTGlzdFwiOmZhbHNlLFwiU1ZHUGF0aFNlZ01vdmV0b0Fic1wiOmZhbHNlLFwiU1ZHUGF0aFNlZ01vdmV0b1JlbFwiOmZhbHNlLFwiU1ZHUGF0dGVybkVsZW1lbnRcIjpmYWxzZSxcIlNWR1BvaW50XCI6ZmFsc2UsXCJTVkdQb2ludExpc3RcIjpmYWxzZSxcIlNWR1BvbHlnb25FbGVtZW50XCI6ZmFsc2UsXCJTVkdQb2x5bGluZUVsZW1lbnRcIjpmYWxzZSxcIlNWR1ByZXNlcnZlQXNwZWN0UmF0aW9cIjpmYWxzZSxcIlNWR1JhZGlhbEdyYWRpZW50RWxlbWVudFwiOmZhbHNlLFwiU1ZHUmVjdFwiOmZhbHNlLFwiU1ZHUmVjdEVsZW1lbnRcIjpmYWxzZSxcIlNWR1JlbmRlcmluZ0ludGVudFwiOmZhbHNlLFwiU1ZHU2NyaXB0RWxlbWVudFwiOmZhbHNlLFwiU1ZHU2V0RWxlbWVudFwiOmZhbHNlLFwiU1ZHU3RvcEVsZW1lbnRcIjpmYWxzZSxcIlNWR1N0cmluZ0xpc3RcIjpmYWxzZSxcIlNWR1N0eWxhYmxlXCI6ZmFsc2UsXCJTVkdTdHlsZUVsZW1lbnRcIjpmYWxzZSxcIlNWR1NWR0VsZW1lbnRcIjpmYWxzZSxcIlNWR1N3aXRjaEVsZW1lbnRcIjpmYWxzZSxcIlNWR1N5bWJvbEVsZW1lbnRcIjpmYWxzZSxcIlNWR1Rlc3RzXCI6ZmFsc2UsXCJTVkdUZXh0Q29udGVudEVsZW1lbnRcIjpmYWxzZSxcIlNWR1RleHRFbGVtZW50XCI6ZmFsc2UsXCJTVkdUZXh0UGF0aEVsZW1lbnRcIjpmYWxzZSxcIlNWR1RleHRQb3NpdGlvbmluZ0VsZW1lbnRcIjpmYWxzZSxcIlNWR1RpdGxlRWxlbWVudFwiOmZhbHNlLFwiU1ZHVHJhbnNmb3JtXCI6ZmFsc2UsXCJTVkdUcmFuc2Zvcm1hYmxlXCI6ZmFsc2UsXCJTVkdUcmFuc2Zvcm1MaXN0XCI6ZmFsc2UsXCJTVkdUUmVmRWxlbWVudFwiOmZhbHNlLFwiU1ZHVFNwYW5FbGVtZW50XCI6ZmFsc2UsXCJTVkdVbml0VHlwZXNcIjpmYWxzZSxcIlNWR1VSSVJlZmVyZW5jZVwiOmZhbHNlLFwiU1ZHVXNlRWxlbWVudFwiOmZhbHNlLFwiU1ZHVmlld0VsZW1lbnRcIjpmYWxzZSxcIlNWR1ZpZXdTcGVjXCI6ZmFsc2UsXCJTVkdWS2VybkVsZW1lbnRcIjpmYWxzZSxcIlNWR1pvb21BbmRQYW5cIjpmYWxzZSxcIlNWR1pvb21FdmVudFwiOmZhbHNlLFwiVGV4dFwiOmZhbHNlLFwiVGV4dERlY29kZXJcIjpmYWxzZSxcIlRleHRFbmNvZGVyXCI6ZmFsc2UsXCJUZXh0RXZlbnRcIjpmYWxzZSxcIlRleHRNZXRyaWNzXCI6ZmFsc2UsXCJUZXh0VHJhY2tcIjpmYWxzZSxcIlRleHRUcmFja0N1ZVwiOmZhbHNlLFwiVGV4dFRyYWNrQ3VlTGlzdFwiOmZhbHNlLFwiVGV4dFRyYWNrTGlzdFwiOmZhbHNlLFwiVGltZUV2ZW50XCI6ZmFsc2UsXCJUaW1lUmFuZ2VzXCI6ZmFsc2UsXCJ0b29sYmFyXCI6ZmFsc2UsXCJ0b3BcIjpmYWxzZSxcIlRvdWNoXCI6ZmFsc2UsXCJUb3VjaEV2ZW50XCI6ZmFsc2UsXCJUb3VjaExpc3RcIjpmYWxzZSxcIlRyYWNrRXZlbnRcIjpmYWxzZSxcIlRyYW5zaXRpb25FdmVudFwiOmZhbHNlLFwiVHJlZVdhbGtlclwiOmZhbHNlLFwiVUlFdmVudFwiOmZhbHNlLFwiVVJMXCI6ZmFsc2UsXCJVUkxTZWFyY2hQYXJhbXNcIjpmYWxzZSxcIlZhbGlkaXR5U3RhdGVcIjpmYWxzZSxcIlZUVEN1ZVwiOmZhbHNlLFwiV2F2ZVNoYXBlck5vZGVcIjpmYWxzZSxcIldlYkdMQWN0aXZlSW5mb1wiOmZhbHNlLFwiV2ViR0xCdWZmZXJcIjpmYWxzZSxcIldlYkdMQ29udGV4dEV2ZW50XCI6ZmFsc2UsXCJXZWJHTEZyYW1lYnVmZmVyXCI6ZmFsc2UsXCJXZWJHTFByb2dyYW1cIjpmYWxzZSxcIldlYkdMUmVuZGVyYnVmZmVyXCI6ZmFsc2UsXCJXZWJHTFJlbmRlcmluZ0NvbnRleHRcIjpmYWxzZSxcIldlYkdMU2hhZGVyXCI6ZmFsc2UsXCJXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdFwiOmZhbHNlLFwiV2ViR0xUZXh0dXJlXCI6ZmFsc2UsXCJXZWJHTFVuaWZvcm1Mb2NhdGlvblwiOmZhbHNlLFwiV2ViU29ja2V0XCI6ZmFsc2UsXCJXaGVlbEV2ZW50XCI6ZmFsc2UsXCJ3aW5kb3dcIjpmYWxzZSxcIldpbmRvd1wiOmZhbHNlLFwiV29ya2VyXCI6ZmFsc2UsXCJYRG9tYWluUmVxdWVzdFwiOmZhbHNlLFwiWE1MRG9jdW1lbnRcIjpmYWxzZSxcIlhNTEh0dHBSZXF1ZXN0XCI6ZmFsc2UsXCJYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0XCI6ZmFsc2UsXCJYTUxIdHRwUmVxdWVzdFByb2dyZXNzRXZlbnRcIjpmYWxzZSxcIlhNTEh0dHBSZXF1ZXN0VXBsb2FkXCI6ZmFsc2UsXCJYTUxTZXJpYWxpemVyXCI6ZmFsc2UsXCJYUGF0aEV2YWx1YXRvclwiOmZhbHNlLFwiWFBhdGhFeGNlcHRpb25cIjpmYWxzZSxcIlhQYXRoRXhwcmVzc2lvblwiOmZhbHNlLFwiWFBhdGhOYW1lc3BhY2VcIjpmYWxzZSxcIlhQYXRoTlNSZXNvbHZlclwiOmZhbHNlLFwiWFBhdGhSZXN1bHRcIjpmYWxzZSxcIlhTTFRQcm9jZXNzb3JcIjpmYWxzZX0sXCJ3b3JrZXJcIjp7XCJhcHBsaWNhdGlvbkNhY2hlXCI6ZmFsc2UsXCJhdG9iXCI6ZmFsc2UsXCJCbG9iXCI6ZmFsc2UsXCJCcm9hZGNhc3RDaGFubmVsXCI6ZmFsc2UsXCJidG9hXCI6ZmFsc2UsXCJDYWNoZVwiOmZhbHNlLFwiY2FjaGVzXCI6ZmFsc2UsXCJjbGVhckludGVydmFsXCI6ZmFsc2UsXCJjbGVhclRpbWVvdXRcIjpmYWxzZSxcImNsb3NlXCI6dHJ1ZSxcImNvbnNvbGVcIjpmYWxzZSxcImZldGNoXCI6ZmFsc2UsXCJGaWxlUmVhZGVyU3luY1wiOmZhbHNlLFwiRm9ybURhdGFcIjpmYWxzZSxcIkhlYWRlcnNcIjpmYWxzZSxcIklEQkN1cnNvclwiOmZhbHNlLFwiSURCQ3Vyc29yV2l0aFZhbHVlXCI6ZmFsc2UsXCJJREJEYXRhYmFzZVwiOmZhbHNlLFwiSURCRmFjdG9yeVwiOmZhbHNlLFwiSURCSW5kZXhcIjpmYWxzZSxcIklEQktleVJhbmdlXCI6ZmFsc2UsXCJJREJPYmplY3RTdG9yZVwiOmZhbHNlLFwiSURCT3BlbkRCUmVxdWVzdFwiOmZhbHNlLFwiSURCUmVxdWVzdFwiOmZhbHNlLFwiSURCVHJhbnNhY3Rpb25cIjpmYWxzZSxcIklEQlZlcnNpb25DaGFuZ2VFdmVudFwiOmZhbHNlLFwiSW1hZ2VEYXRhXCI6ZmFsc2UsXCJpbXBvcnRTY3JpcHRzXCI6dHJ1ZSxcImluZGV4ZWREQlwiOmZhbHNlLFwibG9jYXRpb25cIjpmYWxzZSxcIk1lc3NhZ2VDaGFubmVsXCI6ZmFsc2UsXCJNZXNzYWdlUG9ydFwiOmZhbHNlLFwibmFtZVwiOmZhbHNlLFwibmF2aWdhdG9yXCI6ZmFsc2UsXCJOb3RpZmljYXRpb25cIjpmYWxzZSxcIm9uY2xvc2VcIjp0cnVlLFwib25jb25uZWN0XCI6dHJ1ZSxcIm9uZXJyb3JcIjp0cnVlLFwib25sYW5ndWFnZWNoYW5nZVwiOnRydWUsXCJvbm1lc3NhZ2VcIjp0cnVlLFwib25vZmZsaW5lXCI6dHJ1ZSxcIm9ub25saW5lXCI6dHJ1ZSxcIm9ucmVqZWN0aW9uaGFuZGxlZFwiOnRydWUsXCJvbnVuaGFuZGxlZHJlamVjdGlvblwiOnRydWUsXCJwZXJmb3JtYW5jZVwiOmZhbHNlLFwiUGVyZm9ybWFuY2VcIjpmYWxzZSxcIlBlcmZvcm1hbmNlRW50cnlcIjpmYWxzZSxcIlBlcmZvcm1hbmNlTWFya1wiOmZhbHNlLFwiUGVyZm9ybWFuY2VNZWFzdXJlXCI6ZmFsc2UsXCJQZXJmb3JtYW5jZU5hdmlnYXRpb25cIjpmYWxzZSxcIlBlcmZvcm1hbmNlUmVzb3VyY2VUaW1pbmdcIjpmYWxzZSxcIlBlcmZvcm1hbmNlVGltaW5nXCI6ZmFsc2UsXCJwb3N0TWVzc2FnZVwiOnRydWUsXCJQcm9taXNlXCI6ZmFsc2UsXCJSZXF1ZXN0XCI6ZmFsc2UsXCJSZXNwb25zZVwiOmZhbHNlLFwic2VsZlwiOnRydWUsXCJTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uXCI6ZmFsc2UsXCJzZXRJbnRlcnZhbFwiOmZhbHNlLFwic2V0VGltZW91dFwiOmZhbHNlLFwiVGV4dERlY29kZXJcIjpmYWxzZSxcIlRleHRFbmNvZGVyXCI6ZmFsc2UsXCJVUkxcIjpmYWxzZSxcIlVSTFNlYXJjaFBhcmFtc1wiOmZhbHNlLFwiV2ViU29ja2V0XCI6ZmFsc2UsXCJXb3JrZXJcIjpmYWxzZSxcIlhNTEh0dHBSZXF1ZXN0XCI6ZmFsc2V9LFwibm9kZVwiOntcIl9fZGlybmFtZVwiOmZhbHNlLFwiX19maWxlbmFtZVwiOmZhbHNlLFwiYXJndW1lbnRzXCI6ZmFsc2UsXCJCdWZmZXJcIjpmYWxzZSxcImNsZWFySW1tZWRpYXRlXCI6ZmFsc2UsXCJjbGVhckludGVydmFsXCI6ZmFsc2UsXCJjbGVhclRpbWVvdXRcIjpmYWxzZSxcImNvbnNvbGVcIjpmYWxzZSxcImV4cG9ydHNcIjp0cnVlLFwiR0xPQkFMXCI6ZmFsc2UsXCJnbG9iYWxcIjpmYWxzZSxcIkludGxcIjpmYWxzZSxcIm1vZHVsZVwiOmZhbHNlLFwicHJvY2Vzc1wiOmZhbHNlLFwicmVxdWlyZVwiOmZhbHNlLFwicm9vdFwiOmZhbHNlLFwic2V0SW1tZWRpYXRlXCI6ZmFsc2UsXCJzZXRJbnRlcnZhbFwiOmZhbHNlLFwic2V0VGltZW91dFwiOmZhbHNlfSxcImNvbW1vbmpzXCI6e1wiZXhwb3J0c1wiOnRydWUsXCJtb2R1bGVcIjpmYWxzZSxcInJlcXVpcmVcIjpmYWxzZSxcImdsb2JhbFwiOmZhbHNlfSxcImFtZFwiOntcImRlZmluZVwiOmZhbHNlLFwicmVxdWlyZVwiOmZhbHNlfSxcIm1vY2hhXCI6e1wiYWZ0ZXJcIjpmYWxzZSxcImFmdGVyRWFjaFwiOmZhbHNlLFwiYmVmb3JlXCI6ZmFsc2UsXCJiZWZvcmVFYWNoXCI6ZmFsc2UsXCJjb250ZXh0XCI6ZmFsc2UsXCJkZXNjcmliZVwiOmZhbHNlLFwiaXRcIjpmYWxzZSxcIm1vY2hhXCI6ZmFsc2UsXCJydW5cIjpmYWxzZSxcInNldHVwXCI6ZmFsc2UsXCJzcGVjaWZ5XCI6ZmFsc2UsXCJzdWl0ZVwiOmZhbHNlLFwic3VpdGVTZXR1cFwiOmZhbHNlLFwic3VpdGVUZWFyZG93blwiOmZhbHNlLFwidGVhcmRvd25cIjpmYWxzZSxcInRlc3RcIjpmYWxzZSxcInhjb250ZXh0XCI6ZmFsc2UsXCJ4ZGVzY3JpYmVcIjpmYWxzZSxcInhpdFwiOmZhbHNlLFwieHNwZWNpZnlcIjpmYWxzZX0sXCJqYXNtaW5lXCI6e1wiYWZ0ZXJBbGxcIjpmYWxzZSxcImFmdGVyRWFjaFwiOmZhbHNlLFwiYmVmb3JlQWxsXCI6ZmFsc2UsXCJiZWZvcmVFYWNoXCI6ZmFsc2UsXCJkZXNjcmliZVwiOmZhbHNlLFwiZXhwZWN0XCI6ZmFsc2UsXCJmYWlsXCI6ZmFsc2UsXCJmZGVzY3JpYmVcIjpmYWxzZSxcImZpdFwiOmZhbHNlLFwiaXRcIjpmYWxzZSxcImphc21pbmVcIjpmYWxzZSxcInBlbmRpbmdcIjpmYWxzZSxcInJ1bnNcIjpmYWxzZSxcInNweU9uXCI6ZmFsc2UsXCJzcHlPblByb3BlcnR5XCI6ZmFsc2UsXCJ3YWl0c1wiOmZhbHNlLFwid2FpdHNGb3JcIjpmYWxzZSxcInhkZXNjcmliZVwiOmZhbHNlLFwieGl0XCI6ZmFsc2V9LFwiamVzdFwiOntcImFmdGVyQWxsXCI6ZmFsc2UsXCJhZnRlckVhY2hcIjpmYWxzZSxcImJlZm9yZUFsbFwiOmZhbHNlLFwiYmVmb3JlRWFjaFwiOmZhbHNlLFwiY2hlY2tcIjpmYWxzZSxcImRlc2NyaWJlXCI6ZmFsc2UsXCJleHBlY3RcIjpmYWxzZSxcImdlblwiOmZhbHNlLFwiaXRcIjpmYWxzZSxcImZkZXNjcmliZVwiOmZhbHNlLFwiZml0XCI6ZmFsc2UsXCJqZXN0XCI6ZmFsc2UsXCJwaXRcIjpmYWxzZSxcInJlcXVpcmVcIjpmYWxzZSxcInRlc3RcIjpmYWxzZSxcInhkZXNjcmliZVwiOmZhbHNlLFwieGl0XCI6ZmFsc2UsXCJ4dGVzdFwiOmZhbHNlfSxcInF1bml0XCI6e1wiYXN5bmNUZXN0XCI6ZmFsc2UsXCJkZWVwRXF1YWxcIjpmYWxzZSxcImVxdWFsXCI6ZmFsc2UsXCJleHBlY3RcIjpmYWxzZSxcIm1vZHVsZVwiOmZhbHNlLFwibm90RGVlcEVxdWFsXCI6ZmFsc2UsXCJub3RFcXVhbFwiOmZhbHNlLFwibm90T2tcIjpmYWxzZSxcIm5vdFByb3BFcXVhbFwiOmZhbHNlLFwibm90U3RyaWN0RXF1YWxcIjpmYWxzZSxcIm9rXCI6ZmFsc2UsXCJwcm9wRXF1YWxcIjpmYWxzZSxcIlFVbml0XCI6ZmFsc2UsXCJyYWlzZXNcIjpmYWxzZSxcInN0YXJ0XCI6ZmFsc2UsXCJzdG9wXCI6ZmFsc2UsXCJzdHJpY3RFcXVhbFwiOmZhbHNlLFwidGVzdFwiOmZhbHNlLFwidGhyb3dzXCI6ZmFsc2V9LFwicGhhbnRvbWpzXCI6e1wiY29uc29sZVwiOnRydWUsXCJleHBvcnRzXCI6dHJ1ZSxcInBoYW50b21cIjp0cnVlLFwicmVxdWlyZVwiOnRydWUsXCJXZWJQYWdlXCI6dHJ1ZX0sXCJjb3VjaFwiOntcImVtaXRcIjpmYWxzZSxcImV4cG9ydHNcIjpmYWxzZSxcImdldFJvd1wiOmZhbHNlLFwibG9nXCI6ZmFsc2UsXCJtb2R1bGVcIjpmYWxzZSxcInByb3ZpZGVzXCI6ZmFsc2UsXCJyZXF1aXJlXCI6ZmFsc2UsXCJyZXNwb25kXCI6ZmFsc2UsXCJzZW5kXCI6ZmFsc2UsXCJzdGFydFwiOmZhbHNlLFwic3VtXCI6ZmFsc2V9LFwicmhpbm9cIjp7XCJkZWZpbmVDbGFzc1wiOmZhbHNlLFwiZGVzZXJpYWxpemVcIjpmYWxzZSxcImdjXCI6ZmFsc2UsXCJoZWxwXCI6ZmFsc2UsXCJpbXBvcnRDbGFzc1wiOmZhbHNlLFwiaW1wb3J0UGFja2FnZVwiOmZhbHNlLFwiamF2YVwiOmZhbHNlLFwibG9hZFwiOmZhbHNlLFwibG9hZENsYXNzXCI6ZmFsc2UsXCJQYWNrYWdlc1wiOmZhbHNlLFwicHJpbnRcIjpmYWxzZSxcInF1aXRcIjpmYWxzZSxcInJlYWRGaWxlXCI6ZmFsc2UsXCJyZWFkVXJsXCI6ZmFsc2UsXCJydW5Db21tYW5kXCI6ZmFsc2UsXCJzZWFsXCI6ZmFsc2UsXCJzZXJpYWxpemVcIjpmYWxzZSxcInNwYXduXCI6ZmFsc2UsXCJzeW5jXCI6ZmFsc2UsXCJ0b2ludDMyXCI6ZmFsc2UsXCJ2ZXJzaW9uXCI6ZmFsc2V9LFwibmFzaG9yblwiOntcIl9fRElSX19cIjpmYWxzZSxcIl9fRklMRV9fXCI6ZmFsc2UsXCJfX0xJTkVfX1wiOmZhbHNlLFwiY29tXCI6ZmFsc2UsXCJlZHVcIjpmYWxzZSxcImV4aXRcIjpmYWxzZSxcIkphdmFcIjpmYWxzZSxcImphdmFcIjpmYWxzZSxcImphdmFmeFwiOmZhbHNlLFwiSmF2YUltcG9ydGVyXCI6ZmFsc2UsXCJqYXZheFwiOmZhbHNlLFwiSlNBZGFwdGVyXCI6ZmFsc2UsXCJsb2FkXCI6ZmFsc2UsXCJsb2FkV2l0aE5ld0dsb2JhbFwiOmZhbHNlLFwib3JnXCI6ZmFsc2UsXCJQYWNrYWdlc1wiOmZhbHNlLFwicHJpbnRcIjpmYWxzZSxcInF1aXRcIjpmYWxzZX0sXCJ3c2hcIjp7XCJBY3RpdmVYT2JqZWN0XCI6dHJ1ZSxcIkVudW1lcmF0b3JcIjp0cnVlLFwiR2V0T2JqZWN0XCI6dHJ1ZSxcIlNjcmlwdEVuZ2luZVwiOnRydWUsXCJTY3JpcHRFbmdpbmVCdWlsZFZlcnNpb25cIjp0cnVlLFwiU2NyaXB0RW5naW5lTWFqb3JWZXJzaW9uXCI6dHJ1ZSxcIlNjcmlwdEVuZ2luZU1pbm9yVmVyc2lvblwiOnRydWUsXCJWQkFycmF5XCI6dHJ1ZSxcIldTY3JpcHRcIjp0cnVlLFwiV1NIXCI6dHJ1ZSxcIlhEb21haW5SZXF1ZXN0XCI6dHJ1ZX0sXCJqcXVlcnlcIjp7XCIkXCI6ZmFsc2UsXCJqUXVlcnlcIjpmYWxzZX0sXCJ5dWlcIjp7XCJZXCI6ZmFsc2UsXCJZVUlcIjpmYWxzZSxcIllVSV9jb25maWdcIjpmYWxzZX0sXCJzaGVsbGpzXCI6e1wiY2F0XCI6ZmFsc2UsXCJjZFwiOmZhbHNlLFwiY2htb2RcIjpmYWxzZSxcImNvbmZpZ1wiOmZhbHNlLFwiY3BcIjpmYWxzZSxcImRpcnNcIjpmYWxzZSxcImVjaG9cIjpmYWxzZSxcImVudlwiOmZhbHNlLFwiZXJyb3JcIjpmYWxzZSxcImV4ZWNcIjpmYWxzZSxcImV4aXRcIjpmYWxzZSxcImZpbmRcIjpmYWxzZSxcImdyZXBcIjpmYWxzZSxcImxzXCI6ZmFsc2UsXCJsblwiOmZhbHNlLFwibWtkaXJcIjpmYWxzZSxcIm12XCI6ZmFsc2UsXCJwb3BkXCI6ZmFsc2UsXCJwdXNoZFwiOmZhbHNlLFwicHdkXCI6ZmFsc2UsXCJybVwiOmZhbHNlLFwic2VkXCI6ZmFsc2UsXCJzZXRcIjpmYWxzZSxcInRhcmdldFwiOmZhbHNlLFwidGVtcGRpclwiOmZhbHNlLFwidGVzdFwiOmZhbHNlLFwidG91Y2hcIjpmYWxzZSxcIndoaWNoXCI6ZmFsc2V9LFwicHJvdG90eXBlanNcIjp7XCIkXCI6ZmFsc2UsXCIkJFwiOmZhbHNlLFwiJEFcIjpmYWxzZSxcIiRicmVha1wiOmZhbHNlLFwiJGNvbnRpbnVlXCI6ZmFsc2UsXCIkRlwiOmZhbHNlLFwiJEhcIjpmYWxzZSxcIiRSXCI6ZmFsc2UsXCIkd1wiOmZhbHNlLFwiQWJzdHJhY3RcIjpmYWxzZSxcIkFqYXhcIjpmYWxzZSxcIkF1dG9jb21wbGV0ZXJcIjpmYWxzZSxcIkJ1aWxkZXJcIjpmYWxzZSxcIkNsYXNzXCI6ZmFsc2UsXCJDb250cm9sXCI6ZmFsc2UsXCJEcmFnZ2FibGVcIjpmYWxzZSxcIkRyYWdnYWJsZXNcIjpmYWxzZSxcIkRyb3BwYWJsZXNcIjpmYWxzZSxcIkVmZmVjdFwiOmZhbHNlLFwiRWxlbWVudFwiOmZhbHNlLFwiRW51bWVyYWJsZVwiOmZhbHNlLFwiRXZlbnRcIjpmYWxzZSxcIkZpZWxkXCI6ZmFsc2UsXCJGb3JtXCI6ZmFsc2UsXCJIYXNoXCI6ZmFsc2UsXCJJbnNlcnRpb25cIjpmYWxzZSxcIk9iamVjdFJhbmdlXCI6ZmFsc2UsXCJQZXJpb2RpY2FsRXhlY3V0ZXJcIjpmYWxzZSxcIlBvc2l0aW9uXCI6ZmFsc2UsXCJQcm90b3R5cGVcIjpmYWxzZSxcIlNjcmlwdGFjdWxvdXNcIjpmYWxzZSxcIlNlbGVjdG9yXCI6ZmFsc2UsXCJTb3J0YWJsZVwiOmZhbHNlLFwiU29ydGFibGVPYnNlcnZlclwiOmZhbHNlLFwiU291bmRcIjpmYWxzZSxcIlRlbXBsYXRlXCI6ZmFsc2UsXCJUb2dnbGVcIjpmYWxzZSxcIlRyeVwiOmZhbHNlfSxcIm1ldGVvclwiOntcIiRcIjpmYWxzZSxcIl9cIjpmYWxzZSxcIkFjY291bnRzXCI6ZmFsc2UsXCJBY2NvdW50c0NsaWVudFwiOmZhbHNlLFwiQWNjb3VudHNTZXJ2ZXJcIjpmYWxzZSxcIkFjY291bnRzQ29tbW9uXCI6ZmFsc2UsXCJBcHBcIjpmYWxzZSxcIkFzc2V0c1wiOmZhbHNlLFwiQmxhemVcIjpmYWxzZSxcImNoZWNrXCI6ZmFsc2UsXCJDb3Jkb3ZhXCI6ZmFsc2UsXCJERFBcIjpmYWxzZSxcIkREUFNlcnZlclwiOmZhbHNlLFwiRERQUmF0ZUxpbWl0ZXJcIjpmYWxzZSxcIkRlcHNcIjpmYWxzZSxcIkVKU09OXCI6ZmFsc2UsXCJFbWFpbFwiOmZhbHNlLFwiSFRUUFwiOmZhbHNlLFwiTG9nXCI6ZmFsc2UsXCJNYXRjaFwiOmZhbHNlLFwiTWV0ZW9yXCI6ZmFsc2UsXCJNb25nb1wiOmZhbHNlLFwiTW9uZ29JbnRlcm5hbHNcIjpmYWxzZSxcIk5wbVwiOmZhbHNlLFwiUGFja2FnZVwiOmZhbHNlLFwiUGx1Z2luXCI6ZmFsc2UsXCJwcm9jZXNzXCI6ZmFsc2UsXCJSYW5kb21cIjpmYWxzZSxcIlJlYWN0aXZlRGljdFwiOmZhbHNlLFwiUmVhY3RpdmVWYXJcIjpmYWxzZSxcIlJvdXRlclwiOmZhbHNlLFwiU2VydmljZUNvbmZpZ3VyYXRpb25cIjpmYWxzZSxcIlNlc3Npb25cIjpmYWxzZSxcInNoYXJlXCI6ZmFsc2UsXCJTcGFjZWJhcnNcIjpmYWxzZSxcIlRlbXBsYXRlXCI6ZmFsc2UsXCJUaW55dGVzdFwiOmZhbHNlLFwiVHJhY2tlclwiOmZhbHNlLFwiVUlcIjpmYWxzZSxcIlV0aWxzXCI6ZmFsc2UsXCJXZWJBcHBcIjpmYWxzZSxcIldlYkFwcEludGVybmFsc1wiOmZhbHNlfSxcIm1vbmdvXCI6e1wiX2lzV2luZG93c1wiOmZhbHNlLFwiX3JhbmRcIjpmYWxzZSxcIkJ1bGtXcml0ZVJlc3VsdFwiOmZhbHNlLFwiY2F0XCI6ZmFsc2UsXCJjZFwiOmZhbHNlLFwiY29ubmVjdFwiOmZhbHNlLFwiZGJcIjpmYWxzZSxcImdldEhvc3ROYW1lXCI6ZmFsc2UsXCJnZXRNZW1JbmZvXCI6ZmFsc2UsXCJob3N0bmFtZVwiOmZhbHNlLFwiSVNPRGF0ZVwiOmZhbHNlLFwibGlzdEZpbGVzXCI6ZmFsc2UsXCJsb2FkXCI6ZmFsc2UsXCJsc1wiOmZhbHNlLFwibWQ1c3VtRmlsZVwiOmZhbHNlLFwibWtkaXJcIjpmYWxzZSxcIk1vbmdvXCI6ZmFsc2UsXCJOdW1iZXJJbnRcIjpmYWxzZSxcIk51bWJlckxvbmdcIjpmYWxzZSxcIk9iamVjdElkXCI6ZmFsc2UsXCJQbGFuQ2FjaGVcIjpmYWxzZSxcInByaW50XCI6ZmFsc2UsXCJwcmludGpzb25cIjpmYWxzZSxcInB3ZFwiOmZhbHNlLFwicXVpdFwiOmZhbHNlLFwicmVtb3ZlRmlsZVwiOmZhbHNlLFwicnNcIjpmYWxzZSxcInNoXCI6ZmFsc2UsXCJVVUlEXCI6ZmFsc2UsXCJ2ZXJzaW9uXCI6ZmFsc2UsXCJXcml0ZVJlc3VsdFwiOmZhbHNlfSxcImFwcGxlc2NyaXB0XCI6e1wiJFwiOmZhbHNlLFwiQXBwbGljYXRpb25cIjpmYWxzZSxcIkF1dG9tYXRpb25cIjpmYWxzZSxcImNvbnNvbGVcIjpmYWxzZSxcImRlbGF5XCI6ZmFsc2UsXCJMaWJyYXJ5XCI6ZmFsc2UsXCJPYmpDXCI6ZmFsc2UsXCJPYmplY3RTcGVjaWZpZXJcIjpmYWxzZSxcIlBhdGhcIjpmYWxzZSxcIlByb2dyZXNzXCI6ZmFsc2UsXCJSZWZcIjpmYWxzZX0sXCJzZXJ2aWNld29ya2VyXCI6e1wiY2FjaGVzXCI6ZmFsc2UsXCJDYWNoZVwiOmZhbHNlLFwiQ2FjaGVTdG9yYWdlXCI6ZmFsc2UsXCJDbGllbnRcIjpmYWxzZSxcImNsaWVudHNcIjpmYWxzZSxcIkNsaWVudHNcIjpmYWxzZSxcIkV4dGVuZGFibGVFdmVudFwiOmZhbHNlLFwiRXh0ZW5kYWJsZU1lc3NhZ2VFdmVudFwiOmZhbHNlLFwiRmV0Y2hFdmVudFwiOmZhbHNlLFwiaW1wb3J0U2NyaXB0c1wiOmZhbHNlLFwicmVnaXN0cmF0aW9uXCI6ZmFsc2UsXCJzZWxmXCI6ZmFsc2UsXCJTZXJ2aWNlV29ya2VyXCI6ZmFsc2UsXCJTZXJ2aWNlV29ya2VyQ29udGFpbmVyXCI6ZmFsc2UsXCJTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGVcIjpmYWxzZSxcIlNlcnZpY2VXb3JrZXJNZXNzYWdlRXZlbnRcIjpmYWxzZSxcIlNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb25cIjpmYWxzZSxcInNraXBXYWl0aW5nXCI6ZmFsc2UsXCJXaW5kb3dDbGllbnRcIjpmYWxzZX0sXCJhdG9tdGVzdFwiOntcImFkdmFuY2VDbG9ja1wiOmZhbHNlLFwiZmFrZUNsZWFySW50ZXJ2YWxcIjpmYWxzZSxcImZha2VDbGVhclRpbWVvdXRcIjpmYWxzZSxcImZha2VTZXRJbnRlcnZhbFwiOmZhbHNlLFwiZmFrZVNldFRpbWVvdXRcIjpmYWxzZSxcInJlc2V0VGltZW91dHNcIjpmYWxzZSxcIndhaXRzRm9yUHJvbWlzZVwiOmZhbHNlfSxcImVtYmVydGVzdFwiOntcImFuZFRoZW5cIjpmYWxzZSxcImNsaWNrXCI6ZmFsc2UsXCJjdXJyZW50UGF0aFwiOmZhbHNlLFwiY3VycmVudFJvdXRlTmFtZVwiOmZhbHNlLFwiY3VycmVudFVSTFwiOmZhbHNlLFwiZmlsbEluXCI6ZmFsc2UsXCJmaW5kXCI6ZmFsc2UsXCJmaW5kV2l0aEFzc2VydFwiOmZhbHNlLFwia2V5RXZlbnRcIjpmYWxzZSxcInBhdXNlVGVzdFwiOmZhbHNlLFwicmVzdW1lVGVzdFwiOmZhbHNlLFwidHJpZ2dlckV2ZW50XCI6ZmFsc2UsXCJ2aXNpdFwiOmZhbHNlfSxcInByb3RyYWN0b3JcIjp7XCIkXCI6ZmFsc2UsXCIkJFwiOmZhbHNlLFwiYnJvd3NlclwiOmZhbHNlLFwiQnlcIjpmYWxzZSxcImJ5XCI6ZmFsc2UsXCJEYXJ0T2JqZWN0XCI6ZmFsc2UsXCJlbGVtZW50XCI6ZmFsc2UsXCJwcm90cmFjdG9yXCI6ZmFsc2V9LFwic2hhcmVkLW5vZGUtYnJvd3NlclwiOntcImNsZWFySW50ZXJ2YWxcIjpmYWxzZSxcImNsZWFyVGltZW91dFwiOmZhbHNlLFwiY29uc29sZVwiOmZhbHNlLFwic2V0SW50ZXJ2YWxcIjpmYWxzZSxcInNldFRpbWVvdXRcIjpmYWxzZX0sXCJ3ZWJleHRlbnNpb25zXCI6e1wiYnJvd3NlclwiOmZhbHNlLFwiY2hyb21lXCI6ZmFsc2UsXCJvcHJcIjpmYWxzZX0sXCJncmVhc2Vtb25rZXlcIjp7XCJHTV9hZGRTdHlsZVwiOmZhbHNlLFwiR01fZGVsZXRlVmFsdWVcIjpmYWxzZSxcIkdNX2dldFJlc291cmNlVGV4dFwiOmZhbHNlLFwiR01fZ2V0UmVzb3VyY2VVUkxcIjpmYWxzZSxcIkdNX2dldFZhbHVlXCI6ZmFsc2UsXCJHTV9pbmZvXCI6ZmFsc2UsXCJHTV9saXN0VmFsdWVzXCI6ZmFsc2UsXCJHTV9sb2dcIjpmYWxzZSxcIkdNX29wZW5JblRhYlwiOmZhbHNlLFwiR01fcmVnaXN0ZXJNZW51Q29tbWFuZFwiOmZhbHNlLFwiR01fc2V0Q2xpcGJvYXJkXCI6ZmFsc2UsXCJHTV9zZXRWYWx1ZVwiOmZhbHNlLFwiR01feG1saHR0cFJlcXVlc3RcIjpmYWxzZSxcInVuc2FmZVdpbmRvd1wiOmZhbHNlfX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2dsb2JhbHNAOS4xOC4wQGdsb2JhbHMvZ2xvYmFscy5qc29uXG4vLyBtb2R1bGUgaWQgPSAzNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3dlYWstbWFwXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvd2Vhay1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDM1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuV2Vha01hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDM1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyk7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIHRtcCA9IHt9O1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3ICRXZWFrTWFwKCkuc2V0KChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkodG1wKSwgNykuZ2V0KHRtcCkgIT0gNzsgfSkpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYud2Vhay1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDM1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrTWFwJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LndlYWstbWFwLm9mLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmV4cG9ydHMuZmluZFBhcmVudCA9IGZpbmRQYXJlbnQ7XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuZXhwb3J0cy5nZXRGdW5jdGlvblBhcmVudCA9IGdldEZ1bmN0aW9uUGFyZW50O1xuZXhwb3J0cy5nZXRTdGF0ZW1lbnRQYXJlbnQgPSBnZXRTdGF0ZW1lbnRQYXJlbnQ7XG5leHBvcnRzLmdldEVhcmxpZXN0Q29tbW9uQW5jZXN0b3JGcm9tID0gZ2V0RWFybGllc3RDb21tb25BbmNlc3RvckZyb207XG5leHBvcnRzLmdldERlZXBlc3RDb21tb25BbmNlc3RvckZyb20gPSBnZXREZWVwZXN0Q29tbW9uQW5jZXN0b3JGcm9tO1xuZXhwb3J0cy5nZXRBbmNlc3RyeSA9IGdldEFuY2VzdHJ5O1xuZXhwb3J0cy5pc0FuY2VzdG9yID0gaXNBbmNlc3RvcjtcbmV4cG9ydHMuaXNEZXNjZW5kYW50ID0gaXNEZXNjZW5kYW50O1xuZXhwb3J0cy5pblR5cGUgPSBpblR5cGU7XG5leHBvcnRzLmluU2hhZG93ID0gaW5TaGFkb3c7XG5cbnZhciBfYmFiZWxUeXBlcyA9IHJlcXVpcmUoXCJiYWJlbC10eXBlc1wiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYmFiZWxUeXBlcyk7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGZpbmRQYXJlbnQoY2FsbGJhY2spIHtcbiAgdmFyIHBhdGggPSB0aGlzO1xuICB3aGlsZSAocGF0aCA9IHBhdGgucGFyZW50UGF0aCkge1xuICAgIGlmIChjYWxsYmFjayhwYXRoKSkgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmQoY2FsbGJhY2spIHtcbiAgdmFyIHBhdGggPSB0aGlzO1xuICBkbyB7XG4gICAgaWYgKGNhbGxiYWNrKHBhdGgpKSByZXR1cm4gcGF0aDtcbiAgfSB3aGlsZSAocGF0aCA9IHBhdGgucGFyZW50UGF0aCk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRGdW5jdGlvblBhcmVudCgpIHtcbiAgcmV0dXJuIHRoaXMuZmluZFBhcmVudChmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBwYXRoLmlzRnVuY3Rpb24oKSB8fCBwYXRoLmlzUHJvZ3JhbSgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVtZW50UGFyZW50KCkge1xuICB2YXIgcGF0aCA9IHRoaXM7XG4gIGRvIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoLmNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfSB3aGlsZSAocGF0aCA9IHBhdGgucGFyZW50UGF0aCk7XG59XG5cbmZ1bmN0aW9uIGdldEVhcmxpZXN0Q29tbW9uQW5jZXN0b3JGcm9tKHBhdGhzKSB7XG4gIHJldHVybiB0aGlzLmdldERlZXBlc3RDb21tb25BbmNlc3RvckZyb20ocGF0aHMsIGZ1bmN0aW9uIChkZWVwZXN0LCBpLCBhbmNlc3RyaWVzKSB7XG4gICAgdmFyIGVhcmxpZXN0ID0gdm9pZCAwO1xuICAgIHZhciBrZXlzID0gdC5WSVNJVE9SX0tFWVNbZGVlcGVzdC50eXBlXTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFuY2VzdHJpZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmNlc3RyeSA9IF9yZWY7XG5cbiAgICAgIHZhciBwYXRoID0gYW5jZXN0cnlbaSArIDFdO1xuXG4gICAgICBpZiAoIWVhcmxpZXN0KSB7XG4gICAgICAgIGVhcmxpZXN0ID0gcGF0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoLmxpc3RLZXkgJiYgZWFybGllc3QubGlzdEtleSA9PT0gcGF0aC5saXN0S2V5KSB7XG4gICAgICAgIGlmIChwYXRoLmtleSA8IGVhcmxpZXN0LmtleSkge1xuICAgICAgICAgIGVhcmxpZXN0ID0gcGF0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZWFybGllc3RLZXlJbmRleCA9IGtleXMuaW5kZXhPZihlYXJsaWVzdC5wYXJlbnRLZXkpO1xuICAgICAgdmFyIGN1cnJlbnRLZXlJbmRleCA9IGtleXMuaW5kZXhPZihwYXRoLnBhcmVudEtleSk7XG4gICAgICBpZiAoZWFybGllc3RLZXlJbmRleCA+IGN1cnJlbnRLZXlJbmRleCkge1xuICAgICAgICBlYXJsaWVzdCA9IHBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhcmxpZXN0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVlcGVzdENvbW1vbkFuY2VzdG9yRnJvbShwYXRocywgZmlsdGVyKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCFwYXRocy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gcGF0aHNbMF07XG4gIH1cblxuICB2YXIgbWluRGVwdGggPSBJbmZpbml0eTtcblxuICB2YXIgbGFzdENvbW1vbkluZGV4ID0gdm9pZCAwLFxuICAgICAgbGFzdENvbW1vbiA9IHZvaWQgMDtcblxuICB2YXIgYW5jZXN0cmllcyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBhbmNlc3RyeSA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgYW5jZXN0cnkudW5zaGlmdChwYXRoKTtcbiAgICB9IHdoaWxlICgocGF0aCA9IHBhdGgucGFyZW50UGF0aCkgJiYgcGF0aCAhPT0gX3RoaXMpO1xuXG4gICAgaWYgKGFuY2VzdHJ5Lmxlbmd0aCA8IG1pbkRlcHRoKSB7XG4gICAgICBtaW5EZXB0aCA9IGFuY2VzdHJ5Lmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0cnk7XG4gIH0pO1xuXG4gIHZhciBmaXJzdCA9IGFuY2VzdHJpZXNbMF07XG5cbiAgZGVwdGhMb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkRlcHRoOyBpKyspIHtcbiAgICB2YXIgc2hvdWxkTWF0Y2ggPSBmaXJzdFtpXTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBhbmNlc3RyaWVzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjIpOzspIHtcbiAgICAgIHZhciBfcmVmMjtcblxuICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2VzdHJ5ID0gX3JlZjI7XG5cbiAgICAgIGlmIChhbmNlc3RyeVtpXSAhPT0gc2hvdWxkTWF0Y2gpIHtcbiAgICAgICAgYnJlYWsgZGVwdGhMb29wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RDb21tb25JbmRleCA9IGk7XG4gICAgbGFzdENvbW1vbiA9IHNob3VsZE1hdGNoO1xuICB9XG5cbiAgaWYgKGxhc3RDb21tb24pIHtcbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICByZXR1cm4gZmlsdGVyKGxhc3RDb21tb24sIGxhc3RDb21tb25JbmRleCwgYW5jZXN0cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYXN0Q29tbW9uO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGludGVyc2VjdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmNlc3RyeSgpIHtcbiAgdmFyIHBhdGggPSB0aGlzO1xuICB2YXIgcGF0aHMgPSBbXTtcbiAgZG8ge1xuICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gIH0gd2hpbGUgKHBhdGggPSBwYXRoLnBhcmVudFBhdGgpO1xuICByZXR1cm4gcGF0aHM7XG59XG5cbmZ1bmN0aW9uIGlzQW5jZXN0b3IobWF5YmVEZXNjZW5kYW50KSB7XG4gIHJldHVybiBtYXliZURlc2NlbmRhbnQuaXNEZXNjZW5kYW50KHRoaXMpO1xufVxuXG5mdW5jdGlvbiBpc0Rlc2NlbmRhbnQobWF5YmVBbmNlc3Rvcikge1xuICByZXR1cm4gISF0aGlzLmZpbmRQYXJlbnQoZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIHJldHVybiBwYXJlbnQgPT09IG1heWJlQW5jZXN0b3I7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpblR5cGUoKSB7XG4gIHZhciBwYXRoID0gdGhpcztcbiAgd2hpbGUgKHBhdGgpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gYXJndW1lbnRzLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjMpOzspIHtcbiAgICAgIHZhciBfcmVmMztcblxuICAgICAgaWYgKF9pc0FycmF5Mykge1xuICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpO1xuICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSBfcmVmMztcblxuICAgICAgaWYgKHBhdGgubm9kZS50eXBlID09PSB0eXBlKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaW5TaGFkb3coa2V5KSB7XG4gIHZhciBwYXJlbnRGbiA9IHRoaXMuaXNGdW5jdGlvbigpID8gdGhpcyA6IHRoaXMuZmluZFBhcmVudChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLmlzRnVuY3Rpb24oKTtcbiAgfSk7XG4gIGlmICghcGFyZW50Rm4pIHJldHVybjtcblxuICBpZiAocGFyZW50Rm4uaXNGdW5jdGlvbkV4cHJlc3Npb24oKSB8fCBwYXJlbnRGbi5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSkge1xuICAgIHZhciBzaGFkb3cgPSBwYXJlbnRGbi5ub2RlLnNoYWRvdztcblxuICAgIGlmIChzaGFkb3cgJiYgKCFrZXkgfHwgc2hhZG93W2tleV0gIT09IGZhbHNlKSkge1xuICAgICAgcmV0dXJuIHBhcmVudEZuO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRGbi5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkpIHtcbiAgICByZXR1cm4gcGFyZW50Rm47XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvcGF0aC9hbmNlc3RyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmV4cG9ydHMuZ2V0VHlwZUFubm90YXRpb24gPSBnZXRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuX2dldFR5cGVBbm5vdGF0aW9uID0gX2dldFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Jhc2VUeXBlID0gaXNCYXNlVHlwZTtcbmV4cG9ydHMuY291bGRCZUJhc2VUeXBlID0gY291bGRCZUJhc2VUeXBlO1xuZXhwb3J0cy5iYXNlVHlwZVN0cmljdGx5TWF0Y2hlcyA9IGJhc2VUeXBlU3RyaWN0bHlNYXRjaGVzO1xuZXhwb3J0cy5pc0dlbmVyaWNUeXBlID0gaXNHZW5lcmljVHlwZTtcblxudmFyIF9pbmZlcmVycyA9IHJlcXVpcmUoXCIuL2luZmVyZXJzXCIpO1xuXG52YXIgaW5mZXJlcnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaW5mZXJlcnMpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRUeXBlQW5ub3RhdGlvbigpIHtcbiAgaWYgKHRoaXMudHlwZUFubm90YXRpb24pIHJldHVybiB0aGlzLnR5cGVBbm5vdGF0aW9uO1xuXG4gIHZhciB0eXBlID0gdGhpcy5fZ2V0VHlwZUFubm90YXRpb24oKSB8fCB0LmFueVR5cGVBbm5vdGF0aW9uKCk7XG4gIGlmICh0LmlzVHlwZUFubm90YXRpb24odHlwZSkpIHR5cGUgPSB0eXBlLnR5cGVBbm5vdGF0aW9uO1xuICByZXR1cm4gdGhpcy50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG59XG5cbmZ1bmN0aW9uIF9nZXRUeXBlQW5ub3RhdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgaWYgKHRoaXMua2V5ID09PSBcImluaXRcIiAmJiB0aGlzLnBhcmVudFBhdGguaXNWYXJpYWJsZURlY2xhcmF0b3IoKSkge1xuICAgICAgdmFyIGRlY2xhciA9IHRoaXMucGFyZW50UGF0aC5wYXJlbnRQYXRoO1xuICAgICAgdmFyIGRlY2xhclBhcmVudCA9IGRlY2xhci5wYXJlbnRQYXRoO1xuXG4gICAgICBpZiAoZGVjbGFyLmtleSA9PT0gXCJsZWZ0XCIgJiYgZGVjbGFyUGFyZW50LmlzRm9ySW5TdGF0ZW1lbnQoKSkge1xuICAgICAgICByZXR1cm4gdC5zdHJpbmdUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVjbGFyLmtleSA9PT0gXCJsZWZ0XCIgJiYgZGVjbGFyUGFyZW50LmlzRm9yT2ZTdGF0ZW1lbnQoKSkge1xuICAgICAgICByZXR1cm4gdC5hbnlUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC52b2lkVHlwZUFubm90YXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZUFubm90YXRpb247XG4gIH1cblxuICB2YXIgaW5mZXJlciA9IGluZmVyZXJzW25vZGUudHlwZV07XG4gIGlmIChpbmZlcmVyKSB7XG4gICAgcmV0dXJuIGluZmVyZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgfVxuXG4gIGluZmVyZXIgPSBpbmZlcmVyc1t0aGlzLnBhcmVudFBhdGgudHlwZV07XG4gIGlmIChpbmZlcmVyICYmIGluZmVyZXIudmFsaWRQYXJlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRQYXRoLmdldFR5cGVBbm5vdGF0aW9uKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCYXNlVHlwZShiYXNlTmFtZSwgc29mdCkge1xuICByZXR1cm4gX2lzQmFzZVR5cGUoYmFzZU5hbWUsIHRoaXMuZ2V0VHlwZUFubm90YXRpb24oKSwgc29mdCk7XG59XG5cbmZ1bmN0aW9uIF9pc0Jhc2VUeXBlKGJhc2VOYW1lLCB0eXBlLCBzb2Z0KSB7XG4gIGlmIChiYXNlTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB0LmlzU3RyaW5nVHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdC5pc051bWJlclR5cGVBbm5vdGF0aW9uKHR5cGUpO1xuICB9IGVsc2UgaWYgKGJhc2VOYW1lID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0LmlzQm9vbGVhblR5cGVBbm5vdGF0aW9uKHR5cGUpO1xuICB9IGVsc2UgaWYgKGJhc2VOYW1lID09PSBcImFueVwiKSB7XG4gICAgcmV0dXJuIHQuaXNBbnlUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJtaXhlZFwiKSB7XG4gICAgcmV0dXJuIHQuaXNNaXhlZFR5cGVBbm5vdGF0aW9uKHR5cGUpO1xuICB9IGVsc2UgaWYgKGJhc2VOYW1lID09PSBcImVtcHR5XCIpIHtcbiAgICByZXR1cm4gdC5pc0VtcHR5VHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwidm9pZFwiKSB7XG4gICAgcmV0dXJuIHQuaXNWb2lkVHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNvZnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBiYXNlIHR5cGUgXCIgKyBiYXNlTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvdWxkQmVCYXNlVHlwZShuYW1lKSB7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRUeXBlQW5ub3RhdGlvbigpO1xuICBpZiAodC5pc0FueVR5cGVBbm5vdGF0aW9uKHR5cGUpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodC5pc1VuaW9uVHlwZUFubm90YXRpb24odHlwZSkpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0eXBlLnR5cGVzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcik7Oykge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZTIgPSBfcmVmO1xuXG4gICAgICBpZiAodC5pc0FueVR5cGVBbm5vdGF0aW9uKHR5cGUyKSB8fCBfaXNCYXNlVHlwZShuYW1lLCB0eXBlMiwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gX2lzQmFzZVR5cGUobmFtZSwgdHlwZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVR5cGVTdHJpY3RseU1hdGNoZXMocmlnaHQpIHtcbiAgdmFyIGxlZnQgPSB0aGlzLmdldFR5cGVBbm5vdGF0aW9uKCk7XG4gIHJpZ2h0ID0gcmlnaHQuZ2V0VHlwZUFubm90YXRpb24oKTtcblxuICBpZiAoIXQuaXNBbnlUeXBlQW5ub3RhdGlvbihsZWZ0KSAmJiB0LmlzRmxvd0Jhc2VBbm5vdGF0aW9uKGxlZnQpKSB7XG4gICAgcmV0dXJuIHJpZ2h0LnR5cGUgPT09IGxlZnQudHlwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0dlbmVyaWNUeXBlKGdlbmVyaWNOYW1lKSB7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRUeXBlQW5ub3RhdGlvbigpO1xuICByZXR1cm4gdC5pc0dlbmVyaWNUeXBlQW5ub3RhdGlvbih0eXBlKSAmJiB0LmlzSWRlbnRpZmllcih0eXBlLmlkLCB7IG5hbWU6IGdlbmVyaWNOYW1lIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9wYXRoL2luZmVyZW5jZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBleHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gZXhwb3J0cy5GdW5jdGlvbkV4cHJlc3Npb24gPSBleHBvcnRzLklkZW50aWZpZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfaW5mZXJlclJlZmVyZW5jZSA9IHJlcXVpcmUoXCIuL2luZmVyZXItcmVmZXJlbmNlXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJZGVudGlmaWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luZmVyZXJSZWZlcmVuY2UpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0b3IgPSBWYXJpYWJsZURlY2xhcmF0b3I7XG5leHBvcnRzLlR5cGVDYXN0RXhwcmVzc2lvbiA9IFR5cGVDYXN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuTmV3RXhwcmVzc2lvbiA9IE5ld0V4cHJlc3Npb247XG5leHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IFRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gVW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuTG9naWNhbEV4cHJlc3Npb24gPSBMb2dpY2FsRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5TZXF1ZW5jZUV4cHJlc3Npb24gPSBTZXF1ZW5jZUV4cHJlc3Npb247XG5leHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5TdHJpbmdMaXRlcmFsID0gU3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuTnVtZXJpY0xpdGVyYWwgPSBOdW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWwgPSBCb29sZWFuTGl0ZXJhbDtcbmV4cG9ydHMuTnVsbExpdGVyYWwgPSBOdWxsTGl0ZXJhbDtcbmV4cG9ydHMuUmVnRXhwTGl0ZXJhbCA9IFJlZ0V4cExpdGVyYWw7XG5leHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBPYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5BcnJheUV4cHJlc3Npb24gPSBBcnJheUV4cHJlc3Npb247XG5leHBvcnRzLlJlc3RFbGVtZW50ID0gUmVzdEVsZW1lbnQ7XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcblxudmFyIF9iYWJlbFR5cGVzID0gcmVxdWlyZShcImJhYmVsLXR5cGVzXCIpO1xuXG52YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9iYWJlbFR5cGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdG9yKCkge1xuICB2YXIgaWQgPSB0aGlzLmdldChcImlkXCIpO1xuXG4gIGlmIChpZC5pc0lkZW50aWZpZXIoKSkge1xuICAgIHJldHVybiB0aGlzLmdldChcImluaXRcIikuZ2V0VHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gVHlwZUNhc3RFeHByZXNzaW9uKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZUFubm90YXRpb247XG59XG5cblR5cGVDYXN0RXhwcmVzc2lvbi52YWxpZFBhcmVudCA9IHRydWU7XG5cbmZ1bmN0aW9uIE5ld0V4cHJlc3Npb24obm9kZSkge1xuICBpZiAodGhpcy5nZXQoXCJjYWxsZWVcIikuaXNJZGVudGlmaWVyKCkpIHtcbiAgICByZXR1cm4gdC5nZW5lcmljVHlwZUFubm90YXRpb24obm9kZS5jYWxsZWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRlbXBsYXRlTGl0ZXJhbCgpIHtcbiAgcmV0dXJuIHQuc3RyaW5nVHlwZUFubm90YXRpb24oKTtcbn1cblxuZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG5vZGUpIHtcbiAgdmFyIG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcblxuICBpZiAob3BlcmF0b3IgPT09IFwidm9pZFwiKSB7XG4gICAgcmV0dXJuIHQudm9pZFR5cGVBbm5vdGF0aW9uKCk7XG4gIH0gZWxzZSBpZiAodC5OVU1CRVJfVU5BUllfT1BFUkFUT1JTLmluZGV4T2Yob3BlcmF0b3IpID49IDApIHtcbiAgICByZXR1cm4gdC5udW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKHQuU1RSSU5HX1VOQVJZX09QRVJBVE9SUy5pbmRleE9mKG9wZXJhdG9yKSA+PSAwKSB7XG4gICAgcmV0dXJuIHQuc3RyaW5nVHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIGlmICh0LkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTLmluZGV4T2Yob3BlcmF0b3IpID49IDApIHtcbiAgICByZXR1cm4gdC5ib29sZWFuVHlwZUFubm90YXRpb24oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKG5vZGUpIHtcbiAgdmFyIG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcblxuICBpZiAodC5OVU1CRVJfQklOQVJZX09QRVJBVE9SUy5pbmRleE9mKG9wZXJhdG9yKSA+PSAwKSB7XG4gICAgcmV0dXJuIHQubnVtYmVyVHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIGlmICh0LkJPT0xFQU5fQklOQVJZX09QRVJBVE9SUy5pbmRleE9mKG9wZXJhdG9yKSA+PSAwKSB7XG4gICAgcmV0dXJuIHQuYm9vbGVhblR5cGVBbm5vdGF0aW9uKCk7XG4gIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09IFwiK1wiKSB7XG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5nZXQoXCJyaWdodFwiKTtcbiAgICB2YXIgbGVmdCA9IHRoaXMuZ2V0KFwibGVmdFwiKTtcblxuICAgIGlmIChsZWZ0LmlzQmFzZVR5cGUoXCJudW1iZXJcIikgJiYgcmlnaHQuaXNCYXNlVHlwZShcIm51bWJlclwiKSkge1xuICAgICAgcmV0dXJuIHQubnVtYmVyVHlwZUFubm90YXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKGxlZnQuaXNCYXNlVHlwZShcInN0cmluZ1wiKSB8fCByaWdodC5pc0Jhc2VUeXBlKFwic3RyaW5nXCIpKSB7XG4gICAgICByZXR1cm4gdC5zdHJpbmdUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0LnVuaW9uVHlwZUFubm90YXRpb24oW3Quc3RyaW5nVHlwZUFubm90YXRpb24oKSwgdC5udW1iZXJUeXBlQW5ub3RhdGlvbigpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gTG9naWNhbEV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB0LmNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb24oW3RoaXMuZ2V0KFwibGVmdFwiKS5nZXRUeXBlQW5ub3RhdGlvbigpLCB0aGlzLmdldChcInJpZ2h0XCIpLmdldFR5cGVBbm5vdGF0aW9uKCldKTtcbn1cblxuZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICByZXR1cm4gdC5jcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uKFt0aGlzLmdldChcImNvbnNlcXVlbnRcIikuZ2V0VHlwZUFubm90YXRpb24oKSwgdGhpcy5nZXQoXCJhbHRlcm5hdGVcIikuZ2V0VHlwZUFubm90YXRpb24oKV0pO1xufVxuXG5mdW5jdGlvbiBTZXF1ZW5jZUV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB0aGlzLmdldChcImV4cHJlc3Npb25zXCIpLnBvcCgpLmdldFR5cGVBbm5vdGF0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICByZXR1cm4gdGhpcy5nZXQoXCJyaWdodFwiKS5nZXRUeXBlQW5ub3RhdGlvbigpO1xufVxuXG5mdW5jdGlvbiBVcGRhdGVFeHByZXNzaW9uKG5vZGUpIHtcbiAgdmFyIG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcbiAgaWYgKG9wZXJhdG9yID09PSBcIisrXCIgfHwgb3BlcmF0b3IgPT09IFwiLS1cIikge1xuICAgIHJldHVybiB0Lm51bWJlclR5cGVBbm5vdGF0aW9uKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbCgpIHtcbiAgcmV0dXJuIHQuc3RyaW5nVHlwZUFubm90YXRpb24oKTtcbn1cblxuZnVuY3Rpb24gTnVtZXJpY0xpdGVyYWwoKSB7XG4gIHJldHVybiB0Lm51bWJlclR5cGVBbm5vdGF0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIEJvb2xlYW5MaXRlcmFsKCkge1xuICByZXR1cm4gdC5ib29sZWFuVHlwZUFubm90YXRpb24oKTtcbn1cblxuZnVuY3Rpb24gTnVsbExpdGVyYWwoKSB7XG4gIHJldHVybiB0Lm51bGxMaXRlcmFsVHlwZUFubm90YXRpb24oKTtcbn1cblxuZnVuY3Rpb24gUmVnRXhwTGl0ZXJhbCgpIHtcbiAgcmV0dXJuIHQuZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKHQuaWRlbnRpZmllcihcIlJlZ0V4cFwiKSk7XG59XG5cbmZ1bmN0aW9uIE9iamVjdEV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB0LmdlbmVyaWNUeXBlQW5ub3RhdGlvbih0LmlkZW50aWZpZXIoXCJPYmplY3RcIikpO1xufVxuXG5mdW5jdGlvbiBBcnJheUV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB0LmdlbmVyaWNUeXBlQW5ub3RhdGlvbih0LmlkZW50aWZpZXIoXCJBcnJheVwiKSk7XG59XG5cbmZ1bmN0aW9uIFJlc3RFbGVtZW50KCkge1xuICByZXR1cm4gQXJyYXlFeHByZXNzaW9uKCk7XG59XG5cblJlc3RFbGVtZW50LnZhbGlkUGFyZW50ID0gdHJ1ZTtcblxuZnVuY3Rpb24gRnVuYygpIHtcbiAgcmV0dXJuIHQuZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKHQuaWRlbnRpZmllcihcIkZ1bmN0aW9uXCIpKTtcbn1cblxuZXhwb3J0cy5GdW5jdGlvbkV4cHJlc3Npb24gPSBGdW5jO1xuZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEZ1bmM7XG5leHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBGdW5jO1xuZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBGdW5jO1xuZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gRnVuYztcbmZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKCkge1xuICByZXR1cm4gcmVzb2x2ZUNhbGwodGhpcy5nZXQoXCJjYWxsZWVcIikpO1xufVxuXG5mdW5jdGlvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oKSB7XG4gIHJldHVybiByZXNvbHZlQ2FsbCh0aGlzLmdldChcInRhZ1wiKSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDYWxsKGNhbGxlZSkge1xuICBjYWxsZWUgPSBjYWxsZWUucmVzb2x2ZSgpO1xuXG4gIGlmIChjYWxsZWUuaXNGdW5jdGlvbigpKSB7XG4gICAgaWYgKGNhbGxlZS5pcyhcImFzeW5jXCIpKSB7XG4gICAgICBpZiAoY2FsbGVlLmlzKFwiZ2VuZXJhdG9yXCIpKSB7XG4gICAgICAgIHJldHVybiB0LmdlbmVyaWNUeXBlQW5ub3RhdGlvbih0LmlkZW50aWZpZXIoXCJBc3luY0l0ZXJhdG9yXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0LmdlbmVyaWNUeXBlQW5ub3RhdGlvbih0LmlkZW50aWZpZXIoXCJQcm9taXNlXCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNhbGxlZS5ub2RlLnJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxlZS5ub2RlLnJldHVyblR5cGU7XG4gICAgICB9IGVsc2Uge31cbiAgICB9XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvcGF0aC9pbmZlcmVuY2UvaW5mZXJlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDM2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIXRoaXMuaXNSZWZlcmVuY2VkKCkpIHJldHVybjtcblxuICB2YXIgYmluZGluZyA9IHRoaXMuc2NvcGUuZ2V0QmluZGluZyhub2RlLm5hbWUpO1xuICBpZiAoYmluZGluZykge1xuICAgIGlmIChiaW5kaW5nLmlkZW50aWZpZXIudHlwZUFubm90YXRpb24pIHtcbiAgICAgIHJldHVybiBiaW5kaW5nLmlkZW50aWZpZXIudHlwZUFubm90YXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRUeXBlQW5ub3RhdGlvbkJpbmRpbmdDb25zdGFudFZpb2xhdGlvbnModGhpcywgbm9kZS5uYW1lKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS5uYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHQudm9pZFR5cGVBbm5vdGF0aW9uKCk7XG4gIH0gZWxzZSBpZiAobm9kZS5uYW1lID09PSBcIk5hTlwiIHx8IG5vZGUubmFtZSA9PT0gXCJJbmZpbml0eVwiKSB7XG4gICAgcmV0dXJuIHQubnVtYmVyVHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIGlmIChub2RlLm5hbWUgPT09IFwiYXJndW1lbnRzXCIpIHt9XG59O1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRUeXBlQW5ub3RhdGlvbkJpbmRpbmdDb25zdGFudFZpb2xhdGlvbnMocGF0aCwgbmFtZSkge1xuICB2YXIgYmluZGluZyA9IHBhdGguc2NvcGUuZ2V0QmluZGluZyhuYW1lKTtcblxuICB2YXIgdHlwZXMgPSBbXTtcbiAgcGF0aC50eXBlQW5ub3RhdGlvbiA9IHQudW5pb25UeXBlQW5ub3RhdGlvbih0eXBlcyk7XG5cbiAgdmFyIGZ1bmN0aW9uQ29uc3RhbnRWaW9sYXRpb25zID0gW107XG4gIHZhciBjb25zdGFudFZpb2xhdGlvbnMgPSBnZXRDb25zdGFudFZpb2xhdGlvbnNCZWZvcmUoYmluZGluZywgcGF0aCwgZnVuY3Rpb25Db25zdGFudFZpb2xhdGlvbnMpO1xuXG4gIHZhciB0ZXN0VHlwZSA9IGdldENvbmRpdGlvbmFsQW5ub3RhdGlvbihwYXRoLCBuYW1lKTtcbiAgaWYgKHRlc3RUeXBlKSB7XG4gICAgdmFyIHRlc3RDb25zdGFudFZpb2xhdGlvbnMgPSBnZXRDb25zdGFudFZpb2xhdGlvbnNCZWZvcmUoYmluZGluZywgdGVzdFR5cGUuaWZTdGF0ZW1lbnQpO1xuXG4gICAgY29uc3RhbnRWaW9sYXRpb25zID0gY29uc3RhbnRWaW9sYXRpb25zLmZpbHRlcihmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIHRlc3RDb25zdGFudFZpb2xhdGlvbnMuaW5kZXhPZihwYXRoKSA8IDA7XG4gICAgfSk7XG5cbiAgICB0eXBlcy5wdXNoKHRlc3RUeXBlLnR5cGVBbm5vdGF0aW9uKTtcbiAgfVxuXG4gIGlmIChjb25zdGFudFZpb2xhdGlvbnMubGVuZ3RoKSB7XG4gICAgY29uc3RhbnRWaW9sYXRpb25zID0gY29uc3RhbnRWaW9sYXRpb25zLmNvbmNhdChmdW5jdGlvbkNvbnN0YW50VmlvbGF0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjb25zdGFudFZpb2xhdGlvbnMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2aW9sYXRpb24gPSBfcmVmO1xuXG4gICAgICB0eXBlcy5wdXNoKHZpb2xhdGlvbi5nZXRUeXBlQW5ub3RhdGlvbigpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHQuY3JlYXRlVW5pb25UeXBlQW5ub3RhdGlvbih0eXBlcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29uc3RhbnRWaW9sYXRpb25zQmVmb3JlKGJpbmRpbmcsIHBhdGgsIGZ1bmN0aW9ucykge1xuICB2YXIgdmlvbGF0aW9ucyA9IGJpbmRpbmcuY29uc3RhbnRWaW9sYXRpb25zLnNsaWNlKCk7XG4gIHZpb2xhdGlvbnMudW5zaGlmdChiaW5kaW5nLnBhdGgpO1xuICByZXR1cm4gdmlvbGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHZpb2xhdGlvbikge1xuICAgIHZpb2xhdGlvbiA9IHZpb2xhdGlvbi5yZXNvbHZlKCk7XG4gICAgdmFyIHN0YXR1cyA9IHZpb2xhdGlvbi5fZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvKHBhdGgpO1xuICAgIGlmIChmdW5jdGlvbnMgJiYgc3RhdHVzID09PSBcImZ1bmN0aW9uXCIpIGZ1bmN0aW9ucy5wdXNoKHZpb2xhdGlvbik7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gXCJiZWZvcmVcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluZmVyQW5ub3RhdGlvbkZyb21CaW5hcnlFeHByZXNzaW9uKG5hbWUsIHBhdGgpIHtcbiAgdmFyIG9wZXJhdG9yID0gcGF0aC5ub2RlLm9wZXJhdG9yO1xuXG4gIHZhciByaWdodCA9IHBhdGguZ2V0KFwicmlnaHRcIikucmVzb2x2ZSgpO1xuICB2YXIgbGVmdCA9IHBhdGguZ2V0KFwibGVmdFwiKS5yZXNvbHZlKCk7XG5cbiAgdmFyIHRhcmdldCA9IHZvaWQgMDtcbiAgaWYgKGxlZnQuaXNJZGVudGlmaWVyKHsgbmFtZTogbmFtZSB9KSkge1xuICAgIHRhcmdldCA9IHJpZ2h0O1xuICB9IGVsc2UgaWYgKHJpZ2h0LmlzSWRlbnRpZmllcih7IG5hbWU6IG5hbWUgfSkpIHtcbiAgICB0YXJnZXQgPSBsZWZ0O1xuICB9XG4gIGlmICh0YXJnZXQpIHtcbiAgICBpZiAob3BlcmF0b3IgPT09IFwiPT09XCIpIHtcbiAgICAgIHJldHVybiB0YXJnZXQuZ2V0VHlwZUFubm90YXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHQuQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUy5pbmRleE9mKG9wZXJhdG9yKSA+PSAwKSB7XG4gICAgICByZXR1cm4gdC5udW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChvcGVyYXRvciAhPT0gXCI9PT1cIikgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHR5cGVvZlBhdGggPSB2b2lkIDA7XG4gIHZhciB0eXBlUGF0aCA9IHZvaWQgMDtcbiAgaWYgKGxlZnQuaXNVbmFyeUV4cHJlc3Npb24oeyBvcGVyYXRvcjogXCJ0eXBlb2ZcIiB9KSkge1xuICAgIHR5cGVvZlBhdGggPSBsZWZ0O1xuICAgIHR5cGVQYXRoID0gcmlnaHQ7XG4gIH0gZWxzZSBpZiAocmlnaHQuaXNVbmFyeUV4cHJlc3Npb24oeyBvcGVyYXRvcjogXCJ0eXBlb2ZcIiB9KSkge1xuICAgIHR5cGVvZlBhdGggPSByaWdodDtcbiAgICB0eXBlUGF0aCA9IGxlZnQ7XG4gIH1cbiAgaWYgKCF0eXBlUGF0aCAmJiAhdHlwZW9mUGF0aCkgcmV0dXJuO1xuXG4gIHR5cGVQYXRoID0gdHlwZVBhdGgucmVzb2x2ZSgpO1xuICBpZiAoIXR5cGVQYXRoLmlzTGl0ZXJhbCgpKSByZXR1cm47XG5cbiAgdmFyIHR5cGVWYWx1ZSA9IHR5cGVQYXRoLm5vZGUudmFsdWU7XG4gIGlmICh0eXBlb2YgdHlwZVZhbHVlICE9PSBcInN0cmluZ1wiKSByZXR1cm47XG5cbiAgaWYgKCF0eXBlb2ZQYXRoLmdldChcImFyZ3VtZW50XCIpLmlzSWRlbnRpZmllcih7IG5hbWU6IG5hbWUgfSkpIHJldHVybjtcblxuICByZXR1cm4gdC5jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YodHlwZVBhdGgubm9kZS52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudENvbmRpdGlvbmFsUGF0aChwYXRoKSB7XG4gIHZhciBwYXJlbnRQYXRoID0gdm9pZCAwO1xuICB3aGlsZSAocGFyZW50UGF0aCA9IHBhdGgucGFyZW50UGF0aCkge1xuICAgIGlmIChwYXJlbnRQYXRoLmlzSWZTdGF0ZW1lbnQoKSB8fCBwYXJlbnRQYXRoLmlzQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkpIHtcbiAgICAgIGlmIChwYXRoLmtleSA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBwYXJlbnRQYXRoO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb25kaXRpb25hbEFubm90YXRpb24ocGF0aCwgbmFtZSkge1xuICB2YXIgaWZTdGF0ZW1lbnQgPSBnZXRQYXJlbnRDb25kaXRpb25hbFBhdGgocGF0aCk7XG4gIGlmICghaWZTdGF0ZW1lbnQpIHJldHVybjtcblxuICB2YXIgdGVzdCA9IGlmU3RhdGVtZW50LmdldChcInRlc3RcIik7XG4gIHZhciBwYXRocyA9IFt0ZXN0XTtcbiAgdmFyIHR5cGVzID0gW107XG5cbiAgZG8ge1xuICAgIHZhciBfcGF0aCA9IHBhdGhzLnNoaWZ0KCkucmVzb2x2ZSgpO1xuXG4gICAgaWYgKF9wYXRoLmlzTG9naWNhbEV4cHJlc3Npb24oKSkge1xuICAgICAgcGF0aHMucHVzaChfcGF0aC5nZXQoXCJsZWZ0XCIpKTtcbiAgICAgIHBhdGhzLnB1c2goX3BhdGguZ2V0KFwicmlnaHRcIikpO1xuICAgIH1cblxuICAgIGlmIChfcGF0aC5pc0JpbmFyeUV4cHJlc3Npb24oKSkge1xuICAgICAgdmFyIHR5cGUgPSBpbmZlckFubm90YXRpb25Gcm9tQmluYXJ5RXhwcmVzc2lvbihuYW1lLCBfcGF0aCk7XG4gICAgICBpZiAodHlwZSkgdHlwZXMucHVzaCh0eXBlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHBhdGhzLmxlbmd0aCk7XG5cbiAgaWYgKHR5cGVzLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlQW5ub3RhdGlvbjogdC5jcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uKHR5cGVzKSxcbiAgICAgIGlmU3RhdGVtZW50OiBpZlN0YXRlbWVudFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldENvbmRpdGlvbmFsQW5ub3RhdGlvbihpZlN0YXRlbWVudCwgbmFtZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2UvbGliL3BhdGgvaW5mZXJlbmNlL2luZmVyZXItcmVmZXJlbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZXhwb3J0cy5yZXBsYWNlV2l0aE11bHRpcGxlID0gcmVwbGFjZVdpdGhNdWx0aXBsZTtcbmV4cG9ydHMucmVwbGFjZVdpdGhTb3VyY2VTdHJpbmcgPSByZXBsYWNlV2l0aFNvdXJjZVN0cmluZztcbmV4cG9ydHMucmVwbGFjZVdpdGggPSByZXBsYWNlV2l0aDtcbmV4cG9ydHMuX3JlcGxhY2VXaXRoID0gX3JlcGxhY2VXaXRoO1xuZXhwb3J0cy5yZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzID0gcmVwbGFjZUV4cHJlc3Npb25XaXRoU3RhdGVtZW50cztcbmV4cG9ydHMucmVwbGFjZUlubGluZSA9IHJlcGxhY2VJbmxpbmU7XG5cbnZhciBfYmFiZWxDb2RlRnJhbWUgPSByZXF1aXJlKFwiYmFiZWwtY29kZS1mcmFtZVwiKTtcblxudmFyIF9iYWJlbENvZGVGcmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYWJlbENvZGVGcmFtZSk7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG5cbnZhciBfaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5kZXgpO1xuXG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuXG52YXIgX2luZGV4NCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luZGV4Myk7XG5cbnZhciBfYmFieWxvbiA9IHJlcXVpcmUoXCJiYWJ5bG9uXCIpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaG9pc3RWYXJpYWJsZXNWaXNpdG9yID0ge1xuICBGdW5jdGlvbjogZnVuY3Rpb24gRnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGguc2tpcCgpO1xuICB9LFxuICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0aW9uKHBhdGgpIHtcbiAgICBpZiAocGF0aC5ub2RlLmtpbmQgIT09IFwidmFyXCIpIHJldHVybjtcblxuICAgIHZhciBiaW5kaW5ncyA9IHBhdGguZ2V0QmluZGluZ0lkZW50aWZpZXJzKCk7XG4gICAgZm9yICh2YXIga2V5IGluIGJpbmRpbmdzKSB7XG4gICAgICBwYXRoLnNjb3BlLnB1c2goeyBpZDogYmluZGluZ3Nba2V5XSB9KTtcbiAgICB9XG5cbiAgICB2YXIgZXhwcnMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHBhdGgubm9kZS5kZWNsYXJhdGlvbnMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWNsYXIgPSBfcmVmO1xuXG4gICAgICBpZiAoZGVjbGFyLmluaXQpIHtcbiAgICAgICAgZXhwcnMucHVzaCh0LmV4cHJlc3Npb25TdGF0ZW1lbnQodC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbGFyLmlkLCBkZWNsYXIuaW5pdCkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoLnJlcGxhY2VXaXRoTXVsdGlwbGUoZXhwcnMpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZXBsYWNlV2l0aE11bHRpcGxlKG5vZGVzKSB7XG4gIHRoaXMucmVzeW5jKCk7XG5cbiAgbm9kZXMgPSB0aGlzLl92ZXJpZnlOb2RlTGlzdChub2Rlcyk7XG4gIHQuaW5oZXJpdExlYWRpbmdDb21tZW50cyhub2Rlc1swXSwgdGhpcy5ub2RlKTtcbiAgdC5pbmhlcml0VHJhaWxpbmdDb21tZW50cyhub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgdGhpcy5ub2RlKTtcbiAgdGhpcy5ub2RlID0gdGhpcy5jb250YWluZXJbdGhpcy5rZXldID0gbnVsbDtcbiAgdGhpcy5pbnNlcnRBZnRlcihub2Rlcyk7XG5cbiAgaWYgKHRoaXMubm9kZSkge1xuICAgIHRoaXMucmVxdWV1ZSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVdpdGhTb3VyY2VTdHJpbmcocmVwbGFjZW1lbnQpIHtcbiAgdGhpcy5yZXN5bmMoKTtcblxuICB0cnkge1xuICAgIHJlcGxhY2VtZW50ID0gXCIoXCIgKyByZXBsYWNlbWVudCArIFwiKVwiO1xuICAgIHJlcGxhY2VtZW50ID0gKDAsIF9iYWJ5bG9uLnBhcnNlKShyZXBsYWNlbWVudCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHZhciBsb2MgPSBlcnIubG9jO1xuICAgIGlmIChsb2MpIHtcbiAgICAgIGVyci5tZXNzYWdlICs9IFwiIC0gbWFrZSBzdXJlIHRoaXMgaXMgYW4gZXhwcmVzc2lvbi5cIjtcbiAgICAgIGVyci5tZXNzYWdlICs9IFwiXFxuXCIgKyAoMCwgX2JhYmVsQ29kZUZyYW1lMi5kZWZhdWx0KShyZXBsYWNlbWVudCwgbG9jLmxpbmUsIGxvYy5jb2x1bW4gKyAxKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5wcm9ncmFtLmJvZHlbMF0uZXhwcmVzc2lvbjtcbiAgX2luZGV4Mi5kZWZhdWx0LnJlbW92ZVByb3BlcnRpZXMocmVwbGFjZW1lbnQpO1xuICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChyZXBsYWNlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VXaXRoKHJlcGxhY2VtZW50KSB7XG4gIHRoaXMucmVzeW5jKCk7XG5cbiAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4ndCByZXBsYWNlIHRoaXMgbm9kZSwgd2UndmUgYWxyZWFkeSByZW1vdmVkIGl0XCIpO1xuICB9XG5cbiAgaWYgKHJlcGxhY2VtZW50IGluc3RhbmNlb2YgX2luZGV4NC5kZWZhdWx0KSB7XG4gICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5ub2RlO1xuICB9XG5cbiAgaWYgKCFyZXBsYWNlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBwYXNzZWQgYHBhdGgucmVwbGFjZVdpdGgoKWAgYSBmYWxzeSBub2RlLCB1c2UgYHBhdGgucmVtb3ZlKClgIGluc3RlYWRcIik7XG4gIH1cblxuICBpZiAodGhpcy5ub2RlID09PSByZXBsYWNlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmlzUHJvZ3JhbSgpICYmICF0LmlzUHJvZ3JhbShyZXBsYWNlbWVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuIG9ubHkgcmVwbGFjZSBhIFByb2dyYW0gcm9vdCBub2RlIHdpdGggYW5vdGhlciBQcm9ncmFtIG5vZGVcIik7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCB1c2UgYHBhdGgucmVwbGFjZVdpdGgoKWAgd2l0aCBhbiBhcnJheSBvZiBub2RlcywgdXNlIGBwYXRoLnJlcGxhY2VXaXRoTXVsdGlwbGUoKWBcIik7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3QgdXNlIGBwYXRoLnJlcGxhY2VXaXRoKClgIHdpdGggYSBzb3VyY2Ugc3RyaW5nLCB1c2UgYHBhdGgucmVwbGFjZVdpdGhTb3VyY2VTdHJpbmcoKWBcIik7XG4gIH1cblxuICBpZiAodGhpcy5pc05vZGVUeXBlKFwiU3RhdGVtZW50XCIpICYmIHQuaXNFeHByZXNzaW9uKHJlcGxhY2VtZW50KSkge1xuICAgIGlmICghdGhpcy5jYW5IYXZlVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbigpICYmICF0aGlzLmNhblN3YXBCZXR3ZWVuRXhwcmVzc2lvbkFuZFN0YXRlbWVudChyZXBsYWNlbWVudCkgJiYgIXRoaXMucGFyZW50UGF0aC5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbigpKSB7XG4gICAgICByZXBsYWNlbWVudCA9IHQuZXhwcmVzc2lvblN0YXRlbWVudChyZXBsYWNlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuaXNOb2RlVHlwZShcIkV4cHJlc3Npb25cIikgJiYgdC5pc1N0YXRlbWVudChyZXBsYWNlbWVudCkpIHtcbiAgICBpZiAoIXRoaXMuY2FuSGF2ZVZhcmlhYmxlRGVjbGFyYXRpb25PckV4cHJlc3Npb24oKSAmJiAhdGhpcy5jYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQocmVwbGFjZW1lbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzKFtyZXBsYWNlbWVudF0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvbGROb2RlID0gdGhpcy5ub2RlO1xuICBpZiAob2xkTm9kZSkge1xuICAgIHQuaW5oZXJpdHNDb21tZW50cyhyZXBsYWNlbWVudCwgb2xkTm9kZSk7XG4gICAgdC5yZW1vdmVDb21tZW50cyhvbGROb2RlKTtcbiAgfVxuXG4gIHRoaXMuX3JlcGxhY2VXaXRoKHJlcGxhY2VtZW50KTtcbiAgdGhpcy50eXBlID0gcmVwbGFjZW1lbnQudHlwZTtcblxuICB0aGlzLnNldFNjb3BlKCk7XG5cbiAgdGhpcy5yZXF1ZXVlKCk7XG59XG5cbmZ1bmN0aW9uIF9yZXBsYWNlV2l0aChub2RlKSB7XG4gIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJDb250YWluZXIgaXMgZmFsc3lcIik7XG4gIH1cblxuICBpZiAodGhpcy5pbkxpc3QpIHtcbiAgICB0LnZhbGlkYXRlKHRoaXMucGFyZW50LCB0aGlzLmtleSwgW25vZGVdKTtcbiAgfSBlbHNlIHtcbiAgICB0LnZhbGlkYXRlKHRoaXMucGFyZW50LCB0aGlzLmtleSwgbm9kZSk7XG4gIH1cblxuICB0aGlzLmRlYnVnKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJSZXBsYWNlIHdpdGggXCIgKyAobm9kZSAmJiBub2RlLnR5cGUpO1xuICB9KTtcblxuICB0aGlzLm5vZGUgPSB0aGlzLmNvbnRhaW5lclt0aGlzLmtleV0gPSBub2RlO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzKG5vZGVzKSB7XG4gIHRoaXMucmVzeW5jKCk7XG5cbiAgdmFyIHRvU2VxdWVuY2VFeHByZXNzaW9uID0gdC50b1NlcXVlbmNlRXhwcmVzc2lvbihub2RlcywgdGhpcy5zY29wZSk7XG5cbiAgaWYgKHQuaXNTZXF1ZW5jZUV4cHJlc3Npb24odG9TZXF1ZW5jZUV4cHJlc3Npb24pKSB7XG4gICAgdmFyIGV4cHJzID0gdG9TZXF1ZW5jZUV4cHJlc3Npb24uZXhwcmVzc2lvbnM7XG5cbiAgICBpZiAoZXhwcnMubGVuZ3RoID49IDIgJiYgdGhpcy5wYXJlbnRQYXRoLmlzRXhwcmVzc2lvblN0YXRlbWVudCgpKSB7XG4gICAgICB0aGlzLl9tYXliZVBvcEZyb21TdGF0ZW1lbnRzKGV4cHJzKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnJlcGxhY2VXaXRoKGV4cHJzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXBsYWNlV2l0aCh0b1NlcXVlbmNlRXhwcmVzc2lvbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRvU2VxdWVuY2VFeHByZXNzaW9uKSB7XG4gICAgdGhpcy5yZXBsYWNlV2l0aCh0b1NlcXVlbmNlRXhwcmVzc2lvbik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHQuZnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIFtdLCB0LmJsb2NrU3RhdGVtZW50KG5vZGVzKSk7XG4gICAgY29udGFpbmVyLnNoYWRvdyA9IHRydWU7XG5cbiAgICB0aGlzLnJlcGxhY2VXaXRoKHQuY2FsbEV4cHJlc3Npb24oY29udGFpbmVyLCBbXSkpO1xuICAgIHRoaXMudHJhdmVyc2UoaG9pc3RWYXJpYWJsZXNWaXNpdG9yKTtcblxuICAgIHZhciBjb21wbGV0aW9uUmVjb3JkcyA9IHRoaXMuZ2V0KFwiY2FsbGVlXCIpLmdldENvbXBsZXRpb25SZWNvcmRzKCk7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGNvbXBsZXRpb25SZWNvcmRzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjIpOzspIHtcbiAgICAgIHZhciBfcmVmMjtcblxuICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSBfcmVmMjtcblxuICAgICAgaWYgKCFwYXRoLmlzRXhwcmVzc2lvblN0YXRlbWVudCgpKSBjb250aW51ZTtcblxuICAgICAgdmFyIGxvb3AgPSBwYXRoLmZpbmRQYXJlbnQoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguaXNMb29wKCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wKSB7XG4gICAgICAgIHZhciB1aWQgPSBsb29wLmdldERhdGEoXCJleHByZXNzaW9uUmVwbGFjZW1lbnRSZXR1cm5VaWRcIik7XG5cbiAgICAgICAgaWYgKCF1aWQpIHtcbiAgICAgICAgICB2YXIgY2FsbGVlID0gdGhpcy5nZXQoXCJjYWxsZWVcIik7XG4gICAgICAgICAgdWlkID0gY2FsbGVlLnNjb3BlLmdlbmVyYXRlRGVjbGFyZWRVaWRJZGVudGlmaWVyKFwicmV0XCIpO1xuICAgICAgICAgIGNhbGxlZS5nZXQoXCJib2R5XCIpLnB1c2hDb250YWluZXIoXCJib2R5XCIsIHQucmV0dXJuU3RhdGVtZW50KHVpZCkpO1xuICAgICAgICAgIGxvb3Auc2V0RGF0YShcImV4cHJlc3Npb25SZXBsYWNlbWVudFJldHVyblVpZFwiLCB1aWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVpZCA9IHQuaWRlbnRpZmllcih1aWQubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLmdldChcImV4cHJlc3Npb25cIikucmVwbGFjZVdpdGgodC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgdWlkLCBwYXRoLm5vZGUuZXhwcmVzc2lvbikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5yZXBsYWNlV2l0aCh0LnJldHVyblN0YXRlbWVudChwYXRoLm5vZGUuZXhwcmVzc2lvbikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUlubGluZShub2Rlcykge1xuICB0aGlzLnJlc3luYygpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29udGFpbmVyKSkge1xuICAgICAgbm9kZXMgPSB0aGlzLl92ZXJpZnlOb2RlTGlzdChub2Rlcyk7XG4gICAgICB0aGlzLl9jb250YWluZXJJbnNlcnRBZnRlcihub2Rlcyk7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGhNdWx0aXBsZShub2Rlcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2VXaXRoKG5vZGVzKTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9wYXRoL3JlcGxhY2VtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChyYXdMaW5lcywgbGluZU51bWJlciwgY29sTnVtYmVyKSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICBjb2xOdW1iZXIgPSBNYXRoLm1heChjb2xOdW1iZXIsIDApO1xuXG4gIHZhciBoaWdobGlnaHRlZCA9IG9wdHMuaGlnaGxpZ2h0Q29kZSAmJiBfY2hhbGsyLmRlZmF1bHQuc3VwcG9ydHNDb2xvciB8fCBvcHRzLmZvcmNlQ29sb3I7XG4gIHZhciBjaGFsayA9IF9jaGFsazIuZGVmYXVsdDtcbiAgaWYgKG9wdHMuZm9yY2VDb2xvcikge1xuICAgIGNoYWxrID0gbmV3IF9jaGFsazIuZGVmYXVsdC5jb25zdHJ1Y3Rvcih7IGVuYWJsZWQ6IHRydWUgfSk7XG4gIH1cbiAgdmFyIG1heWJlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gbWF5YmVIaWdobGlnaHQoY2hhbGtGbiwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkID8gY2hhbGtGbihzdHJpbmcpIDogc3RyaW5nO1xuICB9O1xuICB2YXIgZGVmcyA9IGdldERlZnMoY2hhbGspO1xuICBpZiAoaGlnaGxpZ2h0ZWQpIHJhd0xpbmVzID0gaGlnaGxpZ2h0KGRlZnMsIHJhd0xpbmVzKTtcblxuICB2YXIgbGluZXNBYm92ZSA9IG9wdHMubGluZXNBYm92ZSB8fCAyO1xuICB2YXIgbGluZXNCZWxvdyA9IG9wdHMubGluZXNCZWxvdyB8fCAzO1xuXG4gIHZhciBsaW5lcyA9IHJhd0xpbmVzLnNwbGl0KE5FV0xJTkUpO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1heChsaW5lTnVtYmVyIC0gKGxpbmVzQWJvdmUgKyAxKSwgMCk7XG4gIHZhciBlbmQgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIGxpbmVOdW1iZXIgKyBsaW5lc0JlbG93KTtcblxuICBpZiAoIWxpbmVOdW1iZXIgJiYgIWNvbE51bWJlcikge1xuICAgIHN0YXJ0ID0gMDtcbiAgICBlbmQgPSBsaW5lcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgbnVtYmVyTWF4V2lkdGggPSBTdHJpbmcoZW5kKS5sZW5ndGg7XG5cbiAgdmFyIGZyYW1lID0gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uIChsaW5lLCBpbmRleCkge1xuICAgIHZhciBudW1iZXIgPSBzdGFydCArIDEgKyBpbmRleDtcbiAgICB2YXIgcGFkZGVkTnVtYmVyID0gKFwiIFwiICsgbnVtYmVyKS5zbGljZSgtbnVtYmVyTWF4V2lkdGgpO1xuICAgIHZhciBndXR0ZXIgPSBcIiBcIiArIHBhZGRlZE51bWJlciArIFwiIHwgXCI7XG4gICAgaWYgKG51bWJlciA9PT0gbGluZU51bWJlcikge1xuICAgICAgdmFyIG1hcmtlckxpbmUgPSBcIlwiO1xuICAgICAgaWYgKGNvbE51bWJlcikge1xuICAgICAgICB2YXIgbWFya2VyU3BhY2luZyA9IGxpbmUuc2xpY2UoMCwgY29sTnVtYmVyIC0gMSkucmVwbGFjZSgvW15cXHRdL2csIFwiIFwiKTtcbiAgICAgICAgbWFya2VyTGluZSA9IFtcIlxcbiBcIiwgbWF5YmVIaWdobGlnaHQoZGVmcy5ndXR0ZXIsIGd1dHRlci5yZXBsYWNlKC9cXGQvZywgXCIgXCIpKSwgbWFya2VyU3BhY2luZywgbWF5YmVIaWdobGlnaHQoZGVmcy5tYXJrZXIsIFwiXlwiKV0uam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWF5YmVIaWdobGlnaHQoZGVmcy5tYXJrZXIsIFwiPlwiKSwgbWF5YmVIaWdobGlnaHQoZGVmcy5ndXR0ZXIsIGd1dHRlciksIGxpbmUsIG1hcmtlckxpbmVdLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIiBcIiArIG1heWJlSGlnaGxpZ2h0KGRlZnMuZ3V0dGVyLCBndXR0ZXIpICsgbGluZTtcbiAgICB9XG4gIH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgaWYgKGhpZ2hsaWdodGVkKSB7XG4gICAgcmV0dXJuIGNoYWxrLnJlc2V0KGZyYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cbn07XG5cbnZhciBfanNUb2tlbnMgPSByZXF1aXJlKFwianMtdG9rZW5zXCIpO1xuXG52YXIgX2pzVG9rZW5zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzVG9rZW5zKTtcblxudmFyIF9lc3V0aWxzID0gcmVxdWlyZShcImVzdXRpbHNcIik7XG5cbnZhciBfZXN1dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lc3V0aWxzKTtcblxudmFyIF9jaGFsayA9IHJlcXVpcmUoXCJjaGFsa1wiKTtcblxudmFyIF9jaGFsazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jaGFsayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldERlZnMoY2hhbGspIHtcbiAgcmV0dXJuIHtcbiAgICBrZXl3b3JkOiBjaGFsay5jeWFuLFxuICAgIGNhcGl0YWxpemVkOiBjaGFsay55ZWxsb3csXG4gICAganN4X3RhZzogY2hhbGsueWVsbG93LFxuICAgIHB1bmN0dWF0b3I6IGNoYWxrLnllbGxvdyxcblxuICAgIG51bWJlcjogY2hhbGsubWFnZW50YSxcbiAgICBzdHJpbmc6IGNoYWxrLmdyZWVuLFxuICAgIHJlZ2V4OiBjaGFsay5tYWdlbnRhLFxuICAgIGNvbW1lbnQ6IGNoYWxrLmdyZXksXG4gICAgaW52YWxpZDogY2hhbGsud2hpdGUuYmdSZWQuYm9sZCxcbiAgICBndXR0ZXI6IGNoYWxrLmdyZXksXG4gICAgbWFya2VyOiBjaGFsay5yZWQuYm9sZFxuICB9O1xufVxuXG52YXIgTkVXTElORSA9IC9cXHJcXG58W1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbnZhciBKU1hfVEFHID0gL15bYS16XVtcXHctXSokL2k7XG5cbnZhciBCUkFDS0VUID0gL15bKClcXFtcXF17fV0kLztcblxuZnVuY3Rpb24gZ2V0VG9rZW5UeXBlKG1hdGNoKSB7XG4gIHZhciBfbWF0Y2gkc2xpY2UgPSBtYXRjaC5zbGljZSgtMiksXG4gICAgICBvZmZzZXQgPSBfbWF0Y2gkc2xpY2VbMF0sXG4gICAgICB0ZXh0ID0gX21hdGNoJHNsaWNlWzFdO1xuXG4gIHZhciB0b2tlbiA9ICgwLCBfanNUb2tlbnMubWF0Y2hUb1Rva2VuKShtYXRjaCk7XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFwibmFtZVwiKSB7XG4gICAgaWYgKF9lc3V0aWxzMi5kZWZhdWx0LmtleXdvcmQuaXNSZXNlcnZlZFdvcmRFUzYodG9rZW4udmFsdWUpKSB7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuXG4gICAgaWYgKEpTWF9UQUcudGVzdCh0b2tlbi52YWx1ZSkgJiYgKHRleHRbb2Zmc2V0IC0gMV0gPT09IFwiPFwiIHx8IHRleHQuc3Vic3RyKG9mZnNldCAtIDIsIDIpID09IFwiPC9cIikpIHtcbiAgICAgIHJldHVybiBcImpzeF90YWdcIjtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udmFsdWVbMF0gIT09IHRva2VuLnZhbHVlWzBdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHJldHVybiBcImNhcGl0YWxpemVkXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFwicHVuY3R1YXRvclwiICYmIEJSQUNLRVQudGVzdCh0b2tlbi52YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gIH1cblxuICByZXR1cm4gdG9rZW4udHlwZTtcbn1cblxuZnVuY3Rpb24gaGlnaGxpZ2h0KGRlZnMsIHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZShfanNUb2tlbnMyLmRlZmF1bHQsIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IGdldFRva2VuVHlwZShhcmdzKTtcbiAgICB2YXIgY29sb3JpemUgPSBkZWZzW3R5cGVdO1xuICAgIGlmIChjb2xvcml6ZSkge1xuICAgICAgcmV0dXJuIGFyZ3NbMF0uc3BsaXQoTkVXTElORSkubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yaXplKHN0cik7XG4gICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtY29kZS1mcmFtZUA2LjI2LjBAYmFiZWwtY29kZS1mcmFtZS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgMjAxNCwgMjAxNSwgMjAxNiwgMjAxNyBTaW1vbiBMeWRlbGxcbi8vIExpY2Vuc2U6IE1JVC4gKFNlZSBMSUNFTlNFLilcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KVxuXG4vLyBUaGlzIHJlZ2V4IGNvbWVzIGZyb20gcmVnZXguY29mZmVlLCBhbmQgaXMgaW5zZXJ0ZWQgaGVyZSBieSBnZW5lcmF0ZS1pbmRleC5qc1xuLy8gKHJ1biBgbnBtIHJ1biBidWlsZGApLlxuZXhwb3J0cy5kZWZhdWx0ID0gLygoWydcIl0pKD86KD8hXFwyfFxcXFwpLnxcXFxcKD86XFxyXFxufFtcXHNcXFNdKSkqKFxcMik/fGAoPzpbXmBcXFxcJF18XFxcXFtcXHNcXFNdfFxcJCg/IVxceyl8XFwkXFx7KD86W157fV18XFx7W159XSpcXH0/KSpcXH0/KSooYCk/KXwoXFwvXFwvLiopfChcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKihcXCpcXC8pPyl8KFxcLyg/IVxcKikoPzpcXFsoPzooPyFbXFxdXFxcXF0pLnxcXFxcLikqXFxdfCg/IVtcXC9cXF1cXFxcXSkufFxcXFwuKStcXC8oPzooPyFcXHMqKD86XFxifFtcXHUwMDgwLVxcdUZGRkYkXFxcXCdcIn4oe118WytcXC0hXSg/IT0pfFxcLj9cXGQpKXxbZ21peXVdezEsNX1cXGIoPyFbXFx1MDA4MC1cXHVGRkZGJFxcXFxdfFxccyooPzpbK1xcLSolJnxePD4hPT8oe118XFwvKD8hW1xcLypdKSkpKSl8KDBbeFhdW1xcZGEtZkEtRl0rfDBbb09dWzAtN10rfDBbYkJdWzAxXSt8KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/KXwoKD8hXFxkKSg/Oig/IVxccylbJFxcd1xcdTAwODAtXFx1RkZGRl18XFxcXHVbXFxkYS1mQS1GXXs0fXxcXFxcdVxce1tcXGRhLWZBLUZdK1xcfSkrKXwoLS18XFwrXFwrfCYmfFxcfFxcfHw9PnxcXC57M318KD86WytcXC1cXC8lJnxeXXxcXCp7MSwyfXw8ezEsMn18PnsxLDN9fCE9P3w9ezEsMn0pPT98Wz9+Liw6O1tcXF0oKXt9XSl8KFxccyspfCheJHxbXFxzXFxTXSkvZ1xuXG5leHBvcnRzLm1hdGNoVG9Ub2tlbiA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHZhciB0b2tlbiA9IHt0eXBlOiBcImludmFsaWRcIiwgdmFsdWU6IG1hdGNoWzBdfVxuICAgICAgIGlmIChtYXRjaFsgMV0pIHRva2VuLnR5cGUgPSBcInN0cmluZ1wiICwgdG9rZW4uY2xvc2VkID0gISEobWF0Y2hbM10gfHwgbWF0Y2hbNF0pXG4gIGVsc2UgaWYgKG1hdGNoWyA1XSkgdG9rZW4udHlwZSA9IFwiY29tbWVudFwiXG4gIGVsc2UgaWYgKG1hdGNoWyA2XSkgdG9rZW4udHlwZSA9IFwiY29tbWVudFwiLCB0b2tlbi5jbG9zZWQgPSAhIW1hdGNoWzddXG4gIGVsc2UgaWYgKG1hdGNoWyA4XSkgdG9rZW4udHlwZSA9IFwicmVnZXhcIlxuICBlbHNlIGlmIChtYXRjaFsgOV0pIHRva2VuLnR5cGUgPSBcIm51bWJlclwiXG4gIGVsc2UgaWYgKG1hdGNoWzEwXSkgdG9rZW4udHlwZSA9IFwibmFtZVwiXG4gIGVsc2UgaWYgKG1hdGNoWzExXSkgdG9rZW4udHlwZSA9IFwicHVuY3R1YXRvclwiXG4gIGVsc2UgaWYgKG1hdGNoWzEyXSkgdG9rZW4udHlwZSA9IFwid2hpdGVzcGFjZVwiXG4gIHJldHVybiB0b2tlblxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9qcy10b2tlbnNAMy4wLjJAanMtdG9rZW5zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XG52YXIgYW5zaVN0eWxlcyA9IHJlcXVpcmUoJ2Fuc2ktc3R5bGVzJyk7XG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xudmFyIGhhc0Fuc2kgPSByZXF1aXJlKCdoYXMtYW5zaScpO1xudmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xudmFyIGRlZmluZVByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgaXNTaW1wbGVXaW5kb3dzVGVybSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgIS9eeHRlcm0vaS50ZXN0KHByb2Nlc3MuZW52LlRFUk0pO1xuXG5mdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG5cdC8vIGRldGVjdCBtb2RlIGlmIG5vdCBzZXQgbWFudWFsbHlcblx0dGhpcy5lbmFibGVkID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQgPyBzdXBwb3J0c0NvbG9yIDogb3B0aW9ucy5lbmFibGVkO1xufVxuXG4vLyB1c2UgYnJpZ2h0IGJsdWUgb24gV2luZG93cyBhcyB0aGUgbm9ybWFsIGJsdWUgY29sb3IgaXMgaWxsZWdpYmxlXG5pZiAoaXNTaW1wbGVXaW5kb3dzVGVybSkge1xuXHRhbnNpU3R5bGVzLmJsdWUub3BlbiA9ICdcXHUwMDFiWzk0bSc7XG59XG5cbnZhciBzdHlsZXMgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgcmV0ID0ge307XG5cblx0T2JqZWN0LmtleXMoYW5zaVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0YW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzW2tleV0uY2xvc2UpLCAnZycpO1xuXG5cdFx0cmV0W2tleV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzLmNvbmNhdChrZXkpKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufSkoKTtcblxudmFyIHByb3RvID0gZGVmaW5lUHJvcHMoZnVuY3Rpb24gY2hhbGsoKSB7fSwgc3R5bGVzKTtcblxuZnVuY3Rpb24gYnVpbGQoX3N0eWxlcykge1xuXHR2YXIgYnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gYXBwbHlTdHlsZS5hcHBseShidWlsZGVyLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdGJ1aWxkZXIuX3N0eWxlcyA9IF9zdHlsZXM7XG5cdGJ1aWxkZXIuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZDtcblx0Ly8gX19wcm90b19fIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcblx0Ly8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlLlxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXHRidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvO1xuXG5cdHJldHVybiBidWlsZGVyO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0eWxlKCkge1xuXHQvLyBzdXBwb3J0IHZhcmFncywgYnV0IHNpbXBseSBjYXN0IHRvIHN0cmluZyBpbiBjYXNlIHRoZXJlJ3Mgb25seSBvbmUgYXJnXG5cdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHR2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuXHR2YXIgc3RyID0gYXJnc0xlbiAhPT0gMCAmJiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcblxuXHRpZiAoYXJnc0xlbiA+IDEpIHtcblx0XHQvLyBkb24ndCBzbGljZSBgYXJndW1lbnRzYCwgaXQgcHJldmVudHMgdjggb3B0aW1pemF0aW9uc1xuXHRcdGZvciAodmFyIGEgPSAxOyBhIDwgYXJnc0xlbjsgYSsrKSB7XG5cdFx0XHRzdHIgKz0gJyAnICsgYXJnc1thXTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIXRoaXMuZW5hYmxlZCB8fCAhc3RyKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXG5cdHZhciBuZXN0ZWRTdHlsZXMgPSB0aGlzLl9zdHlsZXM7XG5cdHZhciBpID0gbmVzdGVkU3R5bGVzLmxlbmd0aDtcblxuXHQvLyBUdXJucyBvdXQgdGhhdCBvbiBXaW5kb3dzIGRpbW1lZCBncmF5IHRleHQgYmVjb21lcyBpbnZpc2libGUgaW4gY21kLmV4ZSxcblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFsay9jaGFsay9pc3N1ZXMvNThcblx0Ly8gSWYgd2UncmUgb24gV2luZG93cyBhbmQgd2UncmUgZGVhbGluZyB3aXRoIGEgZ3JheSBjb2xvciwgdGVtcG9yYXJpbHkgbWFrZSAnZGltJyBhIG5vb3AuXG5cdHZhciBvcmlnaW5hbERpbSA9IGFuc2lTdHlsZXMuZGltLm9wZW47XG5cdGlmIChpc1NpbXBsZVdpbmRvd3NUZXJtICYmIChuZXN0ZWRTdHlsZXMuaW5kZXhPZignZ3JheScpICE9PSAtMSB8fCBuZXN0ZWRTdHlsZXMuaW5kZXhPZignZ3JleScpICE9PSAtMSkpIHtcblx0XHRhbnNpU3R5bGVzLmRpbS5vcGVuID0gJyc7XG5cdH1cblxuXHR3aGlsZSAoaS0tKSB7XG5cdFx0dmFyIGNvZGUgPSBhbnNpU3R5bGVzW25lc3RlZFN0eWxlc1tpXV07XG5cblx0XHQvLyBSZXBsYWNlIGFueSBpbnN0YW5jZXMgYWxyZWFkeSBwcmVzZW50IHdpdGggYSByZS1vcGVuaW5nIGNvZGVcblx0XHQvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG5cdFx0Ly8gd2lsbCBiZSBjb2xvcmVkLCBhbmQgdGhlIHJlc3Qgd2lsbCBzaW1wbHkgYmUgJ3BsYWluJy5cblx0XHRzdHIgPSBjb2RlLm9wZW4gKyBzdHIucmVwbGFjZShjb2RlLmNsb3NlUmUsIGNvZGUub3BlbikgKyBjb2RlLmNsb3NlO1xuXHR9XG5cblx0Ly8gUmVzZXQgdGhlIG9yaWdpbmFsICdkaW0nIGlmIHdlIGNoYW5nZWQgaXQgdG8gd29yayBhcm91bmQgdGhlIFdpbmRvd3MgZGltbWVkIGdyYXkgaXNzdWUuXG5cdGFuc2lTdHlsZXMuZGltLm9wZW4gPSBvcmlnaW5hbERpbTtcblxuXHRyZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBpbml0KCkge1xuXHR2YXIgcmV0ID0ge307XG5cblx0T2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0W25hbWVdID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBidWlsZC5jYWxsKHRoaXMsIFtuYW1lXSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZGVmaW5lUHJvcHMoQ2hhbGsucHJvdG90eXBlLCBpbml0KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDaGFsaygpO1xubW9kdWxlLmV4cG9ydHMuc3R5bGVzID0gYW5zaVN0eWxlcztcbm1vZHVsZS5leHBvcnRzLmhhc0NvbG9yID0gaGFzQW5zaTtcbm1vZHVsZS5leHBvcnRzLnN0cmlwQ29sb3IgPSBzdHJpcEFuc2k7XG5tb2R1bGUuZXhwb3J0cy5zdXBwb3J0c0NvbG9yID0gc3VwcG9ydHNDb2xvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY2hhbGtAMS4xLjNAY2hhbGsvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAnXFxcXCQmJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9lc2NhcGUtc3RyaW5nLXJlZ2V4cEAxLjAuNUBlc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMgKCkge1xuXHR2YXIgc3R5bGVzID0ge1xuXHRcdG1vZGlmaWVyczoge1xuXHRcdFx0cmVzZXQ6IFswLCAwXSxcblx0XHRcdGJvbGQ6IFsxLCAyMl0sIC8vIDIxIGlzbid0IHdpZGVseSBzdXBwb3J0ZWQgYW5kIDIyIGRvZXMgdGhlIHNhbWUgdGhpbmdcblx0XHRcdGRpbTogWzIsIDIyXSxcblx0XHRcdGl0YWxpYzogWzMsIDIzXSxcblx0XHRcdHVuZGVybGluZTogWzQsIDI0XSxcblx0XHRcdGludmVyc2U6IFs3LCAyN10sXG5cdFx0XHRoaWRkZW46IFs4LCAyOF0sXG5cdFx0XHRzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG5cdFx0fSxcblx0XHRjb2xvcnM6IHtcblx0XHRcdGJsYWNrOiBbMzAsIDM5XSxcblx0XHRcdHJlZDogWzMxLCAzOV0sXG5cdFx0XHRncmVlbjogWzMyLCAzOV0sXG5cdFx0XHR5ZWxsb3c6IFszMywgMzldLFxuXHRcdFx0Ymx1ZTogWzM0LCAzOV0sXG5cdFx0XHRtYWdlbnRhOiBbMzUsIDM5XSxcblx0XHRcdGN5YW46IFszNiwgMzldLFxuXHRcdFx0d2hpdGU6IFszNywgMzldLFxuXHRcdFx0Z3JheTogWzkwLCAzOV1cblx0XHR9LFxuXHRcdGJnQ29sb3JzOiB7XG5cdFx0XHRiZ0JsYWNrOiBbNDAsIDQ5XSxcblx0XHRcdGJnUmVkOiBbNDEsIDQ5XSxcblx0XHRcdGJnR3JlZW46IFs0MiwgNDldLFxuXHRcdFx0YmdZZWxsb3c6IFs0MywgNDldLFxuXHRcdFx0YmdCbHVlOiBbNDQsIDQ5XSxcblx0XHRcdGJnTWFnZW50YTogWzQ1LCA0OV0sXG5cdFx0XHRiZ0N5YW46IFs0NiwgNDldLFxuXHRcdFx0YmdXaGl0ZTogWzQ3LCA0OV1cblx0XHR9XG5cdH07XG5cblx0Ly8gZml4IGh1bWFuc1xuXHRzdHlsZXMuY29sb3JzLmdyZXkgPSBzdHlsZXMuY29sb3JzLmdyYXk7XG5cblx0T2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChncm91cE5hbWUpIHtcblx0XHR2YXIgZ3JvdXAgPSBzdHlsZXNbZ3JvdXBOYW1lXTtcblxuXHRcdE9iamVjdC5rZXlzKGdyb3VwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcblx0XHRcdHZhciBzdHlsZSA9IGdyb3VwW3N0eWxlTmFtZV07XG5cblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0gZ3JvdXBbc3R5bGVOYW1lXSA9IHtcblx0XHRcdFx0b3BlbjogJ1xcdTAwMWJbJyArIHN0eWxlWzBdICsgJ20nLFxuXHRcdFx0XHRjbG9zZTogJ1xcdTAwMWJbJyArIHN0eWxlWzFdICsgJ20nXG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgZ3JvdXBOYW1lLCB7XG5cdFx0XHR2YWx1ZTogZ3JvdXAsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBhc3NlbWJsZVN0eWxlc1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2Fuc2ktc3R5bGVzQDIuMi4xQGFuc2ktc3R5bGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9zdHJpcC1hbnNpQDMuMC4xQHN0cmlwLWFuc2kvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpO1xudmFyIHJlID0gbmV3IFJlZ0V4cChhbnNpUmVnZXgoKS5zb3VyY2UpOyAvLyByZW1vdmUgdGhlIGBnYCBmbGFnXG5tb2R1bGUuZXhwb3J0cyA9IHJlLnRlc3QuYmluZChyZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2hhcy1hbnNpQDIuMC4wQGhhcy1hbnNpL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3Y7XG5cbnZhciB0ZXJtaW5hdG9yID0gYXJndi5pbmRleE9mKCctLScpO1xudmFyIGhhc0ZsYWcgPSBmdW5jdGlvbiAoZmxhZykge1xuXHRmbGFnID0gJy0tJyArIGZsYWc7XG5cdHZhciBwb3MgPSBhcmd2LmluZGV4T2YoZmxhZyk7XG5cdHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yICE9PSAtMSA/IHBvcyA8IHRlcm1pbmF0b3IgOiB0cnVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKCdGT1JDRV9DT0xPUicgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnbm8tY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1mYWxzZScpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5zdGRvdXQgJiYgIXByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBwcm9jZXNzLmVudikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MuZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICgvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChwcm9jZXNzLmVudi5URVJNKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fc3VwcG9ydHMtY29sb3JAMi4wLjBAc3VwcG9ydHMtY29sb3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbnZhciBfbWFwID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXBcIik7XG5cbnZhciBfbWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hcCk7XG5cbmV4cG9ydHMuZXZhbHVhdGVUcnV0aHkgPSBldmFsdWF0ZVRydXRoeTtcbmV4cG9ydHMuZXZhbHVhdGUgPSBldmFsdWF0ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFZBTElEX0NBTExFRVMgPSBbXCJTdHJpbmdcIiwgXCJOdW1iZXJcIiwgXCJNYXRoXCJdO1xudmFyIElOVkFMSURfTUVUSE9EUyA9IFtcInJhbmRvbVwiXTtcblxuZnVuY3Rpb24gZXZhbHVhdGVUcnV0aHkoKSB7XG4gIHZhciByZXMgPSB0aGlzLmV2YWx1YXRlKCk7XG4gIGlmIChyZXMuY29uZmlkZW50KSByZXR1cm4gISFyZXMudmFsdWU7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlKCkge1xuICB2YXIgY29uZmlkZW50ID0gdHJ1ZTtcbiAgdmFyIGRlb3B0UGF0aCA9IHZvaWQgMDtcbiAgdmFyIHNlZW4gPSBuZXcgX21hcDIuZGVmYXVsdCgpO1xuXG4gIGZ1bmN0aW9uIGRlb3B0KHBhdGgpIHtcbiAgICBpZiAoIWNvbmZpZGVudCkgcmV0dXJuO1xuICAgIGRlb3B0UGF0aCA9IHBhdGg7XG4gICAgY29uZmlkZW50ID0gZmFsc2U7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBldmFsdWF0ZSh0aGlzKTtcbiAgaWYgKCFjb25maWRlbnQpIHZhbHVlID0gdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZGVudDogY29uZmlkZW50LFxuICAgIGRlb3B0OiBkZW9wdFBhdGgsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGUocGF0aCkge1xuICAgIHZhciBub2RlID0gcGF0aC5ub2RlO1xuXG5cbiAgICBpZiAoc2Vlbi5oYXMobm9kZSkpIHtcbiAgICAgIHZhciBleGlzdGluZyA9IHNlZW4uZ2V0KG5vZGUpO1xuICAgICAgaWYgKGV4aXN0aW5nLnJlc29sdmVkKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZy52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlb3B0KHBhdGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVtID0geyByZXNvbHZlZDogZmFsc2UgfTtcbiAgICAgIHNlZW4uc2V0KG5vZGUsIGl0ZW0pO1xuXG4gICAgICB2YXIgdmFsID0gX2V2YWx1YXRlKHBhdGgpO1xuICAgICAgaWYgKGNvbmZpZGVudCkge1xuICAgICAgICBpdGVtLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgaXRlbS52YWx1ZSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2V2YWx1YXRlKHBhdGgpIHtcbiAgICBpZiAoIWNvbmZpZGVudCkgcmV0dXJuO1xuXG4gICAgdmFyIG5vZGUgPSBwYXRoLm5vZGU7XG5cblxuICAgIGlmIChwYXRoLmlzU2VxdWVuY2VFeHByZXNzaW9uKCkpIHtcbiAgICAgIHZhciBleHBycyA9IHBhdGguZ2V0KFwiZXhwcmVzc2lvbnNcIik7XG4gICAgICByZXR1cm4gZXZhbHVhdGUoZXhwcnNbZXhwcnMubGVuZ3RoIC0gMV0pO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmlzU3RyaW5nTGl0ZXJhbCgpIHx8IHBhdGguaXNOdW1lcmljTGl0ZXJhbCgpIHx8IHBhdGguaXNCb29sZWFuTGl0ZXJhbCgpKSB7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc051bGxMaXRlcmFsKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmlzVGVtcGxhdGVMaXRlcmFsKCkpIHtcbiAgICAgIHZhciBzdHIgPSBcIlwiO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2V4cHJzID0gcGF0aC5nZXQoXCJleHByZXNzaW9uc1wiKTtcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbm9kZS5xdWFzaXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgICAgIHZhciBfcmVmO1xuXG4gICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW0gPSBfcmVmO1xuXG4gICAgICAgIGlmICghY29uZmlkZW50KSBicmVhaztcblxuICAgICAgICBzdHIgKz0gZWxlbS52YWx1ZS5jb29rZWQ7XG5cbiAgICAgICAgdmFyIGV4cHIgPSBfZXhwcnNbaSsrXTtcbiAgICAgICAgaWYgKGV4cHIpIHN0ciArPSBTdHJpbmcoZXZhbHVhdGUoZXhwcikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmZpZGVudCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc0NvbmRpdGlvbmFsRXhwcmVzc2lvbigpKSB7XG4gICAgICB2YXIgdGVzdFJlc3VsdCA9IGV2YWx1YXRlKHBhdGguZ2V0KFwidGVzdFwiKSk7XG4gICAgICBpZiAoIWNvbmZpZGVudCkgcmV0dXJuO1xuICAgICAgaWYgKHRlc3RSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlKHBhdGguZ2V0KFwiY29uc2VxdWVudFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXZhbHVhdGUocGF0aC5nZXQoXCJhbHRlcm5hdGVcIikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXRoLmlzRXhwcmVzc2lvbldyYXBwZXIoKSkge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlKHBhdGguZ2V0KFwiZXhwcmVzc2lvblwiKSk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGguaXNNZW1iZXJFeHByZXNzaW9uKCkgJiYgIXBhdGgucGFyZW50UGF0aC5pc0NhbGxFeHByZXNzaW9uKHsgY2FsbGVlOiBub2RlIH0pKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBwYXRoLmdldChcInByb3BlcnR5XCIpO1xuICAgICAgdmFyIG9iamVjdCA9IHBhdGguZ2V0KFwib2JqZWN0XCIpO1xuXG4gICAgICBpZiAob2JqZWN0LmlzTGl0ZXJhbCgpICYmIHByb3BlcnR5LmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBvYmplY3Qubm9kZS52YWx1ZTtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgX3ZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShfdmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIF92YWx1ZVtwcm9wZXJ0eS5ub2RlLm5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGguaXNSZWZlcmVuY2VkSWRlbnRpZmllcigpKSB7XG4gICAgICB2YXIgYmluZGluZyA9IHBhdGguc2NvcGUuZ2V0QmluZGluZyhub2RlLm5hbWUpO1xuXG4gICAgICBpZiAoYmluZGluZyAmJiBiaW5kaW5nLmNvbnN0YW50VmlvbGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBkZW9wdChiaW5kaW5nLnBhdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmluZGluZyAmJiBwYXRoLm5vZGUuc3RhcnQgPCBiaW5kaW5nLnBhdGgubm9kZS5lbmQpIHtcbiAgICAgICAgcmV0dXJuIGRlb3B0KGJpbmRpbmcucGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiaW5kaW5nICYmIGJpbmRpbmcuaGFzVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmcudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRpbmcgPyBkZW9wdChiaW5kaW5nLnBhdGgpIDogdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmFtZSA9PT0gXCJJbmZpbml0eVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRpbmcgPyBkZW9wdChiaW5kaW5nLnBhdGgpIDogSW5maW5pdHk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5uYW1lID09PSBcIk5hTlwiKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRpbmcgPyBkZW9wdChiaW5kaW5nLnBhdGgpIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF0aC5yZXNvbHZlKCk7XG4gICAgICAgIGlmIChyZXNvbHZlZCA9PT0gcGF0aCkge1xuICAgICAgICAgIHJldHVybiBkZW9wdChwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXZhbHVhdGUocmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGguaXNVbmFyeUV4cHJlc3Npb24oeyBwcmVmaXg6IHRydWUgfSkpIHtcbiAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSBcInZvaWRcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJndW1lbnQgPSBwYXRoLmdldChcImFyZ3VtZW50XCIpO1xuICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwidHlwZW9mXCIgJiYgKGFyZ3VtZW50LmlzRnVuY3Rpb24oKSB8fCBhcmd1bWVudC5pc0NsYXNzKCkpKSB7XG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmcgPSBldmFsdWF0ZShhcmd1bWVudCk7XG4gICAgICBpZiAoIWNvbmZpZGVudCkgcmV0dXJuO1xuICAgICAgc3dpdGNoIChub2RlLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgcmV0dXJuICFhcmc7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgcmV0dXJuICthcmc7XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgcmV0dXJuIC1hcmc7XG4gICAgICAgIGNhc2UgXCJ+XCI6XG4gICAgICAgICAgcmV0dXJuIH5hcmc7XG4gICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoYXJnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc0FycmF5RXhwcmVzc2lvbigpKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgZWxlbXMgPSBwYXRoLmdldChcImVsZW1lbnRzXCIpO1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGVsZW1zLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjIpOzspIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTIuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2VsZW0gPSBfcmVmMjtcblxuICAgICAgICBfZWxlbSA9IF9lbGVtLmV2YWx1YXRlKCk7XG5cbiAgICAgICAgaWYgKF9lbGVtLmNvbmZpZGVudCkge1xuICAgICAgICAgIGFyci5wdXNoKF9lbGVtLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVvcHQoX2VsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmlzT2JqZWN0RXhwcmVzc2lvbigpKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICB2YXIgcHJvcHMgPSBwYXRoLmdldChcInByb3BlcnRpZXNcIik7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gcHJvcHMsIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMyk7Oykge1xuICAgICAgICB2YXIgX3JlZjM7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5Mykge1xuICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yM1tfaTMrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMy5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wID0gX3JlZjM7XG5cbiAgICAgICAgaWYgKHByb3AuaXNPYmplY3RNZXRob2QoKSB8fCBwcm9wLmlzU3ByZWFkUHJvcGVydHkoKSkge1xuICAgICAgICAgIHJldHVybiBkZW9wdChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5UGF0aCA9IHByb3AuZ2V0KFwia2V5XCIpO1xuICAgICAgICB2YXIga2V5ID0ga2V5UGF0aDtcbiAgICAgICAgaWYgKHByb3Aubm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgIGtleSA9IGtleS5ldmFsdWF0ZSgpO1xuICAgICAgICAgIGlmICgha2V5LmNvbmZpZGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlb3B0KGtleVBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBrZXkudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5LmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAga2V5ID0ga2V5Lm5vZGUubmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBrZXkubm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVQYXRoID0gcHJvcC5nZXQoXCJ2YWx1ZVwiKTtcbiAgICAgICAgdmFyIF92YWx1ZTIgPSB2YWx1ZVBhdGguZXZhbHVhdGUoKTtcbiAgICAgICAgaWYgKCFfdmFsdWUyLmNvbmZpZGVudCkge1xuICAgICAgICAgIHJldHVybiBkZW9wdCh2YWx1ZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIF92YWx1ZTIgPSBfdmFsdWUyLnZhbHVlO1xuICAgICAgICBvYmpba2V5XSA9IF92YWx1ZTI7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmlzTG9naWNhbEV4cHJlc3Npb24oKSkge1xuICAgICAgdmFyIHdhc0NvbmZpZGVudCA9IGNvbmZpZGVudDtcbiAgICAgIHZhciBsZWZ0ID0gZXZhbHVhdGUocGF0aC5nZXQoXCJsZWZ0XCIpKTtcbiAgICAgIHZhciBsZWZ0Q29uZmlkZW50ID0gY29uZmlkZW50O1xuICAgICAgY29uZmlkZW50ID0gd2FzQ29uZmlkZW50O1xuICAgICAgdmFyIHJpZ2h0ID0gZXZhbHVhdGUocGF0aC5nZXQoXCJyaWdodFwiKSk7XG4gICAgICB2YXIgcmlnaHRDb25maWRlbnQgPSBjb25maWRlbnQ7XG4gICAgICBjb25maWRlbnQgPSBsZWZ0Q29uZmlkZW50ICYmIHJpZ2h0Q29uZmlkZW50O1xuXG4gICAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgaWYgKGxlZnQgJiYgbGVmdENvbmZpZGVudCkge1xuICAgICAgICAgICAgY29uZmlkZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29uZmlkZW50KSByZXR1cm47XG5cbiAgICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICAgICAgY2FzZSBcIiYmXCI6XG4gICAgICAgICAgaWYgKCFsZWZ0ICYmIGxlZnRDb25maWRlbnQgfHwgIXJpZ2h0ICYmIHJpZ2h0Q29uZmlkZW50KSB7XG4gICAgICAgICAgICBjb25maWRlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29uZmlkZW50KSByZXR1cm47XG5cbiAgICAgICAgICByZXR1cm4gbGVmdCAmJiByaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc0JpbmFyeUV4cHJlc3Npb24oKSkge1xuICAgICAgdmFyIF9sZWZ0ID0gZXZhbHVhdGUocGF0aC5nZXQoXCJsZWZ0XCIpKTtcbiAgICAgIGlmICghY29uZmlkZW50KSByZXR1cm47XG4gICAgICB2YXIgX3JpZ2h0ID0gZXZhbHVhdGUocGF0aC5nZXQoXCJyaWdodFwiKSk7XG4gICAgICBpZiAoIWNvbmZpZGVudCkgcmV0dXJuO1xuXG4gICAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICByZXR1cm4gX2xlZnQgLSBfcmlnaHQ7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0ICsgX3JpZ2h0O1xuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgIHJldHVybiBfbGVmdCAvIF9yaWdodDtcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICByZXR1cm4gX2xlZnQgKiBfcmlnaHQ7XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0ICUgX3JpZ2h0O1xuICAgICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgICByZXR1cm4gTWF0aC5wb3coX2xlZnQsIF9yaWdodCk7XG4gICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0IDwgX3JpZ2h0O1xuICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIHJldHVybiBfbGVmdCA+IF9yaWdodDtcbiAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0IDw9IF9yaWdodDtcbiAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0ID49IF9yaWdodDtcbiAgICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0ID09IF9yaWdodDtcbiAgICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0ICE9IF9yaWdodDtcbiAgICAgICAgY2FzZSBcIj09PVwiOlxuICAgICAgICAgIHJldHVybiBfbGVmdCA9PT0gX3JpZ2h0O1xuICAgICAgICBjYXNlIFwiIT09XCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0ICE9PSBfcmlnaHQ7XG4gICAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgICAgcmV0dXJuIF9sZWZ0IHwgX3JpZ2h0O1xuICAgICAgICBjYXNlIFwiJlwiOlxuICAgICAgICAgIHJldHVybiBfbGVmdCAmIF9yaWdodDtcbiAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICByZXR1cm4gX2xlZnQgXiBfcmlnaHQ7XG4gICAgICAgIGNhc2UgXCI8PFwiOlxuICAgICAgICAgIHJldHVybiBfbGVmdCA8PCBfcmlnaHQ7XG4gICAgICAgIGNhc2UgXCI+PlwiOlxuICAgICAgICAgIHJldHVybiBfbGVmdCA+PiBfcmlnaHQ7XG4gICAgICAgIGNhc2UgXCI+Pj5cIjpcbiAgICAgICAgICByZXR1cm4gX2xlZnQgPj4+IF9yaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICAgIHZhciBjYWxsZWUgPSBwYXRoLmdldChcImNhbGxlZVwiKTtcbiAgICAgIHZhciBjb250ZXh0ID0gdm9pZCAwO1xuICAgICAgdmFyIGZ1bmMgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChjYWxsZWUuaXNJZGVudGlmaWVyKCkgJiYgIXBhdGguc2NvcGUuZ2V0QmluZGluZyhjYWxsZWUubm9kZS5uYW1lLCB0cnVlKSAmJiBWQUxJRF9DQUxMRUVTLmluZGV4T2YoY2FsbGVlLm5vZGUubmFtZSkgPj0gMCkge1xuICAgICAgICBmdW5jID0gZ2xvYmFsW25vZGUuY2FsbGVlLm5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGVlLmlzTWVtYmVyRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIHZhciBfb2JqZWN0ID0gY2FsbGVlLmdldChcIm9iamVjdFwiKTtcbiAgICAgICAgdmFyIF9wcm9wZXJ0eSA9IGNhbGxlZS5nZXQoXCJwcm9wZXJ0eVwiKTtcblxuICAgICAgICBpZiAoX29iamVjdC5pc0lkZW50aWZpZXIoKSAmJiBfcHJvcGVydHkuaXNJZGVudGlmaWVyKCkgJiYgVkFMSURfQ0FMTEVFUy5pbmRleE9mKF9vYmplY3Qubm9kZS5uYW1lKSA+PSAwICYmIElOVkFMSURfTUVUSE9EUy5pbmRleE9mKF9wcm9wZXJ0eS5ub2RlLm5hbWUpIDwgMCkge1xuICAgICAgICAgIGNvbnRleHQgPSBnbG9iYWxbX29iamVjdC5ub2RlLm5hbWVdO1xuICAgICAgICAgIGZ1bmMgPSBjb250ZXh0W19wcm9wZXJ0eS5ub2RlLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9vYmplY3QuaXNMaXRlcmFsKCkgJiYgX3Byb3BlcnR5LmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgdmFyIF90eXBlID0gKDAsIF90eXBlb2YzLmRlZmF1bHQpKF9vYmplY3Qubm9kZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKF90eXBlID09PSBcInN0cmluZ1wiIHx8IF90eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gX29iamVjdC5ub2RlLnZhbHVlO1xuICAgICAgICAgICAgZnVuYyA9IGNvbnRleHRbX3Byb3BlcnR5Lm5vZGUubmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHZhciBhcmdzID0gcGF0aC5nZXQoXCJhcmd1bWVudHNcIikubWFwKGV2YWx1YXRlKTtcbiAgICAgICAgaWYgKCFjb25maWRlbnQpIHJldHVybjtcblxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZW9wdChwYXRoKTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9wYXRoL2V2YWx1YXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudG9Db21wdXRlZEtleSA9IHRvQ29tcHV0ZWRLZXk7XG5leHBvcnRzLmVuc3VyZUJsb2NrID0gZW5zdXJlQmxvY2s7XG5leHBvcnRzLmFycm93RnVuY3Rpb25Ub1NoYWRvd2VkID0gYXJyb3dGdW5jdGlvblRvU2hhZG93ZWQ7XG5cbnZhciBfYmFiZWxUeXBlcyA9IHJlcXVpcmUoXCJiYWJlbC10eXBlc1wiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYmFiZWxUeXBlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIHRvQ29tcHV0ZWRLZXkoKSB7XG4gIHZhciBub2RlID0gdGhpcy5ub2RlO1xuXG4gIHZhciBrZXkgPSB2b2lkIDA7XG4gIGlmICh0aGlzLmlzTWVtYmVyRXhwcmVzc2lvbigpKSB7XG4gICAga2V5ID0gbm9kZS5wcm9wZXJ0eTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzUHJvcGVydHkoKSB8fCB0aGlzLmlzTWV0aG9kKCkpIHtcbiAgICBrZXkgPSBub2RlLmtleTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0b2RvXCIpO1xuICB9XG5cbiAgaWYgKCFub2RlLmNvbXB1dGVkKSB7XG4gICAgaWYgKHQuaXNJZGVudGlmaWVyKGtleSkpIGtleSA9IHQuc3RyaW5nTGl0ZXJhbChrZXkubmFtZSk7XG4gIH1cblxuICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVCbG9jaygpIHtcbiAgcmV0dXJuIHQuZW5zdXJlQmxvY2sodGhpcy5ub2RlKTtcbn1cblxuZnVuY3Rpb24gYXJyb3dGdW5jdGlvblRvU2hhZG93ZWQoKSB7XG4gIGlmICghdGhpcy5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkpIHJldHVybjtcblxuICB0aGlzLmVuc3VyZUJsb2NrKCk7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG5cbiAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gIG5vZGUudHlwZSA9IFwiRnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gIG5vZGUuc2hhZG93ID0gbm9kZS5zaGFkb3cgfHwgdHJ1ZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvcGF0aC9jb252ZXJzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzID0gdW5kZWZpbmVkO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmV4cG9ydHMubWF0Y2hlc1BhdHRlcm4gPSBtYXRjaGVzUGF0dGVybjtcbmV4cG9ydHMuaGFzID0gaGFzO1xuZXhwb3J0cy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuZXhwb3J0cy5pc250ID0gaXNudDtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5pc05vZGVUeXBlID0gaXNOb2RlVHlwZTtcbmV4cG9ydHMuY2FuSGF2ZVZhcmlhYmxlRGVjbGFyYXRpb25PckV4cHJlc3Npb24gPSBjYW5IYXZlVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbjtcbmV4cG9ydHMuY2FuU3dhcEJldHdlZW5FeHByZXNzaW9uQW5kU3RhdGVtZW50ID0gY2FuU3dhcEJldHdlZW5FeHByZXNzaW9uQW5kU3RhdGVtZW50O1xuZXhwb3J0cy5pc0NvbXBsZXRpb25SZWNvcmQgPSBpc0NvbXBsZXRpb25SZWNvcmQ7XG5leHBvcnRzLmlzU3RhdGVtZW50T3JCbG9jayA9IGlzU3RhdGVtZW50T3JCbG9jaztcbmV4cG9ydHMucmVmZXJlbmNlc0ltcG9ydCA9IHJlZmVyZW5jZXNJbXBvcnQ7XG5leHBvcnRzLmdldFNvdXJjZSA9IGdldFNvdXJjZTtcbmV4cG9ydHMud2lsbElNYXliZUV4ZWN1dGVCZWZvcmUgPSB3aWxsSU1heWJlRXhlY3V0ZUJlZm9yZTtcbmV4cG9ydHMuX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUbyA9IF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG87XG5leHBvcnRzLl9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9EaWZmZXJlbnRGdW5jdGlvbnMgPSBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvRGlmZmVyZW50RnVuY3Rpb25zO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbmV4cG9ydHMuX3Jlc29sdmUgPSBfcmVzb2x2ZTtcblxudmFyIF9pbmNsdWRlcyA9IHJlcXVpcmUoXCJsb2Rhc2gvaW5jbHVkZXNcIik7XG5cbnZhciBfaW5jbHVkZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5jbHVkZXMpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBtYXRjaGVzUGF0dGVybihwYXR0ZXJuLCBhbGxvd1BhcnRpYWwpIHtcbiAgaWYgKCF0aGlzLmlzTWVtYmVyRXhwcmVzc2lvbigpKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHBhcnRzID0gcGF0dGVybi5zcGxpdChcIi5cIik7XG4gIHZhciBzZWFyY2ggPSBbdGhpcy5ub2RlXTtcbiAgdmFyIGkgPSAwO1xuXG4gIGZ1bmN0aW9uIG1hdGNoZXMobmFtZSkge1xuICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgcmV0dXJuIHBhcnQgPT09IFwiKlwiIHx8IG5hbWUgPT09IHBhcnQ7XG4gIH1cblxuICB3aGlsZSAoc2VhcmNoLmxlbmd0aCkge1xuICAgIHZhciBub2RlID0gc2VhcmNoLnNoaWZ0KCk7XG5cbiAgICBpZiAoYWxsb3dQYXJ0aWFsICYmIGkgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgICBpZiAoIW1hdGNoZXMobm9kZS5uYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodC5pc0xpdGVyYWwobm9kZSkpIHtcbiAgICAgIGlmICghbWF0Y2hlcyhub2RlLnZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodC5pc01lbWJlckV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIGlmIChub2RlLmNvbXB1dGVkICYmICF0LmlzTGl0ZXJhbChub2RlLnByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2gudW5zaGlmdChub2RlLnByb3BlcnR5KTtcbiAgICAgICAgc2VhcmNoLnVuc2hpZnQobm9kZS5vYmplY3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHQuaXNUaGlzRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgaWYgKCFtYXRjaGVzKFwidGhpc1wiKSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCsraSA+IHBhcnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpID09PSBwYXJ0cy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgdmFyIHZhbCA9IHRoaXMubm9kZSAmJiB0aGlzLm5vZGVba2V5XTtcbiAgaWYgKHZhbCAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gISF2YWwubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhIXZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYygpIHtcbiAgcmV0dXJuIHRoaXMuc2NvcGUuaXNTdGF0aWModGhpcy5ub2RlKTtcbn1cblxudmFyIGlzID0gZXhwb3J0cy5pcyA9IGhhcztcblxuZnVuY3Rpb24gaXNudChrZXkpIHtcbiAgcmV0dXJuICF0aGlzLmhhcyhrZXkpO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5ub2RlW2tleV0gPT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc05vZGVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHQuaXNUeXBlKHRoaXMudHlwZSwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGNhbkhhdmVWYXJpYWJsZURlY2xhcmF0aW9uT3JFeHByZXNzaW9uKCkge1xuICByZXR1cm4gKHRoaXMua2V5ID09PSBcImluaXRcIiB8fCB0aGlzLmtleSA9PT0gXCJsZWZ0XCIpICYmIHRoaXMucGFyZW50UGF0aC5pc0ZvcigpO1xufVxuXG5mdW5jdGlvbiBjYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQocmVwbGFjZW1lbnQpIHtcbiAgaWYgKHRoaXMua2V5ICE9PSBcImJvZHlcIiB8fCAhdGhpcy5wYXJlbnRQYXRoLmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzRXhwcmVzc2lvbigpKSB7XG4gICAgcmV0dXJuIHQuaXNCbG9ja1N0YXRlbWVudChyZXBsYWNlbWVudCk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc0Jsb2NrU3RhdGVtZW50KCkpIHtcbiAgICByZXR1cm4gdC5pc0V4cHJlc3Npb24ocmVwbGFjZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRpb25SZWNvcmQoYWxsb3dJbnNpZGVGdW5jdGlvbikge1xuICB2YXIgcGF0aCA9IHRoaXM7XG4gIHZhciBmaXJzdCA9IHRydWU7XG5cbiAgZG8ge1xuICAgIHZhciBjb250YWluZXIgPSBwYXRoLmNvbnRhaW5lcjtcblxuICAgIGlmIChwYXRoLmlzRnVuY3Rpb24oKSAmJiAhZmlyc3QpIHtcbiAgICAgIHJldHVybiAhIWFsbG93SW5zaWRlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZmlyc3QgPSBmYWxzZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRhaW5lcikgJiYgcGF0aC5rZXkgIT09IGNvbnRhaW5lci5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IHdoaWxlICgocGF0aCA9IHBhdGgucGFyZW50UGF0aCkgJiYgIXBhdGguaXNQcm9ncmFtKCkpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlbWVudE9yQmxvY2soKSB7XG4gIGlmICh0aGlzLnBhcmVudFBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkgfHwgdC5pc0Jsb2NrU3RhdGVtZW50KHRoaXMuY29udGFpbmVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9pbmNsdWRlczIuZGVmYXVsdCkodC5TVEFURU1FTlRfT1JfQkxPQ0tfS0VZUywgdGhpcy5rZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZmVyZW5jZXNJbXBvcnQobW9kdWxlU291cmNlLCBpbXBvcnROYW1lKSB7XG4gIGlmICghdGhpcy5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKCkpIHJldHVybiBmYWxzZTtcblxuICB2YXIgYmluZGluZyA9IHRoaXMuc2NvcGUuZ2V0QmluZGluZyh0aGlzLm5vZGUubmFtZSk7XG4gIGlmICghYmluZGluZyB8fCBiaW5kaW5nLmtpbmQgIT09IFwibW9kdWxlXCIpIHJldHVybiBmYWxzZTtcblxuICB2YXIgcGF0aCA9IGJpbmRpbmcucGF0aDtcbiAgdmFyIHBhcmVudCA9IHBhdGgucGFyZW50UGF0aDtcbiAgaWYgKCFwYXJlbnQuaXNJbXBvcnREZWNsYXJhdGlvbigpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHBhcmVudC5ub2RlLnNvdXJjZS52YWx1ZSA9PT0gbW9kdWxlU291cmNlKSB7XG4gICAgaWYgKCFpbXBvcnROYW1lKSByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocGF0aC5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSAmJiBpbXBvcnROYW1lID09PSBcImRlZmF1bHRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHBhdGguaXNJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSAmJiBpbXBvcnROYW1lID09PSBcIipcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHBhdGguaXNJbXBvcnRTcGVjaWZpZXIoKSAmJiBwYXRoLm5vZGUuaW1wb3J0ZWQubmFtZSA9PT0gaW1wb3J0TmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2UoKSB7XG4gIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICBpZiAobm9kZS5lbmQpIHtcbiAgICByZXR1cm4gdGhpcy5odWIuZmlsZS5jb2RlLnNsaWNlKG5vZGUuc3RhcnQsIG5vZGUuZW5kKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aWxsSU1heWJlRXhlY3V0ZUJlZm9yZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRoaXMuX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUbyh0YXJnZXQpICE9PSBcImFmdGVyXCI7XG59XG5cbmZ1bmN0aW9uIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG8odGFyZ2V0KSB7XG4gIHZhciB0YXJnZXRGdW5jUGFyZW50ID0gdGFyZ2V0LnNjb3BlLmdldEZ1bmN0aW9uUGFyZW50KCk7XG4gIHZhciBzZWxmRnVuY1BhcmVudCA9IHRoaXMuc2NvcGUuZ2V0RnVuY3Rpb25QYXJlbnQoKTtcblxuICBpZiAodGFyZ2V0RnVuY1BhcmVudC5ub2RlICE9PSBzZWxmRnVuY1BhcmVudC5ub2RlKSB7XG4gICAgdmFyIHN0YXR1cyA9IHRoaXMuX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUb0RpZmZlcmVudEZ1bmN0aW9ucyh0YXJnZXRGdW5jUGFyZW50KTtcbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRGdW5jUGFyZW50LnBhdGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhcmdldFBhdGhzID0gdGFyZ2V0LmdldEFuY2VzdHJ5KCk7XG4gIGlmICh0YXJnZXRQYXRocy5pbmRleE9mKHRoaXMpID49IDApIHJldHVybiBcImFmdGVyXCI7XG5cbiAgdmFyIHNlbGZQYXRocyA9IHRoaXMuZ2V0QW5jZXN0cnkoKTtcblxuICB2YXIgY29tbW9uUGF0aCA9IHZvaWQgMDtcbiAgdmFyIHRhcmdldEluZGV4ID0gdm9pZCAwO1xuICB2YXIgc2VsZkluZGV4ID0gdm9pZCAwO1xuICBmb3IgKHNlbGZJbmRleCA9IDA7IHNlbGZJbmRleCA8IHNlbGZQYXRocy5sZW5ndGg7IHNlbGZJbmRleCsrKSB7XG4gICAgdmFyIHNlbGZQYXRoID0gc2VsZlBhdGhzW3NlbGZJbmRleF07XG4gICAgdGFyZ2V0SW5kZXggPSB0YXJnZXRQYXRocy5pbmRleE9mKHNlbGZQYXRoKTtcbiAgICBpZiAodGFyZ2V0SW5kZXggPj0gMCkge1xuICAgICAgY29tbW9uUGF0aCA9IHNlbGZQYXRoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghY29tbW9uUGF0aCkge1xuICAgIHJldHVybiBcImJlZm9yZVwiO1xuICB9XG5cbiAgdmFyIHRhcmdldFJlbGF0aW9uc2hpcCA9IHRhcmdldFBhdGhzW3RhcmdldEluZGV4IC0gMV07XG4gIHZhciBzZWxmUmVsYXRpb25zaGlwID0gc2VsZlBhdGhzW3NlbGZJbmRleCAtIDFdO1xuICBpZiAoIXRhcmdldFJlbGF0aW9uc2hpcCB8fCAhc2VsZlJlbGF0aW9uc2hpcCkge1xuICAgIHJldHVybiBcImJlZm9yZVwiO1xuICB9XG5cbiAgaWYgKHRhcmdldFJlbGF0aW9uc2hpcC5saXN0S2V5ICYmIHRhcmdldFJlbGF0aW9uc2hpcC5jb250YWluZXIgPT09IHNlbGZSZWxhdGlvbnNoaXAuY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHRhcmdldFJlbGF0aW9uc2hpcC5rZXkgPiBzZWxmUmVsYXRpb25zaGlwLmtleSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG4gIH1cblxuICB2YXIgdGFyZ2V0S2V5UG9zaXRpb24gPSB0LlZJU0lUT1JfS0VZU1t0YXJnZXRSZWxhdGlvbnNoaXAudHlwZV0uaW5kZXhPZih0YXJnZXRSZWxhdGlvbnNoaXAua2V5KTtcbiAgdmFyIHNlbGZLZXlQb3NpdGlvbiA9IHQuVklTSVRPUl9LRVlTW3NlbGZSZWxhdGlvbnNoaXAudHlwZV0uaW5kZXhPZihzZWxmUmVsYXRpb25zaGlwLmtleSk7XG4gIHJldHVybiB0YXJnZXRLZXlQb3NpdGlvbiA+IHNlbGZLZXlQb3NpdGlvbiA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG59XG5cbmZ1bmN0aW9uIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9EaWZmZXJlbnRGdW5jdGlvbnModGFyZ2V0RnVuY1BhcmVudCkge1xuICB2YXIgdGFyZ2V0RnVuY1BhdGggPSB0YXJnZXRGdW5jUGFyZW50LnBhdGg7XG4gIGlmICghdGFyZ2V0RnVuY1BhdGguaXNGdW5jdGlvbkRlY2xhcmF0aW9uKCkpIHJldHVybjtcblxuICB2YXIgYmluZGluZyA9IHRhcmdldEZ1bmNQYXRoLnNjb3BlLmdldEJpbmRpbmcodGFyZ2V0RnVuY1BhdGgubm9kZS5pZC5uYW1lKTtcblxuICBpZiAoIWJpbmRpbmcucmVmZXJlbmNlcykgcmV0dXJuIFwiYmVmb3JlXCI7XG5cbiAgdmFyIHJlZmVyZW5jZVBhdGhzID0gYmluZGluZy5yZWZlcmVuY2VQYXRocztcblxuICBmb3IgKHZhciBfaXRlcmF0b3IgPSByZWZlcmVuY2VQYXRocywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gX3JlZjtcblxuICAgIGlmIChwYXRoLmtleSAhPT0gXCJjYWxsZWVcIiB8fCAhcGF0aC5wYXJlbnRQYXRoLmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhbGxTdGF0dXMgPSB2b2lkIDA7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHJlZmVyZW5jZVBhdGhzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjIpOzspIHtcbiAgICB2YXIgX3JlZjI7XG5cbiAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBfcGF0aCA9IF9yZWYyO1xuXG4gICAgdmFyIGNoaWxkT2ZGdW5jdGlvbiA9ICEhX3BhdGguZmluZChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubm9kZSA9PT0gdGFyZ2V0RnVuY1BhdGgubm9kZTtcbiAgICB9KTtcbiAgICBpZiAoY2hpbGRPZkZ1bmN0aW9uKSBjb250aW51ZTtcblxuICAgIHZhciBzdGF0dXMgPSB0aGlzLl9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG8oX3BhdGgpO1xuXG4gICAgaWYgKGFsbFN0YXR1cykge1xuICAgICAgaWYgKGFsbFN0YXR1cyAhPT0gc3RhdHVzKSByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbFN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxsU3RhdHVzO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGRhbmdlcm91cywgcmVzb2x2ZWQpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCkgfHwgdGhpcztcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCkge1xuICBpZiAocmVzb2x2ZWQgJiYgcmVzb2x2ZWQuaW5kZXhPZih0aGlzKSA+PSAwKSByZXR1cm47XG5cbiAgcmVzb2x2ZWQgPSByZXNvbHZlZCB8fCBbXTtcbiAgcmVzb2x2ZWQucHVzaCh0aGlzKTtcblxuICBpZiAodGhpcy5pc1ZhcmlhYmxlRGVjbGFyYXRvcigpKSB7XG4gICAgaWYgKHRoaXMuZ2V0KFwiaWRcIikuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChcImluaXRcIikucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgICB9IGVsc2Uge31cbiAgfSBlbHNlIGlmICh0aGlzLmlzUmVmZXJlbmNlZElkZW50aWZpZXIoKSkge1xuICAgIHZhciBiaW5kaW5nID0gdGhpcy5zY29wZS5nZXRCaW5kaW5nKHRoaXMubm9kZS5uYW1lKTtcbiAgICBpZiAoIWJpbmRpbmcpIHJldHVybjtcblxuICAgIGlmICghYmluZGluZy5jb25zdGFudCkgcmV0dXJuO1xuXG4gICAgaWYgKGJpbmRpbmcua2luZCA9PT0gXCJtb2R1bGVcIikgcmV0dXJuO1xuXG4gICAgaWYgKGJpbmRpbmcucGF0aCAhPT0gdGhpcykge1xuICAgICAgdmFyIHJldCA9IGJpbmRpbmcucGF0aC5yZXNvbHZlKGRhbmdlcm91cywgcmVzb2x2ZWQpO1xuXG4gICAgICBpZiAodGhpcy5maW5kKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlID09PSByZXQubm9kZTtcbiAgICAgIH0pKSByZXR1cm47XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLmlzVHlwZUNhc3RFeHByZXNzaW9uKCkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJleHByZXNzaW9uXCIpLnJlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCk7XG4gIH0gZWxzZSBpZiAoZGFuZ2Vyb3VzICYmIHRoaXMuaXNNZW1iZXJFeHByZXNzaW9uKCkpIHtcblxuICAgIHZhciB0YXJnZXRLZXkgPSB0aGlzLnRvQ29tcHV0ZWRLZXkoKTtcbiAgICBpZiAoIXQuaXNMaXRlcmFsKHRhcmdldEtleSkpIHJldHVybjtcblxuICAgIHZhciB0YXJnZXROYW1lID0gdGFyZ2V0S2V5LnZhbHVlO1xuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0KFwib2JqZWN0XCIpLnJlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCk7XG5cbiAgICBpZiAodGFyZ2V0LmlzT2JqZWN0RXhwcmVzc2lvbigpKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0YXJnZXQuZ2V0KFwicHJvcGVydGllc1wiKTtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBwcm9wcywgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IzKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTMgPSBfaXRlcmF0b3IzLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3AgPSBfcmVmMztcblxuICAgICAgICBpZiAoIXByb3AuaXNQcm9wZXJ0eSgpKSBjb250aW51ZTtcblxuICAgICAgICB2YXIga2V5ID0gcHJvcC5nZXQoXCJrZXlcIik7XG5cbiAgICAgICAgdmFyIG1hdGNoID0gcHJvcC5pc250KFwiY29tcHV0ZWRcIikgJiYga2V5LmlzSWRlbnRpZmllcih7IG5hbWU6IHRhcmdldE5hbWUgfSk7XG5cbiAgICAgICAgbWF0Y2ggPSBtYXRjaCB8fCBrZXkuaXNMaXRlcmFsKHsgdmFsdWU6IHRhcmdldE5hbWUgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSByZXR1cm4gcHJvcC5nZXQoXCJ2YWx1ZVwiKS5yZXNvbHZlKGRhbmdlcm91cywgcmVzb2x2ZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmlzQXJyYXlFeHByZXNzaW9uKCkgJiYgIWlzTmFOKCt0YXJnZXROYW1lKSkge1xuICAgICAgdmFyIGVsZW1zID0gdGFyZ2V0LmdldChcImVsZW1lbnRzXCIpO1xuICAgICAgdmFyIGVsZW0gPSBlbGVtc1t0YXJnZXROYW1lXTtcbiAgICAgIGlmIChlbGVtKSByZXR1cm4gZWxlbS5yZXNvbHZlKGRhbmdlcm91cywgcmVzb2x2ZWQpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9wYXRoL2ludHJvc3BlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5leHBvcnRzLmNhbGwgPSBjYWxsO1xuZXhwb3J0cy5fY2FsbCA9IF9jYWxsO1xuZXhwb3J0cy5pc0JsYWNrbGlzdGVkID0gaXNCbGFja2xpc3RlZDtcbmV4cG9ydHMudmlzaXQgPSB2aXNpdDtcbmV4cG9ydHMuc2tpcCA9IHNraXA7XG5leHBvcnRzLnNraXBLZXkgPSBza2lwS2V5O1xuZXhwb3J0cy5zdG9wID0gc3RvcDtcbmV4cG9ydHMuc2V0U2NvcGUgPSBzZXRTY29wZTtcbmV4cG9ydHMuc2V0Q29udGV4dCA9IHNldENvbnRleHQ7XG5leHBvcnRzLnJlc3luYyA9IHJlc3luYztcbmV4cG9ydHMuX3Jlc3luY1BhcmVudCA9IF9yZXN5bmNQYXJlbnQ7XG5leHBvcnRzLl9yZXN5bmNLZXkgPSBfcmVzeW5jS2V5O1xuZXhwb3J0cy5fcmVzeW5jTGlzdCA9IF9yZXN5bmNMaXN0O1xuZXhwb3J0cy5fcmVzeW5jUmVtb3ZlZCA9IF9yZXN5bmNSZW1vdmVkO1xuZXhwb3J0cy5wb3BDb250ZXh0ID0gcG9wQ29udGV4dDtcbmV4cG9ydHMucHVzaENvbnRleHQgPSBwdXNoQ29udGV4dDtcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbmV4cG9ydHMuc2V0S2V5ID0gc2V0S2V5O1xuZXhwb3J0cy5yZXF1ZXVlID0gcmVxdWV1ZTtcbmV4cG9ydHMuX2dldFF1ZXVlQ29udGV4dHMgPSBfZ2V0UXVldWVDb250ZXh0cztcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNhbGwoa2V5KSB7XG4gIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuXG4gIHRoaXMuZGVidWcoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIGlmICh0aGlzLm5vZGUpIHtcbiAgICBpZiAodGhpcy5fY2FsbChvcHRzW2tleV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLm5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbChvcHRzW3RoaXMubm9kZS50eXBlXSAmJiBvcHRzW3RoaXMubm9kZS50eXBlXVtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2NhbGwoZm5zKSB7XG4gIGlmICghZm5zKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZm5zLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcik7Oykge1xuICAgIHZhciBfcmVmO1xuXG4gICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGZuID0gX3JlZjtcblxuICAgIGlmICghZm4pIGNvbnRpbnVlO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciByZXQgPSBmbi5jYWxsKHRoaXMuc3RhdGUsIHRoaXMsIHRoaXMuc3RhdGUpO1xuICAgIGlmIChyZXQpIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gdmlzaXRvciBtZXRob2QgXCIgKyBmbik7XG5cbiAgICBpZiAodGhpcy5ub2RlICE9PSBub2RlKSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnNob3VsZFN0b3AgfHwgdGhpcy5zaG91bGRTa2lwIHx8IHRoaXMucmVtb3ZlZCkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmxhY2tsaXN0ZWQoKSB7XG4gIHZhciBibGFja2xpc3QgPSB0aGlzLm9wdHMuYmxhY2tsaXN0O1xuICByZXR1cm4gYmxhY2tsaXN0ICYmIGJsYWNrbGlzdC5pbmRleE9mKHRoaXMubm9kZS50eXBlKSA+IC0xO1xufVxuXG5mdW5jdGlvbiB2aXNpdCgpIHtcbiAgaWYgKCF0aGlzLm5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5pc0JsYWNrbGlzdGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5vcHRzLnNob3VsZFNraXAgJiYgdGhpcy5vcHRzLnNob3VsZFNraXAodGhpcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5jYWxsKFwiZW50ZXJcIikgfHwgdGhpcy5zaG91bGRTa2lwKSB7XG4gICAgdGhpcy5kZWJ1ZyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJTa2lwLi4uXCI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkU3RvcDtcbiAgfVxuXG4gIHRoaXMuZGVidWcoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlJlY3Vyc2luZyBpbnRvLi4uXCI7XG4gIH0pO1xuICBfaW5kZXgyLmRlZmF1bHQubm9kZSh0aGlzLm5vZGUsIHRoaXMub3B0cywgdGhpcy5zY29wZSwgdGhpcy5zdGF0ZSwgdGhpcywgdGhpcy5za2lwS2V5cyk7XG5cbiAgdGhpcy5jYWxsKFwiZXhpdFwiKTtcblxuICByZXR1cm4gdGhpcy5zaG91bGRTdG9wO1xufVxuXG5mdW5jdGlvbiBza2lwKCkge1xuICB0aGlzLnNob3VsZFNraXAgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBza2lwS2V5KGtleSkge1xuICB0aGlzLnNraXBLZXlzW2tleV0gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBzdG9wKCkge1xuICB0aGlzLnNob3VsZFN0b3AgPSB0cnVlO1xuICB0aGlzLnNob3VsZFNraXAgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRTY29wZSgpIHtcbiAgaWYgKHRoaXMub3B0cyAmJiB0aGlzLm9wdHMubm9TY29wZSkgcmV0dXJuO1xuXG4gIHZhciB0YXJnZXQgPSB0aGlzLmNvbnRleHQgJiYgdGhpcy5jb250ZXh0LnNjb3BlO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhcmVudFBhdGg7XG4gICAgd2hpbGUgKHBhdGggJiYgIXRhcmdldCkge1xuICAgICAgaWYgKHBhdGgub3B0cyAmJiBwYXRoLm9wdHMubm9TY29wZSkgcmV0dXJuO1xuXG4gICAgICB0YXJnZXQgPSBwYXRoLnNjb3BlO1xuICAgICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgICB9XG4gIH1cblxuICB0aGlzLnNjb3BlID0gdGhpcy5nZXRTY29wZSh0YXJnZXQpO1xuICBpZiAodGhpcy5zY29wZSkgdGhpcy5zY29wZS5pbml0KCk7XG59XG5cbmZ1bmN0aW9uIHNldENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLnNob3VsZFNraXAgPSBmYWxzZTtcbiAgdGhpcy5zaG91bGRTdG9wID0gZmFsc2U7XG4gIHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuICB0aGlzLnNraXBLZXlzID0ge307XG5cbiAgaWYgKGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuc3RhdGUgPSBjb250ZXh0LnN0YXRlO1xuICAgIHRoaXMub3B0cyA9IGNvbnRleHQub3B0cztcbiAgfVxuXG4gIHRoaXMuc2V0U2NvcGUoKTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gcmVzeW5jKCkge1xuICBpZiAodGhpcy5yZW1vdmVkKSByZXR1cm47XG5cbiAgdGhpcy5fcmVzeW5jUGFyZW50KCk7XG4gIHRoaXMuX3Jlc3luY0xpc3QoKTtcbiAgdGhpcy5fcmVzeW5jS2V5KCk7XG59XG5cbmZ1bmN0aW9uIF9yZXN5bmNQYXJlbnQoKSB7XG4gIGlmICh0aGlzLnBhcmVudFBhdGgpIHtcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMucGFyZW50UGF0aC5ub2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9yZXN5bmNLZXkoKSB7XG4gIGlmICghdGhpcy5jb250YWluZXIpIHJldHVybjtcblxuICBpZiAodGhpcy5ub2RlID09PSB0aGlzLmNvbnRhaW5lclt0aGlzLmtleV0pIHJldHVybjtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbnRhaW5lcikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGFpbmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jb250YWluZXJbaV0gPT09IHRoaXMubm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRLZXkoaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbnRhaW5lcikge1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVyW2tleV0gPT09IHRoaXMubm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRLZXkoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmtleSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIF9yZXN5bmNMaXN0KCkge1xuICBpZiAoIXRoaXMucGFyZW50IHx8ICF0aGlzLmluTGlzdCkgcmV0dXJuO1xuXG4gIHZhciBuZXdDb250YWluZXIgPSB0aGlzLnBhcmVudFt0aGlzLmxpc3RLZXldO1xuICBpZiAodGhpcy5jb250YWluZXIgPT09IG5ld0NvbnRhaW5lcikgcmV0dXJuO1xuXG4gIHRoaXMuY29udGFpbmVyID0gbmV3Q29udGFpbmVyIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIF9yZXN5bmNSZW1vdmVkKCkge1xuICBpZiAodGhpcy5rZXkgPT0gbnVsbCB8fCAhdGhpcy5jb250YWluZXIgfHwgdGhpcy5jb250YWluZXJbdGhpcy5rZXldICE9PSB0aGlzLm5vZGUpIHtcbiAgICB0aGlzLl9tYXJrUmVtb3ZlZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHQoKSB7XG4gIHRoaXMuY29udGV4dHMucG9wKCk7XG4gIHRoaXMuc2V0Q29udGV4dCh0aGlzLmNvbnRleHRzW3RoaXMuY29udGV4dHMubGVuZ3RoIC0gMV0pO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgdGhpcy5zZXRDb250ZXh0KGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBzZXR1cChwYXJlbnRQYXRoLCBjb250YWluZXIsIGxpc3RLZXksIGtleSkge1xuICB0aGlzLmluTGlzdCA9ICEhbGlzdEtleTtcbiAgdGhpcy5saXN0S2V5ID0gbGlzdEtleTtcbiAgdGhpcy5wYXJlbnRLZXkgPSBsaXN0S2V5IHx8IGtleTtcbiAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgdGhpcy5wYXJlbnRQYXRoID0gcGFyZW50UGF0aCB8fCB0aGlzLnBhcmVudFBhdGg7XG4gIHRoaXMuc2V0S2V5KGtleSk7XG59XG5cbmZ1bmN0aW9uIHNldEtleShrZXkpIHtcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMubm9kZSA9IHRoaXMuY29udGFpbmVyW3RoaXMua2V5XTtcbiAgdGhpcy50eXBlID0gdGhpcy5ub2RlICYmIHRoaXMubm9kZS50eXBlO1xufVxuXG5mdW5jdGlvbiByZXF1ZXVlKCkge1xuICB2YXIgcGF0aFRvUXVldWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXM7XG5cbiAgaWYgKHBhdGhUb1F1ZXVlLnJlbW92ZWQpIHJldHVybjtcblxuICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvcjIgPSBjb250ZXh0cywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IyKTs7KSB7XG4gICAgdmFyIF9yZWYyO1xuXG4gICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgIGlmIChfaTIuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IF9yZWYyO1xuXG4gICAgY29udGV4dC5tYXliZVF1ZXVlKHBhdGhUb1F1ZXVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UXVldWVDb250ZXh0cygpIHtcbiAgdmFyIHBhdGggPSB0aGlzO1xuICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICB3aGlsZSAoIWNvbnRleHRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBwYXRoLnBhcmVudFBhdGg7XG4gICAgY29udGV4dHMgPSBwYXRoLmNvbnRleHRzO1xuICB9XG4gIHJldHVybiBjb250ZXh0cztcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvcGF0aC9jb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG5leHBvcnRzLl9jYWxsUmVtb3ZhbEhvb2tzID0gX2NhbGxSZW1vdmFsSG9va3M7XG5leHBvcnRzLl9yZW1vdmUgPSBfcmVtb3ZlO1xuZXhwb3J0cy5fbWFya1JlbW92ZWQgPSBfbWFya1JlbW92ZWQ7XG5leHBvcnRzLl9hc3NlcnRVbnJlbW92ZWQgPSBfYXNzZXJ0VW5yZW1vdmVkO1xuXG52YXIgX3JlbW92YWxIb29rcyA9IHJlcXVpcmUoXCIuL2xpYi9yZW1vdmFsLWhvb2tzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiByZW1vdmUoKSB7XG4gIHRoaXMuX2Fzc2VydFVucmVtb3ZlZCgpO1xuXG4gIHRoaXMucmVzeW5jKCk7XG5cbiAgaWYgKHRoaXMuX2NhbGxSZW1vdmFsSG9va3MoKSkge1xuICAgIHRoaXMuX21hcmtSZW1vdmVkKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5zaGFyZUNvbW1lbnRzV2l0aFNpYmxpbmdzKCk7XG4gIHRoaXMuX3JlbW92ZSgpO1xuICB0aGlzLl9tYXJrUmVtb3ZlZCgpO1xufVxuXG5mdW5jdGlvbiBfY2FsbFJlbW92YWxIb29rcygpIHtcbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX3JlbW92YWxIb29rcy5ob29rcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBmbiA9IF9yZWY7XG5cbiAgICBpZiAoZm4odGhpcywgdGhpcy5wYXJlbnRQYXRoKSkgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3JlbW92ZSgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250YWluZXIpKSB7XG4gICAgdGhpcy5jb250YWluZXIuc3BsaWNlKHRoaXMua2V5LCAxKTtcbiAgICB0aGlzLnVwZGF0ZVNpYmxpbmdLZXlzKHRoaXMua2V5LCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcmVwbGFjZVdpdGgobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX21hcmtSZW1vdmVkKCkge1xuICB0aGlzLnNob3VsZFNraXAgPSB0cnVlO1xuICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICB0aGlzLm5vZGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VW5yZW1vdmVkKCkge1xuICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgdGhyb3cgdGhpcy5idWlsZENvZGVGcmFtZUVycm9yKFwiTm9kZVBhdGggaGFzIGJlZW4gcmVtb3ZlZCBzbyBpcyByZWFkLW9ubHkuXCIpO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2UvbGliL3BhdGgvcmVtb3ZhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGhvb2tzID0gZXhwb3J0cy5ob29rcyA9IFtmdW5jdGlvbiAoc2VsZiwgcGFyZW50KSB7XG4gIHZhciByZW1vdmVQYXJlbnQgPSBzZWxmLmtleSA9PT0gXCJ0ZXN0XCIgJiYgKHBhcmVudC5pc1doaWxlKCkgfHwgcGFyZW50LmlzU3dpdGNoQ2FzZSgpKSB8fCBzZWxmLmtleSA9PT0gXCJkZWNsYXJhdGlvblwiICYmIHBhcmVudC5pc0V4cG9ydERlY2xhcmF0aW9uKCkgfHwgc2VsZi5rZXkgPT09IFwiYm9keVwiICYmIHBhcmVudC5pc0xhYmVsZWRTdGF0ZW1lbnQoKSB8fCBzZWxmLmxpc3RLZXkgPT09IFwiZGVjbGFyYXRpb25zXCIgJiYgcGFyZW50LmlzVmFyaWFibGVEZWNsYXJhdGlvbigpICYmIHBhcmVudC5ub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgfHwgc2VsZi5rZXkgPT09IFwiZXhwcmVzc2lvblwiICYmIHBhcmVudC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoKTtcblxuICBpZiAocmVtb3ZlUGFyZW50KSB7XG4gICAgcGFyZW50LnJlbW92ZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59LCBmdW5jdGlvbiAoc2VsZiwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQuaXNTZXF1ZW5jZUV4cHJlc3Npb24oKSAmJiBwYXJlbnQubm9kZS5leHByZXNzaW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICBwYXJlbnQucmVwbGFjZVdpdGgocGFyZW50Lm5vZGUuZXhwcmVzc2lvbnNbMF0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59LCBmdW5jdGlvbiAoc2VsZiwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQuaXNCaW5hcnkoKSkge1xuICAgIGlmIChzZWxmLmtleSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIHBhcmVudC5yZXBsYWNlV2l0aChwYXJlbnQubm9kZS5yaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5yZXBsYWNlV2l0aChwYXJlbnQubm9kZS5sZWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sIGZ1bmN0aW9uIChzZWxmLCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudC5pc0lmU3RhdGVtZW50KCkgJiYgKHNlbGYua2V5ID09PSBcImNvbnNlcXVlbnRcIiB8fCBzZWxmLmtleSA9PT0gXCJhbHRlcm5hdGVcIikgfHwgc2VsZi5rZXkgPT09IFwiYm9keVwiICYmIChwYXJlbnQuaXNMb29wKCkgfHwgcGFyZW50LmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oKSkpIHtcbiAgICBzZWxmLnJlcGxhY2VXaXRoKHtcbiAgICAgIHR5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIixcbiAgICAgIGJvZHk6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1dO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9wYXRoL2xpYi9yZW1vdmFsLWhvb2tzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5leHBvcnRzLmluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZTtcbmV4cG9ydHMuX2NvbnRhaW5lckluc2VydCA9IF9jb250YWluZXJJbnNlcnQ7XG5leHBvcnRzLl9jb250YWluZXJJbnNlcnRCZWZvcmUgPSBfY29udGFpbmVySW5zZXJ0QmVmb3JlO1xuZXhwb3J0cy5fY29udGFpbmVySW5zZXJ0QWZ0ZXIgPSBfY29udGFpbmVySW5zZXJ0QWZ0ZXI7XG5leHBvcnRzLl9tYXliZVBvcEZyb21TdGF0ZW1lbnRzID0gX21heWJlUG9wRnJvbVN0YXRlbWVudHM7XG5leHBvcnRzLmluc2VydEFmdGVyID0gaW5zZXJ0QWZ0ZXI7XG5leHBvcnRzLnVwZGF0ZVNpYmxpbmdLZXlzID0gdXBkYXRlU2libGluZ0tleXM7XG5leHBvcnRzLl92ZXJpZnlOb2RlTGlzdCA9IF92ZXJpZnlOb2RlTGlzdDtcbmV4cG9ydHMudW5zaGlmdENvbnRhaW5lciA9IHVuc2hpZnRDb250YWluZXI7XG5leHBvcnRzLnB1c2hDb250YWluZXIgPSBwdXNoQ29udGFpbmVyO1xuZXhwb3J0cy5ob2lzdCA9IGhvaXN0O1xuXG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlXCIpO1xuXG52YXIgX2hvaXN0ZXIgPSByZXF1aXJlKFwiLi9saWIvaG9pc3RlclwiKTtcblxudmFyIF9ob2lzdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0ZXIpO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG5cbnZhciBfaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5kZXgpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUobm9kZXMpIHtcbiAgdGhpcy5fYXNzZXJ0VW5yZW1vdmVkKCk7XG5cbiAgbm9kZXMgPSB0aGlzLl92ZXJpZnlOb2RlTGlzdChub2Rlcyk7XG5cbiAgaWYgKHRoaXMucGFyZW50UGF0aC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoKSB8fCB0aGlzLnBhcmVudFBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRQYXRoLmluc2VydEJlZm9yZShub2Rlcyk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc05vZGVUeXBlKFwiRXhwcmVzc2lvblwiKSB8fCB0aGlzLnBhcmVudFBhdGguaXNGb3JTdGF0ZW1lbnQoKSAmJiB0aGlzLmtleSA9PT0gXCJpbml0XCIpIHtcbiAgICBpZiAodGhpcy5ub2RlKSBub2Rlcy5wdXNoKHRoaXMubm9kZSk7XG4gICAgdGhpcy5yZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzKG5vZGVzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9tYXliZVBvcEZyb21TdGF0ZW1lbnRzKG5vZGVzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJJbnNlcnRCZWZvcmUobm9kZXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlbWVudE9yQmxvY2soKSkge1xuICAgICAgaWYgKHRoaXMubm9kZSkgbm9kZXMucHVzaCh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy5fcmVwbGFjZVdpdGgodC5ibG9ja1N0YXRlbWVudChub2RlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBkb24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aCB0aGlzIG5vZGUgdHlwZS4gXCIgKyBcIldlIHdlcmUgcHJldmlvdXNseSBhIFN0YXRlbWVudCBidXQgd2UgY2FuJ3QgZml0IGluIGhlcmU/XCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbdGhpc107XG59XG5cbmZ1bmN0aW9uIF9jb250YWluZXJJbnNlcnQoZnJvbSwgbm9kZXMpIHtcbiAgdGhpcy51cGRhdGVTaWJsaW5nS2V5cyhmcm9tLCBub2Rlcy5sZW5ndGgpO1xuXG4gIHZhciBwYXRocyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG8gPSBmcm9tICsgaTtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHRoaXMuY29udGFpbmVyLnNwbGljZSh0bywgMCwgbm9kZSk7XG5cbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuY29udGV4dC5jcmVhdGUodGhpcy5wYXJlbnQsIHRoaXMuY29udGFpbmVyLCB0bywgdGhpcy5saXN0S2V5KTtcblxuICAgICAgaWYgKHRoaXMuY29udGV4dC5xdWV1ZSkgcGF0aC5wdXNoQ29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMucHVzaChfaW5kZXgyLmRlZmF1bHQuZ2V0KHtcbiAgICAgICAgcGFyZW50UGF0aDogdGhpcy5wYXJlbnRQYXRoLFxuICAgICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBsaXN0S2V5OiB0aGlzLmxpc3RLZXksXG4gICAgICAgIGtleTogdG9cbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dHMgPSB0aGlzLl9nZXRRdWV1ZUNvbnRleHRzKCk7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcGF0aHMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgX3BhdGggPSBfcmVmO1xuXG4gICAgX3BhdGguc2V0U2NvcGUoKTtcbiAgICBfcGF0aC5kZWJ1ZyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJJbnNlcnRlZC5cIjtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBjb250ZXh0cywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IyKTs7KSB7XG4gICAgICB2YXIgX3JlZjI7XG5cbiAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gX3JlZjI7XG5cbiAgICAgIGNvbnRleHQubWF5YmVRdWV1ZShfcGF0aCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG5mdW5jdGlvbiBfY29udGFpbmVySW5zZXJ0QmVmb3JlKG5vZGVzKSB7XG4gIHJldHVybiB0aGlzLl9jb250YWluZXJJbnNlcnQodGhpcy5rZXksIG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gX2NvbnRhaW5lckluc2VydEFmdGVyKG5vZGVzKSB7XG4gIHJldHVybiB0aGlzLl9jb250YWluZXJJbnNlcnQodGhpcy5rZXkgKyAxLCBub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIF9tYXliZVBvcEZyb21TdGF0ZW1lbnRzKG5vZGVzKSB7XG4gIHZhciBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gIHZhciBpc0lkZW50aWZpZXIgPSB0LmlzSWRlbnRpZmllcihsYXN0KSB8fCB0LmlzRXhwcmVzc2lvblN0YXRlbWVudChsYXN0KSAmJiB0LmlzSWRlbnRpZmllcihsYXN0LmV4cHJlc3Npb24pO1xuXG4gIGlmIChpc0lkZW50aWZpZXIgJiYgIXRoaXMuaXNDb21wbGV0aW9uUmVjb3JkKCkpIHtcbiAgICBub2Rlcy5wb3AoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRBZnRlcihub2Rlcykge1xuICB0aGlzLl9hc3NlcnRVbnJlbW92ZWQoKTtcblxuICBub2RlcyA9IHRoaXMuX3ZlcmlmeU5vZGVMaXN0KG5vZGVzKTtcblxuICBpZiAodGhpcy5wYXJlbnRQYXRoLmlzRXhwcmVzc2lvblN0YXRlbWVudCgpIHx8IHRoaXMucGFyZW50UGF0aC5pc0xhYmVsZWRTdGF0ZW1lbnQoKSkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudFBhdGguaW5zZXJ0QWZ0ZXIobm9kZXMpO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNOb2RlVHlwZShcIkV4cHJlc3Npb25cIikgfHwgdGhpcy5wYXJlbnRQYXRoLmlzRm9yU3RhdGVtZW50KCkgJiYgdGhpcy5rZXkgPT09IFwiaW5pdFwiKSB7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgdmFyIHRlbXAgPSB0aGlzLnNjb3BlLmdlbmVyYXRlRGVjbGFyZWRVaWRJZGVudGlmaWVyKCk7XG4gICAgICBub2Rlcy51bnNoaWZ0KHQuZXhwcmVzc2lvblN0YXRlbWVudCh0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCB0ZW1wLCB0aGlzLm5vZGUpKSk7XG4gICAgICBub2Rlcy5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudCh0ZW1wKSk7XG4gICAgfVxuICAgIHRoaXMucmVwbGFjZUV4cHJlc3Npb25XaXRoU3RhdGVtZW50cyhub2Rlcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbWF5YmVQb3BGcm9tU3RhdGVtZW50cyhub2Rlcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVySW5zZXJ0QWZ0ZXIobm9kZXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlbWVudE9yQmxvY2soKSkge1xuICAgICAgaWYgKHRoaXMubm9kZSkgbm9kZXMudW5zaGlmdCh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy5fcmVwbGFjZVdpdGgodC5ibG9ja1N0YXRlbWVudChub2RlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBkb24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aCB0aGlzIG5vZGUgdHlwZS4gXCIgKyBcIldlIHdlcmUgcHJldmlvdXNseSBhIFN0YXRlbWVudCBidXQgd2UgY2FuJ3QgZml0IGluIGhlcmU/XCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbdGhpc107XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpYmxpbmdLZXlzKGZyb21JbmRleCwgaW5jcmVtZW50QnkpIHtcbiAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuO1xuXG4gIHZhciBwYXRocyA9IF9jYWNoZS5wYXRoLmdldCh0aGlzLnBhcmVudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuICAgIGlmIChwYXRoLmtleSA+PSBmcm9tSW5kZXgpIHtcbiAgICAgIHBhdGgua2V5ICs9IGluY3JlbWVudEJ5O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfdmVyaWZ5Tm9kZUxpc3Qobm9kZXMpIHtcbiAgaWYgKCFub2Rlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmIChub2Rlcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICBub2RlcyA9IFtub2Rlc107XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgbXNnID0gdm9pZCAwO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBtc2cgPSBcImhhcyBmYWxzeSBub2RlXCI7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIG5vZGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKG5vZGUpKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgbXNnID0gXCJjb250YWlucyBhIG5vbi1vYmplY3Qgbm9kZVwiO1xuICAgIH0gZWxzZSBpZiAoIW5vZGUudHlwZSkge1xuICAgICAgbXNnID0gXCJ3aXRob3V0IGEgdHlwZVwiO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIF9pbmRleDIuZGVmYXVsdCkge1xuICAgICAgbXNnID0gXCJoYXMgYSBOb2RlUGF0aCB3aGVuIGl0IGV4cGVjdGVkIGEgcmF3IG9iamVjdFwiO1xuICAgIH1cblxuICAgIGlmIChtc2cpIHtcbiAgICAgIHZhciB0eXBlID0gQXJyYXkuaXNBcnJheShub2RlKSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBub2RlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShub2RlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUgbGlzdCBcIiArIG1zZyArIFwiIHdpdGggdGhlIGluZGV4IG9mIFwiICsgaSArIFwiIGFuZCB0eXBlIG9mIFwiICsgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0Q29udGFpbmVyKGxpc3RLZXksIG5vZGVzKSB7XG4gIHRoaXMuX2Fzc2VydFVucmVtb3ZlZCgpO1xuXG4gIG5vZGVzID0gdGhpcy5fdmVyaWZ5Tm9kZUxpc3Qobm9kZXMpO1xuXG4gIHZhciBwYXRoID0gX2luZGV4Mi5kZWZhdWx0LmdldCh7XG4gICAgcGFyZW50UGF0aDogdGhpcyxcbiAgICBwYXJlbnQ6IHRoaXMubm9kZSxcbiAgICBjb250YWluZXI6IHRoaXMubm9kZVtsaXN0S2V5XSxcbiAgICBsaXN0S2V5OiBsaXN0S2V5LFxuICAgIGtleTogMFxuICB9KTtcblxuICByZXR1cm4gcGF0aC5pbnNlcnRCZWZvcmUobm9kZXMpO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGFpbmVyKGxpc3RLZXksIG5vZGVzKSB7XG4gIHRoaXMuX2Fzc2VydFVucmVtb3ZlZCgpO1xuXG4gIG5vZGVzID0gdGhpcy5fdmVyaWZ5Tm9kZUxpc3Qobm9kZXMpO1xuXG4gIHZhciBjb250YWluZXIgPSB0aGlzLm5vZGVbbGlzdEtleV07XG4gIHZhciBwYXRoID0gX2luZGV4Mi5kZWZhdWx0LmdldCh7XG4gICAgcGFyZW50UGF0aDogdGhpcyxcbiAgICBwYXJlbnQ6IHRoaXMubm9kZSxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBsaXN0S2V5OiBsaXN0S2V5LFxuICAgIGtleTogY29udGFpbmVyLmxlbmd0aFxuICB9KTtcblxuICByZXR1cm4gcGF0aC5yZXBsYWNlV2l0aE11bHRpcGxlKG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gaG9pc3QoKSB7XG4gIHZhciBzY29wZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5zY29wZTtcblxuICB2YXIgaG9pc3RlciA9IG5ldyBfaG9pc3RlcjIuZGVmYXVsdCh0aGlzLCBzY29wZSk7XG4gIHJldHVybiBob2lzdGVyLnJ1bigpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtdHJhdmVyc2VANi4yNi4wQGJhYmVsLXRyYXZlcnNlL2xpYi9wYXRoL21vZGlmaWNhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcmVmZXJlbmNlVmlzaXRvciA9IHtcbiAgUmVmZXJlbmNlZElkZW50aWZpZXI6IGZ1bmN0aW9uIFJlZmVyZW5jZWRJZGVudGlmaWVyKHBhdGgsIHN0YXRlKSB7XG4gICAgaWYgKHBhdGguaXNKU1hJZGVudGlmaWVyKCkgJiYgX2JhYmVsVHlwZXMucmVhY3QuaXNDb21wYXRUYWcocGF0aC5ub2RlLm5hbWUpICYmICFwYXRoLnBhcmVudFBhdGguaXNKU1hNZW1iZXJFeHByZXNzaW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGF0aC5ub2RlLm5hbWUgPT09IFwidGhpc1wiKSB7XG4gICAgICB2YXIgc2NvcGUgPSBwYXRoLnNjb3BlO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoc2NvcGUucGF0aC5pc0Z1bmN0aW9uKCkgJiYgIXNjb3BlLnBhdGguaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSBicmVhaztcbiAgICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICAgIGlmIChzY29wZSkgc3RhdGUuYnJlYWtPblNjb3BlUGF0aHMucHVzaChzY29wZS5wYXRoKTtcbiAgICB9XG5cbiAgICB2YXIgYmluZGluZyA9IHBhdGguc2NvcGUuZ2V0QmluZGluZyhwYXRoLm5vZGUubmFtZSk7XG4gICAgaWYgKCFiaW5kaW5nKSByZXR1cm47XG5cbiAgICBpZiAoYmluZGluZyAhPT0gc3RhdGUuc2NvcGUuZ2V0QmluZGluZyhwYXRoLm5vZGUubmFtZSkpIHJldHVybjtcblxuICAgIHN0YXRlLmJpbmRpbmdzW3BhdGgubm9kZS5uYW1lXSA9IGJpbmRpbmc7XG4gIH1cbn07XG5cbnZhciBQYXRoSG9pc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGF0aEhvaXN0ZXIocGF0aCwgc2NvcGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBQYXRoSG9pc3Rlcik7XG5cbiAgICB0aGlzLmJyZWFrT25TY29wZVBhdGhzID0gW107XG5cbiAgICB0aGlzLmJpbmRpbmdzID0ge307XG5cbiAgICB0aGlzLnNjb3BlcyA9IFtdO1xuXG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG5cbiAgICB0aGlzLmF0dGFjaEFmdGVyID0gZmFsc2U7XG4gIH1cblxuICBQYXRoSG9pc3Rlci5wcm90b3R5cGUuaXNDb21wYXRpYmxlU2NvcGUgPSBmdW5jdGlvbiBpc0NvbXBhdGlibGVTY29wZShzY29wZSkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmJpbmRpbmdzKSB7XG4gICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3Nba2V5XTtcbiAgICAgIGlmICghc2NvcGUuYmluZGluZ0lkZW50aWZpZXJFcXVhbHMoa2V5LCBiaW5kaW5nLmlkZW50aWZpZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBQYXRoSG9pc3Rlci5wcm90b3R5cGUuZ2V0Q29tcGF0aWJsZVNjb3BlcyA9IGZ1bmN0aW9uIGdldENvbXBhdGlibGVTY29wZXMoKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5wYXRoLnNjb3BlO1xuICAgIGRvIHtcbiAgICAgIGlmICh0aGlzLmlzQ29tcGF0aWJsZVNjb3BlKHNjb3BlKSkge1xuICAgICAgICB0aGlzLnNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5icmVha09uU2NvcGVQYXRocy5pbmRleE9mKHNjb3BlLnBhdGgpID49IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoc2NvcGUgPSBzY29wZS5wYXJlbnQpO1xuICB9O1xuXG4gIFBhdGhIb2lzdGVyLnByb3RvdHlwZS5nZXRBdHRhY2htZW50UGF0aCA9IGZ1bmN0aW9uIGdldEF0dGFjaG1lbnRQYXRoKCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5fZ2V0QXR0YWNobWVudFBhdGgoKTtcbiAgICBpZiAoIXBhdGgpIHJldHVybjtcblxuICAgIHZhciB0YXJnZXRTY29wZSA9IHBhdGguc2NvcGU7XG5cbiAgICBpZiAodGFyZ2V0U2NvcGUucGF0aCA9PT0gcGF0aCkge1xuICAgICAgdGFyZ2V0U2NvcGUgPSBwYXRoLnNjb3BlLnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0U2NvcGUucGF0aC5pc1Byb2dyYW0oKSB8fCB0YXJnZXRTY29wZS5wYXRoLmlzRnVuY3Rpb24oKSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmJpbmRpbmdzKSB7XG4gICAgICAgIGlmICghdGFyZ2V0U2NvcGUuaGFzT3duQmluZGluZyhuYW1lKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW25hbWVdO1xuXG4gICAgICAgIGlmIChiaW5kaW5nLmtpbmQgPT09IFwicGFyYW1cIikgY29udGludWU7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0QXR0YWNobWVudFBhcmVudEZvclBhdGgoYmluZGluZy5wYXRoKS5rZXkgPiBwYXRoLmtleSkge1xuICAgICAgICAgIHRoaXMuYXR0YWNoQWZ0ZXIgPSB0cnVlO1xuICAgICAgICAgIHBhdGggPSBiaW5kaW5nLnBhdGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBiaW5kaW5nLmNvbnN0YW50VmlvbGF0aW9ucywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcbiAgICAgICAgICAgIHZhciBfcmVmO1xuXG4gICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZpb2xhdGlvblBhdGggPSBfcmVmO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRhY2htZW50UGFyZW50Rm9yUGF0aCh2aW9sYXRpb25QYXRoKS5rZXkgPiBwYXRoLmtleSkge1xuICAgICAgICAgICAgICBwYXRoID0gdmlvbGF0aW9uUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5wYXJlbnRQYXRoLmlzRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBQYXRoSG9pc3Rlci5wcm90b3R5cGUuX2dldEF0dGFjaG1lbnRQYXRoID0gZnVuY3Rpb24gX2dldEF0dGFjaG1lbnRQYXRoKCkge1xuICAgIHZhciBzY29wZXMgPSB0aGlzLnNjb3BlcztcblxuICAgIHZhciBzY29wZSA9IHNjb3Blcy5wb3AoKTtcblxuICAgIGlmICghc2NvcGUpIHJldHVybjtcblxuICAgIGlmIChzY29wZS5wYXRoLmlzRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKHRoaXMuaGFzT3duUGFyYW1CaW5kaW5ncyhzY29wZSkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgPT09IHNjb3BlKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlLnBhdGguZ2V0KFwiYm9keVwiKS5nZXQoXCJib2R5XCIpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dFNjb3BlQXR0YWNobWVudFBhcmVudCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUucGF0aC5pc1Byb2dyYW0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dFNjb3BlQXR0YWNobWVudFBhcmVudCgpO1xuICAgIH1cbiAgfTtcblxuICBQYXRoSG9pc3Rlci5wcm90b3R5cGUuZ2V0TmV4dFNjb3BlQXR0YWNobWVudFBhcmVudCA9IGZ1bmN0aW9uIGdldE5leHRTY29wZUF0dGFjaG1lbnRQYXJlbnQoKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZXMucG9wKCk7XG4gICAgaWYgKHNjb3BlKSByZXR1cm4gdGhpcy5nZXRBdHRhY2htZW50UGFyZW50Rm9yUGF0aChzY29wZS5wYXRoKTtcbiAgfTtcblxuICBQYXRoSG9pc3Rlci5wcm90b3R5cGUuZ2V0QXR0YWNobWVudFBhcmVudEZvclBhdGggPSBmdW5jdGlvbiBnZXRBdHRhY2htZW50UGFyZW50Rm9yUGF0aChwYXRoKSB7XG4gICAgZG8ge1xuICAgICAgaWYgKCFwYXRoLnBhcmVudFBhdGggfHwgQXJyYXkuaXNBcnJheShwYXRoLmNvbnRhaW5lcikgJiYgcGF0aC5pc1N0YXRlbWVudCgpIHx8IHBhdGguaXNWYXJpYWJsZURlY2xhcmF0b3IoKSAmJiBwYXRoLnBhcmVudFBhdGgubm9kZSAhPT0gbnVsbCAmJiBwYXRoLnBhcmVudFBhdGgubm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoID4gMSkgcmV0dXJuIHBhdGg7XG4gICAgfSB3aGlsZSAocGF0aCA9IHBhdGgucGFyZW50UGF0aCk7XG4gIH07XG5cbiAgUGF0aEhvaXN0ZXIucHJvdG90eXBlLmhhc093blBhcmFtQmluZGluZ3MgPSBmdW5jdGlvbiBoYXNPd25QYXJhbUJpbmRpbmdzKHNjb3BlKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmJpbmRpbmdzKSB7XG4gICAgICBpZiAoIXNjb3BlLmhhc093bkJpbmRpbmcobmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbbmFtZV07XG5cbiAgICAgIGlmIChiaW5kaW5nLmtpbmQgPT09IFwicGFyYW1cIiAmJiBiaW5kaW5nLmNvbnN0YW50KSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFBhdGhIb2lzdGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhdGgubm9kZTtcbiAgICBpZiAobm9kZS5faG9pc3RlZCkgcmV0dXJuO1xuICAgIG5vZGUuX2hvaXN0ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5wYXRoLnRyYXZlcnNlKHJlZmVyZW5jZVZpc2l0b3IsIHRoaXMpO1xuXG4gICAgdGhpcy5nZXRDb21wYXRpYmxlU2NvcGVzKCk7XG5cbiAgICB2YXIgYXR0YWNoVG8gPSB0aGlzLmdldEF0dGFjaG1lbnRQYXRoKCk7XG4gICAgaWYgKCFhdHRhY2hUbykgcmV0dXJuO1xuXG4gICAgaWYgKGF0dGFjaFRvLmdldEZ1bmN0aW9uUGFyZW50KCkgPT09IHRoaXMucGF0aC5nZXRGdW5jdGlvblBhcmVudCgpKSByZXR1cm47XG5cbiAgICB2YXIgdWlkID0gYXR0YWNoVG8uc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwicmVmXCIpO1xuICAgIHZhciBkZWNsYXJhdG9yID0gdC52YXJpYWJsZURlY2xhcmF0b3IodWlkLCB0aGlzLnBhdGgubm9kZSk7XG5cbiAgICB2YXIgaW5zZXJ0Rm4gPSB0aGlzLmF0dGFjaEFmdGVyID8gXCJpbnNlcnRBZnRlclwiIDogXCJpbnNlcnRCZWZvcmVcIjtcbiAgICBhdHRhY2hUb1tpbnNlcnRGbl0oW2F0dGFjaFRvLmlzVmFyaWFibGVEZWNsYXJhdG9yKCkgPyBkZWNsYXJhdG9yIDogdC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtkZWNsYXJhdG9yXSldKTtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhdGgucGFyZW50UGF0aDtcbiAgICBpZiAocGFyZW50LmlzSlNYRWxlbWVudCgpICYmIHRoaXMucGF0aC5jb250YWluZXIgPT09IHBhcmVudC5ub2RlLmNoaWxkcmVuKSB7XG4gICAgICB1aWQgPSB0LkpTWEV4cHJlc3Npb25Db250YWluZXIodWlkKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhdGgucmVwbGFjZVdpdGgodWlkKTtcbiAgfTtcblxuICByZXR1cm4gUGF0aEhvaXN0ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBhdGhIb2lzdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvcGF0aC9saWIvaG9pc3Rlci5qc1xuLy8gbW9kdWxlIGlkID0gMzgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5leHBvcnRzLmdldFN0YXRlbWVudFBhcmVudCA9IGdldFN0YXRlbWVudFBhcmVudDtcbmV4cG9ydHMuZ2V0T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZTtcbmV4cG9ydHMuZ2V0Q29tcGxldGlvblJlY29yZHMgPSBnZXRDb21wbGV0aW9uUmVjb3JkcztcbmV4cG9ydHMuZ2V0U2libGluZyA9IGdldFNpYmxpbmc7XG5leHBvcnRzLmdldFByZXZTaWJsaW5nID0gZ2V0UHJldlNpYmxpbmc7XG5leHBvcnRzLmdldE5leHRTaWJsaW5nID0gZ2V0TmV4dFNpYmxpbmc7XG5leHBvcnRzLmdldEFsbE5leHRTaWJsaW5ncyA9IGdldEFsbE5leHRTaWJsaW5ncztcbmV4cG9ydHMuZ2V0QWxsUHJldlNpYmxpbmdzID0gZ2V0QWxsUHJldlNpYmxpbmdzO1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5leHBvcnRzLl9nZXRLZXkgPSBfZ2V0S2V5O1xuZXhwb3J0cy5fZ2V0UGF0dGVybiA9IF9nZXRQYXR0ZXJuO1xuZXhwb3J0cy5nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSBnZXRCaW5kaW5nSWRlbnRpZmllcnM7XG5leHBvcnRzLmdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzID0gZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnM7XG5leHBvcnRzLmdldEJpbmRpbmdJZGVudGlmaWVyUGF0aHMgPSBnZXRCaW5kaW5nSWRlbnRpZmllclBhdGhzO1xuZXhwb3J0cy5nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyUGF0aHMgPSBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyUGF0aHM7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbnZhciBfYmFiZWxUeXBlcyA9IHJlcXVpcmUoXCJiYWJlbC10eXBlc1wiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYmFiZWxUeXBlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFN0YXRlbWVudFBhcmVudCgpIHtcbiAgdmFyIHBhdGggPSB0aGlzO1xuXG4gIGRvIHtcbiAgICBpZiAoIXBhdGgucGFyZW50UGF0aCB8fCBBcnJheS5pc0FycmF5KHBhdGguY29udGFpbmVyKSAmJiBwYXRoLmlzU3RhdGVtZW50KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICAgIH1cbiAgfSB3aGlsZSAocGF0aCk7XG5cbiAgaWYgKHBhdGggJiYgKHBhdGguaXNQcm9ncmFtKCkgfHwgcGF0aC5pc0ZpbGUoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlL1Byb2dyYW0gbm9kZSwgd2UgY2FuJ3QgcG9zc2libHkgZmluZCBhIHN0YXRlbWVudCBwYXJlbnQgdG8gdGhpc1wiKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZSgpIHtcbiAgaWYgKHRoaXMua2V5ID09PSBcImxlZnRcIikge1xuICAgIHJldHVybiB0aGlzLmdldFNpYmxpbmcoXCJyaWdodFwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLmtleSA9PT0gXCJyaWdodFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2libGluZyhcImxlZnRcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29tcGxldGlvblJlY29yZHMoKSB7XG4gIHZhciBwYXRocyA9IFtdO1xuXG4gIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQocGF0aCkge1xuICAgIGlmIChwYXRoKSBwYXRocyA9IHBhdGhzLmNvbmNhdChwYXRoLmdldENvbXBsZXRpb25SZWNvcmRzKCkpO1xuICB9O1xuXG4gIGlmICh0aGlzLmlzSWZTdGF0ZW1lbnQoKSkge1xuICAgIGFkZCh0aGlzLmdldChcImNvbnNlcXVlbnRcIikpO1xuICAgIGFkZCh0aGlzLmdldChcImFsdGVybmF0ZVwiKSk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc0RvRXhwcmVzc2lvbigpIHx8IHRoaXMuaXNGb3IoKSB8fCB0aGlzLmlzV2hpbGUoKSkge1xuICAgIGFkZCh0aGlzLmdldChcImJvZHlcIikpO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNQcm9ncmFtKCkgfHwgdGhpcy5pc0Jsb2NrU3RhdGVtZW50KCkpIHtcbiAgICBhZGQodGhpcy5nZXQoXCJib2R5XCIpLnBvcCgpKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzRnVuY3Rpb24oKSkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJvZHlcIikuZ2V0Q29tcGxldGlvblJlY29yZHMoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzVHJ5U3RhdGVtZW50KCkpIHtcbiAgICBhZGQodGhpcy5nZXQoXCJibG9ja1wiKSk7XG4gICAgYWRkKHRoaXMuZ2V0KFwiaGFuZGxlclwiKSk7XG4gICAgYWRkKHRoaXMuZ2V0KFwiZmluYWxpemVyXCIpKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRocy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG5mdW5jdGlvbiBnZXRTaWJsaW5nKGtleSkge1xuICByZXR1cm4gX2luZGV4Mi5kZWZhdWx0LmdldCh7XG4gICAgcGFyZW50UGF0aDogdGhpcy5wYXJlbnRQYXRoLFxuICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICBsaXN0S2V5OiB0aGlzLmxpc3RLZXksXG4gICAga2V5OiBrZXlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFByZXZTaWJsaW5nKCkge1xuICByZXR1cm4gdGhpcy5nZXRTaWJsaW5nKHRoaXMua2V5IC0gMSk7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKCkge1xuICByZXR1cm4gdGhpcy5nZXRTaWJsaW5nKHRoaXMua2V5ICsgMSk7XG59XG5cbmZ1bmN0aW9uIGdldEFsbE5leHRTaWJsaW5ncygpIHtcbiAgdmFyIF9rZXkgPSB0aGlzLmtleTtcbiAgdmFyIHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmcoKytfa2V5KTtcbiAgdmFyIHNpYmxpbmdzID0gW107XG4gIHdoaWxlIChzaWJsaW5nLm5vZGUpIHtcbiAgICBzaWJsaW5ncy5wdXNoKHNpYmxpbmcpO1xuICAgIHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmcoKytfa2V5KTtcbiAgfVxuICByZXR1cm4gc2libGluZ3M7XG59XG5cbmZ1bmN0aW9uIGdldEFsbFByZXZTaWJsaW5ncygpIHtcbiAgdmFyIF9rZXkgPSB0aGlzLmtleTtcbiAgdmFyIHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmcoLS1fa2V5KTtcbiAgdmFyIHNpYmxpbmdzID0gW107XG4gIHdoaWxlIChzaWJsaW5nLm5vZGUpIHtcbiAgICBzaWJsaW5ncy5wdXNoKHNpYmxpbmcpO1xuICAgIHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmcoLS1fa2V5KTtcbiAgfVxuICByZXR1cm4gc2libGluZ3M7XG59XG5cbmZ1bmN0aW9uIGdldChrZXksIGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQgPT09IHRydWUpIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gIHZhciBwYXJ0cyA9IGtleS5zcGxpdChcIi5cIik7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0S2V5KGtleSwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhdHRlcm4ocGFydHMsIGNvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXkoa2V5LCBjb250ZXh0KSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gIHZhciBjb250YWluZXIgPSBub2RlW2tleV07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY29udGFpbmVyKSkge1xuICAgIHJldHVybiBjb250YWluZXIubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICByZXR1cm4gX2luZGV4Mi5kZWZhdWx0LmdldCh7XG4gICAgICAgIGxpc3RLZXk6IGtleSxcbiAgICAgICAgcGFyZW50UGF0aDogX3RoaXMsXG4gICAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGtleTogaVxuICAgICAgfSkuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gX2luZGV4Mi5kZWZhdWx0LmdldCh7XG4gICAgICBwYXJlbnRQYXRoOiB0aGlzLFxuICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgY29udGFpbmVyOiBub2RlLFxuICAgICAga2V5OiBrZXlcbiAgICB9KS5zZXRDb250ZXh0KGNvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQYXR0ZXJuKHBhcnRzLCBjb250ZXh0KSB7XG4gIHZhciBwYXRoID0gdGhpcztcbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcGFydHMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgcGFydCA9IF9yZWY7XG5cbiAgICBpZiAocGFydCA9PT0gXCIuXCIpIHtcbiAgICAgIHBhdGggPSBwYXRoLnBhcmVudFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIHBhdGggPSBwYXRoW3BhcnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IHBhdGguZ2V0KHBhcnQsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0lkZW50aWZpZXJzKGR1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuIHQuZ2V0QmluZGluZ0lkZW50aWZpZXJzKHRoaXMubm9kZSwgZHVwbGljYXRlcyk7XG59XG5cbmZ1bmN0aW9uIGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzKGR1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuIHQuZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnModGhpcy5ub2RlLCBkdXBsaWNhdGVzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0lkZW50aWZpZXJQYXRocygpIHtcbiAgdmFyIGR1cGxpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICB2YXIgb3V0ZXJPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgcGF0aCA9IHRoaXM7XG4gIHZhciBzZWFyY2ggPSBbXS5jb25jYXQocGF0aCk7XG4gIHZhciBpZHMgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkobnVsbCk7XG5cbiAgd2hpbGUgKHNlYXJjaC5sZW5ndGgpIHtcbiAgICB2YXIgaWQgPSBzZWFyY2guc2hpZnQoKTtcbiAgICBpZiAoIWlkKSBjb250aW51ZTtcbiAgICBpZiAoIWlkLm5vZGUpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtleXMgPSB0LmdldEJpbmRpbmdJZGVudGlmaWVycy5rZXlzW2lkLm5vZGUudHlwZV07XG5cbiAgICBpZiAoaWQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzKSB7XG4gICAgICAgIHZhciBfaWRzID0gaWRzW2lkLm5vZGUubmFtZV0gPSBpZHNbaWQubm9kZS5uYW1lXSB8fCBbXTtcbiAgICAgICAgX2lkcy5wdXNoKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkc1tpZC5ub2RlLm5hbWVdID0gaWQ7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaWQuaXNFeHBvcnREZWNsYXJhdGlvbigpKSB7XG4gICAgICB2YXIgZGVjbGFyYXRpb24gPSBpZC5nZXQoXCJkZWNsYXJhdGlvblwiKTtcbiAgICAgIGlmIChkZWNsYXJhdGlvbi5pc0RlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgc2VhcmNoLnB1c2goZGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG91dGVyT25seSkge1xuICAgICAgaWYgKGlkLmlzRnVuY3Rpb25EZWNsYXJhdGlvbigpKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmdldChcImlkXCIpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaWQuaXNGdW5jdGlvbkV4cHJlc3Npb24oKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgY2hpbGQgPSBpZC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpIHx8IGNoaWxkLm5vZGUpIHtcbiAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guY29uY2F0KGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZHM7XG59XG5cbmZ1bmN0aW9uIGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJQYXRocyhkdXBsaWNhdGVzKSB7XG4gIHJldHVybiB0aGlzLmdldEJpbmRpbmdJZGVudGlmaWVyUGF0aHMoZHVwbGljYXRlcywgdHJ1ZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2UvbGliL3BhdGgvZmFtaWx5LmpzXG4vLyBtb2R1bGUgaWQgPSAzODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNoYXJlQ29tbWVudHNXaXRoU2libGluZ3MgPSBzaGFyZUNvbW1lbnRzV2l0aFNpYmxpbmdzO1xuZXhwb3J0cy5hZGRDb21tZW50ID0gYWRkQ29tbWVudDtcbmV4cG9ydHMuYWRkQ29tbWVudHMgPSBhZGRDb21tZW50cztcbmZ1bmN0aW9uIHNoYXJlQ29tbWVudHNXaXRoU2libGluZ3MoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5rZXkgPT09IFwic3RyaW5nXCIpIHJldHVybjtcblxuICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgdmFyIHRyYWlsaW5nID0gbm9kZS50cmFpbGluZ0NvbW1lbnRzO1xuICB2YXIgbGVhZGluZyA9IG5vZGUubGVhZGluZ0NvbW1lbnRzO1xuICBpZiAoIXRyYWlsaW5nICYmICFsZWFkaW5nKSByZXR1cm47XG5cbiAgdmFyIHByZXYgPSB0aGlzLmdldFNpYmxpbmcodGhpcy5rZXkgLSAxKTtcbiAgdmFyIG5leHQgPSB0aGlzLmdldFNpYmxpbmcodGhpcy5rZXkgKyAxKTtcblxuICBpZiAoIXByZXYubm9kZSkgcHJldiA9IG5leHQ7XG4gIGlmICghbmV4dC5ub2RlKSBuZXh0ID0gcHJldjtcblxuICBwcmV2LmFkZENvbW1lbnRzKFwidHJhaWxpbmdcIiwgbGVhZGluZyk7XG4gIG5leHQuYWRkQ29tbWVudHMoXCJsZWFkaW5nXCIsIHRyYWlsaW5nKTtcbn1cblxuZnVuY3Rpb24gYWRkQ29tbWVudCh0eXBlLCBjb250ZW50LCBsaW5lKSB7XG4gIHRoaXMuYWRkQ29tbWVudHModHlwZSwgW3tcbiAgICB0eXBlOiBsaW5lID8gXCJDb21tZW50TGluZVwiIDogXCJDb21tZW50QmxvY2tcIixcbiAgICB2YWx1ZTogY29udGVudFxuICB9XSk7XG59XG5cbmZ1bmN0aW9uIGFkZENvbW1lbnRzKHR5cGUsIGNvbW1lbnRzKSB7XG4gIGlmICghY29tbWVudHMpIHJldHVybjtcblxuICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgdmFyIGtleSA9IHR5cGUgKyBcIkNvbW1lbnRzXCI7XG5cbiAgaWYgKG5vZGVba2V5XSkge1xuICAgIG5vZGVba2V5XSA9IG5vZGVba2V5XS5jb25jYXQoY29tbWVudHMpO1xuICB9IGVsc2Uge1xuICAgIG5vZGVba2V5XSA9IGNvbW1lbnRzO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2UvbGliL3BhdGgvY29tbWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDM4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9wYXRoMiA9IHJlcXVpcmUoXCIuL3BhdGhcIik7XG5cbnZhciBfcGF0aDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXRoMik7XG5cbnZhciBfYmFiZWxUeXBlcyA9IHJlcXVpcmUoXCJiYWJlbC10eXBlc1wiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYmFiZWxUeXBlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB0ZXN0aW5nID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiO1xuXG52YXIgVHJhdmVyc2FsQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhdmVyc2FsQ29udGV4dChzY29wZSwgb3B0cywgc3RhdGUsIHBhcmVudFBhdGgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBUcmF2ZXJzYWxDb250ZXh0KTtcbiAgICB0aGlzLnF1ZXVlID0gbnVsbDtcblxuICAgIHRoaXMucGFyZW50UGF0aCA9IHBhcmVudFBhdGg7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICB9XG5cbiAgVHJhdmVyc2FsQ29udGV4dC5wcm90b3R5cGUuc2hvdWxkVmlzaXQgPSBmdW5jdGlvbiBzaG91bGRWaXNpdChub2RlKSB7XG4gICAgdmFyIG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgaWYgKG9wdHMuZW50ZXIgfHwgb3B0cy5leGl0KSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChvcHRzW25vZGUudHlwZV0pIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIGtleXMgPSB0LlZJU0lUT1JfS0VZU1tub2RlLnR5cGVdO1xuICAgIGlmICgha2V5cyB8fCAha2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGtleXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXkgPSBfcmVmO1xuXG4gICAgICBpZiAobm9kZVtrZXldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgVHJhdmVyc2FsQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG5vZGUsIG9iaiwga2V5LCBsaXN0S2V5KSB7XG4gICAgcmV0dXJuIF9wYXRoMy5kZWZhdWx0LmdldCh7XG4gICAgICBwYXJlbnRQYXRoOiB0aGlzLnBhcmVudFBhdGgsXG4gICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICBjb250YWluZXI6IG9iaixcbiAgICAgIGtleToga2V5LFxuICAgICAgbGlzdEtleTogbGlzdEtleVxuICAgIH0pO1xuICB9O1xuXG4gIFRyYXZlcnNhbENvbnRleHQucHJvdG90eXBlLm1heWJlUXVldWUgPSBmdW5jdGlvbiBtYXliZVF1ZXVlKHBhdGgsIG5vdFByaW9yaXR5KSB7XG4gICAgaWYgKHRoaXMudHJhcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5maW5pdGUgY3ljbGUgZGV0ZWN0ZWRcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgIGlmIChub3RQcmlvcml0eSkge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW9yaXR5UXVldWUucHVzaChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgVHJhdmVyc2FsQ29udGV4dC5wcm90b3R5cGUudmlzaXRNdWx0aXBsZSA9IGZ1bmN0aW9uIHZpc2l0TXVsdGlwbGUoY29udGFpbmVyLCBwYXJlbnQsIGxpc3RLZXkpIHtcbiAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHF1ZXVlID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgPSAwOyBrZXkgPCBjb250YWluZXIubGVuZ3RoOyBrZXkrKykge1xuICAgICAgdmFyIG5vZGUgPSBjb250YWluZXJba2V5XTtcbiAgICAgIGlmIChub2RlICYmIHRoaXMuc2hvdWxkVmlzaXQobm9kZSkpIHtcbiAgICAgICAgcXVldWUucHVzaCh0aGlzLmNyZWF0ZShwYXJlbnQsIGNvbnRhaW5lciwga2V5LCBsaXN0S2V5KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudmlzaXRRdWV1ZShxdWV1ZSk7XG4gIH07XG5cbiAgVHJhdmVyc2FsQ29udGV4dC5wcm90b3R5cGUudmlzaXRTaW5nbGUgPSBmdW5jdGlvbiB2aXNpdFNpbmdsZShub2RlLCBrZXkpIHtcbiAgICBpZiAodGhpcy5zaG91bGRWaXNpdChub2RlW2tleV0pKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdFF1ZXVlKFt0aGlzLmNyZWF0ZShub2RlLCBub2RlLCBrZXkpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgVHJhdmVyc2FsQ29udGV4dC5wcm90b3R5cGUudmlzaXRRdWV1ZSA9IGZ1bmN0aW9uIHZpc2l0UXVldWUocXVldWUpIHtcbiAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgdGhpcy5wcmlvcml0eVF1ZXVlID0gW107XG5cbiAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgIHZhciBzdG9wID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gcXVldWUsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMik7Oykge1xuICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgIGlmIChfaTIuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IF9yZWYyO1xuXG4gICAgICBwYXRoLnJlc3luYygpO1xuXG4gICAgICBpZiAocGF0aC5jb250ZXh0cy5sZW5ndGggPT09IDAgfHwgcGF0aC5jb250ZXh0c1twYXRoLmNvbnRleHRzLmxlbmd0aCAtIDFdICE9PSB0aGlzKSB7XG4gICAgICAgIHBhdGgucHVzaENvbnRleHQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoLmtleSA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgIGlmICh0ZXN0aW5nICYmIHF1ZXVlLmxlbmd0aCA+PSAxMDAwMCkge1xuICAgICAgICB0aGlzLnRyYXAgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlzaXRlZC5pbmRleE9mKHBhdGgubm9kZSkgPj0gMCkgY29udGludWU7XG4gICAgICB2aXNpdGVkLnB1c2gocGF0aC5ub2RlKTtcblxuICAgICAgaWYgKHBhdGgudmlzaXQoKSkge1xuICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByaW9yaXR5UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHN0b3AgPSB0aGlzLnZpc2l0UXVldWUodGhpcy5wcmlvcml0eVF1ZXVlKTtcbiAgICAgICAgdGhpcy5wcmlvcml0eVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgaWYgKHN0b3ApIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBxdWV1ZSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IzKTs7KSB7XG4gICAgICB2YXIgX3JlZjM7XG5cbiAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yM1tfaTMrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTMgPSBfaXRlcmF0b3IzLm5leHQoKTtcbiAgICAgICAgaWYgKF9pMy5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcGF0aCA9IF9yZWYzO1xuXG4gICAgICBfcGF0aC5wb3BDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5xdWV1ZSA9IG51bGw7XG5cbiAgICByZXR1cm4gc3RvcDtcbiAgfTtcblxuICBUcmF2ZXJzYWxDb250ZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGtleSkge1xuICAgIHZhciBub2RlcyA9IG5vZGVba2V5XTtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0TXVsdGlwbGUobm9kZXMsIG5vZGUsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0U2luZ2xlKG5vZGUsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUcmF2ZXJzYWxDb250ZXh0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUcmF2ZXJzYWxDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLXRyYXZlcnNlQDYuMjYuMEBiYWJlbC10cmF2ZXJzZS9saWIvY29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMzg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfa2V5cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIik7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5leHBvcnRzLmV4cGxvZGUgPSBleHBsb2RlO1xuZXhwb3J0cy52ZXJpZnkgPSB2ZXJpZnk7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5cbnZhciBfdmlydHVhbFR5cGVzID0gcmVxdWlyZShcIi4vcGF0aC9saWIvdmlydHVhbC10eXBlc1wiKTtcblxudmFyIHZpcnR1YWxUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF92aXJ0dWFsVHlwZXMpO1xuXG52YXIgX2JhYmVsTWVzc2FnZXMgPSByZXF1aXJlKFwiYmFiZWwtbWVzc2FnZXNcIik7XG5cbnZhciBtZXNzYWdlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9iYWJlbE1lc3NhZ2VzKTtcblxudmFyIF9iYWJlbFR5cGVzID0gcmVxdWlyZShcImJhYmVsLXR5cGVzXCIpO1xuXG52YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9iYWJlbFR5cGVzKTtcblxudmFyIF9jbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIik7XG5cbnZhciBfY2xvbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBleHBsb2RlKHZpc2l0b3IpIHtcbiAgaWYgKHZpc2l0b3IuX2V4cGxvZGVkKSByZXR1cm4gdmlzaXRvcjtcbiAgdmlzaXRvci5fZXhwbG9kZWQgPSB0cnVlO1xuXG4gIGZvciAodmFyIG5vZGVUeXBlIGluIHZpc2l0b3IpIHtcbiAgICBpZiAoc2hvdWxkSWdub3JlS2V5KG5vZGVUeXBlKSkgY29udGludWU7XG5cbiAgICB2YXIgcGFydHMgPSBub2RlVHlwZS5zcGxpdChcInxcIik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgY29udGludWU7XG5cbiAgICB2YXIgZm5zID0gdmlzaXRvcltub2RlVHlwZV07XG4gICAgZGVsZXRlIHZpc2l0b3Jbbm9kZVR5cGVdO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcGFydHMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJ0ID0gX3JlZjtcblxuICAgICAgdmlzaXRvcltwYXJ0XSA9IGZucztcbiAgICB9XG4gIH1cblxuICB2ZXJpZnkodmlzaXRvcik7XG5cbiAgZGVsZXRlIHZpc2l0b3IuX19lc01vZHVsZTtcblxuICBlbnN1cmVFbnRyYW5jZU9iamVjdHModmlzaXRvcik7XG5cbiAgZW5zdXJlQ2FsbGJhY2tBcnJheXModmlzaXRvcik7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9ICgwLCBfa2V5czIuZGVmYXVsdCkodmlzaXRvciksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMik7Oykge1xuICAgIHZhciBfcmVmMjtcblxuICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xuICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIF9ub2RlVHlwZTMgPSBfcmVmMjtcblxuICAgIGlmIChzaG91bGRJZ25vcmVLZXkoX25vZGVUeXBlMykpIGNvbnRpbnVlO1xuXG4gICAgdmFyIHdyYXBwZXIgPSB2aXJ0dWFsVHlwZXNbX25vZGVUeXBlM107XG4gICAgaWYgKCF3cmFwcGVyKSBjb250aW51ZTtcblxuICAgIHZhciBfZm5zMiA9IHZpc2l0b3JbX25vZGVUeXBlM107XG4gICAgZm9yICh2YXIgdHlwZSBpbiBfZm5zMikge1xuICAgICAgX2ZuczJbdHlwZV0gPSB3cmFwQ2hlY2sod3JhcHBlciwgX2ZuczJbdHlwZV0pO1xuICAgIH1cblxuICAgIGRlbGV0ZSB2aXNpdG9yW19ub2RlVHlwZTNdO1xuXG4gICAgaWYgKHdyYXBwZXIudHlwZXMpIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSB3cmFwcGVyLnR5cGVzLCBfaXNBcnJheTQgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjQpLCBfaTQgPSAwLCBfaXRlcmF0b3I0ID0gX2lzQXJyYXk0ID8gX2l0ZXJhdG9yNCA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcjQpOzspIHtcbiAgICAgICAgdmFyIF9yZWY0O1xuXG4gICAgICAgIGlmIChfaXNBcnJheTQpIHtcbiAgICAgICAgICBpZiAoX2k0ID49IF9pdGVyYXRvcjQubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmNCA9IF9pdGVyYXRvcjRbX2k0KytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pNCA9IF9pdGVyYXRvcjQubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTQuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjQgPSBfaTQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3R5cGUgPSBfcmVmNDtcblxuICAgICAgICBpZiAodmlzaXRvcltfdHlwZV0pIHtcbiAgICAgICAgICBtZXJnZVBhaXIodmlzaXRvcltfdHlwZV0sIF9mbnMyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aXNpdG9yW190eXBlXSA9IF9mbnMyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlUGFpcih2aXNpdG9yLCBfZm5zMik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX25vZGVUeXBlIGluIHZpc2l0b3IpIHtcbiAgICBpZiAoc2hvdWxkSWdub3JlS2V5KF9ub2RlVHlwZSkpIGNvbnRpbnVlO1xuXG4gICAgdmFyIF9mbnMgPSB2aXNpdG9yW19ub2RlVHlwZV07XG5cbiAgICB2YXIgYWxpYXNlcyA9IHQuRkxJUFBFRF9BTElBU19LRVlTW19ub2RlVHlwZV07XG5cbiAgICB2YXIgZGVwcmVjcmF0ZWRLZXkgPSB0LkRFUFJFQ0FURURfS0VZU1tfbm9kZVR5cGVdO1xuICAgIGlmIChkZXByZWNyYXRlZEtleSkge1xuICAgICAgY29uc29sZS50cmFjZShcIlZpc2l0b3IgZGVmaW5lZCBmb3IgXCIgKyBfbm9kZVR5cGUgKyBcIiBidXQgaXQgaGFzIGJlZW4gcmVuYW1lZCB0byBcIiArIGRlcHJlY3JhdGVkS2V5KTtcbiAgICAgIGFsaWFzZXMgPSBbZGVwcmVjcmF0ZWRLZXldO1xuICAgIH1cblxuICAgIGlmICghYWxpYXNlcykgY29udGludWU7XG5cbiAgICBkZWxldGUgdmlzaXRvcltfbm9kZVR5cGVdO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGFsaWFzZXMsIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yMyk7Oykge1xuICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XG4gICAgICAgIGlmIChfaTMuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxpYXMgPSBfcmVmMztcblxuICAgICAgdmFyIGV4aXN0aW5nID0gdmlzaXRvclthbGlhc107XG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgbWVyZ2VQYWlyKGV4aXN0aW5nLCBfZm5zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpc2l0b3JbYWxpYXNdID0gKDAsIF9jbG9uZTIuZGVmYXVsdCkoX2Zucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX25vZGVUeXBlMiBpbiB2aXNpdG9yKSB7XG4gICAgaWYgKHNob3VsZElnbm9yZUtleShfbm9kZVR5cGUyKSkgY29udGludWU7XG5cbiAgICBlbnN1cmVDYWxsYmFja0FycmF5cyh2aXNpdG9yW19ub2RlVHlwZTJdKTtcbiAgfVxuXG4gIHJldHVybiB2aXNpdG9yO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnkodmlzaXRvcikge1xuICBpZiAodmlzaXRvci5fdmVyaWZpZWQpIHJldHVybjtcblxuICBpZiAodHlwZW9mIHZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5nZXQoXCJ0cmF2ZXJzZVZlcmlmeVJvb3RGdW5jdGlvblwiKSk7XG4gIH1cblxuICBmb3IgKHZhciBub2RlVHlwZSBpbiB2aXNpdG9yKSB7XG4gICAgaWYgKG5vZGVUeXBlID09PSBcImVudGVyXCIgfHwgbm9kZVR5cGUgPT09IFwiZXhpdFwiKSB7XG4gICAgICB2YWxpZGF0ZVZpc2l0b3JNZXRob2RzKG5vZGVUeXBlLCB2aXNpdG9yW25vZGVUeXBlXSk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZElnbm9yZUtleShub2RlVHlwZSkpIGNvbnRpbnVlO1xuXG4gICAgaWYgKHQuVFlQRVMuaW5kZXhPZihub2RlVHlwZSkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuZ2V0KFwidHJhdmVyc2VWZXJpZnlOb2RlVHlwZVwiLCBub2RlVHlwZSkpO1xuICAgIH1cblxuICAgIHZhciB2aXNpdG9ycyA9IHZpc2l0b3Jbbm9kZVR5cGVdO1xuICAgIGlmICgodHlwZW9mIHZpc2l0b3JzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KSh2aXNpdG9ycykpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKHZhciB2aXNpdG9yS2V5IGluIHZpc2l0b3JzKSB7XG4gICAgICAgIGlmICh2aXNpdG9yS2V5ID09PSBcImVudGVyXCIgfHwgdmlzaXRvcktleSA9PT0gXCJleGl0XCIpIHtcbiAgICAgICAgICB2YWxpZGF0ZVZpc2l0b3JNZXRob2RzKG5vZGVUeXBlICsgXCIuXCIgKyB2aXNpdG9yS2V5LCB2aXNpdG9yc1t2aXNpdG9yS2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLmdldChcInRyYXZlcnNlVmVyaWZ5VmlzaXRvclByb3BlcnR5XCIsIG5vZGVUeXBlLCB2aXNpdG9yS2V5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2aXNpdG9yLl92ZXJpZmllZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVmlzaXRvck1ldGhvZHMocGF0aCwgdmFsKSB7XG4gIHZhciBmbnMgPSBbXS5jb25jYXQodmFsKTtcbiAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGZucywgX2lzQXJyYXk1ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I1KSwgX2k1ID0gMCwgX2l0ZXJhdG9yNSA9IF9pc0FycmF5NSA/IF9pdGVyYXRvcjUgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3I1KTs7KSB7XG4gICAgdmFyIF9yZWY1O1xuXG4gICAgaWYgKF9pc0FycmF5NSkge1xuICAgICAgaWYgKF9pNSA+PSBfaXRlcmF0b3I1Lmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmNSA9IF9pdGVyYXRvcjVbX2k1KytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaTUgPSBfaXRlcmF0b3I1Lm5leHQoKTtcbiAgICAgIGlmIChfaTUuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmNSA9IF9pNS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZm4gPSBfcmVmNTtcblxuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vbi1mdW5jdGlvbiBmb3VuZCBkZWZpbmVkIGluIFwiICsgcGF0aCArIFwiIHdpdGggdHlwZSBcIiArICh0eXBlb2YgZm4gPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGZuKSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZSh2aXNpdG9ycykge1xuICB2YXIgc3RhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgdmFyIHdyYXBwZXIgPSBhcmd1bWVudHNbMl07XG5cbiAgdmFyIHJvb3RWaXNpdG9yID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2aXNpdG9yID0gdmlzaXRvcnNbaV07XG4gICAgdmFyIHN0YXRlID0gc3RhdGVzW2ldO1xuXG4gICAgZXhwbG9kZSh2aXNpdG9yKTtcblxuICAgIGZvciAodmFyIHR5cGUgaW4gdmlzaXRvcikge1xuICAgICAgdmFyIHZpc2l0b3JUeXBlID0gdmlzaXRvclt0eXBlXTtcblxuICAgICAgaWYgKHN0YXRlIHx8IHdyYXBwZXIpIHtcbiAgICAgICAgdmlzaXRvclR5cGUgPSB3cmFwV2l0aFN0YXRlT3JXcmFwcGVyKHZpc2l0b3JUeXBlLCBzdGF0ZSwgd3JhcHBlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlVmlzaXRvciA9IHJvb3RWaXNpdG9yW3R5cGVdID0gcm9vdFZpc2l0b3JbdHlwZV0gfHwge307XG4gICAgICBtZXJnZVBhaXIobm9kZVZpc2l0b3IsIHZpc2l0b3JUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdFZpc2l0b3I7XG59XG5cbmZ1bmN0aW9uIHdyYXBXaXRoU3RhdGVPcldyYXBwZXIob2xkVmlzaXRvciwgc3RhdGUsIHdyYXBwZXIpIHtcbiAgdmFyIG5ld1Zpc2l0b3IgPSB7fTtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChrZXkpIHtcbiAgICB2YXIgZm5zID0gb2xkVmlzaXRvcltrZXldO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZucykpIHJldHVybiBcImNvbnRpbnVlXCI7XG5cbiAgICBmbnMgPSBmbnMubWFwKGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIG5ld0ZuID0gZm47XG5cbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBuZXdGbiA9IGZ1bmN0aW9uIG5ld0ZuKHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gZm4uY2FsbChzdGF0ZSwgcGF0aCwgc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICBuZXdGbiA9IHdyYXBwZXIoc3RhdGUua2V5LCBrZXksIG5ld0ZuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0ZuO1xuICAgIH0pO1xuXG4gICAgbmV3VmlzaXRvcltrZXldID0gZm5zO1xuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBvbGRWaXNpdG9yKSB7XG4gICAgdmFyIF9yZXQgPSBfbG9vcChrZXkpO1xuXG4gICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gIH1cblxuICByZXR1cm4gbmV3VmlzaXRvcjtcbn1cblxuZnVuY3Rpb24gZW5zdXJlRW50cmFuY2VPYmplY3RzKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKHNob3VsZElnbm9yZUtleShrZXkpKSBjb250aW51ZTtcblxuICAgIHZhciBmbnMgPSBvYmpba2V5XTtcbiAgICBpZiAodHlwZW9mIGZucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvYmpba2V5XSA9IHsgZW50ZXI6IGZucyB9O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVDYWxsYmFja0FycmF5cyhvYmopIHtcbiAgaWYgKG9iai5lbnRlciAmJiAhQXJyYXkuaXNBcnJheShvYmouZW50ZXIpKSBvYmouZW50ZXIgPSBbb2JqLmVudGVyXTtcbiAgaWYgKG9iai5leGl0ICYmICFBcnJheS5pc0FycmF5KG9iai5leGl0KSkgb2JqLmV4aXQgPSBbb2JqLmV4aXRdO1xufVxuXG5mdW5jdGlvbiB3cmFwQ2hlY2sod3JhcHBlciwgZm4pIHtcbiAgdmFyIG5ld0ZuID0gZnVuY3Rpb24gbmV3Rm4ocGF0aCkge1xuICAgIGlmICh3cmFwcGVyLmNoZWNrUGF0aChwYXRoKSkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICBuZXdGbi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4udG9TdHJpbmcoKTtcbiAgfTtcbiAgcmV0dXJuIG5ld0ZuO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVLZXkoa2V5KSB7XG4gIGlmIChrZXlbMF0gPT09IFwiX1wiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoa2V5ID09PSBcImVudGVyXCIgfHwga2V5ID09PSBcImV4aXRcIiB8fCBrZXkgPT09IFwic2hvdWxkU2tpcFwiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoa2V5ID09PSBcImJsYWNrbGlzdFwiIHx8IGtleSA9PT0gXCJub1Njb3BlXCIgfHwga2V5ID09PSBcInNraXBLZXlzXCIpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VQYWlyKGRlc3QsIHNyYykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZGVzdFtrZXldID0gW10uY29uY2F0KGRlc3Rba2V5XSB8fCBbXSwgc3JjW2tleV0pO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC10cmF2ZXJzZUA2LjI2LjBAYmFiZWwtdHJhdmVyc2UvbGliL3Zpc2l0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAzODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkNvZGVHZW5lcmF0b3IgPSB1bmRlZmluZWQ7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIik7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFzdCwgb3B0cywgY29kZSkge1xuICB2YXIgZ2VuID0gbmV3IEdlbmVyYXRvcihhc3QsIG9wdHMsIGNvZGUpO1xuICByZXR1cm4gZ2VuLmdlbmVyYXRlKCk7XG59O1xuXG52YXIgX2RldGVjdEluZGVudCA9IHJlcXVpcmUoXCJkZXRlY3QtaW5kZW50XCIpO1xuXG52YXIgX2RldGVjdEluZGVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXRlY3RJbmRlbnQpO1xuXG52YXIgX3NvdXJjZU1hcCA9IHJlcXVpcmUoXCIuL3NvdXJjZS1tYXBcIik7XG5cbnZhciBfc291cmNlTWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NvdXJjZU1hcCk7XG5cbnZhciBfYmFiZWxNZXNzYWdlcyA9IHJlcXVpcmUoXCJiYWJlbC1tZXNzYWdlc1wiKTtcblxudmFyIG1lc3NhZ2VzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsTWVzc2FnZXMpO1xuXG52YXIgX3ByaW50ZXIgPSByZXF1aXJlKFwiLi9wcmludGVyXCIpO1xuXG52YXIgX3ByaW50ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJpbnRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBHZW5lcmF0b3IgPSBmdW5jdGlvbiAoX1ByaW50ZXIpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoR2VuZXJhdG9yLCBfUHJpbnRlcik7XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKGFzdCkge1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgY29kZSA9IGFyZ3VtZW50c1syXTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBHZW5lcmF0b3IpO1xuXG4gICAgdmFyIHRva2VucyA9IGFzdC50b2tlbnMgfHwgW107XG4gICAgdmFyIGZvcm1hdCA9IG5vcm1hbGl6ZU9wdGlvbnMoY29kZSwgb3B0cywgdG9rZW5zKTtcbiAgICB2YXIgbWFwID0gb3B0cy5zb3VyY2VNYXBzID8gbmV3IF9zb3VyY2VNYXAyLmRlZmF1bHQob3B0cywgY29kZSkgOiBudWxsO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfUHJpbnRlci5jYWxsKHRoaXMsIGZvcm1hdCwgbWFwLCB0b2tlbnMpKTtcblxuICAgIF90aGlzLmFzdCA9IGFzdDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgcmV0dXJuIF9QcmludGVyLnByb3RvdHlwZS5nZW5lcmF0ZS5jYWxsKHRoaXMsIHRoaXMuYXN0KTtcbiAgfTtcblxuICByZXR1cm4gR2VuZXJhdG9yO1xufShfcHJpbnRlcjIuZGVmYXVsdCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMoY29kZSwgb3B0cywgdG9rZW5zKSB7XG4gIHZhciBzdHlsZSA9IFwiICBcIjtcbiAgaWYgKGNvZGUgJiYgdHlwZW9mIGNvZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgaW5kZW50ID0gKDAsIF9kZXRlY3RJbmRlbnQyLmRlZmF1bHQpKGNvZGUpLmluZGVudDtcbiAgICBpZiAoaW5kZW50ICYmIGluZGVudCAhPT0gXCIgXCIpIHN0eWxlID0gaW5kZW50O1xuICB9XG5cbiAgdmFyIGZvcm1hdCA9IHtcbiAgICBhdXhpbGlhcnlDb21tZW50QmVmb3JlOiBvcHRzLmF1eGlsaWFyeUNvbW1lbnRCZWZvcmUsXG4gICAgYXV4aWxpYXJ5Q29tbWVudEFmdGVyOiBvcHRzLmF1eGlsaWFyeUNvbW1lbnRBZnRlcixcbiAgICBzaG91bGRQcmludENvbW1lbnQ6IG9wdHMuc2hvdWxkUHJpbnRDb21tZW50LFxuICAgIHJldGFpbkxpbmVzOiBvcHRzLnJldGFpbkxpbmVzLFxuICAgIHJldGFpbkZ1bmN0aW9uUGFyZW5zOiBvcHRzLnJldGFpbkZ1bmN0aW9uUGFyZW5zLFxuICAgIGNvbW1lbnRzOiBvcHRzLmNvbW1lbnRzID09IG51bGwgfHwgb3B0cy5jb21tZW50cyxcbiAgICBjb21wYWN0OiBvcHRzLmNvbXBhY3QsXG4gICAgbWluaWZpZWQ6IG9wdHMubWluaWZpZWQsXG4gICAgY29uY2lzZTogb3B0cy5jb25jaXNlLFxuICAgIHF1b3Rlczogb3B0cy5xdW90ZXMgfHwgZmluZENvbW1vblN0cmluZ0RlbGltaXRlcihjb2RlLCB0b2tlbnMpLFxuICAgIGpzb25Db21wYXRpYmxlU3RyaW5nczogb3B0cy5qc29uQ29tcGF0aWJsZVN0cmluZ3MsXG4gICAgaW5kZW50OiB7XG4gICAgICBhZGp1c3RNdWx0aWxpbmVDb21tZW50OiB0cnVlLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgYmFzZTogMFxuICAgIH0sXG4gICAgZmxvd0NvbW1hU2VwYXJhdG9yOiBvcHRzLmZsb3dDb21tYVNlcGFyYXRvclxuICB9O1xuXG4gIGlmIChmb3JtYXQubWluaWZpZWQpIHtcbiAgICBmb3JtYXQuY29tcGFjdCA9IHRydWU7XG5cbiAgICBmb3JtYXQuc2hvdWxkUHJpbnRDb21tZW50ID0gZm9ybWF0LnNob3VsZFByaW50Q29tbWVudCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm9ybWF0LmNvbW1lbnRzO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZm9ybWF0LnNob3VsZFByaW50Q29tbWVudCA9IGZvcm1hdC5zaG91bGRQcmludENvbW1lbnQgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0LmNvbW1lbnRzIHx8IHZhbHVlLmluZGV4T2YoXCJAbGljZW5zZVwiKSA+PSAwIHx8IHZhbHVlLmluZGV4T2YoXCJAcHJlc2VydmVcIikgPj0gMDtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZvcm1hdC5jb21wYWN0ID09PSBcImF1dG9cIikge1xuICAgIGZvcm1hdC5jb21wYWN0ID0gY29kZS5sZW5ndGggPiA1MDAwMDA7XG5cbiAgICBpZiAoZm9ybWF0LmNvbXBhY3QpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbQkFCRUxdIFwiICsgbWVzc2FnZXMuZ2V0KFwiY29kZUdlbmVyYXRvckRlb3B0XCIsIG9wdHMuZmlsZW5hbWUsIFwiNTAwS0JcIikpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3JtYXQuY29tcGFjdCkge1xuICAgIGZvcm1hdC5pbmRlbnQuYWRqdXN0TXVsdGlsaW5lQ29tbWVudCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdDtcbn1cblxuZnVuY3Rpb24gZmluZENvbW1vblN0cmluZ0RlbGltaXRlcihjb2RlLCB0b2tlbnMpIHtcbiAgdmFyIERFRkFVTFRfU1RSSU5HX0RFTElNSVRFUiA9IFwiZG91YmxlXCI7XG4gIGlmICghY29kZSkge1xuICAgIHJldHVybiBERUZBVUxUX1NUUklOR19ERUxJTUlURVI7XG4gIH1cblxuICB2YXIgb2NjdXJyZW5jZXMgPSB7XG4gICAgc2luZ2xlOiAwLFxuICAgIGRvdWJsZTogMFxuICB9O1xuXG4gIHZhciBjaGVja2VkID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rZW4udHlwZS5sYWJlbCAhPT0gXCJzdHJpbmdcIikgY29udGludWU7XG5cbiAgICB2YXIgcmF3ID0gY29kZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICBpZiAocmF3WzBdID09PSBcIidcIikge1xuICAgICAgb2NjdXJyZW5jZXMuc2luZ2xlKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9jY3VycmVuY2VzLmRvdWJsZSsrO1xuICAgIH1cblxuICAgIGNoZWNrZWQrKztcbiAgICBpZiAoY2hlY2tlZCA+PSAzKSBicmVhaztcbiAgfVxuICBpZiAob2NjdXJyZW5jZXMuc2luZ2xlID4gb2NjdXJyZW5jZXMuZG91YmxlKSB7XG4gICAgcmV0dXJuIFwic2luZ2xlXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiZG91YmxlXCI7XG4gIH1cbn1cblxudmFyIENvZGVHZW5lcmF0b3IgPSBleHBvcnRzLkNvZGVHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvZGVHZW5lcmF0b3IoYXN0LCBvcHRzLCBjb2RlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQ29kZUdlbmVyYXRvcik7XG5cbiAgICB0aGlzLl9nZW5lcmF0b3IgPSBuZXcgR2VuZXJhdG9yKGFzdCwgb3B0cywgY29kZSk7XG4gIH1cblxuICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZW5lcmF0b3IuZ2VuZXJhdGUoKTtcbiAgfTtcblxuICByZXR1cm4gQ29kZUdlbmVyYXRvcjtcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuLy8gbW9kdWxlIGlkID0gMzg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3NldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4vLyBtb2R1bGUgaWQgPSAzODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDM4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMzkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbi8vIG1vZHVsZSBpZCA9IDM5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciByZXBlYXRpbmcgPSByZXF1aXJlKCdyZXBlYXRpbmcnKTtcblxuLy8gZGV0ZWN0IGVpdGhlciBzcGFjZXMgb3IgdGFicyBidXQgbm90IGJvdGggdG8gcHJvcGVybHkgaGFuZGxlIHRhYnNcbi8vIGZvciBpbmRlbnRhdGlvbiBhbmQgc3BhY2VzIGZvciBhbGlnbm1lbnRcbnZhciBJTkRFTlRfUkUgPSAvXig/OiggKSt8XFx0KykvO1xuXG5mdW5jdGlvbiBnZXRNb3N0VXNlZChpbmRlbnRzKSB7XG5cdHZhciByZXN1bHQgPSAwO1xuXHR2YXIgbWF4VXNlZCA9IDA7XG5cdHZhciBtYXhXZWlnaHQgPSAwO1xuXG5cdGZvciAodmFyIG4gaW4gaW5kZW50cykge1xuXHRcdHZhciBpbmRlbnQgPSBpbmRlbnRzW25dO1xuXHRcdHZhciB1ID0gaW5kZW50WzBdO1xuXHRcdHZhciB3ID0gaW5kZW50WzFdO1xuXG5cdFx0aWYgKHUgPiBtYXhVc2VkIHx8IHUgPT09IG1heFVzZWQgJiYgdyA+IG1heFdlaWdodCkge1xuXHRcdFx0bWF4VXNlZCA9IHU7XG5cdFx0XHRtYXhXZWlnaHQgPSB3O1xuXHRcdFx0cmVzdWx0ID0gTnVtYmVyKG4pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0Ly8gdXNlZCB0byBzZWUgaWYgdGFicyBvciBzcGFjZXMgYXJlIHRoZSBtb3N0IHVzZWRcblx0dmFyIHRhYnMgPSAwO1xuXHR2YXIgc3BhY2VzID0gMDtcblxuXHQvLyByZW1lbWJlciB0aGUgc2l6ZSBvZiBwcmV2aW91cyBsaW5lJ3MgaW5kZW50YXRpb25cblx0dmFyIHByZXYgPSAwO1xuXG5cdC8vIHJlbWVtYmVyIGhvdyBtYW55IGluZGVudHMvdW5pbmRlbnRzIGFzIG9jY3VycmVkIGZvciBhIGdpdmVuIHNpemVcblx0Ly8gYW5kIGhvdyBtdWNoIGxpbmVzIGZvbGxvdyBhIGdpdmVuIGluZGVudGF0aW9uXG5cdC8vXG5cdC8vIGluZGVudHMgPSB7XG5cdC8vICAgIDM6IFsxLCAwXSxcblx0Ly8gICAgNDogWzEsIDVdLFxuXHQvLyAgICA1OiBbMSwgMF0sXG5cdC8vICAgMTI6IFsxLCAwXSxcblx0Ly8gfVxuXHR2YXIgaW5kZW50cyA9IHt9O1xuXG5cdC8vIHBvaW50ZXIgdG8gdGhlIGFycmF5IG9mIGxhc3QgdXNlZCBpbmRlbnRcblx0dmFyIGN1cnJlbnQ7XG5cblx0Ly8gd2hldGhlciB0aGUgbGFzdCBhY3Rpb24gd2FzIGFuIGluZGVudCAob3Bwb3NlZCB0byBhbiB1bmluZGVudClcblx0dmFyIGlzSW5kZW50O1xuXG5cdHN0ci5zcGxpdCgvXFxuL2cpLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcblx0XHRpZiAoIWxpbmUpIHtcblx0XHRcdC8vIGlnbm9yZSBlbXB0eSBsaW5lc1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbmRlbnQ7XG5cdFx0dmFyIG1hdGNoZXMgPSBsaW5lLm1hdGNoKElOREVOVF9SRSk7XG5cblx0XHRpZiAoIW1hdGNoZXMpIHtcblx0XHRcdGluZGVudCA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluZGVudCA9IG1hdGNoZXNbMF0ubGVuZ3RoO1xuXG5cdFx0XHRpZiAobWF0Y2hlc1sxXSkge1xuXHRcdFx0XHRzcGFjZXMrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhYnMrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgZGlmZiA9IGluZGVudCAtIHByZXY7XG5cdFx0cHJldiA9IGluZGVudDtcblxuXHRcdGlmIChkaWZmKSB7XG5cdFx0XHQvLyBhbiBpbmRlbnQgb3IgdW5pbmRlbnQgaGFzIGJlZW4gZGV0ZWN0ZWRcblxuXHRcdFx0aXNJbmRlbnQgPSBkaWZmID4gMDtcblxuXHRcdFx0Y3VycmVudCA9IGluZGVudHNbaXNJbmRlbnQgPyBkaWZmIDogLWRpZmZdO1xuXG5cdFx0XHRpZiAoY3VycmVudCkge1xuXHRcdFx0XHRjdXJyZW50WzBdKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJyZW50ID0gaW5kZW50c1tkaWZmXSA9IFsxLCAwXTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGN1cnJlbnQpIHtcblx0XHRcdC8vIGlmIHRoZSBsYXN0IGFjdGlvbiB3YXMgYW4gaW5kZW50LCBpbmNyZW1lbnQgdGhlIHdlaWdodFxuXHRcdFx0Y3VycmVudFsxXSArPSBOdW1iZXIoaXNJbmRlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0dmFyIGFtb3VudCA9IGdldE1vc3RVc2VkKGluZGVudHMpO1xuXG5cdHZhciB0eXBlO1xuXHR2YXIgYWN0dWFsO1xuXHRpZiAoIWFtb3VudCkge1xuXHRcdHR5cGUgPSBudWxsO1xuXHRcdGFjdHVhbCA9ICcnO1xuXHR9IGVsc2UgaWYgKHNwYWNlcyA+PSB0YWJzKSB7XG5cdFx0dHlwZSA9ICdzcGFjZSc7XG5cdFx0YWN0dWFsID0gcmVwZWF0aW5nKCcgJywgYW1vdW50KTtcblx0fSBlbHNlIHtcblx0XHR0eXBlID0gJ3RhYic7XG5cdFx0YWN0dWFsID0gcmVwZWF0aW5nKCdcXHQnLCBhbW91bnQpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRhbW91bnQ6IGFtb3VudCxcblx0XHR0eXBlOiB0eXBlLFxuXHRcdGluZGVudDogYWN0dWFsXG5cdH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9kZXRlY3QtaW5kZW50QDQuMC4wQGRldGVjdC1pbmRlbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgaXNGaW5pdGUgPSByZXF1aXJlKCdpcy1maW5pdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBpbnB1dGAgdG8gYmUgYSBzdHJpbmcnKTtcblx0fVxuXG5cdGlmIChuIDwgMCB8fCAhaXNGaW5pdGUobikpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgY291bnRgIHRvIGJlIGEgcG9zaXRpdmUgZmluaXRlIG51bWJlcicpO1xuXHR9XG5cblx0dmFyIHJldCA9ICcnO1xuXG5cdGRvIHtcblx0XHRpZiAobiAmIDEpIHtcblx0XHRcdHJldCArPSBzdHI7XG5cdFx0fVxuXG5cdFx0c3RyICs9IHN0cjtcblx0fSB3aGlsZSAoKG4gPj49IDEpKTtcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fcmVwZWF0aW5nQDIuMC4xQHJlcGVhdGluZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBudW1iZXJJc05hbiA9IHJlcXVpcmUoJ251bWJlci1pcy1uYW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHZhbCkge1xuXHRyZXR1cm4gISh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hbih2YWwpIHx8IHZhbCA9PT0gSW5maW5pdHkgfHwgdmFsID09PSAtSW5maW5pdHkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5faXMtZmluaXRlQDEuMC4yQGlzLWZpbml0ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh4KSB7XG5cdHJldHVybiB4ICE9PSB4O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbnVtYmVyLWlzLW5hbkAxLjAuMUBudW1iZXItaXMtbmFuL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfa2V5cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIik7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9zb3VyY2VNYXAgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKTtcblxudmFyIF9zb3VyY2VNYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc291cmNlTWFwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFNvdXJjZU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU291cmNlTWFwKG9wdHMsIGNvZGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTb3VyY2VNYXApO1xuXG4gICAgdGhpcy5fY2FjaGVkTWFwID0gbnVsbDtcbiAgICB0aGlzLl9jb2RlID0gY29kZTtcbiAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICB0aGlzLl9yYXdNYXBwaW5ncyA9IFtdO1xuICB9XG5cbiAgU291cmNlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRNYXApIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9jYWNoZWRNYXAgPSBuZXcgX3NvdXJjZU1hcDIuZGVmYXVsdC5Tb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiB0aGlzLl9vcHRzLnNvdXJjZU1hcFRhcmdldCxcbiAgICAgICAgc291cmNlUm9vdDogdGhpcy5fb3B0cy5zb3VyY2VSb290XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNvZGUgPSB0aGlzLl9jb2RlO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHRoaXMuX29wdHMuc291cmNlRmlsZU5hbWUsIGNvZGUpO1xuICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGNvZGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNvZGUpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAoMCwgX2tleXMyLmRlZmF1bHQpKGNvZGUpLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGVOYW1lKSB7XG4gICAgICAgICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZU5hbWUsIGNvZGVbc291cmNlRmlsZU5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Jhd01hcHBpbmdzLmZvckVhY2gobWFwLmFkZE1hcHBpbmcsIG1hcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1hcC50b0pTT04oKTtcbiAgfTtcblxuICBTb3VyY2VNYXAucHJvdG90eXBlLmdldFJhd01hcHBpbmdzID0gZnVuY3Rpb24gZ2V0UmF3TWFwcGluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd01hcHBpbmdzLnNsaWNlKCk7XG4gIH07XG5cbiAgU291cmNlTWFwLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24gbWFyayhnZW5lcmF0ZWRMaW5lLCBnZW5lcmF0ZWRDb2x1bW4sIGxpbmUsIGNvbHVtbiwgaWRlbnRpZmllck5hbWUsIGZpbGVuYW1lKSB7XG4gICAgaWYgKHRoaXMuX2xhc3RHZW5MaW5lICE9PSBnZW5lcmF0ZWRMaW5lICYmIGxpbmUgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh0aGlzLl9sYXN0R2VuTGluZSA9PT0gZ2VuZXJhdGVkTGluZSAmJiB0aGlzLl9sYXN0U291cmNlTGluZSA9PT0gbGluZSAmJiB0aGlzLl9sYXN0U291cmNlQ29sdW1uID09PSBjb2x1bW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWNoZWRNYXAgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RHZW5MaW5lID0gZ2VuZXJhdGVkTGluZTtcbiAgICB0aGlzLl9sYXN0U291cmNlTGluZSA9IGxpbmU7XG4gICAgdGhpcy5fbGFzdFNvdXJjZUNvbHVtbiA9IGNvbHVtbjtcblxuICAgIHRoaXMuX3Jhd01hcHBpbmdzLnB1c2goe1xuICAgICAgbmFtZTogaWRlbnRpZmllck5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgIGxpbmU6IGdlbmVyYXRlZExpbmUsXG4gICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkQ29sdW1uXG4gICAgICB9LFxuICAgICAgc291cmNlOiBsaW5lID09IG51bGwgPyB1bmRlZmluZWQgOiBmaWxlbmFtZSB8fCB0aGlzLl9vcHRzLnNvdXJjZUZpbGVOYW1lLFxuICAgICAgb3JpZ2luYWw6IGxpbmUgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHtcbiAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU291cmNlTWFwO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTb3VyY2VNYXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3IvbGliL3NvdXJjZS1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDM5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fc291cmNlLW1hcEAwLjUuN0Bzb3VyY2UtbWFwL3NvdXJjZS1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDM5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9zb3VyY2UtbWFwQDAuNS43QHNvdXJjZS1tYXAvbGliL2Jhc2U2NC5qc1xuLy8gbW9kdWxlIGlkID0gMzk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fc291cmNlLW1hcEAwLjUuN0Bzb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDQwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3NvdXJjZS1tYXBAMC41LjdAc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qc1xuLy8gbW9kdWxlIGlkID0gNDAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3NvdXJjZS1tYXBAMC41LjdAc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gNDAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3NvdXJjZS1tYXBAMC41LjdAc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gNDAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSBhY2Nlc3NlZCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICB2YXIgcmVtYWluaW5nTGluZXNJbmRleCA9IDA7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSBnZXROZXh0TGluZSgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSBnZXROZXh0TGluZSgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TmV4dExpbmUoKSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoID9cbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXgrK10gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XTtcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF07XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNwbGljZShyZW1haW5pbmdMaW5lc0luZGV4KS5qb2luKFwiXCIpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlO1xuXG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYUNodW5rKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICB2YXIgY2h1bms7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gIHZhciBuZXdDaGlsZHJlbjtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICB9XG4gICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICpcbiAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgfTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgc3RyICs9IGNodW5rO1xuICB9KTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICogbWFwLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgIGNvZGU6IFwiXCIsXG4gICAgbGluZTogMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICB9KTtcblxuICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbn07XG5cbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3NvdXJjZS1tYXBAMC41LjdAc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDQwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIik7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5XCIpO1xuXG52YXIgX3N0cmluZ2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnkpO1xuXG52YXIgX3dlYWtTZXQgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3dlYWstc2V0XCIpO1xuXG52YXIgX3dlYWtTZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2Vha1NldCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2ZpbmQgPSByZXF1aXJlKFwibG9kYXNoL2ZpbmRcIik7XG5cbnZhciBfZmluZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maW5kKTtcblxudmFyIF9maW5kTGFzdCA9IHJlcXVpcmUoXCJsb2Rhc2gvZmluZExhc3RcIik7XG5cbnZhciBfZmluZExhc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmluZExhc3QpO1xuXG52YXIgX2lzSW50ZWdlciA9IHJlcXVpcmUoXCJsb2Rhc2gvaXNJbnRlZ2VyXCIpO1xuXG52YXIgX2lzSW50ZWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0ludGVnZXIpO1xuXG52YXIgX3JlcGVhdCA9IHJlcXVpcmUoXCJsb2Rhc2gvcmVwZWF0XCIpO1xuXG52YXIgX3JlcGVhdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXBlYXQpO1xuXG52YXIgX2J1ZmZlciA9IHJlcXVpcmUoXCIuL2J1ZmZlclwiKTtcblxudmFyIF9idWZmZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnVmZmVyKTtcblxudmFyIF9ub2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIG4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfbm9kZSk7XG5cbnZhciBfd2hpdGVzcGFjZSA9IHJlcXVpcmUoXCIuL3doaXRlc3BhY2VcIik7XG5cbnZhciBfd2hpdGVzcGFjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93aGl0ZXNwYWNlKTtcblxudmFyIF9iYWJlbFR5cGVzID0gcmVxdWlyZShcImJhYmVsLXR5cGVzXCIpO1xuXG52YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9iYWJlbFR5cGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFNDSUVOVElGSUNfTk9UQVRJT04gPSAvZS9pO1xudmFyIFpFUk9fREVDSU1BTF9JTlRFR0VSID0gL1xcLjArJC87XG52YXIgTk9OX0RFQ0lNQUxfTElURVJBTCA9IC9eMFtib3hdLztcblxudmFyIFByaW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByaW50ZXIoZm9ybWF0LCBtYXAsIHRva2Vucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFByaW50ZXIpO1xuICAgIHRoaXMuaW5Gb3JTdGF0ZW1lbnRJbml0Q291bnRlciA9IDA7XG4gICAgdGhpcy5fcHJpbnRTdGFjayA9IFtdO1xuICAgIHRoaXMuX2luZGVudCA9IDA7XG4gICAgdGhpcy5faW5zaWRlQXV4ID0gZmFsc2U7XG4gICAgdGhpcy5fcHJpbnRlZENvbW1lbnRTdGFydHMgPSB7fTtcbiAgICB0aGlzLl9wYXJlblB1c2hOZXdsaW5lU3RhdGUgPSBudWxsO1xuICAgIHRoaXMuX3ByaW50QXV4QWZ0ZXJPbk5leHRVc2VyTm9kZSA9IGZhbHNlO1xuICAgIHRoaXMuX3ByaW50ZWRDb21tZW50cyA9IG5ldyBfd2Vha1NldDIuZGVmYXVsdCgpO1xuICAgIHRoaXMuX2VuZHNXaXRoSW50ZWdlciA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZHNXaXRoV29yZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgfHwge307XG4gICAgdGhpcy5fYnVmID0gbmV3IF9idWZmZXIyLmRlZmF1bHQobWFwKTtcbiAgICB0aGlzLl93aGl0ZXNwYWNlID0gdG9rZW5zLmxlbmd0aCA+IDAgPyBuZXcgX3doaXRlc3BhY2UyLmRlZmF1bHQodG9rZW5zKSA6IG51bGw7XG4gIH1cblxuICBQcmludGVyLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGFzdCkge1xuICAgIHRoaXMucHJpbnQoYXN0KTtcbiAgICB0aGlzLl9tYXliZUFkZEF1eENvbW1lbnQoKTtcblxuICAgIHJldHVybiB0aGlzLl9idWYuZ2V0KCk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gaW5kZW50KCkge1xuICAgIGlmICh0aGlzLmZvcm1hdC5jb21wYWN0IHx8IHRoaXMuZm9ybWF0LmNvbmNpc2UpIHJldHVybjtcblxuICAgIHRoaXMuX2luZGVudCsrO1xuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLmRlZGVudCA9IGZ1bmN0aW9uIGRlZGVudCgpIHtcbiAgICBpZiAodGhpcy5mb3JtYXQuY29tcGFjdCB8fCB0aGlzLmZvcm1hdC5jb25jaXNlKSByZXR1cm47XG5cbiAgICB0aGlzLl9pbmRlbnQtLTtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5zZW1pY29sb24gPSBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG4gICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHRoaXMuX21heWJlQWRkQXV4Q29tbWVudCgpO1xuICAgIHRoaXMuX2FwcGVuZChcIjtcIiwgIWZvcmNlKTtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5yaWdodEJyYWNlID0gZnVuY3Rpb24gcmlnaHRCcmFjZSgpIHtcbiAgICBpZiAodGhpcy5mb3JtYXQubWluaWZpZWQpIHtcbiAgICAgIHRoaXMuX2J1Zi5yZW1vdmVMYXN0U2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHRoaXMudG9rZW4oXCJ9XCIpO1xuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLnNwYWNlID0gZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIGlmICh0aGlzLmZvcm1hdC5jb21wYWN0KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5fYnVmLmhhc0NvbnRlbnQoKSAmJiAhdGhpcy5lbmRzV2l0aChcIiBcIikgJiYgIXRoaXMuZW5kc1dpdGgoXCJcXG5cIikgfHwgZm9yY2UpIHtcbiAgICAgIHRoaXMuX3NwYWNlKCk7XG4gICAgfVxuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLndvcmQgPSBmdW5jdGlvbiB3b3JkKHN0cikge1xuICAgIGlmICh0aGlzLl9lbmRzV2l0aFdvcmQpIHRoaXMuX3NwYWNlKCk7XG5cbiAgICB0aGlzLl9tYXliZUFkZEF1eENvbW1lbnQoKTtcbiAgICB0aGlzLl9hcHBlbmQoc3RyKTtcblxuICAgIHRoaXMuX2VuZHNXaXRoV29yZCA9IHRydWU7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24gbnVtYmVyKHN0cikge1xuICAgIHRoaXMud29yZChzdHIpO1xuXG4gICAgdGhpcy5fZW5kc1dpdGhJbnRlZ2VyID0gKDAsIF9pc0ludGVnZXIyLmRlZmF1bHQpKCtzdHIpICYmICFOT05fREVDSU1BTF9MSVRFUkFMLnRlc3Qoc3RyKSAmJiAhU0NJRU5USUZJQ19OT1RBVElPTi50ZXN0KHN0cikgJiYgIVpFUk9fREVDSU1BTF9JTlRFR0VSLnRlc3Qoc3RyKSAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdICE9PSBcIi5cIjtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uIHRva2VuKHN0cikge1xuICAgIGlmIChzdHIgPT09IFwiLS1cIiAmJiB0aGlzLmVuZHNXaXRoKFwiIVwiKSB8fCBzdHJbMF0gPT09IFwiK1wiICYmIHRoaXMuZW5kc1dpdGgoXCIrXCIpIHx8IHN0clswXSA9PT0gXCItXCIgJiYgdGhpcy5lbmRzV2l0aChcIi1cIikgfHwgc3RyWzBdID09PSBcIi5cIiAmJiB0aGlzLl9lbmRzV2l0aEludGVnZXIpIHtcbiAgICAgIHRoaXMuX3NwYWNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWF5YmVBZGRBdXhDb21tZW50KCk7XG4gICAgdGhpcy5fYXBwZW5kKHN0cik7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUubmV3bGluZSA9IGZ1bmN0aW9uIG5ld2xpbmUoaSkge1xuICAgIGlmICh0aGlzLmZvcm1hdC5yZXRhaW5MaW5lcyB8fCB0aGlzLmZvcm1hdC5jb21wYWN0KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5mb3JtYXQuY29uY2lzZSkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuZHNXaXRoKFwiXFxuXFxuXCIpKSByZXR1cm47XG5cbiAgICBpZiAodHlwZW9mIGkgIT09IFwibnVtYmVyXCIpIGkgPSAxO1xuXG4gICAgaSA9IE1hdGgubWluKDIsIGkpO1xuICAgIGlmICh0aGlzLmVuZHNXaXRoKFwie1xcblwiKSB8fCB0aGlzLmVuZHNXaXRoKFwiOlxcblwiKSkgaS0tO1xuICAgIGlmIChpIDw9IDApIHJldHVybjtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICB0aGlzLl9uZXdsaW5lKCk7XG4gICAgfVxuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLmVuZHNXaXRoID0gZnVuY3Rpb24gZW5kc1dpdGgoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1Zi5lbmRzV2l0aChzdHIpO1xuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLnJlbW92ZVRyYWlsaW5nTmV3bGluZSA9IGZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nTmV3bGluZSgpIHtcbiAgICB0aGlzLl9idWYucmVtb3ZlVHJhaWxpbmdOZXdsaW5lKCk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24gc291cmNlKHByb3AsIGxvYykge1xuICAgIHRoaXMuX2NhdGNoVXAocHJvcCwgbG9jKTtcblxuICAgIHRoaXMuX2J1Zi5zb3VyY2UocHJvcCwgbG9jKTtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS53aXRoU291cmNlID0gZnVuY3Rpb24gd2l0aFNvdXJjZShwcm9wLCBsb2MsIGNiKSB7XG4gICAgdGhpcy5fY2F0Y2hVcChwcm9wLCBsb2MpO1xuXG4gICAgdGhpcy5fYnVmLndpdGhTb3VyY2UocHJvcCwgbG9jLCBjYik7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuX3NwYWNlID0gZnVuY3Rpb24gX3NwYWNlKCkge1xuICAgIHRoaXMuX2FwcGVuZChcIiBcIiwgdHJ1ZSk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuX25ld2xpbmUgPSBmdW5jdGlvbiBfbmV3bGluZSgpIHtcbiAgICB0aGlzLl9hcHBlbmQoXCJcXG5cIiwgdHJ1ZSk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuX2FwcGVuZCA9IGZ1bmN0aW9uIF9hcHBlbmQoc3RyKSB7XG4gICAgdmFyIHF1ZXVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHRoaXMuX21heWJlQWRkUGFyZW4oc3RyKTtcbiAgICB0aGlzLl9tYXliZUluZGVudChzdHIpO1xuXG4gICAgaWYgKHF1ZXVlKSB0aGlzLl9idWYucXVldWUoc3RyKTtlbHNlIHRoaXMuX2J1Zi5hcHBlbmQoc3RyKTtcblxuICAgIHRoaXMuX2VuZHNXaXRoV29yZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZHNXaXRoSW50ZWdlciA9IGZhbHNlO1xuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLl9tYXliZUluZGVudCA9IGZ1bmN0aW9uIF9tYXliZUluZGVudChzdHIpIHtcbiAgICBpZiAodGhpcy5faW5kZW50ICYmIHRoaXMuZW5kc1dpdGgoXCJcXG5cIikgJiYgc3RyWzBdICE9PSBcIlxcblwiKSB7XG4gICAgICB0aGlzLl9idWYucXVldWUodGhpcy5fZ2V0SW5kZW50KCkpO1xuICAgIH1cbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5fbWF5YmVBZGRQYXJlbiA9IGZ1bmN0aW9uIF9tYXliZUFkZFBhcmVuKHN0cikge1xuICAgIHZhciBwYXJlblB1c2hOZXdsaW5lU3RhdGUgPSB0aGlzLl9wYXJlblB1c2hOZXdsaW5lU3RhdGU7XG4gICAgaWYgKCFwYXJlblB1c2hOZXdsaW5lU3RhdGUpIHJldHVybjtcbiAgICB0aGlzLl9wYXJlblB1c2hOZXdsaW5lU3RhdGUgPSBudWxsO1xuXG4gICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGggJiYgc3RyW2ldID09PSBcIiBcIjsgaSsrKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9aWYgKGkgPT09IHN0ci5sZW5ndGgpIHJldHVybjtcblxuICAgIHZhciBjaGEgPSBzdHJbaV07XG4gICAgaWYgKGNoYSA9PT0gXCJcXG5cIiB8fCBjaGEgPT09IFwiL1wiKSB7XG4gICAgICB0aGlzLnRva2VuKFwiKFwiKTtcbiAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICBwYXJlblB1c2hOZXdsaW5lU3RhdGUucHJpbnRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLl9jYXRjaFVwID0gZnVuY3Rpb24gX2NhdGNoVXAocHJvcCwgbG9jKSB7XG4gICAgaWYgKCF0aGlzLmZvcm1hdC5yZXRhaW5MaW5lcykgcmV0dXJuO1xuXG4gICAgdmFyIHBvcyA9IGxvYyA/IGxvY1twcm9wXSA6IG51bGw7XG4gICAgaWYgKHBvcyAmJiBwb3MubGluZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGNvdW50ID0gcG9zLmxpbmUgLSB0aGlzLl9idWYuZ2V0Q3VycmVudExpbmUoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX25ld2xpbmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuX2dldEluZGVudCA9IGZ1bmN0aW9uIF9nZXRJbmRlbnQoKSB7XG4gICAgcmV0dXJuICgwLCBfcmVwZWF0Mi5kZWZhdWx0KSh0aGlzLmZvcm1hdC5pbmRlbnQuc3R5bGUsIHRoaXMuX2luZGVudCk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuc3RhcnRUZXJtaW5hdG9ybGVzcyA9IGZ1bmN0aW9uIHN0YXJ0VGVybWluYXRvcmxlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVuUHVzaE5ld2xpbmVTdGF0ZSA9IHtcbiAgICAgIHByaW50ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5lbmRUZXJtaW5hdG9ybGVzcyA9IGZ1bmN0aW9uIGVuZFRlcm1pbmF0b3JsZXNzKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnByaW50ZWQpIHtcbiAgICAgIHRoaXMuZGVkZW50KCk7XG4gICAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICAgIHRoaXMudG9rZW4oXCIpXCIpO1xuICAgIH1cbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50KG5vZGUsIHBhcmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIW5vZGUpIHJldHVybjtcblxuICAgIHZhciBvbGRDb25jaXNlID0gdGhpcy5mb3JtYXQuY29uY2lzZTtcbiAgICBpZiAobm9kZS5fY29tcGFjdCkge1xuICAgICAgdGhpcy5mb3JtYXQuY29uY2lzZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByaW50TWV0aG9kID0gdGhpc1tub2RlLnR5cGVdO1xuICAgIGlmICghcHJpbnRNZXRob2QpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInVua25vd24gbm9kZSBvZiB0eXBlIFwiICsgKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKG5vZGUudHlwZSkgKyBcIiB3aXRoIGNvbnN0cnVjdG9yIFwiICsgKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKG5vZGUgJiYgbm9kZS5jb25zdHJ1Y3Rvci5uYW1lKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbnRTdGFjay5wdXNoKG5vZGUpO1xuXG4gICAgdmFyIG9sZEluQXV4ID0gdGhpcy5faW5zaWRlQXV4O1xuICAgIHRoaXMuX2luc2lkZUF1eCA9ICFub2RlLmxvYztcbiAgICB0aGlzLl9tYXliZUFkZEF1eENvbW1lbnQodGhpcy5faW5zaWRlQXV4ICYmICFvbGRJbkF1eCk7XG5cbiAgICB2YXIgbmVlZHNQYXJlbnMgPSBuLm5lZWRzUGFyZW5zKG5vZGUsIHBhcmVudCwgdGhpcy5fcHJpbnRTdGFjayk7XG4gICAgaWYgKHRoaXMuZm9ybWF0LnJldGFpbkZ1bmN0aW9uUGFyZW5zICYmIG5vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBub2RlLmV4dHJhICYmIG5vZGUuZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgbmVlZHNQYXJlbnMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmVlZHNQYXJlbnMpIHRoaXMudG9rZW4oXCIoXCIpO1xuXG4gICAgdGhpcy5fcHJpbnRMZWFkaW5nQ29tbWVudHMobm9kZSwgcGFyZW50KTtcblxuICAgIHZhciBsb2MgPSB0LmlzUHJvZ3JhbShub2RlKSB8fCB0LmlzRmlsZShub2RlKSA/IG51bGwgOiBub2RlLmxvYztcbiAgICB0aGlzLndpdGhTb3VyY2UoXCJzdGFydFwiLCBsb2MsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzW25vZGUudHlwZV0obm9kZSwgcGFyZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3ByaW50VHJhaWxpbmdDb21tZW50cyhub2RlLCBwYXJlbnQpO1xuXG4gICAgaWYgKG5lZWRzUGFyZW5zKSB0aGlzLnRva2VuKFwiKVwiKTtcblxuICAgIHRoaXMuX3ByaW50U3RhY2sucG9wKCk7XG5cbiAgICB0aGlzLmZvcm1hdC5jb25jaXNlID0gb2xkQ29uY2lzZTtcbiAgICB0aGlzLl9pbnNpZGVBdXggPSBvbGRJbkF1eDtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5fbWF5YmVBZGRBdXhDb21tZW50ID0gZnVuY3Rpb24gX21heWJlQWRkQXV4Q29tbWVudChlbnRlcmVkUG9zaXRpb25sZXNzTm9kZSkge1xuICAgIGlmIChlbnRlcmVkUG9zaXRpb25sZXNzTm9kZSkgdGhpcy5fcHJpbnRBdXhCZWZvcmVDb21tZW50KCk7XG4gICAgaWYgKCF0aGlzLl9pbnNpZGVBdXgpIHRoaXMuX3ByaW50QXV4QWZ0ZXJDb21tZW50KCk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuX3ByaW50QXV4QmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uIF9wcmludEF1eEJlZm9yZUNvbW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuX3ByaW50QXV4QWZ0ZXJPbk5leHRVc2VyTm9kZSkgcmV0dXJuO1xuICAgIHRoaXMuX3ByaW50QXV4QWZ0ZXJPbk5leHRVc2VyTm9kZSA9IHRydWU7XG5cbiAgICB2YXIgY29tbWVudCA9IHRoaXMuZm9ybWF0LmF1eGlsaWFyeUNvbW1lbnRCZWZvcmU7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgIHRoaXMuX3ByaW50Q29tbWVudCh7XG4gICAgICAgIHR5cGU6IFwiQ29tbWVudEJsb2NrXCIsXG4gICAgICAgIHZhbHVlOiBjb21tZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuX3ByaW50QXV4QWZ0ZXJDb21tZW50ID0gZnVuY3Rpb24gX3ByaW50QXV4QWZ0ZXJDb21tZW50KCkge1xuICAgIGlmICghdGhpcy5fcHJpbnRBdXhBZnRlck9uTmV4dFVzZXJOb2RlKSByZXR1cm47XG4gICAgdGhpcy5fcHJpbnRBdXhBZnRlck9uTmV4dFVzZXJOb2RlID0gZmFsc2U7XG5cbiAgICB2YXIgY29tbWVudCA9IHRoaXMuZm9ybWF0LmF1eGlsaWFyeUNvbW1lbnRBZnRlcjtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgdGhpcy5fcHJpbnRDb21tZW50KHtcbiAgICAgICAgdHlwZTogXCJDb21tZW50QmxvY2tcIixcbiAgICAgICAgdmFsdWU6IGNvbW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5nZXRQb3NzaWJsZVJhdyA9IGZ1bmN0aW9uIGdldFBvc3NpYmxlUmF3KG5vZGUpIHtcbiAgICB2YXIgZXh0cmEgPSBub2RlLmV4dHJhO1xuICAgIGlmIChleHRyYSAmJiBleHRyYS5yYXcgIT0gbnVsbCAmJiBleHRyYS5yYXdWYWx1ZSAhPSBudWxsICYmIG5vZGUudmFsdWUgPT09IGV4dHJhLnJhd1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZXh0cmEucmF3O1xuICAgIH1cbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5wcmludEpvaW4gPSBmdW5jdGlvbiBwcmludEpvaW4obm9kZXMsIHBhcmVudCkge1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICghbm9kZXMgfHwgIW5vZGVzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgaWYgKG9wdHMuaW5kZW50KSB0aGlzLmluZGVudCgpO1xuXG4gICAgdmFyIG5ld2xpbmVPcHRzID0ge1xuICAgICAgYWRkTmV3bGluZXM6IG9wdHMuYWRkTmV3bGluZXNcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICghbm9kZSkgY29udGludWU7XG5cbiAgICAgIGlmIChvcHRzLnN0YXRlbWVudCkgdGhpcy5fcHJpbnROZXdsaW5lKHRydWUsIG5vZGUsIHBhcmVudCwgbmV3bGluZU9wdHMpO1xuXG4gICAgICB0aGlzLnByaW50KG5vZGUsIHBhcmVudCk7XG5cbiAgICAgIGlmIChvcHRzLml0ZXJhdG9yKSB7XG4gICAgICAgIG9wdHMuaXRlcmF0b3Iobm9kZSwgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLnNlcGFyYXRvciAmJiBpIDwgbm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBvcHRzLnNlcGFyYXRvci5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5zdGF0ZW1lbnQpIHRoaXMuX3ByaW50TmV3bGluZShmYWxzZSwgbm9kZSwgcGFyZW50LCBuZXdsaW5lT3B0cyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaW5kZW50KSB0aGlzLmRlZGVudCgpO1xuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLnByaW50QW5kSW5kZW50T25Db21tZW50cyA9IGZ1bmN0aW9uIHByaW50QW5kSW5kZW50T25Db21tZW50cyhub2RlLCBwYXJlbnQpIHtcbiAgICB2YXIgaW5kZW50ID0gISFub2RlLmxlYWRpbmdDb21tZW50cztcbiAgICBpZiAoaW5kZW50KSB0aGlzLmluZGVudCgpO1xuICAgIHRoaXMucHJpbnQobm9kZSwgcGFyZW50KTtcbiAgICBpZiAoaW5kZW50KSB0aGlzLmRlZGVudCgpO1xuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLnByaW50QmxvY2sgPSBmdW5jdGlvbiBwcmludEJsb2NrKHBhcmVudCkge1xuICAgIHZhciBub2RlID0gcGFyZW50LmJvZHk7XG5cbiAgICBpZiAoIXQuaXNFbXB0eVN0YXRlbWVudChub2RlKSkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cblxuICAgIHRoaXMucHJpbnQobm9kZSwgcGFyZW50KTtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5fcHJpbnRUcmFpbGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gX3ByaW50VHJhaWxpbmdDb21tZW50cyhub2RlLCBwYXJlbnQpIHtcbiAgICB0aGlzLl9wcmludENvbW1lbnRzKHRoaXMuX2dldENvbW1lbnRzKGZhbHNlLCBub2RlLCBwYXJlbnQpKTtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5fcHJpbnRMZWFkaW5nQ29tbWVudHMgPSBmdW5jdGlvbiBfcHJpbnRMZWFkaW5nQ29tbWVudHMobm9kZSwgcGFyZW50KSB7XG4gICAgdGhpcy5fcHJpbnRDb21tZW50cyh0aGlzLl9nZXRDb21tZW50cyh0cnVlLCBub2RlLCBwYXJlbnQpKTtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5wcmludElubmVyQ29tbWVudHMgPSBmdW5jdGlvbiBwcmludElubmVyQ29tbWVudHMobm9kZSkge1xuICAgIHZhciBpbmRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICBpZiAoIW5vZGUuaW5uZXJDb21tZW50cykgcmV0dXJuO1xuICAgIGlmIChpbmRlbnQpIHRoaXMuaW5kZW50KCk7XG4gICAgdGhpcy5fcHJpbnRDb21tZW50cyhub2RlLmlubmVyQ29tbWVudHMpO1xuICAgIGlmIChpbmRlbnQpIHRoaXMuZGVkZW50KCk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUucHJpbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uIHByaW50U2VxdWVuY2Uobm9kZXMsIHBhcmVudCkge1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIG9wdHMuc3RhdGVtZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5wcmludEpvaW4obm9kZXMsIHBhcmVudCwgb3B0cyk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUucHJpbnRMaXN0ID0gZnVuY3Rpb24gcHJpbnRMaXN0KGl0ZW1zLCBwYXJlbnQpIHtcbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBpZiAob3B0cy5zZXBhcmF0b3IgPT0gbnVsbCkge1xuICAgICAgb3B0cy5zZXBhcmF0b3IgPSBjb21tYVNlcGFyYXRvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcmludEpvaW4oaXRlbXMsIHBhcmVudCwgb3B0cyk7XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuX3ByaW50TmV3bGluZSA9IGZ1bmN0aW9uIF9wcmludE5ld2xpbmUobGVhZGluZywgbm9kZSwgcGFyZW50LCBvcHRzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5mb3JtYXQucmV0YWluTGluZXMgfHwgdGhpcy5mb3JtYXQuY29tcGFjdCkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuZm9ybWF0LmNvbmNpc2UpIHtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGluZXMgPSAwO1xuXG4gICAgaWYgKG5vZGUuc3RhcnQgIT0gbnVsbCAmJiAhbm9kZS5faWdub3JlVXNlcldoaXRlc3BhY2UgJiYgdGhpcy5fd2hpdGVzcGFjZSkge1xuICAgICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgICAgdmFyIF9jb21tZW50cyA9IG5vZGUubGVhZGluZ0NvbW1lbnRzO1xuICAgICAgICB2YXIgX2NvbW1lbnQgPSBfY29tbWVudHMgJiYgKDAsIF9maW5kMi5kZWZhdWx0KShfY29tbWVudHMsIGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICAgICAgcmV0dXJuICEhY29tbWVudC5sb2MgJiYgX3RoaXMyLmZvcm1hdC5zaG91bGRQcmludENvbW1lbnQoY29tbWVudC52YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxpbmVzID0gdGhpcy5fd2hpdGVzcGFjZS5nZXROZXdsaW5lc0JlZm9yZShfY29tbWVudCB8fCBub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29tbWVudHMyID0gbm9kZS50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICB2YXIgX2NvbW1lbnQyID0gX2NvbW1lbnRzMiAmJiAoMCwgX2ZpbmRMYXN0Mi5kZWZhdWx0KShfY29tbWVudHMyLCBmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgICAgIHJldHVybiAhIWNvbW1lbnQubG9jICYmIF90aGlzMi5mb3JtYXQuc2hvdWxkUHJpbnRDb21tZW50KGNvbW1lbnQudmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsaW5lcyA9IHRoaXMuX3doaXRlc3BhY2UuZ2V0TmV3bGluZXNBZnRlcihfY29tbWVudDIgfHwgbm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbGVhZGluZykgbGluZXMrKztcbiAgICAgIGlmIChvcHRzLmFkZE5ld2xpbmVzKSBsaW5lcyArPSBvcHRzLmFkZE5ld2xpbmVzKGxlYWRpbmcsIG5vZGUpIHx8IDA7XG5cbiAgICAgIHZhciBuZWVkcyA9IG4ubmVlZHNXaGl0ZXNwYWNlQWZ0ZXI7XG4gICAgICBpZiAobGVhZGluZykgbmVlZHMgPSBuLm5lZWRzV2hpdGVzcGFjZUJlZm9yZTtcbiAgICAgIGlmIChuZWVkcyhub2RlLCBwYXJlbnQpKSBsaW5lcysrO1xuXG4gICAgICBpZiAoIXRoaXMuX2J1Zi5oYXNDb250ZW50KCkpIGxpbmVzID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLm5ld2xpbmUobGluZXMpO1xuICB9O1xuXG4gIFByaW50ZXIucHJvdG90eXBlLl9nZXRDb21tZW50cyA9IGZ1bmN0aW9uIF9nZXRDb21tZW50cyhsZWFkaW5nLCBub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKGxlYWRpbmcgPyBub2RlLmxlYWRpbmdDb21tZW50cyA6IG5vZGUudHJhaWxpbmdDb21tZW50cykgfHwgW107XG4gIH07XG5cbiAgUHJpbnRlci5wcm90b3R5cGUuX3ByaW50Q29tbWVudCA9IGZ1bmN0aW9uIF9wcmludENvbW1lbnQoY29tbWVudCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLmZvcm1hdC5zaG91bGRQcmludENvbW1lbnQoY29tbWVudC52YWx1ZSkpIHJldHVybjtcblxuICAgIGlmIChjb21tZW50Lmlnbm9yZSkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuX3ByaW50ZWRDb21tZW50cy5oYXMoY29tbWVudCkpIHJldHVybjtcbiAgICB0aGlzLl9wcmludGVkQ29tbWVudHMuYWRkKGNvbW1lbnQpO1xuXG4gICAgaWYgKGNvbW1lbnQuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX3ByaW50ZWRDb21tZW50U3RhcnRzW2NvbW1lbnQuc3RhcnRdKSByZXR1cm47XG4gICAgICB0aGlzLl9wcmludGVkQ29tbWVudFN0YXJ0c1tjb21tZW50LnN0YXJ0XSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5uZXdsaW5lKHRoaXMuX3doaXRlc3BhY2UgPyB0aGlzLl93aGl0ZXNwYWNlLmdldE5ld2xpbmVzQmVmb3JlKGNvbW1lbnQpIDogMCk7XG5cbiAgICBpZiAoIXRoaXMuZW5kc1dpdGgoXCJbXCIpICYmICF0aGlzLmVuZHNXaXRoKFwie1wiKSkgdGhpcy5zcGFjZSgpO1xuXG4gICAgdmFyIHZhbCA9IGNvbW1lbnQudHlwZSA9PT0gXCJDb21tZW50TGluZVwiID8gXCIvL1wiICsgY29tbWVudC52YWx1ZSArIFwiXFxuXCIgOiBcIi8qXCIgKyBjb21tZW50LnZhbHVlICsgXCIqL1wiO1xuXG4gICAgaWYgKGNvbW1lbnQudHlwZSA9PT0gXCJDb21tZW50QmxvY2tcIiAmJiB0aGlzLmZvcm1hdC5pbmRlbnQuYWRqdXN0TXVsdGlsaW5lQ29tbWVudCkge1xuICAgICAgdmFyIG9mZnNldCA9IGNvbW1lbnQubG9jICYmIGNvbW1lbnQubG9jLnN0YXJ0LmNvbHVtbjtcbiAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIG5ld2xpbmVSZWdleCA9IG5ldyBSZWdFeHAoXCJcXFxcblxcXFxzezEsXCIgKyBvZmZzZXQgKyBcIn1cIiwgXCJnXCIpO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShuZXdsaW5lUmVnZXgsIFwiXFxuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZW50U2l6ZSA9IE1hdGgubWF4KHRoaXMuX2dldEluZGVudCgpLmxlbmd0aCwgdGhpcy5fYnVmLmdldEN1cnJlbnRDb2x1bW4oKSk7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFxuKD8hJCkvZywgXCJcXG5cIiArICgwLCBfcmVwZWF0Mi5kZWZhdWx0KShcIiBcIiwgaW5kZW50U2l6ZSkpO1xuICAgIH1cblxuICAgIHRoaXMud2l0aFNvdXJjZShcInN0YXJ0XCIsIGNvbW1lbnQubG9jLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczMuX2FwcGVuZCh2YWwpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5uZXdsaW5lKCh0aGlzLl93aGl0ZXNwYWNlID8gdGhpcy5fd2hpdGVzcGFjZS5nZXROZXdsaW5lc0FmdGVyKGNvbW1lbnQpIDogMCkgKyAoY29tbWVudC50eXBlID09PSBcIkNvbW1lbnRMaW5lXCIgPyAtMSA6IDApKTtcbiAgfTtcblxuICBQcmludGVyLnByb3RvdHlwZS5fcHJpbnRDb21tZW50cyA9IGZ1bmN0aW9uIF9wcmludENvbW1lbnRzKGNvbW1lbnRzKSB7XG4gICAgaWYgKCFjb21tZW50cyB8fCAhY29tbWVudHMubGVuZ3RoKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjb21tZW50cywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9jb21tZW50MyA9IF9yZWY7XG5cbiAgICAgIHRoaXMuX3ByaW50Q29tbWVudChfY29tbWVudDMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUHJpbnRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHJpbnRlcjtcblxuXG5mdW5jdGlvbiBjb21tYVNlcGFyYXRvcigpIHtcbiAgdGhpcy50b2tlbihcIixcIik7XG4gIHRoaXMuc3BhY2UoKTtcbn1cblxudmFyIF9hcnIgPSBbcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy90ZW1wbGF0ZS1saXRlcmFsc1wiKSwgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9leHByZXNzaW9uc1wiKSwgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9zdGF0ZW1lbnRzXCIpLCByZXF1aXJlKFwiLi9nZW5lcmF0b3JzL2NsYXNzZXNcIiksIHJlcXVpcmUoXCIuL2dlbmVyYXRvcnMvbWV0aG9kc1wiKSwgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9tb2R1bGVzXCIpLCByZXF1aXJlKFwiLi9nZW5lcmF0b3JzL3R5cGVzXCIpLCByZXF1aXJlKFwiLi9nZW5lcmF0b3JzL2Zsb3dcIiksIHJlcXVpcmUoXCIuL2dlbmVyYXRvcnMvYmFzZVwiKSwgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9qc3hcIildO1xuZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX2Fyci5sZW5ndGg7IF9pMisrKSB7XG4gIHZhciBnZW5lcmF0b3IgPSBfYXJyW19pMl07XG4gICgwLCBfYXNzaWduMi5kZWZhdWx0KShQcmludGVyLnByb3RvdHlwZSwgZ2VuZXJhdG9yKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvci9saWIvcHJpbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gNDA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2NvcmUtanNAMi41LjNAY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDQwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3dlYWstc2V0XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvd2Vhay1zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcud2Vhay1zZXQuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuV2Vha1NldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfU0VUID0gJ1dlYWtTZXQnO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX1NFVCksIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi53ZWFrLXNldC5qc1xuLy8gbW9kdWxlIGlkID0gNDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtTZXQnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY29yZS1qc0AyLjUuM0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1zZXQub2YuanNcbi8vIG1vZHVsZSBpZCA9IDQxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha1NldCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9jb3JlLWpzQDIuNS4zQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNyZWF0ZUZpbmQgPSByZXF1aXJlKCcuL19jcmVhdGVGaW5kJyksXG4gICAgZmluZEluZGV4ID0gcmVxdWlyZSgnLi9maW5kSW5kZXgnKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKi9cbnZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2ZpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDQxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlTWF0Y2hlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Jhc2VJc01hdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19hcnJheVNvbWUuanNcbi8vIG1vZHVsZSBpZCA9IDQxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19lcXVhbEJ5VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbWFwVG9BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19lcXVhbE9iamVjdHMuanNcbi8vIG1vZHVsZSBpZCA9IDQyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19nZXRNYXRjaERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDQyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gNDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9nZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX3N0cmluZ1RvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qc1xuLy8gbW9kdWxlIGlkID0gNDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9tZW1vaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvaGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDQyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlSGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDQyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2hhc1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDQzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL3Byb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDQzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanNcbi8vIG1vZHVsZSBpZCA9IDQzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRJbmRleDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvZmluZEluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNyZWF0ZUZpbmQgPSByZXF1aXJlKCcuL19jcmVhdGVGaW5kJyksXG4gICAgZmluZExhc3RJbmRleCA9IHJlcXVpcmUoJy4vZmluZExhc3RJbmRleCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICogfSk7XG4gKiAvLyA9PiAzXG4gKi9cbnZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZExhc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2ZpbmRMYXN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAqIC8vID0+IDJcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMlxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAwXG4gKi9cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcbiAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRMYXN0SW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2ZpbmRMYXN0SW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzSW50ZWdlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzSW50ZWdlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ludGVnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL2lzSW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF90cmltUmlnaHQgPSByZXF1aXJlKFwidHJpbS1yaWdodFwiKTtcblxudmFyIF90cmltUmlnaHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbVJpZ2h0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFNQQUNFU19SRSA9IC9eWyBcXHRdKyQvO1xuXG52YXIgQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXIobWFwKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQnVmZmVyKTtcbiAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgIHRoaXMuX2J1ZiA9IFtdO1xuICAgIHRoaXMuX2xhc3QgPSBcIlwiO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fcG9zaXRpb24gPSB7XG4gICAgICBsaW5lOiAxLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB0aGlzLl9zb3VyY2VQb3NpdGlvbiA9IHtcbiAgICAgIGlkZW50aWZpZXJOYW1lOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIGZpbGVuYW1lOiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIHRoaXMuX2ZsdXNoKCk7XG5cbiAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBjb2RlOiAoMCwgX3RyaW1SaWdodDIuZGVmYXVsdCkodGhpcy5fYnVmLmpvaW4oXCJcIikpLFxuICAgICAgbWFwOiBudWxsLFxuICAgICAgcmF3TWFwcGluZ3M6IG1hcCAmJiBtYXAuZ2V0UmF3TWFwcGluZ3MoKVxuICAgIH07XG5cbiAgICBpZiAobWFwKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcIm1hcFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFwID0gbWFwLmdldCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcFwiLCB7IHZhbHVlOiB2YWx1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc3RyKSB7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgICB2YXIgX3NvdXJjZVBvc2l0aW9uID0gdGhpcy5fc291cmNlUG9zaXRpb24sXG4gICAgICAgIGxpbmUgPSBfc291cmNlUG9zaXRpb24ubGluZSxcbiAgICAgICAgY29sdW1uID0gX3NvdXJjZVBvc2l0aW9uLmNvbHVtbixcbiAgICAgICAgZmlsZW5hbWUgPSBfc291cmNlUG9zaXRpb24uZmlsZW5hbWUsXG4gICAgICAgIGlkZW50aWZpZXJOYW1lID0gX3NvdXJjZVBvc2l0aW9uLmlkZW50aWZpZXJOYW1lO1xuXG4gICAgdGhpcy5fYXBwZW5kKHN0ciwgbGluZSwgY29sdW1uLCBpZGVudGlmaWVyTmFtZSwgZmlsZW5hbWUpO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbiBxdWV1ZShzdHIpIHtcbiAgICBpZiAoc3RyID09PSBcIlxcblwiKSB3aGlsZSAodGhpcy5fcXVldWUubGVuZ3RoID4gMCAmJiBTUEFDRVNfUkUudGVzdCh0aGlzLl9xdWV1ZVswXVswXSkpIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgfXZhciBfc291cmNlUG9zaXRpb24yID0gdGhpcy5fc291cmNlUG9zaXRpb24sXG4gICAgICAgIGxpbmUgPSBfc291cmNlUG9zaXRpb24yLmxpbmUsXG4gICAgICAgIGNvbHVtbiA9IF9zb3VyY2VQb3NpdGlvbjIuY29sdW1uLFxuICAgICAgICBmaWxlbmFtZSA9IF9zb3VyY2VQb3NpdGlvbjIuZmlsZW5hbWUsXG4gICAgICAgIGlkZW50aWZpZXJOYW1lID0gX3NvdXJjZVBvc2l0aW9uMi5pZGVudGlmaWVyTmFtZTtcblxuICAgIHRoaXMuX3F1ZXVlLnVuc2hpZnQoW3N0ciwgbGluZSwgY29sdW1uLCBpZGVudGlmaWVyTmFtZSwgZmlsZW5hbWVdKTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIF9mbHVzaCgpIHtcbiAgICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgICB3aGlsZSAoaXRlbSA9IHRoaXMuX3F1ZXVlLnBvcCgpKSB7XG4gICAgICB0aGlzLl9hcHBlbmQuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUuX2FwcGVuZCA9IGZ1bmN0aW9uIF9hcHBlbmQoc3RyLCBsaW5lLCBjb2x1bW4sIGlkZW50aWZpZXJOYW1lLCBmaWxlbmFtZSkge1xuICAgIGlmICh0aGlzLl9tYXAgJiYgc3RyWzBdICE9PSBcIlxcblwiKSB7XG4gICAgICB0aGlzLl9tYXAubWFyayh0aGlzLl9wb3NpdGlvbi5saW5lLCB0aGlzLl9wb3NpdGlvbi5jb2x1bW4sIGxpbmUsIGNvbHVtbiwgaWRlbnRpZmllck5hbWUsIGZpbGVuYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl9idWYucHVzaChzdHIpO1xuICAgIHRoaXMuX2xhc3QgPSBzdHJbc3RyLmxlbmd0aCAtIDFdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJbaV0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24ubGluZSsrO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbi5jb2x1bW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24uY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlVHJhaWxpbmdOZXdsaW5lID0gZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdOZXdsaW5lKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwICYmIHRoaXMuX3F1ZXVlWzBdWzBdID09PSBcIlxcblwiKSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlTGFzdFNlbWljb2xvbiA9IGZ1bmN0aW9uIHJlbW92ZUxhc3RTZW1pY29sb24oKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5fcXVldWVbMF1bMF0gPT09IFwiO1wiKSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUuZW5kc1dpdGggPSBmdW5jdGlvbiBlbmRzV2l0aChzdWZmaXgpIHtcbiAgICBpZiAoc3VmZml4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGxhc3QgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5fcXVldWVbMF1bMF07XG4gICAgICAgIGxhc3QgPSBzdHJbc3RyLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdCA9IHRoaXMuX2xhc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXN0ID09PSBzdWZmaXg7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IHRoaXMuX2xhc3QgKyB0aGlzLl9xdWV1ZS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW1bMF0gKyBhY2M7XG4gICAgfSwgXCJcIik7XG4gICAgaWYgKHN1ZmZpeC5sZW5ndGggPD0gZW5kLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGVuZC5zbGljZSgtc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5oYXNDb250ZW50ID0gZnVuY3Rpb24gaGFzQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWUubGVuZ3RoID4gMCB8fCAhIXRoaXMuX2xhc3Q7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UocHJvcCwgbG9jKSB7XG4gICAgaWYgKHByb3AgJiYgIWxvYykgcmV0dXJuO1xuXG4gICAgdmFyIHBvcyA9IGxvYyA/IGxvY1twcm9wXSA6IG51bGw7XG5cbiAgICB0aGlzLl9zb3VyY2VQb3NpdGlvbi5pZGVudGlmaWVyTmFtZSA9IGxvYyAmJiBsb2MuaWRlbnRpZmllck5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLl9zb3VyY2VQb3NpdGlvbi5saW5lID0gcG9zID8gcG9zLmxpbmUgOiBudWxsO1xuICAgIHRoaXMuX3NvdXJjZVBvc2l0aW9uLmNvbHVtbiA9IHBvcyA/IHBvcy5jb2x1bW4gOiBudWxsO1xuICAgIHRoaXMuX3NvdXJjZVBvc2l0aW9uLmZpbGVuYW1lID0gbG9jICYmIGxvYy5maWxlbmFtZSB8fCBudWxsO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud2l0aFNvdXJjZSA9IGZ1bmN0aW9uIHdpdGhTb3VyY2UocHJvcCwgbG9jLCBjYikge1xuICAgIGlmICghdGhpcy5fbWFwKSByZXR1cm4gY2IoKTtcblxuICAgIHZhciBvcmlnaW5hbExpbmUgPSB0aGlzLl9zb3VyY2VQb3NpdGlvbi5saW5lO1xuICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IHRoaXMuX3NvdXJjZVBvc2l0aW9uLmNvbHVtbjtcbiAgICB2YXIgb3JpZ2luYWxGaWxlbmFtZSA9IHRoaXMuX3NvdXJjZVBvc2l0aW9uLmZpbGVuYW1lO1xuICAgIHZhciBvcmlnaW5hbElkZW50aWZpZXJOYW1lID0gdGhpcy5fc291cmNlUG9zaXRpb24uaWRlbnRpZmllck5hbWU7XG5cbiAgICB0aGlzLnNvdXJjZShwcm9wLCBsb2MpO1xuXG4gICAgY2IoKTtcblxuICAgIHRoaXMuX3NvdXJjZVBvc2l0aW9uLmxpbmUgPSBvcmlnaW5hbExpbmU7XG4gICAgdGhpcy5fc291cmNlUG9zaXRpb24uY29sdW1uID0gb3JpZ2luYWxDb2x1bW47XG4gICAgdGhpcy5fc291cmNlUG9zaXRpb24uZmlsZW5hbWUgPSBvcmlnaW5hbEZpbGVuYW1lO1xuICAgIHRoaXMuX3NvdXJjZVBvc2l0aW9uLmlkZW50aWZpZXJOYW1lID0gb3JpZ2luYWxJZGVudGlmaWVyTmFtZTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLmdldEN1cnJlbnRDb2x1bW4gPSBmdW5jdGlvbiBnZXRDdXJyZW50Q29sdW1uKCkge1xuICAgIHZhciBleHRyYSA9IHRoaXMuX3F1ZXVlLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbVswXSArIGFjYztcbiAgICB9LCBcIlwiKTtcbiAgICB2YXIgbGFzdEluZGV4ID0gZXh0cmEubGFzdEluZGV4T2YoXCJcXG5cIik7XG5cbiAgICByZXR1cm4gbGFzdEluZGV4ID09PSAtMSA/IHRoaXMuX3Bvc2l0aW9uLmNvbHVtbiArIGV4dHJhLmxlbmd0aCA6IGV4dHJhLmxlbmd0aCAtIDEgLSBsYXN0SW5kZXg7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5nZXRDdXJyZW50TGluZSA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMaW5lKCkge1xuICAgIHZhciBleHRyYSA9IHRoaXMuX3F1ZXVlLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbVswXSArIGFjYztcbiAgICB9LCBcIlwiKTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRyYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV4dHJhW2ldID09PSBcIlxcblwiKSBjb3VudCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbi5saW5lICsgY291bnQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQnVmZmVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yL2xpYi9idWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0dmFyIHRhaWwgPSBzdHIubGVuZ3RoO1xuXG5cdHdoaWxlICgvW1xcc1xcdUZFRkZcXHUwMEEwXS8udGVzdChzdHJbdGFpbCAtIDFdKSkge1xuXHRcdHRhaWwtLTtcblx0fVxuXG5cdHJldHVybiBzdHIuc2xpY2UoMCwgdGFpbCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl90cmltLXJpZ2h0QDEuMC4xQHRyaW0tcmlnaHQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9tYXAgPSByZXF1aXJlKFwibG9kYXNoL21hcFwiKTtcblxudmFyIF9tYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwKTtcblxudmFyIF9iYWJlbFR5cGVzID0gcmVxdWlyZShcImJhYmVsLXR5cGVzXCIpO1xuXG52YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9iYWJlbFR5cGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3Jhd2wobm9kZSkge1xuICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihub2RlKSkge1xuICAgIGNyYXdsKG5vZGUub2JqZWN0LCBzdGF0ZSk7XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIGNyYXdsKG5vZGUucHJvcGVydHksIHN0YXRlKTtcbiAgfSBlbHNlIGlmICh0LmlzQmluYXJ5KG5vZGUpIHx8IHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSkge1xuICAgIGNyYXdsKG5vZGUubGVmdCwgc3RhdGUpO1xuICAgIGNyYXdsKG5vZGUucmlnaHQsIHN0YXRlKTtcbiAgfSBlbHNlIGlmICh0LmlzQ2FsbEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICBzdGF0ZS5oYXNDYWxsID0gdHJ1ZTtcbiAgICBjcmF3bChub2RlLmNhbGxlZSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHQuaXNGdW5jdGlvbihub2RlKSkge1xuICAgIHN0YXRlLmhhc0Z1bmN0aW9uID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0LmlzSWRlbnRpZmllcihub2RlKSkge1xuICAgIHN0YXRlLmhhc0hlbHBlciA9IHN0YXRlLmhhc0hlbHBlciB8fCBpc0hlbHBlcihub2RlLmNhbGxlZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGlzSGVscGVyKG5vZGUpIHtcbiAgaWYgKHQuaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGlzSGVscGVyKG5vZGUub2JqZWN0KSB8fCBpc0hlbHBlcihub2RlLnByb3BlcnR5KTtcbiAgfSBlbHNlIGlmICh0LmlzSWRlbnRpZmllcihub2RlKSkge1xuICAgIHJldHVybiBub2RlLm5hbWUgPT09IFwicmVxdWlyZVwiIHx8IG5vZGUubmFtZVswXSA9PT0gXCJfXCI7XG4gIH0gZWxzZSBpZiAodC5pc0NhbGxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGlzSGVscGVyKG5vZGUuY2FsbGVlKTtcbiAgfSBlbHNlIGlmICh0LmlzQmluYXJ5KG5vZGUpIHx8IHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiB0LmlzSWRlbnRpZmllcihub2RlLmxlZnQpICYmIGlzSGVscGVyKG5vZGUubGVmdCkgfHwgaXNIZWxwZXIobm9kZS5yaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVHlwZShub2RlKSB7XG4gIHJldHVybiB0LmlzTGl0ZXJhbChub2RlKSB8fCB0LmlzT2JqZWN0RXhwcmVzc2lvbihub2RlKSB8fCB0LmlzQXJyYXlFeHByZXNzaW9uKG5vZGUpIHx8IHQuaXNJZGVudGlmaWVyKG5vZGUpIHx8IHQuaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUpO1xufVxuXG5leHBvcnRzLm5vZGVzID0ge1xuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSkge1xuICAgIHZhciBzdGF0ZSA9IGNyYXdsKG5vZGUucmlnaHQpO1xuICAgIGlmIChzdGF0ZS5oYXNDYWxsICYmIHN0YXRlLmhhc0hlbHBlciB8fCBzdGF0ZS5oYXNGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmVmb3JlOiBzdGF0ZS5oYXNGdW5jdGlvbixcbiAgICAgICAgYWZ0ZXI6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBTd2l0Y2hDYXNlOiBmdW5jdGlvbiBTd2l0Y2hDYXNlKG5vZGUsIHBhcmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICBiZWZvcmU6IG5vZGUuY29uc2VxdWVudC5sZW5ndGggfHwgcGFyZW50LmNhc2VzWzBdID09PSBub2RlXG4gICAgfTtcbiAgfSxcbiAgTG9naWNhbEV4cHJlc3Npb246IGZ1bmN0aW9uIExvZ2ljYWxFeHByZXNzaW9uKG5vZGUpIHtcbiAgICBpZiAodC5pc0Z1bmN0aW9uKG5vZGUubGVmdCkgfHwgdC5pc0Z1bmN0aW9uKG5vZGUucmlnaHQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZnRlcjogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIExpdGVyYWw6IGZ1bmN0aW9uIExpdGVyYWwobm9kZSkge1xuICAgIGlmIChub2RlLnZhbHVlID09PSBcInVzZSBzdHJpY3RcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWZ0ZXI6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuICAgIGlmICh0LmlzRnVuY3Rpb24obm9kZS5jYWxsZWUpIHx8IGlzSGVscGVyKG5vZGUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiZWZvcmU6IHRydWUsXG4gICAgICAgIGFmdGVyOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlY2xhciA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuXG4gICAgICB2YXIgZW5hYmxlZCA9IGlzSGVscGVyKGRlY2xhci5pZCkgJiYgIWlzVHlwZShkZWNsYXIuaW5pdCk7XG4gICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gY3Jhd2woZGVjbGFyLmluaXQpO1xuICAgICAgICBlbmFibGVkID0gaXNIZWxwZXIoZGVjbGFyLmluaXQpICYmIHN0YXRlLmhhc0NhbGwgfHwgc3RhdGUuaGFzRnVuY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmVmb3JlOiB0cnVlLFxuICAgICAgICAgIGFmdGVyOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBJZlN0YXRlbWVudDogZnVuY3Rpb24gSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmICh0LmlzQmxvY2tTdGF0ZW1lbnQobm9kZS5jb25zZXF1ZW50KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmVmb3JlOiB0cnVlLFxuICAgICAgICBhZnRlcjogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMubm9kZXMuT2JqZWN0UHJvcGVydHkgPSBleHBvcnRzLm5vZGVzLk9iamVjdFR5cGVQcm9wZXJ0eSA9IGV4cG9ydHMubm9kZXMuT2JqZWN0TWV0aG9kID0gZXhwb3J0cy5ub2Rlcy5TcHJlYWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudC5wcm9wZXJ0aWVzWzBdID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJlZm9yZTogdHJ1ZVxuICAgIH07XG4gIH1cbn07XG5cbmV4cG9ydHMubGlzdCA9IHtcbiAgVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgcmV0dXJuICgwLCBfbWFwMi5kZWZhdWx0KShub2RlLmRlY2xhcmF0aW9ucywgXCJpbml0XCIpO1xuICB9LFxuICBBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uIEFycmF5RXhwcmVzc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZWxlbWVudHM7XG4gIH0sXG4gIE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIE9iamVjdEV4cHJlc3Npb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLnByb3BlcnRpZXM7XG4gIH1cbn07XG5cbltbXCJGdW5jdGlvblwiLCB0cnVlXSwgW1wiQ2xhc3NcIiwgdHJ1ZV0sIFtcIkxvb3BcIiwgdHJ1ZV0sIFtcIkxhYmVsZWRTdGF0ZW1lbnRcIiwgdHJ1ZV0sIFtcIlN3aXRjaFN0YXRlbWVudFwiLCB0cnVlXSwgW1wiVHJ5U3RhdGVtZW50XCIsIHRydWVdXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciB0eXBlID0gX3JlZlswXSxcbiAgICAgIGFtb3VudHMgPSBfcmVmWzFdO1xuXG4gIGlmICh0eXBlb2YgYW1vdW50cyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBhbW91bnRzID0geyBhZnRlcjogYW1vdW50cywgYmVmb3JlOiBhbW91bnRzIH07XG4gIH1cbiAgW3R5cGVdLmNvbmNhdCh0LkZMSVBQRURfQUxJQVNfS0VZU1t0eXBlXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydHMubm9kZXNbdHlwZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYW1vdW50cztcbiAgICB9O1xuICB9KTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3IvbGliL25vZGUvd2hpdGVzcGFjZS5qc1xuLy8gbW9kdWxlIGlkID0gNDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZU1hcCA9IHJlcXVpcmUoJy4vX2Jhc2VNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICogICByZXR1cm4gbiAqIG47XG4gKiB9XG4gKlxuICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF1cbiAqXG4gKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gKi9cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fbG9kYXNoQDQuMTcuNUBsb2Rhc2gvbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZU1hcC5qc1xuLy8gbW9kdWxlIGlkID0gNDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlRWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gNDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19iYXNlRm9yT3duLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fYmFzZUZvci5qc1xuLy8gbW9kdWxlIGlkID0gNDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xvZGFzaEA0LjE3LjVAbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9sb2Rhc2hANC4xNy41QGxvZGFzaC9fY3JlYXRlQmFzZUVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDQ0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gZXhwb3J0cy5GdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5OdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gTnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVXBkYXRlRXhwcmVzc2lvbiA9IFVwZGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBPYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5Eb0V4cHJlc3Npb24gPSBEb0V4cHJlc3Npb247XG5leHBvcnRzLkJpbmFyeSA9IEJpbmFyeTtcbmV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9IEJpbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLlNlcXVlbmNlRXhwcmVzc2lvbiA9IFNlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuWWllbGRFeHByZXNzaW9uID0gWWllbGRFeHByZXNzaW9uO1xuZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBDbGFzc0V4cHJlc3Npb247XG5leHBvcnRzLlVuYXJ5TGlrZSA9IFVuYXJ5TGlrZTtcbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5Db25kaXRpb25hbEV4cHJlc3Npb24gPSBDb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb247XG5cbnZhciBfYmFiZWxUeXBlcyA9IHJlcXVpcmUoXCJiYWJlbC10eXBlc1wiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYmFiZWxUeXBlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbnZhciBQUkVDRURFTkNFID0ge1xuICBcInx8XCI6IDAsXG4gIFwiJiZcIjogMSxcbiAgXCJ8XCI6IDIsXG4gIFwiXlwiOiAzLFxuICBcIiZcIjogNCxcbiAgXCI9PVwiOiA1LFxuICBcIj09PVwiOiA1LFxuICBcIiE9XCI6IDUsXG4gIFwiIT09XCI6IDUsXG4gIFwiPFwiOiA2LFxuICBcIj5cIjogNixcbiAgXCI8PVwiOiA2LFxuICBcIj49XCI6IDYsXG4gIGluOiA2LFxuICBpbnN0YW5jZW9mOiA2LFxuICBcIj4+XCI6IDcsXG4gIFwiPDxcIjogNyxcbiAgXCI+Pj5cIjogNyxcbiAgXCIrXCI6IDgsXG4gIFwiLVwiOiA4LFxuICBcIipcIjogOSxcbiAgXCIvXCI6IDksXG4gIFwiJVwiOiA5LFxuICBcIioqXCI6IDEwXG59O1xuXG5mdW5jdGlvbiBOdWxsYWJsZVR5cGVBbm5vdGF0aW9uKG5vZGUsIHBhcmVudCkge1xuICByZXR1cm4gdC5pc0FycmF5VHlwZUFubm90YXRpb24ocGFyZW50KTtcbn1cblxuZXhwb3J0cy5GdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gTnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbmZ1bmN0aW9uIFVwZGF0ZUV4cHJlc3Npb24obm9kZSwgcGFyZW50KSB7XG4gIHJldHVybiB0LmlzTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGU7XG59XG5cbmZ1bmN0aW9uIE9iamVjdEV4cHJlc3Npb24obm9kZSwgcGFyZW50LCBwcmludFN0YWNrKSB7XG4gIHJldHVybiBpc0ZpcnN0SW5TdGF0ZW1lbnQocHJpbnRTdGFjaywgeyBjb25zaWRlckFycm93OiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiBEb0V4cHJlc3Npb24obm9kZSwgcGFyZW50LCBwcmludFN0YWNrKSB7XG4gIHJldHVybiBpc0ZpcnN0SW5TdGF0ZW1lbnQocHJpbnRTdGFjayk7XG59XG5cbmZ1bmN0aW9uIEJpbmFyeShub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCh0LmlzQ2FsbEV4cHJlc3Npb24ocGFyZW50KSB8fCB0LmlzTmV3RXhwcmVzc2lvbihwYXJlbnQpKSAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlIHx8IHQuaXNVbmFyeUxpa2UocGFyZW50KSB8fCB0LmlzTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGUgfHwgdC5pc0F3YWl0RXhwcmVzc2lvbihwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodC5pc0JpbmFyeShwYXJlbnQpKSB7XG4gICAgdmFyIHBhcmVudE9wID0gcGFyZW50Lm9wZXJhdG9yO1xuICAgIHZhciBwYXJlbnRQb3MgPSBQUkVDRURFTkNFW3BhcmVudE9wXTtcblxuICAgIHZhciBub2RlT3AgPSBub2RlLm9wZXJhdG9yO1xuICAgIHZhciBub2RlUG9zID0gUFJFQ0VERU5DRVtub2RlT3BdO1xuXG4gICAgaWYgKHBhcmVudFBvcyA9PT0gbm9kZVBvcyAmJiBwYXJlbnQucmlnaHQgPT09IG5vZGUgJiYgIXQuaXNMb2dpY2FsRXhwcmVzc2lvbihwYXJlbnQpIHx8IHBhcmVudFBvcyA+IG5vZGVQb3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gQmluYXJ5RXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIG5vZGUub3BlcmF0b3IgPT09IFwiaW5cIiAmJiAodC5pc1ZhcmlhYmxlRGVjbGFyYXRvcihwYXJlbnQpIHx8IHQuaXNGb3IocGFyZW50KSk7XG59XG5cbmZ1bmN0aW9uIFNlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcblxuICBpZiAodC5pc0ZvclN0YXRlbWVudChwYXJlbnQpIHx8IHQuaXNUaHJvd1N0YXRlbWVudChwYXJlbnQpIHx8IHQuaXNSZXR1cm5TdGF0ZW1lbnQocGFyZW50KSB8fCB0LmlzSWZTdGF0ZW1lbnQocGFyZW50KSAmJiBwYXJlbnQudGVzdCA9PT0gbm9kZSB8fCB0LmlzV2hpbGVTdGF0ZW1lbnQocGFyZW50KSAmJiBwYXJlbnQudGVzdCA9PT0gbm9kZSB8fCB0LmlzRm9ySW5TdGF0ZW1lbnQocGFyZW50KSAmJiBwYXJlbnQucmlnaHQgPT09IG5vZGUgfHwgdC5pc1N3aXRjaFN0YXRlbWVudChwYXJlbnQpICYmIHBhcmVudC5kaXNjcmltaW5hbnQgPT09IG5vZGUgfHwgdC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQocGFyZW50KSAmJiBwYXJlbnQuZXhwcmVzc2lvbiA9PT0gbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBZaWVsZEV4cHJlc3Npb24obm9kZSwgcGFyZW50KSB7XG4gIHJldHVybiB0LmlzQmluYXJ5KHBhcmVudCkgfHwgdC5pc1VuYXJ5TGlrZShwYXJlbnQpIHx8IHQuaXNDYWxsRXhwcmVzc2lvbihwYXJlbnQpIHx8IHQuaXNNZW1iZXJFeHByZXNzaW9uKHBhcmVudCkgfHwgdC5pc05ld0V4cHJlc3Npb24ocGFyZW50KSB8fCB0LmlzQ29uZGl0aW9uYWxFeHByZXNzaW9uKHBhcmVudCkgJiYgbm9kZSA9PT0gcGFyZW50LnRlc3Q7XG59XG5cbmV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gWWllbGRFeHByZXNzaW9uO1xuZnVuY3Rpb24gQ2xhc3NFeHByZXNzaW9uKG5vZGUsIHBhcmVudCwgcHJpbnRTdGFjaykge1xuICByZXR1cm4gaXNGaXJzdEluU3RhdGVtZW50KHByaW50U3RhY2ssIHsgY29uc2lkZXJEZWZhdWx0RXhwb3J0czogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gVW5hcnlMaWtlKG5vZGUsIHBhcmVudCkge1xuICByZXR1cm4gdC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50LCB7IG9iamVjdDogbm9kZSB9KSB8fCB0LmlzQ2FsbEV4cHJlc3Npb24ocGFyZW50LCB7IGNhbGxlZTogbm9kZSB9KSB8fCB0LmlzTmV3RXhwcmVzc2lvbihwYXJlbnQsIHsgY2FsbGVlOiBub2RlIH0pO1xufVxuXG5mdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgcGFyZW50LCBwcmludFN0YWNrKSB7XG4gIHJldHVybiBpc0ZpcnN0SW5TdGF0ZW1lbnQocHJpbnRTdGFjaywgeyBjb25zaWRlckRlZmF1bHRFeHBvcnRzOiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKHQuaXNFeHBvcnREZWNsYXJhdGlvbihwYXJlbnQpIHx8IHQuaXNCaW5hcnlFeHByZXNzaW9uKHBhcmVudCkgfHwgdC5pc0xvZ2ljYWxFeHByZXNzaW9uKHBhcmVudCkgfHwgdC5pc1VuYXJ5RXhwcmVzc2lvbihwYXJlbnQpIHx8IHQuaXNUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24ocGFyZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIFVuYXJ5TGlrZShub2RlLCBwYXJlbnQpO1xufVxuXG5mdW5jdGlvbiBDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgcGFyZW50KSB7XG4gIGlmICh0LmlzVW5hcnlMaWtlKHBhcmVudCkgfHwgdC5pc0JpbmFyeShwYXJlbnQpIHx8IHQuaXNDb25kaXRpb25hbEV4cHJlc3Npb24ocGFyZW50LCB7IHRlc3Q6IG5vZGUgfSkgfHwgdC5pc0F3YWl0RXhwcmVzc2lvbihwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gVW5hcnlMaWtlKG5vZGUsIHBhcmVudCk7XG59XG5cbmZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUpIHtcbiAgaWYgKHQuaXNPYmplY3RQYXR0ZXJuKG5vZGUubGVmdCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWxFeHByZXNzaW9uLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ZpcnN0SW5TdGF0ZW1lbnQocHJpbnRTdGFjaykge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmJGNvbnNpZGVyQXJyb3cgPSBfcmVmLmNvbnNpZGVyQXJyb3csXG4gICAgICBjb25zaWRlckFycm93ID0gX3JlZiRjb25zaWRlckFycm93ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY29uc2lkZXJBcnJvdyxcbiAgICAgIF9yZWYkY29uc2lkZXJEZWZhdWx0RSA9IF9yZWYuY29uc2lkZXJEZWZhdWx0RXhwb3J0cyxcbiAgICAgIGNvbnNpZGVyRGVmYXVsdEV4cG9ydHMgPSBfcmVmJGNvbnNpZGVyRGVmYXVsdEUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjb25zaWRlckRlZmF1bHRFO1xuXG4gIHZhciBpID0gcHJpbnRTdGFjay5sZW5ndGggLSAxO1xuICB2YXIgbm9kZSA9IHByaW50U3RhY2tbaV07XG4gIGktLTtcbiAgdmFyIHBhcmVudCA9IHByaW50U3RhY2tbaV07XG4gIHdoaWxlIChpID4gMCkge1xuICAgIGlmICh0LmlzRXhwcmVzc2lvblN0YXRlbWVudChwYXJlbnQsIHsgZXhwcmVzc2lvbjogbm9kZSB9KSB8fCB0LmlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKHBhcmVudCkgfHwgY29uc2lkZXJEZWZhdWx0RXhwb3J0cyAmJiB0LmlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKHBhcmVudCwgeyBkZWNsYXJhdGlvbjogbm9kZSB9KSB8fCBjb25zaWRlckFycm93ICYmIHQuaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJlbnQsIHsgYm9keTogbm9kZSB9KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNDYWxsRXhwcmVzc2lvbihwYXJlbnQsIHsgY2FsbGVlOiBub2RlIH0pIHx8IHQuaXNTZXF1ZW5jZUV4cHJlc3Npb24ocGFyZW50KSAmJiBwYXJlbnQuZXhwcmVzc2lvbnNbMF0gPT09IG5vZGUgfHwgdC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50LCB7IG9iamVjdDogbm9kZSB9KSB8fCB0LmlzQ29uZGl0aW9uYWwocGFyZW50LCB7IHRlc3Q6IG5vZGUgfSkgfHwgdC5pc0JpbmFyeShwYXJlbnQsIHsgbGVmdDogbm9kZSB9KSB8fCB0LmlzQXNzaWdubWVudEV4cHJlc3Npb24ocGFyZW50LCB7IGxlZnQ6IG5vZGUgfSkpIHtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBpLS07XG4gICAgICBwYXJlbnQgPSBwcmludFN0YWNrW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3IvbGliL25vZGUvcGFyZW50aGVzZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXaGl0ZXNwYWNlKHRva2Vucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFdoaXRlc3BhY2UpO1xuXG4gICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgdGhpcy51c2VkID0ge307XG4gIH1cblxuICBXaGl0ZXNwYWNlLnByb3RvdHlwZS5nZXROZXdsaW5lc0JlZm9yZSA9IGZ1bmN0aW9uIGdldE5ld2xpbmVzQmVmb3JlKG5vZGUpIHtcbiAgICB2YXIgc3RhcnRUb2tlbiA9IHZvaWQgMDtcbiAgICB2YXIgZW5kVG9rZW4gPSB2b2lkIDA7XG4gICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFRva2VuKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLnN0YXJ0IC0gbm9kZS5zdGFydDtcbiAgICB9LCAwLCB0b2tlbnMubGVuZ3RoKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgd2hpbGUgKGluZGV4ICYmIG5vZGUuc3RhcnQgPT09IHRva2Vuc1tpbmRleCAtIDFdLnN0YXJ0KSB7XG4gICAgICAgIC0taW5kZXg7XG4gICAgICB9c3RhcnRUb2tlbiA9IHRva2Vuc1tpbmRleCAtIDFdO1xuICAgICAgZW5kVG9rZW4gPSB0b2tlbnNbaW5kZXhdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXROZXdsaW5lc0JldHdlZW4oc3RhcnRUb2tlbiwgZW5kVG9rZW4pO1xuICB9O1xuXG4gIFdoaXRlc3BhY2UucHJvdG90eXBlLmdldE5ld2xpbmVzQWZ0ZXIgPSBmdW5jdGlvbiBnZXROZXdsaW5lc0FmdGVyKG5vZGUpIHtcbiAgICB2YXIgc3RhcnRUb2tlbiA9IHZvaWQgMDtcbiAgICB2YXIgZW5kVG9rZW4gPSB2b2lkIDA7XG4gICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFRva2VuKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLmVuZCAtIG5vZGUuZW5kO1xuICAgIH0sIDAsIHRva2Vucy5sZW5ndGgpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB3aGlsZSAoaW5kZXggJiYgbm9kZS5lbmQgPT09IHRva2Vuc1tpbmRleCAtIDFdLmVuZCkge1xuICAgICAgICAtLWluZGV4O1xuICAgICAgfXN0YXJ0VG9rZW4gPSB0b2tlbnNbaW5kZXhdO1xuICAgICAgZW5kVG9rZW4gPSB0b2tlbnNbaW5kZXggKyAxXTtcbiAgICAgIGlmIChlbmRUb2tlbiAmJiBlbmRUb2tlbi50eXBlLmxhYmVsID09PSBcIixcIikgZW5kVG9rZW4gPSB0b2tlbnNbaW5kZXggKyAyXTtcbiAgICB9XG5cbiAgICBpZiAoZW5kVG9rZW4gJiYgZW5kVG9rZW4udHlwZS5sYWJlbCA9PT0gXCJlb2ZcIikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXROZXdsaW5lc0JldHdlZW4oc3RhcnRUb2tlbiwgZW5kVG9rZW4pO1xuICAgIH1cbiAgfTtcblxuICBXaGl0ZXNwYWNlLnByb3RvdHlwZS5fZ2V0TmV3bGluZXNCZXR3ZWVuID0gZnVuY3Rpb24gX2dldE5ld2xpbmVzQmV0d2VlbihzdGFydFRva2VuLCBlbmRUb2tlbikge1xuICAgIGlmICghZW5kVG9rZW4gfHwgIWVuZFRva2VuLmxvYykgcmV0dXJuIDA7XG5cbiAgICB2YXIgc3RhcnQgPSBzdGFydFRva2VuID8gc3RhcnRUb2tlbi5sb2MuZW5kLmxpbmUgOiAxO1xuICAgIHZhciBlbmQgPSBlbmRUb2tlbi5sb2Muc3RhcnQubGluZTtcbiAgICB2YXIgbGluZXMgPSAwO1xuXG4gICAgZm9yICh2YXIgbGluZSA9IHN0YXJ0OyBsaW5lIDwgZW5kOyBsaW5lKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy51c2VkW2xpbmVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMudXNlZFtsaW5lXSA9IHRydWU7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9O1xuXG4gIFdoaXRlc3BhY2UucHJvdG90eXBlLl9maW5kVG9rZW4gPSBmdW5jdGlvbiBfZmluZFRva2VuKHRlc3QsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQgPj0gZW5kKSByZXR1cm4gLTE7XG4gICAgdmFyIG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+PiAxO1xuICAgIHZhciBtYXRjaCA9IHRlc3QodGhpcy50b2tlbnNbbWlkZGxlXSk7XG4gICAgaWYgKG1hdGNoIDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRUb2tlbih0ZXN0LCBtaWRkbGUgKyAxLCBlbmQpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZFRva2VuKHRlc3QsIHN0YXJ0LCBtaWRkbGUpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IDApIHtcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICByZXR1cm4gV2hpdGVzcGFjZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV2hpdGVzcGFjZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvci9saWIvd2hpdGVzcGFjZS5qc1xuLy8gbW9kdWxlIGlkID0gNDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLlRlbXBsYXRlRWxlbWVudCA9IFRlbXBsYXRlRWxlbWVudDtcbmV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gVGVtcGxhdGVMaXRlcmFsO1xuZnVuY3Rpb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLnRhZywgbm9kZSk7XG4gIHRoaXMucHJpbnQobm9kZS5xdWFzaSwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIFRlbXBsYXRlRWxlbWVudChub2RlLCBwYXJlbnQpIHtcbiAgdmFyIGlzRmlyc3QgPSBwYXJlbnQucXVhc2lzWzBdID09PSBub2RlO1xuICB2YXIgaXNMYXN0ID0gcGFyZW50LnF1YXNpc1twYXJlbnQucXVhc2lzLmxlbmd0aCAtIDFdID09PSBub2RlO1xuXG4gIHZhciB2YWx1ZSA9IChpc0ZpcnN0ID8gXCJgXCIgOiBcIn1cIikgKyBub2RlLnZhbHVlLnJhdyArIChpc0xhc3QgPyBcImBcIiA6IFwiJHtcIik7XG5cbiAgdGhpcy50b2tlbih2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIFRlbXBsYXRlTGl0ZXJhbChub2RlKSB7XG4gIHZhciBxdWFzaXMgPSBub2RlLnF1YXNpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1YXNpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucHJpbnQocXVhc2lzW2ldLCBub2RlKTtcblxuICAgIGlmIChpICsgMSA8IHF1YXNpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uc1tpXSwgbm9kZSk7XG4gICAgfVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy90ZW1wbGF0ZS1saXRlcmFscy5qc1xuLy8gbW9kdWxlIGlkID0gNDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5Mb2dpY2FsRXhwcmVzc2lvbiA9IGV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9IGV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSB1bmRlZmluZWQ7XG5leHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IFVuYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuRG9FeHByZXNzaW9uID0gRG9FeHByZXNzaW9uO1xuZXhwb3J0cy5QYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gVXBkYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gTmV3RXhwcmVzc2lvbjtcbmV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gU2VxdWVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IFRoaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5TdXBlciA9IFN1cGVyO1xuZXhwb3J0cy5EZWNvcmF0b3IgPSBEZWNvcmF0b3I7XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLkltcG9ydCA9IEltcG9ydDtcbmV4cG9ydHMuRW1wdHlTdGF0ZW1lbnQgPSBFbXB0eVN0YXRlbWVudDtcbmV4cG9ydHMuRXhwcmVzc2lvblN0YXRlbWVudCA9IEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG5leHBvcnRzLkFzc2lnbm1lbnRQYXR0ZXJuID0gQXNzaWdubWVudFBhdHRlcm47XG5leHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLkJpbmRFeHByZXNzaW9uID0gQmluZEV4cHJlc3Npb247XG5leHBvcnRzLk1lbWJlckV4cHJlc3Npb24gPSBNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBNZXRhUHJvcGVydHk7XG5cbnZhciBfYmFiZWxUeXBlcyA9IHJlcXVpcmUoXCJiYWJlbC10eXBlc1wiKTtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYmFiZWxUeXBlcyk7XG5cbnZhciBfbm9kZSA9IHJlcXVpcmUoXCIuLi9ub2RlXCIpO1xuXG52YXIgbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9ub2RlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwidm9pZFwiIHx8IG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgfHwgbm9kZS5vcGVyYXRvciA9PT0gXCJ0eXBlb2ZcIikge1xuICAgIHRoaXMud29yZChub2RlLm9wZXJhdG9yKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbihub2RlLm9wZXJhdG9yKTtcbiAgfVxuXG4gIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIERvRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMud29yZChcImRvXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnRva2VuKFwiKFwiKTtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24sIG5vZGUpO1xuICB0aGlzLnRva2VuKFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmIChub2RlLnByZWZpeCkge1xuICAgIHRoaXMudG9rZW4obm9kZS5vcGVyYXRvcik7XG4gICAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50LCBub2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByaW50KG5vZGUuYXJndW1lbnQsIG5vZGUpO1xuICAgIHRoaXMudG9rZW4obm9kZS5vcGVyYXRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLnRlc3QsIG5vZGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCI/XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5jb25zZXF1ZW50LCBub2RlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuKFwiOlwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYWx0ZXJuYXRlLCBub2RlKTtcbn1cblxuZnVuY3Rpb24gTmV3RXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgdGhpcy53b3JkKFwibmV3XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5jYWxsZWUsIG5vZGUpO1xuICBpZiAobm9kZS5hcmd1bWVudHMubGVuZ3RoID09PSAwICYmIHRoaXMuZm9ybWF0Lm1pbmlmaWVkICYmICF0LmlzQ2FsbEV4cHJlc3Npb24ocGFyZW50LCB7IGNhbGxlZTogbm9kZSB9KSAmJiAhdC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50KSAmJiAhdC5pc05ld0V4cHJlc3Npb24ocGFyZW50KSkgcmV0dXJuO1xuXG4gIHRoaXMudG9rZW4oXCIoXCIpO1xuICB0aGlzLnByaW50TGlzdChub2RlLmFyZ3VtZW50cywgbm9kZSk7XG4gIHRoaXMudG9rZW4oXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBTZXF1ZW5jZUV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50TGlzdChub2RlLmV4cHJlc3Npb25zLCBub2RlKTtcbn1cblxuZnVuY3Rpb24gVGhpc0V4cHJlc3Npb24oKSB7XG4gIHRoaXMud29yZChcInRoaXNcIik7XG59XG5cbmZ1bmN0aW9uIFN1cGVyKCkge1xuICB0aGlzLndvcmQoXCJzdXBlclwiKTtcbn1cblxuZnVuY3Rpb24gRGVjb3JhdG9yKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIkBcIik7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uLCBub2RlKTtcbiAgdGhpcy5uZXdsaW5lKCk7XG59XG5cbmZ1bmN0aW9uIGNvbW1hU2VwYXJhdG9yTmV3bGluZSgpIHtcbiAgdGhpcy50b2tlbihcIixcIik7XG4gIHRoaXMubmV3bGluZSgpO1xuXG4gIGlmICghdGhpcy5lbmRzV2l0aChcIlxcblwiKSkgdGhpcy5zcGFjZSgpO1xufVxuXG5mdW5jdGlvbiBDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5jYWxsZWUsIG5vZGUpO1xuXG4gIHRoaXMudG9rZW4oXCIoXCIpO1xuXG4gIHZhciBpc1ByZXR0eUNhbGwgPSBub2RlLl9wcmV0dHlDYWxsO1xuXG4gIHZhciBzZXBhcmF0b3IgPSB2b2lkIDA7XG4gIGlmIChpc1ByZXR0eUNhbGwpIHtcbiAgICBzZXBhcmF0b3IgPSBjb21tYVNlcGFyYXRvck5ld2xpbmU7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgdGhpcy5pbmRlbnQoKTtcbiAgfVxuXG4gIHRoaXMucHJpbnRMaXN0KG5vZGUuYXJndW1lbnRzLCBub2RlLCB7IHNlcGFyYXRvcjogc2VwYXJhdG9yIH0pO1xuXG4gIGlmIChpc1ByZXR0eUNhbGwpIHtcbiAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICB0aGlzLmRlZGVudCgpO1xuICB9XG5cbiAgdGhpcy50b2tlbihcIilcIik7XG59XG5cbmZ1bmN0aW9uIEltcG9ydCgpIHtcbiAgdGhpcy53b3JkKFwiaW1wb3J0XCIpO1xufVxuXG5mdW5jdGlvbiBidWlsZFlpZWxkQXdhaXQoa2V5d29yZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB0aGlzLndvcmQoa2V5d29yZCk7XG5cbiAgICBpZiAobm9kZS5kZWxlZ2F0ZSkge1xuICAgICAgdGhpcy50b2tlbihcIipcIik7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuYXJndW1lbnQpIHtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHZhciB0ZXJtaW5hdG9yU3RhdGUgPSB0aGlzLnN0YXJ0VGVybWluYXRvcmxlc3MoKTtcbiAgICAgIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCwgbm9kZSk7XG4gICAgICB0aGlzLmVuZFRlcm1pbmF0b3JsZXNzKHRlcm1pbmF0b3JTdGF0ZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgWWllbGRFeHByZXNzaW9uID0gZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSBidWlsZFlpZWxkQXdhaXQoXCJ5aWVsZFwiKTtcbnZhciBBd2FpdEV4cHJlc3Npb24gPSBleHBvcnRzLkF3YWl0RXhwcmVzc2lvbiA9IGJ1aWxkWWllbGRBd2FpdChcImF3YWl0XCIpO1xuXG5mdW5jdGlvbiBFbXB0eVN0YXRlbWVudCgpIHtcbiAgdGhpcy5zZW1pY29sb24odHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbiwgbm9kZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5cbmZ1bmN0aW9uIEFzc2lnbm1lbnRQYXR0ZXJuKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmxlZnQsIG5vZGUpO1xuICBpZiAobm9kZS5sZWZ0Lm9wdGlvbmFsKSB0aGlzLnRva2VuKFwiP1wiKTtcbiAgdGhpcy5wcmludChub2RlLmxlZnQudHlwZUFubm90YXRpb24sIG5vZGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCI9XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5yaWdodCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICB2YXIgcGFyZW5zID0gdGhpcy5pbkZvclN0YXRlbWVudEluaXRDb3VudGVyICYmIG5vZGUub3BlcmF0b3IgPT09IFwiaW5cIiAmJiAhbi5uZWVkc1BhcmVucyhub2RlLCBwYXJlbnQpO1xuXG4gIGlmIChwYXJlbnMpIHtcbiAgICB0aGlzLnRva2VuKFwiKFwiKTtcbiAgfVxuXG4gIHRoaXMucHJpbnQobm9kZS5sZWZ0LCBub2RlKTtcblxuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChub2RlLm9wZXJhdG9yID09PSBcImluXCIgfHwgbm9kZS5vcGVyYXRvciA9PT0gXCJpbnN0YW5jZW9mXCIpIHtcbiAgICB0aGlzLndvcmQobm9kZS5vcGVyYXRvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbihub2RlLm9wZXJhdG9yKTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG5cbiAgdGhpcy5wcmludChub2RlLnJpZ2h0LCBub2RlKTtcblxuICBpZiAocGFyZW5zKSB7XG4gICAgdGhpcy50b2tlbihcIilcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gQmluZEV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUub2JqZWN0LCBub2RlKTtcbiAgdGhpcy50b2tlbihcIjo6XCIpO1xuICB0aGlzLnByaW50KG5vZGUuY2FsbGVlLCBub2RlKTtcbn1cblxuZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLkxvZ2ljYWxFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb247XG5mdW5jdGlvbiBNZW1iZXJFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLm9iamVjdCwgbm9kZSk7XG5cbiAgaWYgKCFub2RlLmNvbXB1dGVkICYmIHQuaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUucHJvcGVydHkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdvdCBhIE1lbWJlckV4cHJlc3Npb24gZm9yIE1lbWJlckV4cHJlc3Npb24gcHJvcGVydHlcIik7XG4gIH1cblxuICB2YXIgY29tcHV0ZWQgPSBub2RlLmNvbXB1dGVkO1xuICBpZiAodC5pc0xpdGVyYWwobm9kZS5wcm9wZXJ0eSkgJiYgdHlwZW9mIG5vZGUucHJvcGVydHkudmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb21wdXRlZCA9IHRydWU7XG4gIH1cblxuICBpZiAoY29tcHV0ZWQpIHtcbiAgICB0aGlzLnRva2VuKFwiW1wiKTtcbiAgICB0aGlzLnByaW50KG5vZGUucHJvcGVydHksIG5vZGUpO1xuICAgIHRoaXMudG9rZW4oXCJdXCIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW4oXCIuXCIpO1xuICAgIHRoaXMucHJpbnQobm9kZS5wcm9wZXJ0eSwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gTWV0YVByb3BlcnR5KG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLm1ldGEsIG5vZGUpO1xuICB0aGlzLnRva2VuKFwiLlwiKTtcbiAgdGhpcy5wcmludChub2RlLnByb3BlcnR5LCBub2RlKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL2V4cHJlc3Npb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLlRocm93U3RhdGVtZW50ID0gZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IGV4cG9ydHMuUmV0dXJuU3RhdGVtZW50ID0gZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IGV4cG9ydHMuRm9yQXdhaXRTdGF0ZW1lbnQgPSBleHBvcnRzLkZvck9mU3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5leHBvcnRzLldpdGhTdGF0ZW1lbnQgPSBXaXRoU3RhdGVtZW50O1xuZXhwb3J0cy5JZlN0YXRlbWVudCA9IElmU3RhdGVtZW50O1xuZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBGb3JTdGF0ZW1lbnQ7XG5leHBvcnRzLldoaWxlU3RhdGVtZW50ID0gV2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLkRvV2hpbGVTdGF0ZW1lbnQgPSBEb1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5MYWJlbGVkU3RhdGVtZW50ID0gTGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuVHJ5U3RhdGVtZW50ID0gVHJ5U3RhdGVtZW50O1xuZXhwb3J0cy5DYXRjaENsYXVzZSA9IENhdGNoQ2xhdXNlO1xuZXhwb3J0cy5Td2l0Y2hTdGF0ZW1lbnQgPSBTd2l0Y2hTdGF0ZW1lbnQ7XG5leHBvcnRzLlN3aXRjaENhc2UgPSBTd2l0Y2hDYXNlO1xuZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IERlYnVnZ2VyU3RhdGVtZW50O1xuZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0aW9uID0gVmFyaWFibGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdG9yID0gVmFyaWFibGVEZWNsYXJhdG9yO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBXaXRoU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwid2l0aFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuKFwiKFwiKTtcbiAgdGhpcy5wcmludChub2RlLm9iamVjdCwgbm9kZSk7XG4gIHRoaXMudG9rZW4oXCIpXCIpO1xuICB0aGlzLnByaW50QmxvY2sobm9kZSk7XG59XG5cbmZ1bmN0aW9uIElmU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiaWZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbihcIihcIik7XG4gIHRoaXMucHJpbnQobm9kZS50ZXN0LCBub2RlKTtcbiAgdGhpcy50b2tlbihcIilcIik7XG4gIHRoaXMuc3BhY2UoKTtcblxuICB2YXIgbmVlZHNCbG9jayA9IG5vZGUuYWx0ZXJuYXRlICYmIHQuaXNJZlN0YXRlbWVudChnZXRMYXN0U3RhdGVtZW50KG5vZGUuY29uc2VxdWVudCkpO1xuICBpZiAobmVlZHNCbG9jaykge1xuICAgIHRoaXMudG9rZW4oXCJ7XCIpO1xuICAgIHRoaXMubmV3bGluZSgpO1xuICAgIHRoaXMuaW5kZW50KCk7XG4gIH1cblxuICB0aGlzLnByaW50QW5kSW5kZW50T25Db21tZW50cyhub2RlLmNvbnNlcXVlbnQsIG5vZGUpO1xuXG4gIGlmIChuZWVkc0Jsb2NrKSB7XG4gICAgdGhpcy5kZWRlbnQoKTtcbiAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICB0aGlzLnRva2VuKFwifVwiKTtcbiAgfVxuXG4gIGlmIChub2RlLmFsdGVybmF0ZSkge1xuICAgIGlmICh0aGlzLmVuZHNXaXRoKFwifVwiKSkgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImVsc2VcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRBbmRJbmRlbnRPbkNvbW1lbnRzKG5vZGUuYWx0ZXJuYXRlLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMYXN0U3RhdGVtZW50KHN0YXRlbWVudCkge1xuICBpZiAoIXQuaXNTdGF0ZW1lbnQoc3RhdGVtZW50LmJvZHkpKSByZXR1cm4gc3RhdGVtZW50O1xuICByZXR1cm4gZ2V0TGFzdFN0YXRlbWVudChzdGF0ZW1lbnQuYm9keSk7XG59XG5cbmZ1bmN0aW9uIEZvclN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcImZvclwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuKFwiKFwiKTtcblxuICB0aGlzLmluRm9yU3RhdGVtZW50SW5pdENvdW50ZXIrKztcbiAgdGhpcy5wcmludChub2RlLmluaXQsIG5vZGUpO1xuICB0aGlzLmluRm9yU3RhdGVtZW50SW5pdENvdW50ZXItLTtcbiAgdGhpcy50b2tlbihcIjtcIik7XG5cbiAgaWYgKG5vZGUudGVzdCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUudGVzdCwgbm9kZSk7XG4gIH1cbiAgdGhpcy50b2tlbihcIjtcIik7XG5cbiAgaWYgKG5vZGUudXBkYXRlKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS51cGRhdGUsIG5vZGUpO1xuICB9XG5cbiAgdGhpcy50b2tlbihcIilcIik7XG4gIHRoaXMucHJpbnRCbG9jayhub2RlKTtcbn1cblxuZnVuY3Rpb24gV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJ3aGlsZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuKFwiKFwiKTtcbiAgdGhpcy5wcmludChub2RlLnRlc3QsIG5vZGUpO1xuICB0aGlzLnRva2VuKFwiKVwiKTtcbiAgdGhpcy5wcmludEJsb2NrKG5vZGUpO1xufVxuXG52YXIgYnVpbGRGb3JYU3RhdGVtZW50ID0gZnVuY3Rpb24gYnVpbGRGb3JYU3RhdGVtZW50KG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHRoaXMud29yZChcImZvclwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgaWYgKG9wID09PSBcImF3YWl0XCIpIHtcbiAgICAgIHRoaXMud29yZChcImF3YWl0XCIpO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cbiAgICB0aGlzLnRva2VuKFwiKFwiKTtcblxuICAgIHRoaXMucHJpbnQobm9kZS5sZWZ0LCBub2RlKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKG9wID09PSBcImF3YWl0XCIgPyBcIm9mXCIgOiBvcCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5yaWdodCwgbm9kZSk7XG4gICAgdGhpcy50b2tlbihcIilcIik7XG4gICAgdGhpcy5wcmludEJsb2NrKG5vZGUpO1xuICB9O1xufTtcblxudmFyIEZvckluU3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9IGJ1aWxkRm9yWFN0YXRlbWVudChcImluXCIpO1xudmFyIEZvck9mU3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IGJ1aWxkRm9yWFN0YXRlbWVudChcIm9mXCIpO1xudmFyIEZvckF3YWl0U3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JBd2FpdFN0YXRlbWVudCA9IGJ1aWxkRm9yWFN0YXRlbWVudChcImF3YWl0XCIpO1xuXG5mdW5jdGlvbiBEb1doaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiZG9cIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHksIG5vZGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcIndoaWxlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCIoXCIpO1xuICB0aGlzLnByaW50KG5vZGUudGVzdCwgbm9kZSk7XG4gIHRoaXMudG9rZW4oXCIpXCIpO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuXG5mdW5jdGlvbiBidWlsZExhYmVsU3RhdGVtZW50KHByZWZpeCkge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImxhYmVsXCI7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdGhpcy53b3JkKHByZWZpeCk7XG5cbiAgICB2YXIgbGFiZWwgPSBub2RlW2tleV07XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG5cbiAgICAgIHZhciB0ZXJtaW5hdG9yU3RhdGUgPSB0aGlzLnN0YXJ0VGVybWluYXRvcmxlc3MoKTtcbiAgICAgIHRoaXMucHJpbnQobGFiZWwsIG5vZGUpO1xuICAgICAgdGhpcy5lbmRUZXJtaW5hdG9ybGVzcyh0ZXJtaW5hdG9yU3RhdGUpO1xuICAgIH1cblxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH07XG59XG5cbnZhciBDb250aW51ZVN0YXRlbWVudCA9IGV4cG9ydHMuQ29udGludWVTdGF0ZW1lbnQgPSBidWlsZExhYmVsU3RhdGVtZW50KFwiY29udGludWVcIik7XG52YXIgUmV0dXJuU3RhdGVtZW50ID0gZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBidWlsZExhYmVsU3RhdGVtZW50KFwicmV0dXJuXCIsIFwiYXJndW1lbnRcIik7XG52YXIgQnJlYWtTdGF0ZW1lbnQgPSBleHBvcnRzLkJyZWFrU3RhdGVtZW50ID0gYnVpbGRMYWJlbFN0YXRlbWVudChcImJyZWFrXCIpO1xudmFyIFRocm93U3RhdGVtZW50ID0gZXhwb3J0cy5UaHJvd1N0YXRlbWVudCA9IGJ1aWxkTGFiZWxTdGF0ZW1lbnQoXCJ0aHJvd1wiLCBcImFyZ3VtZW50XCIpO1xuXG5mdW5jdGlvbiBMYWJlbGVkU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmxhYmVsLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIjpcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHksIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBUcnlTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJ0cnlcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJsb2NrLCBub2RlKTtcbiAgdGhpcy5zcGFjZSgpO1xuXG4gIGlmIChub2RlLmhhbmRsZXJzKSB7XG4gICAgdGhpcy5wcmludChub2RlLmhhbmRsZXJzWzBdLCBub2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByaW50KG5vZGUuaGFuZGxlciwgbm9kZSk7XG4gIH1cblxuICBpZiAobm9kZS5maW5hbGl6ZXIpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiZmluYWxseVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmZpbmFsaXplciwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gQ2F0Y2hDbGF1c2Uobm9kZSkge1xuICB0aGlzLndvcmQoXCJjYXRjaFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuKFwiKFwiKTtcbiAgdGhpcy5wcmludChub2RlLnBhcmFtLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIilcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHksIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBTd2l0Y2hTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJzd2l0Y2hcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbihcIihcIik7XG4gIHRoaXMucHJpbnQobm9kZS5kaXNjcmltaW5hbnQsIG5vZGUpO1xuICB0aGlzLnRva2VuKFwiKVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuKFwie1wiKTtcblxuICB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5jYXNlcywgbm9kZSwge1xuICAgIGluZGVudDogdHJ1ZSxcbiAgICBhZGROZXdsaW5lczogZnVuY3Rpb24gYWRkTmV3bGluZXMobGVhZGluZywgY2FzKSB7XG4gICAgICBpZiAoIWxlYWRpbmcgJiYgbm9kZS5jYXNlc1tub2RlLmNhc2VzLmxlbmd0aCAtIDFdID09PSBjYXMpIHJldHVybiAtMTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMudG9rZW4oXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBTd2l0Y2hDYXNlKG5vZGUpIHtcbiAgaWYgKG5vZGUudGVzdCkge1xuICAgIHRoaXMud29yZChcImNhc2VcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS50ZXN0LCBub2RlKTtcbiAgICB0aGlzLnRva2VuKFwiOlwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndvcmQoXCJkZWZhdWx0XCIpO1xuICAgIHRoaXMudG9rZW4oXCI6XCIpO1xuICB9XG5cbiAgaWYgKG5vZGUuY29uc2VxdWVudC5sZW5ndGgpIHtcbiAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5jb25zZXF1ZW50LCBub2RlLCB7IGluZGVudDogdHJ1ZSB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEZWJ1Z2dlclN0YXRlbWVudCgpIHtcbiAgdGhpcy53b3JkKFwiZGVidWdnZXJcIik7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5cbmZ1bmN0aW9uIHZhcmlhYmxlRGVjbGFyYXRpb25JZGVudCgpIHtcbiAgdGhpcy50b2tlbihcIixcIik7XG4gIHRoaXMubmV3bGluZSgpO1xuICBpZiAodGhpcy5lbmRzV2l0aChcIlxcblwiKSkgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB0aGlzLnNwYWNlKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0RGVjbGFyYXRpb25JZGVudCgpIHtcbiAgdGhpcy50b2tlbihcIixcIik7XG4gIHRoaXMubmV3bGluZSgpO1xuICBpZiAodGhpcy5lbmRzV2l0aChcIlxcblwiKSkgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICB0aGlzLnNwYWNlKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgcGFyZW50KSB7XG4gIHRoaXMud29yZChub2RlLmtpbmQpO1xuICB0aGlzLnNwYWNlKCk7XG5cbiAgdmFyIGhhc0luaXRzID0gZmFsc2U7XG5cbiAgaWYgKCF0LmlzRm9yKHBhcmVudCkpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBub2RlLmRlY2xhcmF0aW9ucywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlY2xhciA9IF9yZWY7XG5cbiAgICAgIGlmIChkZWNsYXIuaW5pdCkge1xuICAgICAgICBoYXNJbml0cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlcGFyYXRvciA9IHZvaWQgMDtcbiAgaWYgKGhhc0luaXRzKSB7XG4gICAgc2VwYXJhdG9yID0gbm9kZS5raW5kID09PSBcImNvbnN0XCIgPyBjb25zdERlY2xhcmF0aW9uSWRlbnQgOiB2YXJpYWJsZURlY2xhcmF0aW9uSWRlbnQ7XG4gIH1cblxuICB0aGlzLnByaW50TGlzdChub2RlLmRlY2xhcmF0aW9ucywgbm9kZSwgeyBzZXBhcmF0b3I6IHNlcGFyYXRvciB9KTtcblxuICBpZiAodC5pc0ZvcihwYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudC5sZWZ0ID09PSBub2RlIHx8IHBhcmVudC5pbml0ID09PSBub2RlKSByZXR1cm47XG4gIH1cblxuICB0aGlzLnNlbWljb2xvbigpO1xufVxuXG5mdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuaWQsIG5vZGUpO1xuICB0aGlzLnByaW50KG5vZGUuaWQudHlwZUFubm90YXRpb24sIG5vZGUpO1xuICBpZiAobm9kZS5pbml0KSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW4oXCI9XCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuaW5pdCwgbm9kZSk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2JhYmVsLWdlbmVyYXRvckA2LjI2LjFAYmFiZWwtZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL3N0YXRlbWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2xhc3NEZWNsYXJhdGlvbiA9IENsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLkNsYXNzQm9keSA9IENsYXNzQm9keTtcbmV4cG9ydHMuQ2xhc3NQcm9wZXJ0eSA9IENsYXNzUHJvcGVydHk7XG5leHBvcnRzLkNsYXNzTWV0aG9kID0gQ2xhc3NNZXRob2Q7XG5mdW5jdGlvbiBDbGFzc0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludEpvaW4obm9kZS5kZWNvcmF0b3JzLCBub2RlKTtcbiAgdGhpcy53b3JkKFwiY2xhc3NcIik7XG5cbiAgaWYgKG5vZGUuaWQpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmlkLCBub2RlKTtcbiAgfVxuXG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycywgbm9kZSk7XG5cbiAgaWYgKG5vZGUuc3VwZXJDbGFzcykge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJleHRlbmRzXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuc3VwZXJDbGFzcywgbm9kZSk7XG4gICAgdGhpcy5wcmludChub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMsIG5vZGUpO1xuICB9XG5cbiAgaWYgKG5vZGUuaW1wbGVtZW50cykge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJpbXBsZW1lbnRzXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50TGlzdChub2RlLmltcGxlbWVudHMsIG5vZGUpO1xuICB9XG5cbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYm9keSwgbm9kZSk7XG59XG5cbmV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gQ2xhc3NEZWNsYXJhdGlvbjtcbmZ1bmN0aW9uIENsYXNzQm9keShub2RlKSB7XG4gIHRoaXMudG9rZW4oXCJ7XCIpO1xuICB0aGlzLnByaW50SW5uZXJDb21tZW50cyhub2RlKTtcbiAgaWYgKG5vZGUuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnRva2VuKFwifVwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5ld2xpbmUoKTtcblxuICAgIHRoaXMuaW5kZW50KCk7XG4gICAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuYm9keSwgbm9kZSk7XG4gICAgdGhpcy5kZWRlbnQoKTtcblxuICAgIGlmICghdGhpcy5lbmRzV2l0aChcIlxcblwiKSkgdGhpcy5uZXdsaW5lKCk7XG5cbiAgICB0aGlzLnJpZ2h0QnJhY2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBDbGFzc1Byb3BlcnR5KG5vZGUpIHtcbiAgdGhpcy5wcmludEpvaW4obm9kZS5kZWNvcmF0b3JzLCBub2RlKTtcblxuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICB0aGlzLndvcmQoXCJzdGF0aWNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgdGhpcy50b2tlbihcIltcIik7XG4gICAgdGhpcy5wcmludChub2RlLmtleSwgbm9kZSk7XG4gICAgdGhpcy50b2tlbihcIl1cIik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdmFyaWFuY2Uobm9kZSk7XG4gICAgdGhpcy5wcmludChub2RlLmtleSwgbm9kZSk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uLCBub2RlKTtcbiAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbihcIj1cIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS52YWx1ZSwgbm9kZSk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NNZXRob2Qobm9kZSkge1xuICB0aGlzLnByaW50Sm9pbihub2RlLmRlY29yYXRvcnMsIG5vZGUpO1xuXG4gIGlmIChub2RlLnN0YXRpYykge1xuICAgIHRoaXMud29yZChcInN0YXRpY1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cblxuICBpZiAobm9kZS5raW5kID09PSBcImNvbnN0cnVjdG9yQ2FsbFwiKSB7XG4gICAgdGhpcy53b3JkKFwiY2FsbFwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cblxuICB0aGlzLl9tZXRob2Qobm9kZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9jbGFzc2VzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSB1bmRlZmluZWQ7XG5leHBvcnRzLl9wYXJhbXMgPSBfcGFyYW1zO1xuZXhwb3J0cy5fbWV0aG9kID0gX21ldGhvZDtcbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfcGFyYW1zKG5vZGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMsIG5vZGUpO1xuICB0aGlzLnRva2VuKFwiKFwiKTtcbiAgdGhpcy5wcmludExpc3Qobm9kZS5wYXJhbXMsIG5vZGUsIHtcbiAgICBpdGVyYXRvcjogZnVuY3Rpb24gaXRlcmF0b3Iobm9kZSkge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIF90aGlzLnRva2VuKFwiP1wiKTtcbiAgICAgIF90aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24sIG5vZGUpO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMudG9rZW4oXCIpXCIpO1xuXG4gIGlmIChub2RlLnJldHVyblR5cGUpIHtcbiAgICB0aGlzLnByaW50KG5vZGUucmV0dXJuVHlwZSwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX21ldGhvZChub2RlKSB7XG4gIHZhciBraW5kID0gbm9kZS5raW5kO1xuICB2YXIga2V5ID0gbm9kZS5rZXk7XG5cbiAgaWYgKGtpbmQgPT09IFwibWV0aG9kXCIgfHwga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICBpZiAobm9kZS5nZW5lcmF0b3IpIHtcbiAgICAgIHRoaXMudG9rZW4oXCIqXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChraW5kID09PSBcImdldFwiIHx8IGtpbmQgPT09IFwic2V0XCIpIHtcbiAgICB0aGlzLndvcmQoa2luZCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG5cbiAgaWYgKG5vZGUuYXN5bmMpIHtcbiAgICB0aGlzLndvcmQoXCJhc3luY1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cblxuICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgIHRoaXMudG9rZW4oXCJbXCIpO1xuICAgIHRoaXMucHJpbnQoa2V5LCBub2RlKTtcbiAgICB0aGlzLnRva2VuKFwiXVwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByaW50KGtleSwgbm9kZSk7XG4gIH1cblxuICB0aGlzLl9wYXJhbXMobm9kZSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHksIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24obm9kZSkge1xuICBpZiAobm9kZS5hc3luYykge1xuICAgIHRoaXMud29yZChcImFzeW5jXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLndvcmQoXCJmdW5jdGlvblwiKTtcbiAgaWYgKG5vZGUuZ2VuZXJhdG9yKSB0aGlzLnRva2VuKFwiKlwiKTtcblxuICBpZiAobm9kZS5pZCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuaWQsIG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuXG4gIHRoaXMuX3BhcmFtcyhub2RlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYm9keSwgbm9kZSk7XG59XG5cbmV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvbiA9IEZ1bmN0aW9uRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUuYXN5bmMpIHtcbiAgICB0aGlzLndvcmQoXCJhc3luY1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cblxuICB2YXIgZmlyc3RQYXJhbSA9IG5vZGUucGFyYW1zWzBdO1xuXG4gIGlmIChub2RlLnBhcmFtcy5sZW5ndGggPT09IDEgJiYgdC5pc0lkZW50aWZpZXIoZmlyc3RQYXJhbSkgJiYgIWhhc1R5cGVzKG5vZGUsIGZpcnN0UGFyYW0pKSB7XG4gICAgdGhpcy5wcmludChmaXJzdFBhcmFtLCBub2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9wYXJhbXMobm9kZSk7XG4gIH1cblxuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCI9PlwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuXG4gIHRoaXMucHJpbnQobm9kZS5ib2R5LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gaGFzVHlwZXMobm9kZSwgcGFyYW0pIHtcbiAgcmV0dXJuIG5vZGUudHlwZVBhcmFtZXRlcnMgfHwgbm9kZS5yZXR1cm5UeXBlIHx8IHBhcmFtLnR5cGVBbm5vdGF0aW9uIHx8IHBhcmFtLm9wdGlvbmFsIHx8IHBhcmFtLnRyYWlsaW5nQ29tbWVudHM7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9tZXRob2RzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkltcG9ydFNwZWNpZmllciA9IEltcG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLkV4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBFeHBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5FeHBvcnRTcGVjaWZpZXIgPSBFeHBvcnRTcGVjaWZpZXI7XG5leHBvcnRzLkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbmV4cG9ydHMuSW1wb3J0RGVjbGFyYXRpb24gPSBJbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBJbXBvcnRTcGVjaWZpZXIobm9kZSkge1xuICBpZiAobm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZW9mXCIpIHtcbiAgICB0aGlzLndvcmQobm9kZS5pbXBvcnRLaW5kKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cblxuICB0aGlzLnByaW50KG5vZGUuaW1wb3J0ZWQsIG5vZGUpO1xuICBpZiAobm9kZS5sb2NhbCAmJiBub2RlLmxvY2FsLm5hbWUgIT09IG5vZGUuaW1wb3J0ZWQubmFtZSkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJhc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmxvY2FsLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmxvY2FsLCBub2RlKTtcbn1cblxuZnVuY3Rpb24gRXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5leHBvcnRlZCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIEV4cG9ydFNwZWNpZmllcihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5sb2NhbCwgbm9kZSk7XG4gIGlmIChub2RlLmV4cG9ydGVkICYmIG5vZGUubG9jYWwubmFtZSAhPT0gbm9kZS5leHBvcnRlZC5uYW1lKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImFzXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuZXhwb3J0ZWQsIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gIHRoaXMudG9rZW4oXCIqXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcImFzXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5leHBvcnRlZCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIEV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiZXhwb3J0XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCIqXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcImZyb21cIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLnNvdXJjZSwgbm9kZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5cbmZ1bmN0aW9uIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24oKSB7XG4gIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBFeHBvcnREZWNsYXJhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oKSB7XG4gIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJkZWZhdWx0XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIEV4cG9ydERlY2xhcmF0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICB2YXIgZGVjbGFyID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICB0aGlzLnByaW50KGRlY2xhciwgbm9kZSk7XG4gICAgaWYgKCF0LmlzU3RhdGVtZW50KGRlY2xhcikpIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgIHRoaXMud29yZChcInR5cGVcIik7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgfVxuXG4gICAgdmFyIHNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMuc2xpY2UoMCk7XG5cbiAgICB2YXIgaGFzU3BlY2lhbCA9IGZhbHNlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgZmlyc3QgPSBzcGVjaWZpZXJzWzBdO1xuICAgICAgaWYgKHQuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKGZpcnN0KSB8fCB0LmlzRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGZpcnN0KSkge1xuICAgICAgICBoYXNTcGVjaWFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmludChzcGVjaWZpZXJzLnNoaWZ0KCksIG5vZGUpO1xuICAgICAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnRva2VuKFwiLFwiKTtcbiAgICAgICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGVjaWZpZXJzLmxlbmd0aCB8fCAhc3BlY2lmaWVycy5sZW5ndGggJiYgIWhhc1NwZWNpYWwpIHtcbiAgICAgIHRoaXMudG9rZW4oXCJ7XCIpO1xuICAgICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgICAgdGhpcy5wcmludExpc3Qoc3BlY2lmaWVycywgbm9kZSk7XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9rZW4oXCJ9XCIpO1xuICAgIH1cblxuICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy53b3JkKFwiZnJvbVwiKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMucHJpbnQobm9kZS5zb3VyY2UsIG5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gSW1wb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJpbXBvcnRcIik7XG4gIHRoaXMuc3BhY2UoKTtcblxuICBpZiAobm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZW9mXCIpIHtcbiAgICB0aGlzLndvcmQobm9kZS5pbXBvcnRLaW5kKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cblxuICB2YXIgc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycy5zbGljZSgwKTtcbiAgaWYgKHNwZWNpZmllcnMgJiYgc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGZpcnN0ID0gc3BlY2lmaWVyc1swXTtcbiAgICAgIGlmICh0LmlzSW1wb3J0RGVmYXVsdFNwZWNpZmllcihmaXJzdCkgfHwgdC5pc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihmaXJzdCkpIHtcbiAgICAgICAgdGhpcy5wcmludChzcGVjaWZpZXJzLnNoaWZ0KCksIG5vZGUpO1xuICAgICAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnRva2VuKFwiLFwiKTtcbiAgICAgICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy50b2tlbihcIntcIik7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50TGlzdChzcGVjaWZpZXJzLCBub2RlKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMudG9rZW4oXCJ9XCIpO1xuICAgIH1cblxuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJmcm9tXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuXG4gIHRoaXMucHJpbnQobm9kZS5zb3VyY2UsIG5vZGUpO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuXG5mdW5jdGlvbiBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSkge1xuICB0aGlzLnRva2VuKFwiKlwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJhc1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUubG9jYWwsIG5vZGUpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fYmFiZWwtZ2VuZXJhdG9yQDYuMjYuMUBiYWJlbC1nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvbW9kdWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBodHRwczovL210aHMuYmUvanNlc2MgdjEuMy4wIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBvYmplY3QgPSB7fTtcblx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHR2YXIgZm9yT3duID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuXHRcdHZhciBrZXk7XG5cdFx0Zm9yIChrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcblx0XHRcdFx0Y2FsbGJhY2soa2V5LCBvYmplY3Rba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBleHRlbmQgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG5cdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdHJldHVybiBkZXN0aW5hdGlvbjtcblx0XHR9XG5cdFx0Zm9yT3duKHNvdXJjZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXHRcdHJldHVybiBkZXN0aW5hdGlvbjtcblx0fTtcblxuXHR2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjaykge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNhbGxiYWNrKGFycmF5W2luZGV4XSk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciB0b1N0cmluZyA9IG9iamVjdC50b1N0cmluZztcblx0dmFyIGlzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBBcnJheV0nO1xuXHR9O1xuXHR2YXIgaXNPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsZSBjaGVjaywgYnV0IGl04oCZcyBnb29kIGVub3VnaCBmb3Igd2hhdCB3ZSBuZWVkLlxuXHRcdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBPYmplY3RdJztcblx0fTtcblx0dmFyIGlzU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG5cdFx0XHR0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBTdHJpbmddJztcblx0fTtcblx0dmFyIGlzTnVtYmVyID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG5cdFx0XHR0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBOdW1iZXJdJztcblx0fTtcblx0dmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIEluIGEgcGVyZmVjdCB3b3JsZCwgdGhlIGB0eXBlb2ZgIGNoZWNrIHdvdWxkIGJlIHN1ZmZpY2llbnQuIEhvd2V2ZXIsXG5cdFx0Ly8gaW4gQ2hyb21lIDHigJMxMiwgYHR5cGVvZiAveC8gPT0gJ29iamVjdCdgLCBhbmQgaW4gSUUgNuKAkzhcblx0XHQvLyBgdHlwZW9mIGFsZXJ0ID09ICdvYmplY3QnYCBhbmQgc2ltaWxhciBmb3Igb3RoZXIgaG9zdCBvYmplY3RzLlxuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyB8fFxuXHRcdFx0dG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fTtcblx0dmFyIGlzTWFwID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgTWFwXSc7XG5cdH07XG5cdHZhciBpc1NldCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFNldF0nO1xuXHR9O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVzY2FwZXMjc2luZ2xlXG5cdHZhciBzaW5nbGVFc2NhcGVzID0ge1xuXHRcdCdcIic6ICdcXFxcXCInLFxuXHRcdCdcXCcnOiAnXFxcXFxcJycsXG5cdFx0J1xcXFwnOiAnXFxcXFxcXFwnLFxuXHRcdCdcXGInOiAnXFxcXGInLFxuXHRcdCdcXGYnOiAnXFxcXGYnLFxuXHRcdCdcXG4nOiAnXFxcXG4nLFxuXHRcdCdcXHInOiAnXFxcXHInLFxuXHRcdCdcXHQnOiAnXFxcXHQnXG5cdFx0Ly8gYFxcdmAgaXMgb21pdHRlZCBpbnRlbnRpb25hbGx5LCBiZWNhdXNlIGluIElFIDwgOSwgJ1xcdicgPT0gJ3YnLlxuXHRcdC8vICdcXHYnOiAnXFxcXHgwQidcblx0fTtcblx0dmFyIHJlZ2V4U2luZ2xlRXNjYXBlID0gL1tcIidcXFxcXFxiXFxmXFxuXFxyXFx0XS87XG5cblx0dmFyIHJlZ2V4RGlnaXQgPSAvWzAtOV0vO1xuXHR2YXIgcmVnZXhXaGl0ZWxpc3QgPSAvWyAhIy0mXFwoLVxcW1xcXS1+XS87XG5cblx0dmFyIGpzZXNjID0gZnVuY3Rpb24oYXJndW1lbnQsIG9wdGlvbnMpIHtcblx0XHQvLyBIYW5kbGUgb3B0aW9uc1xuXHRcdHZhciBkZWZhdWx0cyA9IHtcblx0XHRcdCdlc2NhcGVFdmVyeXRoaW5nJzogZmFsc2UsXG5cdFx0XHQnZXNjYXBlRXRhZ28nOiBmYWxzZSxcblx0XHRcdCdxdW90ZXMnOiAnc2luZ2xlJyxcblx0XHRcdCd3cmFwJzogZmFsc2UsXG5cdFx0XHQnZXM2JzogZmFsc2UsXG5cdFx0XHQnanNvbic6IGZhbHNlLFxuXHRcdFx0J2NvbXBhY3QnOiB0cnVlLFxuXHRcdFx0J2xvd2VyY2FzZUhleCc6IGZhbHNlLFxuXHRcdFx0J251bWJlcnMnOiAnZGVjaW1hbCcsXG5cdFx0XHQnaW5kZW50JzogJ1xcdCcsXG5cdFx0XHQnX19pbmRlbnRfXyc6ICcnLFxuXHRcdFx0J19faW5saW5lMV9fJzogZmFsc2UsXG5cdFx0XHQnX19pbmxpbmUyX18nOiBmYWxzZVxuXHRcdH07XG5cdFx0dmFyIGpzb24gPSBvcHRpb25zICYmIG9wdGlvbnMuanNvbjtcblx0XHRpZiAoanNvbikge1xuXHRcdFx0ZGVmYXVsdHMucXVvdGVzID0gJ2RvdWJsZSc7XG5cdFx0XHRkZWZhdWx0cy53cmFwID0gdHJ1ZTtcblx0XHR9XG5cdFx0b3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cdFx0aWYgKG9wdGlvbnMucXVvdGVzICE9ICdzaW5nbGUnICYmIG9wdGlvbnMucXVvdGVzICE9ICdkb3VibGUnKSB7XG5cdFx0XHRvcHRpb25zLnF1b3RlcyA9ICdzaW5nbGUnO1xuXHRcdH1cblx0XHR2YXIgcXVvdGUgPSBvcHRpb25zLnF1b3RlcyA9PSAnZG91YmxlJyA/ICdcIicgOiAnXFwnJztcblx0XHR2YXIgY29tcGFjdCA9IG9wdGlvbnMuY29tcGFjdDtcblx0XHR2YXIgaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQ7XG5cdFx0dmFyIGxvd2VyY2FzZUhleCA9IG9wdGlvbnMubG93ZXJjYXNlSGV4O1xuXHRcdHZhciBvbGRJbmRlbnQgPSAnJztcblx0XHR2YXIgaW5saW5lMSA9IG9wdGlvbnMuX19pbmxpbmUxX187XG5cdFx0dmFyIGlubGluZTIgPSBvcHRpb25zLl9faW5saW5lMl9fO1xuXHRcdHZhciBuZXdMaW5lID0gY29tcGFjdCA/ICcnIDogJ1xcbic7XG5cdFx0dmFyIHJlc3VsdDtcblx0XHR2YXIgaXNFbXB0eSA9IHRydWU7XG5cdFx0dmFyIHVzZUJpbk51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2JpbmFyeSc7XG5cdFx0dmFyIHVzZU9jdE51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ29jdGFsJztcblx0XHR2YXIgdXNlRGVjTnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnZGVjaW1hbCc7XG5cdFx0dmFyIHVzZUhleE51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2hleGFkZWNpbWFsJztcblxuXHRcdGlmIChqc29uICYmIGFyZ3VtZW50ICYmIGlzRnVuY3Rpb24oYXJndW1lbnQudG9KU09OKSkge1xuXHRcdFx0YXJndW1lbnQgPSBhcmd1bWVudC50b0pTT04oKTtcblx0XHR9XG5cblx0XHRpZiAoIWlzU3RyaW5nKGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGlzTWFwKGFyZ3VtZW50KSkge1xuXHRcdFx0XHRpZiAoYXJndW1lbnQuc2l6ZSA9PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICduZXcgTWFwKCknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghY29tcGFjdCkge1xuXHRcdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUxX18gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnbmV3IE1hcCgnICsganNlc2MoQXJyYXkuZnJvbShhcmd1bWVudCksIG9wdGlvbnMpICsgJyknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzU2V0KGFyZ3VtZW50KSkge1xuXHRcdFx0XHRpZiAoYXJndW1lbnQuc2l6ZSA9PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICduZXcgU2V0KCknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnbmV3IFNldCgnICsganNlc2MoQXJyYXkuZnJvbShhcmd1bWVudCksIG9wdGlvbnMpICsgJyknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXJyYXkoYXJndW1lbnQpKSB7XG5cdFx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0XHRvcHRpb25zLndyYXAgPSB0cnVlO1xuXHRcdFx0XHRpZiAoaW5saW5lMSkge1xuXHRcdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUxX18gPSBmYWxzZTtcblx0XHRcdFx0XHRvcHRpb25zLl9faW5saW5lMl9fID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvbGRJbmRlbnQgPSBvcHRpb25zLl9faW5kZW50X187XG5cdFx0XHRcdFx0aW5kZW50ICs9IG9sZEluZGVudDtcblx0XHRcdFx0XHRvcHRpb25zLl9faW5kZW50X18gPSBpbmRlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yRWFjaChhcmd1bWVudCwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRpc0VtcHR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGlubGluZTIpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUyX18gPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdFx0XHQoY29tcGFjdCB8fCBpbmxpbmUyID8gJycgOiBpbmRlbnQpICtcblx0XHRcdFx0XHRcdGpzZXNjKHZhbHVlLCBvcHRpb25zKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoaXNFbXB0eSkge1xuXHRcdFx0XHRcdHJldHVybiAnW10nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpbmxpbmUyKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsICcpICsgJ10nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnWycgKyBuZXdMaW5lICsgcmVzdWx0LmpvaW4oJywnICsgbmV3TGluZSkgKyBuZXdMaW5lICtcblx0XHRcdFx0XHQoY29tcGFjdCA/ICcnIDogb2xkSW5kZW50KSArICddJztcblx0XHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoYXJndW1lbnQpKSB7XG5cdFx0XHRcdGlmIChqc29uKSB7XG5cdFx0XHRcdFx0Ly8gU29tZSBudW1iZXIgdmFsdWVzIChlLmcuIGBJbmZpbml0eWApIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OLlxuXHRcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhcmd1bWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHVzZURlY051bWJlcnMpIHtcblx0XHRcdFx0XHRyZXR1cm4gU3RyaW5nKGFyZ3VtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodXNlSGV4TnVtYmVycykge1xuXHRcdFx0XHRcdHZhciB0bXAgPSBhcmd1bWVudC50b1N0cmluZygxNik7XG5cdFx0XHRcdFx0aWYgKCFsb3dlcmNhc2VIZXgpIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRtcC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gJzB4JyArIHRtcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodXNlQmluTnVtYmVycykge1xuXHRcdFx0XHRcdHJldHVybiAnMGInICsgYXJndW1lbnQudG9TdHJpbmcoMik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHVzZU9jdE51bWJlcnMpIHtcblx0XHRcdFx0XHRyZXR1cm4gJzBvJyArIGFyZ3VtZW50LnRvU3RyaW5nKDgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCFpc09iamVjdChhcmd1bWVudCkpIHtcblx0XHRcdFx0aWYgKGpzb24pIHtcblx0XHRcdFx0XHQvLyBGb3Igc29tZSB2YWx1ZXMgKGUuZy4gYHVuZGVmaW5lZGAsIGBmdW5jdGlvbmAgb2JqZWN0cyksXG5cdFx0XHRcdFx0Ly8gYEpTT04uc3RyaW5naWZ5KHZhbHVlKWAgcmV0dXJucyBgdW5kZWZpbmVkYCAod2hpY2ggaXNu4oCZdCB2YWxpZFxuXHRcdFx0XHRcdC8vIEpTT04pIGluc3RlYWQgb2YgYCdudWxsJ2AuXG5cdFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50KSB8fCAnbnVsbCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG5cdFx0XHR9IGVsc2UgeyAvLyBpdOKAmXMgYW4gb2JqZWN0XG5cdFx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0XHRvcHRpb25zLndyYXAgPSB0cnVlO1xuXHRcdFx0XHRvbGRJbmRlbnQgPSBvcHRpb25zLl9faW5kZW50X187XG5cdFx0XHRcdGluZGVudCArPSBvbGRJbmRlbnQ7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmRlbnRfXyA9IGluZGVudDtcblx0XHRcdFx0Zm9yT3duKGFyZ3VtZW50LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0XHRcdFx0aXNFbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6IGluZGVudCkgK1xuXHRcdFx0XHRcdFx0anNlc2Moa2V5LCBvcHRpb25zKSArICc6JyArXG5cdFx0XHRcdFx0XHQoY29tcGFjdCA/ICcnIDogJyAnKSArXG5cdFx0XHRcdFx0XHRqc2VzYyh2YWx1ZSwgb3B0aW9ucylcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKGlzRW1wdHkpIHtcblx0XHRcdFx0XHRyZXR1cm4gJ3t9Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJ3snICsgbmV3TGluZSArIHJlc3VsdC5qb2luKCcsJyArIG5ld0xpbmUpICsgbmV3TGluZSArXG5cdFx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6IG9sZEluZGVudCkgKyAnfSc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHN0cmluZyA9IGFyZ3VtZW50O1xuXHRcdC8vIExvb3Agb3ZlciBlYWNoIGNvZGUgdW5pdCBpbiB0aGUgc3RyaW5nIGFuZCBlc2NhcGUgaXRcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgZmlyc3Q7XG5cdFx0dmFyIHNlY29uZDtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHJlc3VsdCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YXIgY2hhcmFjdGVyID0gc3RyaW5nLmNoYXJBdChpbmRleCk7XG5cdFx0XHRpZiAob3B0aW9ucy5lczYpIHtcblx0XHRcdFx0Zmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG5cdFx0XHRcdGlmICggLy8gY2hlY2sgaWYgaXTigJlzIHRoZSBzdGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0Zmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiAvLyBoaWdoIHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdGxlbmd0aCA+IGluZGV4ICsgMSAvLyB0aGVyZSBpcyBhIG5leHQgY29kZSB1bml0XG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cdFx0XHRcdFx0aWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcblx0XHRcdFx0XHRcdGNvZGVQb2ludCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG5cdFx0XHRcdFx0XHR2YXIgaGV4YWRlY2ltYWwgPSBjb2RlUG9pbnQudG9TdHJpbmcoMTYpO1xuXHRcdFx0XHRcdFx0aWYgKCFsb3dlcmNhc2VIZXgpIHtcblx0XHRcdFx0XHRcdFx0aGV4YWRlY2ltYWwgPSBoZXhhZGVjaW1hbC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcdXsnICsgaGV4YWRlY2ltYWwgKyAnfSc7XG5cdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIW9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZykge1xuXHRcdFx0XHRpZiAocmVnZXhXaGl0ZWxpc3QudGVzdChjaGFyYWN0ZXIpKSB7XG5cdFx0XHRcdFx0Ly8gSXTigJlzIGEgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlciB0aGF0IGlzIG5vdCBgXCJgLCBgJ2Agb3IgYFxcYCxcblx0XHRcdFx0XHQvLyBzbyBkb27igJl0IGVzY2FwZSBpdC5cblx0XHRcdFx0XHRyZXN1bHQgKz0gY2hhcmFjdGVyO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjaGFyYWN0ZXIgPT0gJ1wiJykge1xuXHRcdFx0XHRcdHJlc3VsdCArPSBxdW90ZSA9PSBjaGFyYWN0ZXIgPyAnXFxcXFwiJyA6IGNoYXJhY3Rlcjtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2hhcmFjdGVyID09ICdcXCcnKSB7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHF1b3RlID09IGNoYXJhY3RlciA/ICdcXFxcXFwnJyA6IGNoYXJhY3Rlcjtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjaGFyYWN0ZXIgPT0gJ1xcMCcgJiZcblx0XHRcdFx0IWpzb24gJiZcblx0XHRcdFx0IXJlZ2V4RGlnaXQudGVzdChzdHJpbmcuY2hhckF0KGluZGV4ICsgMSkpXG5cdFx0XHQpIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcMCc7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlZ2V4U2luZ2xlRXNjYXBlLnRlc3QoY2hhcmFjdGVyKSkge1xuXHRcdFx0XHQvLyBubyBuZWVkIGZvciBhIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2sgaGVyZVxuXHRcdFx0XHRyZXN1bHQgKz0gc2luZ2xlRXNjYXBlc1tjaGFyYWN0ZXJdO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHZhciBjaGFyQ29kZSA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuXHRcdFx0dmFyIGhleGFkZWNpbWFsID0gY2hhckNvZGUudG9TdHJpbmcoMTYpO1xuXHRcdFx0aWYgKCFsb3dlcmNhc2VIZXgpIHtcblx0XHRcdFx0aGV4YWRlY2ltYWwgPSBoZXhhZGVjaW1hbC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxvbmdoYW5kID0gaGV4YWRlY2ltYWwubGVuZ3RoID4gMiB8fCBqc29uO1xuXHRcdFx0dmFyIGVzY2FwZWQgPSAnXFxcXCcgKyAobG9uZ2hhbmQgPyAndScgOiAneCcpICtcblx0XHRcdFx0KCcwMDAwJyArIGhleGFkZWNpbWFsKS5zbGljZShsb25naGFuZCA/IC00IDogLTIpO1xuXHRcdFx0cmVzdWx0ICs9IGVzY2FwZWQ7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMud3JhcCkge1xuXHRcdFx0cmVzdWx0ID0gcXVvdGUgKyByZXN1bHQgKyBxdW90ZTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuZXNjYXBlRXRhZ28pIHtcblx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9ldGFnb1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5yZXBsYWNlKC88XFwvKHNjcmlwdHxzdHlsZSkvZ2ksICc8XFxcXC8kMScpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGpzZXNjLnZlcnNpb24gPSAnMS4zLjAnO1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpzZXNjO1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0ganNlc2M7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZyZWVFeHBvcnRzLmpzZXNjID0ganNlc2M7XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5qc2VzYyA9IGpzZXNjO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9qc2VzY0AxLjMuMEBqc2VzYy9qc2VzYy5qc1xuLy8gbW9kdWxlIGlkID0gNDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5UeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBleHBvcnRzLlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuTnVtZXJpY0xpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuR2VuZXJpY1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5DbGFzc0ltcGxlbWVudHMgPSB1bmRlZmluZWQ7XG5leHBvcnRzLkFueVR5cGVBbm5vdGF0aW9uID0gQW55VHlwZUFubm90YXRpb247XG5leHBvcnRzLkFycmF5VHlwZUFubm90YXRpb24gPSBBcnJheVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5Cb29sZWFuVHlwZUFubm90YXRpb24gPSBCb29sZWFuVHlwZUFubm90YXRpb247XG5leHBvcnRzLkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24gPSBCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5OdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuRGVjbGFyZUNsYXNzID0gRGVjbGFyZUNsYXNzO1xuZXhwb3J0cy5EZWNsYXJlRnVuY3Rpb24gPSBEZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLkRlY2xhcmVJbnRlcmZhY2UgPSBEZWNsYXJlSW50ZXJmYWNlO1xuZXhwb3J0cy5EZWNsYXJlTW9kdWxlID0gRGVjbGFyZU1vZHVsZTtcbmV4cG9ydHMuRGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBEZWNsYXJlTW9kdWxlRXhwb3J0cztcbmV4cG9ydHMuRGVjbGFyZVR5cGVBbGlhcyA9IERlY2xhcmVUeXBlQWxpYXM7XG5leHBvcnRzLkRlY2xhcmVPcGFxdWVUeXBlID0gRGVjbGFyZU9wYXF1ZVR5cGU7XG5leHBvcnRzLkRlY2xhcmVWYXJpYWJsZSA9IERlY2xhcmVWYXJpYWJsZTtcbmV4cG9ydHMuRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5FeGlzdGVudGlhbFR5cGVQYXJhbSA9IEV4aXN0ZW50aWFsVHlwZVBhcmFtO1xuZXhwb3J0cy5GdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gRnVuY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuRnVuY3Rpb25UeXBlUGFyYW0gPSBGdW5jdGlvblR5cGVQYXJhbTtcbmV4cG9ydHMuSW50ZXJmYWNlRXh0ZW5kcyA9IEludGVyZmFjZUV4dGVuZHM7XG5leHBvcnRzLl9pbnRlcmZhY2Vpc2ggPSBfaW50ZXJmYWNlaXNoO1xuZXhwb3J0cy5fdmFyaWFuY2UgPSBfdmFyaWFuY2U7XG5leHBvcnRzLkludGVyZmFjZURlY2xhcmF0aW9uID0gSW50ZXJmYWNlRGVjbGFyYXRpb247XG5leHBvcnRzLkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLk1peGVkVHlwZUFubm90YXRpb24gPSBNaXhlZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5FbXB0eVR5cGVBbm5vdGF0aW9uID0gRW1wdHlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTnVsbGFibGVUeXBlQW5ub3RhdGlvbiA9IE51bGxhYmxlVHlwZUFubm90YXRpb247XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVtZXJpY0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZXMuTnVtZXJpY0xpdGVyYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlcy5TdHJpbmdMaXRlcmFsO1xuICB9XG59KTtcbmV4cG9ydHMuTnVtYmVyVHlwZUFubm90YXRpb24gPSBOdW1iZXJUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuU3RyaW5nVHlwZUFubm90YXRpb24gPSBTdHJpbmdUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVGhpc1R5cGVBbm5vdGF0aW9uID0gVGhpc1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5UdXBsZVR5cGVBbm5vdGF0aW9uID0gVHVwbGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHlwZW9mVHlwZUFubm90YXRpb24gPSBUeXBlb2ZUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHlwZUFsaWFzID0gVHlwZUFsaWFzO1xuZXhwb3J0cy5PcGFxdWVUeXBlID0gT3BhcXVlVHlwZTtcbmV4cG9ydHMuVHlwZUFubm90YXRpb24gPSBUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHlwZVBhcmFtZXRlciA9IFR5cGVQYXJhbWV0ZXI7XG5leHBvcnRzLlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLk9iamVjdFR5cGVBbm5vdGF0aW9uID0gT2JqZWN0VHlwZUFubm90YXRpb247XG5leHBvcnRzLk9iamVjdFR5cGVDYWxsUHJvcGVydHkgPSBPYmplY3RUeXBlQ2FsbFByb3BlcnR5O1xuZXhwb3J0cy5PYmplY3RUeXBlSW5kZXhlciA9IE9iamVjdFR5cGVJbmRleGVyO1xuZXhwb3J0cy5PYmplY3RUeXBlUHJvcGVydHkgPSBPYmplY3RUeXBlUHJvcGVydHk7XG5leHBvcnRzLk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbmV4cG9ydHMuUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBRdWFsaWZpZWRUeXBlSWRlbnRpZmllcjtcbmV4cG9ydHMuVW5pb25UeXBlQW5ub3RhdGlvbiA9IFVuaW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLlR5cGVDYXN0RXhwcmVzc2lvbiA9IFR5cGVDYXN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuVm9pZFR5cGVBbm5vdGF0aW9uID0gVm9pZFR5cGVBbm5vdGF0aW9uO1xuXG52YXIgX2JhYmVsVHlwZXMgPSByZXF1aXJlKFwiYmFiZWwtdHlwZXNcIik7XG5cbnZhciB0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2JhYmVsVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBBbnlUeXBlQW5ub3RhdGlvbigpIHtcbiAgdGhpcy53b3JkKFwiYW55XCIpO1xufVxuXG5mdW5jdGlvbiBBcnJheVR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmVsZW1lbnRUeXBlLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIltcIik7XG4gIHRoaXMudG9rZW4oXCJdXCIpO1xufVxuXG5mdW5jdGlvbiBCb29sZWFuVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcImJvb2xlYW5cIik7XG59XG5cbmZ1bmN0aW9uIEJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSkge1xuICB0aGlzLndvcmQobm9kZS52YWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcbn1cblxuZnVuY3Rpb24gTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbigpIHtcbiAgdGhpcy53b3JkKFwibnVsbFwiKTtcbn1cblxuZnVuY3Rpb24gRGVjbGFyZUNsYXNzKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIXQuaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24ocGFyZW50KSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImNsYXNzXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMuX2ludGVyZmFjZWlzaChub2RlKTtcbn1cblxuZnVuY3Rpb24gRGVjbGFyZUZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIXQuaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24ocGFyZW50KSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImZ1bmN0aW9uXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5pZCwgbm9kZSk7XG4gIHRoaXMucHJpbnQobm9kZS5pZC50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbiwgbm9kZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5cbmZ1bmN0aW9uIERlY2xhcmVJbnRlcmZhY2Uobm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMuSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSk7XG59XG5cbmZ1bmN0aW9uIERlY2xhcmVNb2R1bGUobm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcIm1vZHVsZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuaWQsIG5vZGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcIm1vZHVsZVwiKTtcbiAgdGhpcy50b2tlbihcIi5cIik7XG4gIHRoaXMud29yZChcImV4cG9ydHNcIik7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbiwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIERlY2xhcmVUeXBlQWxpYXMobm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMuVHlwZUFsaWFzKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBEZWNsYXJlT3BhcXVlVHlwZShub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCF0LmlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKHBhcmVudCkpIHtcbiAgICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLk9wYXF1ZVR5cGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIERlY2xhcmVWYXJpYWJsZShub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCF0LmlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKHBhcmVudCkpIHtcbiAgICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLndvcmQoXCJ2YXJcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmlkLCBub2RlKTtcbiAgdGhpcy5wcmludChub2RlLmlkLnR5cGVBbm5vdGF0aW9uLCBub2RlKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cblxuZnVuY3Rpb24gRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJleHBvcnRcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKG5vZGUuZGVmYXVsdCkge1xuICAgIHRoaXMud29yZChcImRlZmF1bHRcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG5cbiAgRmxvd0V4cG9ydERlY2xhcmF0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIEZsb3dFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgdmFyIGRlY2xhciA9IG5vZGUuZGVjbGFyYXRpb247XG4gICAgdGhpcy5wcmludChkZWNsYXIsIG5vZGUpO1xuICAgIGlmICghdC5pc1N0YXRlbWVudChkZWNsYXIpKSB0aGlzLnNlbWljb2xvbigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW4oXCJ7XCIpO1xuICAgIGlmIChub2RlLnNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50TGlzdChub2RlLnNwZWNpZmllcnMsIG5vZGUpO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cbiAgICB0aGlzLnRva2VuKFwifVwiKTtcblxuICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy53b3JkKFwiZnJvbVwiKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMucHJpbnQobm9kZS5zb3VyY2UsIG5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gRXhpc3RlbnRpYWxUeXBlUGFyYW0oKSB7XG4gIHRoaXMudG9rZW4oXCIqXCIpO1xufVxuXG5mdW5jdGlvbiBGdW5jdGlvblR5cGVBbm5vdGF0aW9uKG5vZGUsIHBhcmVudCkge1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMsIG5vZGUpO1xuICB0aGlzLnRva2VuKFwiKFwiKTtcbiAgdGhpcy5wcmludExpc3Qobm9kZS5wYXJhbXMsIG5vZGUpO1xuXG4gIGlmIChub2RlLnJlc3QpIHtcbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRva2VuKFwiLFwiKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICB9XG4gICAgdGhpcy50b2tlbihcIi4uLlwiKTtcbiAgICB0aGlzLnByaW50KG5vZGUucmVzdCwgbm9kZSk7XG4gIH1cblxuICB0aGlzLnRva2VuKFwiKVwiKTtcblxuICBpZiAocGFyZW50LnR5cGUgPT09IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiIHx8IHBhcmVudC50eXBlID09PSBcIkRlY2xhcmVGdW5jdGlvblwiKSB7XG4gICAgdGhpcy50b2tlbihcIjpcIik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW4oXCI9PlwiKTtcbiAgfVxuXG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLnJldHVyblR5cGUsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBGdW5jdGlvblR5cGVQYXJhbShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5uYW1lLCBub2RlKTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHRoaXMudG9rZW4oXCI/XCIpO1xuICB0aGlzLnRva2VuKFwiOlwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24sIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBJbnRlcmZhY2VFeHRlbmRzKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmlkLCBub2RlKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzLCBub2RlKTtcbn1cblxuZXhwb3J0cy5DbGFzc0ltcGxlbWVudHMgPSBJbnRlcmZhY2VFeHRlbmRzO1xuZXhwb3J0cy5HZW5lcmljVHlwZUFubm90YXRpb24gPSBJbnRlcmZhY2VFeHRlbmRzO1xuZnVuY3Rpb24gX2ludGVyZmFjZWlzaChub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5pZCwgbm9kZSk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycywgbm9kZSk7XG4gIGlmIChub2RlLmV4dGVuZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImV4dGVuZHNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRMaXN0KG5vZGUuZXh0ZW5kcywgbm9kZSk7XG4gIH1cbiAgaWYgKG5vZGUubWl4aW5zICYmIG5vZGUubWl4aW5zLmxlbmd0aCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJtaXhpbnNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRMaXN0KG5vZGUubWl4aW5zLCBub2RlKTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gX3ZhcmlhbmNlKG5vZGUpIHtcbiAgaWYgKG5vZGUudmFyaWFuY2UgPT09IFwicGx1c1wiKSB7XG4gICAgdGhpcy50b2tlbihcIitcIik7XG4gIH0gZWxzZSBpZiAobm9kZS52YXJpYW5jZSA9PT0gXCJtaW51c1wiKSB7XG4gICAgdGhpcy50b2tlbihcIi1cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJpbnRlcmZhY2VcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5faW50ZXJmYWNlaXNoKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBhbmRTZXBhcmF0b3IoKSB7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbihcIiZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbn1cblxuZnVuY3Rpb24gSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24obm9kZSkge1xuICB0aGlzLnByaW50Sm9pbihub2RlLnR5cGVzLCBub2RlLCB7IHNlcGFyYXRvcjogYW5kU2VwYXJhdG9yIH0pO1xufVxuXG5mdW5jdGlvbiBNaXhlZFR5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJtaXhlZFwiKTtcbn1cblxuZnVuY3Rpb24gRW1wdHlUeXBlQW5ub3RhdGlvbigpIHtcbiAgdGhpcy53b3JkKFwiZW1wdHlcIik7XG59XG5cbmZ1bmN0aW9uIE51bGxhYmxlVHlwZUFubm90YXRpb24obm9kZSkge1xuICB0aGlzLnRva2VuKFwiP1wiKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uLCBub2RlKTtcbn1cblxuZnVuY3Rpb24gTnVtYmVyVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcIm51bWJlclwiKTtcbn1cblxuZnVuY3Rpb24gU3RyaW5nVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcInN0cmluZ1wiKTtcbn1cblxuZnVuY3Rpb24gVGhpc1R5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJ0aGlzXCIpO1xufVxuXG5mdW5jdGlvbiBUdXBsZVR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIltcIik7XG4gIHRoaXMucHJpbnRMaXN0KG5vZGUudHlwZXMsIG5vZGUpO1xuICB0aGlzLnRva2VuKFwiXVwiKTtcbn1cblxuZnVuY3Rpb24gVHlwZW9mVHlwZUFubm90YXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJ0eXBlb2ZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gVHlwZUFsaWFzKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwidHlwZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuaWQsIG5vZGUpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMsIG5vZGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCI9XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5yaWdodCwgbm9kZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBPcGFxdWVUeXBlKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwib3BhcXVlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcInR5cGVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmlkLCBub2RlKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzLCBub2RlKTtcbiAgaWYgKG5vZGUuc3VwZXJ0eXBlKSB7XG4gICAgdGhpcy50b2tlbihcIjpcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5zdXBlcnR5cGUsIG5vZGUpO1xuICB9XG4gIGlmIChub2RlLmltcGx0eXBlKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW4oXCI9XCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuaW1wbHR5cGUsIG5vZGUpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5cbmZ1bmN0aW9uIFR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIjpcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHRoaXMudG9rZW4oXCI/XCIpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24sIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBUeXBlUGFyYW1ldGVyKG5vZGUpIHtcbiAgdGhpcy5fdmFyaWFuY2Uobm9kZSk7XG5cbiAgdGhpcy53b3JkKG5vZGUubmFtZSk7XG5cbiAgaWYgKG5vZGUuYm91bmQpIHtcbiAgICB0aGlzLnByaW50KG5vZGUuYm91bmQsIG5vZGUpO1xuICB9XG5cbiAgaWYgKG5vZGUuZGVmYXVsdCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnRva2VuKFwiPVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmRlZmF1bHQsIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIjxcIik7XG4gIHRoaXMucHJpbnRMaXN0KG5vZGUucGFyYW1zLCBub2RlLCB7fSk7XG4gIHRoaXMudG9rZW4oXCI+XCIpO1xufVxuXG5leHBvcnRzLlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZnVuY3Rpb24gT2JqZWN0VHlwZUFubm90YXRpb24obm9kZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmIChub2RlLmV4YWN0KSB7XG4gICAgdGhpcy50b2tlbihcInt8XCIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW4oXCJ7XCIpO1xuICB9XG5cbiAgdmFyIHByb3BzID0gbm9kZS5wcm9wZXJ0aWVzLmNvbmNhdChub2RlLmNhbGxQcm9wZXJ0aWVzLCBub2RlLmluZGV4ZXJzKTtcblxuICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuXG4gICAgdGhpcy5wcmludEpvaW4ocHJvcHMsIG5vZGUsIHtcbiAgICAgIGFkZE5ld2xpbmVzOiBmdW5jdGlvbiBhZGROZXdsaW5lcyhsZWFkaW5nKSB7XG4gICAgICAgIGlmIChsZWFkaW5nICYmICFwcm9wc1swXSkgcmV0dXJuIDE7XG4gICAgICB9LFxuXG4gICAgICBpbmRlbnQ6IHRydWUsXG4gICAgICBzdGF0ZW1lbnQ6IHRydWUsXG4gICAgICBpdGVyYXRvcjogZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuZm9ybWF0LmZsb3dDb21tYVNlcGFyYXRvcikge1xuICAgICAgICAgICAgX3RoaXMudG9rZW4oXCIsXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5zZW1pY29sb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG5cbiAgaWYgKG5vZGUuZXhhY3QpIHtcbiAgICB0aGlzLnRva2VuKFwifH1cIik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbihcIn1cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlKSB7XG4gIGlmIChub2RlLnN0YXRpYykge1xuICAgIHRoaXMud29yZChcInN0YXRpY1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnZhbHVlLCBub2RlKTtcbn1cblxuZnVuY3Rpb24gT2JqZWN0VHlwZUluZGV4ZXIobm9kZSkge1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICB0aGlzLndvcmQoXCJzdGF0aWNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMuX3ZhcmlhbmNlKG5vZGUpO1xuICB0aGlzLnRva2VuKFwiW1wiKTtcbiAgdGhpcy5wcmludChub2RlLmlkLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIjpcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmtleSwgbm9kZSk7XG4gIHRoaXMudG9rZW4oXCJdXCIpO1xuICB0aGlzLnRva2VuKFwiOlwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudmFsdWUsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBPYmplY3RUeXBlUHJvcGVydHkobm9kZSkge1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICB0aGlzLndvcmQoXCJzdGF0aWNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMuX3ZhcmlhbmNlKG5vZGUpO1xuICB0aGlzLnByaW50KG5vZGUua2V5LCBub2RlKTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHRoaXMudG9rZW4oXCI/XCIpO1xuICB0aGlzLnRva2VuKFwiOlwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudmFsdWUsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBPYmplY3RUeXBlU3ByZWFkUHJvcGVydHkobm9kZSkge1xuICB0aGlzLnRva2VuKFwiLi4uXCIpO1xuICB0aGlzLnByaW50KG5vZGUuYXJndW1lbnQsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5xdWFsaWZpY2F0aW9uLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIi5cIik7XG4gIHRoaXMucHJpbnQobm9kZS5pZCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIG9yU2VwYXJhdG9yKCkge1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW4oXCJ8XCIpO1xuICB0aGlzLnNwYWNlKCk7XG59XG5cbmZ1bmN0aW9uIFVuaW9uVHlwZUFubm90YXRpb24obm9kZSkge1xuICB0aGlzLnByaW50Sm9pbihub2RlLnR5cGVzLCBub2RlLCB7IHNlcGFyYXRvcjogb3JTZXBhcmF0b3IgfSk7XG59XG5cbmZ1bmN0aW9uIFR5cGVDYXN0RXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMudG9rZW4oXCIoXCIpO1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbiwgbm9kZSk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbiwgbm9kZSk7XG4gIHRoaXMudG9rZW4oXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBWb2lkVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcInZvaWRcIik7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9mbG93LmpzXG4vLyBtb2R1bGUgaWQgPSA0NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkZpbGUgPSBGaWxlO1xuZXhwb3J0cy5Qcm9ncmFtID0gUHJvZ3JhbTtcbmV4cG9ydHMuQmxvY2tTdGF0ZW1lbnQgPSBCbG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuTm9vcCA9IE5vb3A7XG5leHBvcnRzLkRpcmVjdGl2ZSA9IERpcmVjdGl2ZTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXJlY3RpdmVMaXRlcmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlcy5TdHJpbmdMaXRlcmFsO1xuICB9XG59KTtcbmZ1bmN0aW9uIEZpbGUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUucHJvZ3JhbSwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIFByb2dyYW0obm9kZSkge1xuICB0aGlzLnByaW50SW5uZXJDb21tZW50cyhub2RlLCBmYWxzZSk7XG5cbiAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuZGlyZWN0aXZlcywgbm9kZSk7XG4gIGlmIChub2RlLmRpcmVjdGl2ZXMgJiYgbm9kZS5kaXJlY3RpdmVzLmxlbmd0aCkgdGhpcy5uZXdsaW5lKCk7XG5cbiAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuYm9keSwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIEJsb2NrU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIntcIik7XG4gIHRoaXMucHJpbnRJbm5lckNvbW1lbnRzKG5vZGUpO1xuXG4gIHZhciBoYXNEaXJlY3RpdmVzID0gbm9kZS5kaXJlY3RpdmVzICYmIG5vZGUuZGlyZWN0aXZlcy5sZW5ndGg7XG5cbiAgaWYgKG5vZGUuYm9keS5sZW5ndGggfHwgaGFzRGlyZWN0aXZlcykge1xuICAgIHRoaXMubmV3bGluZSgpO1xuXG4gICAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuZGlyZWN0aXZlcywgbm9kZSwgeyBpbmRlbnQ6IHRydWUgfSk7XG4gICAgaWYgKGhhc0RpcmVjdGl2ZXMpIHRoaXMubmV3bGluZSgpO1xuXG4gICAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuYm9keSwgbm9kZSwgeyBpbmRlbnQ6IHRydWUgfSk7XG4gICAgdGhpcy5yZW1vdmVUcmFpbGluZ05ld2xpbmUoKTtcblxuICAgIHRoaXMuc291cmNlKFwiZW5kXCIsIG5vZGUubG9jKTtcblxuICAgIGlmICghdGhpcy5lbmRzV2l0aChcIlxcblwiKSkgdGhpcy5uZXdsaW5lKCk7XG5cbiAgICB0aGlzLnJpZ2h0QnJhY2UoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNvdXJjZShcImVuZFwiLCBub2RlLmxvYyk7XG4gICAgdGhpcy50b2tlbihcIn1cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gTm9vcCgpIHt9XG5cbmZ1bmN0aW9uIERpcmVjdGl2ZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS52YWx1ZSwgbm9kZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZXhwb3J0cy5KU1hBdHRyaWJ1dGUgPSBKU1hBdHRyaWJ1dGU7XG5leHBvcnRzLkpTWElkZW50aWZpZXIgPSBKU1hJZGVudGlmaWVyO1xuZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IEpTWE5hbWVzcGFjZWROYW1lO1xuZXhwb3J0cy5KU1hNZW1iZXJFeHByZXNzaW9uID0gSlNYTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuSlNYU3ByZWFkQXR0cmlidXRlID0gSlNYU3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcbmV4cG9ydHMuSlNYU3ByZWFkQ2hpbGQgPSBKU1hTcHJlYWRDaGlsZDtcbmV4cG9ydHMuSlNYVGV4dCA9IEpTWFRleHQ7XG5leHBvcnRzLkpTWEVsZW1lbnQgPSBKU1hFbGVtZW50O1xuZXhwb3J0cy5KU1hPcGVuaW5nRWxlbWVudCA9IEpTWE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5KU1hDbG9zaW5nRWxlbWVudCA9IEpTWENsb3NpbmdFbGVtZW50O1xuZXhwb3J0cy5KU1hFbXB0eUV4cHJlc3Npb24gPSBKU1hFbXB0eUV4cHJlc3Npb247XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIEpTWEF0dHJpYnV0ZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5uYW1lLCBub2RlKTtcbiAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICB0aGlzLnRva2VuKFwiPVwiKTtcbiAgICB0aGlzLnByaW50KG5vZGUudmFsdWUsIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIEpTWElkZW50aWZpZXIobm9kZSkge1xuICB0aGlzLndvcmQobm9kZS5uYW1lKTtcbn1cblxuZnVuY3Rpb24gSlNYTmFtZXNwYWNlZE5hbWUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubmFtZXNwYWNlLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIjpcIik7XG4gIHRoaXMucHJpbnQobm9kZS5uYW1lLCBub2RlKTtcbn1cblxuZnVuY3Rpb24gSlNYTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3QsIG5vZGUpO1xuICB0aGlzLnRva2VuKFwiLlwiKTtcbiAgdGhpcy5wcmludChub2RlLnByb3BlcnR5LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gSlNYU3ByZWFkQXR0cmlidXRlKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIntcIik7XG4gIHRoaXMudG9rZW4oXCIuLi5cIik7XG4gIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCwgbm9kZSk7XG4gIHRoaXMudG9rZW4oXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBKU1hFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIntcIik7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIn1cIik7XG59XG5cbmZ1bmN0aW9uIEpTWFNwcmVhZENoaWxkKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIntcIik7XG4gIHRoaXMudG9rZW4oXCIuLi5cIik7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIn1cIik7XG59XG5cbmZ1bmN0aW9uIEpTWFRleHQobm9kZSkge1xuICB0aGlzLnRva2VuKG5vZGUudmFsdWUpO1xufVxuXG5mdW5jdGlvbiBKU1hFbGVtZW50KG5vZGUpIHtcbiAgdmFyIG9wZW4gPSBub2RlLm9wZW5pbmdFbGVtZW50O1xuICB0aGlzLnByaW50KG9wZW4sIG5vZGUpO1xuICBpZiAob3Blbi5zZWxmQ2xvc2luZykgcmV0dXJuO1xuXG4gIHRoaXMuaW5kZW50KCk7XG4gIGZvciAodmFyIF9pdGVyYXRvciA9IG5vZGUuY2hpbGRyZW4sIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoX2l0ZXJhdG9yKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBfcmVmO1xuXG4gICAgdGhpcy5wcmludChjaGlsZCwgbm9kZSk7XG4gIH1cbiAgdGhpcy5kZWRlbnQoKTtcblxuICB0aGlzLnByaW50KG5vZGUuY2xvc2luZ0VsZW1lbnQsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBzcGFjZVNlcGFyYXRvcigpIHtcbiAgdGhpcy5zcGFjZSgpO1xufVxuXG5mdW5jdGlvbiBKU1hPcGVuaW5nRWxlbWVudChub2RlKSB7XG4gIHRoaXMudG9rZW4oXCI8XCIpO1xuICB0aGlzLnByaW50KG5vZGUubmFtZSwgbm9kZSk7XG4gIGlmIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50Sm9pbihub2RlLmF0dHJpYnV0ZXMsIG5vZGUsIHsgc2VwYXJhdG9yOiBzcGFjZVNlcGFyYXRvciB9KTtcbiAgfVxuICBpZiAobm9kZS5zZWxmQ2xvc2luZykge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnRva2VuKFwiLz5cIik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbihcIj5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gSlNYQ2xvc2luZ0VsZW1lbnQobm9kZSkge1xuICB0aGlzLnRva2VuKFwiPC9cIik7XG4gIHRoaXMucHJpbnQobm9kZS5uYW1lLCBub2RlKTtcbiAgdGhpcy50b2tlbihcIj5cIik7XG59XG5cbmZ1bmN0aW9uIEpTWEVtcHR5RXhwcmVzc2lvbigpIHt9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvLl9iYWJlbC1nZW5lcmF0b3JANi4yNi4xQGJhYmVsLWdlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9qc3guanNcbi8vIG1vZHVsZSBpZCA9IDQ1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuaW1wb3J0IHtGaWxlSW50ZXJmYWNlfSBmcm9tICcuL0ZpbGVJbnRlcmZhY2UnXHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJ1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnXHJcblxyXG5leHBvcnQgY2xhc3MgRm9sZGVyIGltcGxlbWVudHMgRmlsZUludGVyZmFjZXtcclxuXHJcbiAgICBwcml2YXRlIGZyb206c3RyaW5nO1xyXG4gICAgcHJpdmF0ZSB0bzpzdHJpbmc7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFic29sdXRlUGF0aDpzdHJpbmcpe1xyXG4gICAgICAgLy8gdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID1hYnNvbHV0ZVBhdGg7IFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvcGVyYXRlKCl7XHJcblxyXG4gICAgICAgIGlmKGZzLmV4aXN0c1N5bmModGhpcy50bykpe1xyXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUZvbGRlclJlY3Vyc2l2ZSh0aGlzLnRvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZzLm1rZGlyU3luYyh0aGlzLnRvLDBvNzc3KTtcclxuICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZGVsZXRlRm9sZGVyUmVjdXJzaXZlKHVybDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdmFyIGZpbGVzID0gW107XHJcbiAgICAgICAgLy/liKTmlq3nu5nlrprnmoTot6/lvoTmmK/lkKblrZjlnKhcclxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyh1cmwpKSB7XHJcbiAgICAgICAgICAgIC8v6L+U5Zue5paH5Lu25ZKM5a2Q55uu5b2V55qE5pWw57uEXHJcbiAgICAgICAgICAgIGZpbGVzID0gZnMucmVhZGRpclN5bmModXJsKTtcclxuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaCggKGZpbGUsIGluZGV4KT0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHZhciBjdXJQYXRoID0gdXJsICsgXCIvXCIgKyBmaWxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1clBhdGggPSBwYXRoLmpvaW4odXJsLCBmaWxlKTtcclxuICAgICAgICAgICAgICAgIC8vZnMuc3RhdFN5bmPlkIzmraXor7vlj5bmlofku7blpLnmlofku7bvvIzlpoLmnpzmmK/mlofku7blpLnvvIzlnKjph43lpI3op6blj5Hlh73mlbBcclxuICAgICAgICAgICAgICAgIGlmIChmcy5zdGF0U3luYyhjdXJQYXRoKS5pc0RpcmVjdG9yeSgpKSB7IC8vIHJlY3Vyc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZUZvbGRlclJlY3Vyc2l2ZShjdXJQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmmK/mlofku7ZkZWxldGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGN1clBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy/muIXpmaTmlofku7blpLlcclxuICAgICAgICAgICAgZnMucm1kaXJTeW5jKHVybCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLnu5nlrprnmoTot6/lvoTkuI3lrZjlnKjvvIzor7fnu5nlh7rmraPnoa7nmoTot6/lvoRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG5cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2pvL0ZvbGRlci50cyIsImltcG9ydCB7IGNvcHlGaWxlLHJlYWQsIHdyaXRlLHdyaXRlRmlsZSB9IGZyb20gJy4uL2NvbW1vbi9Ub29scyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCdcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnXHJcbmltcG9ydCB7UGFnZX0gZnJvbSBcIi4vUGFnZVwiXHJcbmltcG9ydCB7RmlsZUludGVyZmFjZX0gZnJvbSAnLi9GaWxlSW50ZXJmYWNlJ1xyXG5pbXBvcnQge2VuY3J5cHRDb2RlfSBmcm9tIFwiLi4vY29tbW9uL2VuY3J5cHRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBzY3JpcHRQYWdlIGV4dGVuZHMgIFBhZ2V7XHJcblxyXG4gICAgcHJpdmF0ZSBjb21wcmVzcyA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZyb206c3RyaW5nLHRvOnN0cmluZyxjb21wcmVzczpib29sZWFuID0gZmFsc2UgKXtcclxuICAgICAgICBzdXBlcihmcm9tLHRvKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb21wcmVzcyA9IGNvbXByZXNzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvcGVyYXRlKCl7XHJcblxyXG4gICAgICAgIC8vZnMud3JpdGVGaWxlU3luYyh0aGlzLnRvLCB0aGlzLmNvbnRlbnQpO1xyXG5cclxuICAgICAgICBsZXQgdHh0ID10aGlzLnJlYWQodGhpcy5mcm9tKTs7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuY29tcHJlc3Mpe1xyXG4gICAgICAgICAgICBsZXQgcDpQcm9taXNlPGFueT4gPSBlbmNyeXB0Q29kZSh0eHQpO1xyXG4gICAgICAgICAgICBwLnRoZW4oIChkYXRhKT0+e1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIi0tLS0tLS0tLS0tLS0tLS0+XCIsZGF0YS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZGF0YSx0aGlzLnRvKTtcclxuICAgICAgICAgICAgICAgIC8vZnMud3JpdGVGaWxlU3luYyh0aGlzLnRvLGRhdGEpO1xyXG4gICAgICAgICAgICB9ICkuY2F0Y2goKGUpPT57XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWKoOWvhi0tLS0tPlwiLGUpXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgIC8vIGZzLndyaXRlRmlsZVN5bmModGhpcy50byx0eHQpO1xyXG4gICAgICAgICAgIHdyaXRlRmlsZSh0eHQsdGhpcy50byk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgLy8gcHVibGljIFxyXG5cclxuXHJcblxyXG5cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2pvL3NjcmlwdFBhZ2UudHMiLCJpbXBvcnQge1BhZ2V9IGZyb20gXCIuL1BhZ2VcIlxyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcydcclxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tIFwiLi4vY29tbW9uL2NvbmZcIlxyXG4vL2ltcG9ydCB7cmVhZCx3cml0ZUZpbGV9IGZyb20gXCIuLi9jb21tb24vVG9vbHNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBtYW5pZmVzdFBhZ2UgZXh0ZW5kcyAgUGFnZXtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihmcm9tOnN0cmluZyx0bzpzdHJpbmcsY29tcHJlc3M6Ym9vbGVhbiA9IGZhbHNlICl7XHJcbiAgICAgICAgc3VwZXIoZnJvbSx0byk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyAgcmVhZCggSU46c3RyaW5nKTpzdHJpbmd7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlYWQoSU4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb3BlcmF0ZSgpe1xyXG5cclxuICAgICAgICBsZXQgdHh0ID10aGlzLnJlYWQodGhpcy5mcm9tKTtcclxuICAgICAgICBsZXQganNvbiA9IEpTT04ucGFyc2UodHh0KTtcclxuICAgICAgICBqc29uLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIGxldCBvdXQgPSBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAnXFx0Jyk7XHJcbiAgICAgICAgdGhpcy53cml0ZUZpbGUob3V0LHRoaXMudG8pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2pvL21hbmlmZXN0UGFnZS50cyJdLCJzb3VyY2VSb290IjoiIn0=